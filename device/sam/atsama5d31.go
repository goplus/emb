// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from ATSAMA5D31.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Atmel

//go:build sam && atsama5d31

/*
// Atmel ATSAMA5D31 device: ARM Cortex-A5 processor-based embedded MPU, 536MHz, Linux support, FPU, LCD controller, 10/100 Ethernet, security (refer to http://www.atmel.com/devices/SAMA5D31.aspx for more)
*/

package sam

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device = "ATSAMA5D31"
)

// Interrupt numbers.
const (
	// Advanced Interrupt Controller
	IRQ_FIQ = 0

	// Power Management Controller
	IRQ_PMC = 1

	// Debug Unit
	IRQ_DBGU = 2

	// Parallel Input/Output Controller A
	IRQ_PIOA = 6

	// Parallel Input/Output Controller B
	IRQ_PIOB = 7

	// Parallel Input/Output Controller C
	IRQ_PIOC = 8

	// Parallel Input/Output Controller D
	IRQ_PIOD = 9

	// Parallel Input/Output Controller E
	IRQ_PIOE = 10

	// Software Modem Device
	IRQ_SMD = 11

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	IRQ_USART0 = 12

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	IRQ_USART1 = 13

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	IRQ_USART2 = 14

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	IRQ_USART3 = 15

	// Universal Asynchronous Receiver Transmitter 0
	IRQ_UART0 = 16

	// Universal Asynchronous Receiver Transmitter 1
	IRQ_UART1 = 17

	// Two-wire Interface 0
	IRQ_TWI0 = 18

	// Two-wire Interface 1
	IRQ_TWI1 = 19

	// Two-wire Interface 2
	IRQ_TWI2 = 20

	// High Speed MultiMedia Card Interface 0
	IRQ_HSMCI0 = 21

	// High Speed MultiMedia Card Interface 1
	IRQ_HSMCI1 = 22

	// High Speed MultiMedia Card Interface 2
	IRQ_HSMCI2 = 23

	// Serial Peripheral Interface 0
	IRQ_SPI0 = 24

	// Serial Peripheral Interface 1
	IRQ_SPI1 = 25

	// Timer Counter 0
	IRQ_TC0 = 26

	// Timer Counter 0
	IRQ_TC1 = 27

	// Pulse Width Modulation Controller
	IRQ_PWM = 28

	// Analog-to-Digital Converter
	IRQ_ADC = 29

	// DMA Controller 0
	IRQ_DMAC0 = 30

	// DMA Controller 1
	IRQ_DMAC1 = 31

	// USB High Speed Device Port
	IRQ_UDPHS = 33

	// Ethernet MAC 10/100
	IRQ_EMAC = 35

	// LCD Controller
	IRQ_LCDC = 36

	// Image Sensor Interface
	IRQ_ISI = 37

	// Synchronous Serial Controller 0
	IRQ_SSC0 = 38

	// Synchronous Serial Controller 1
	IRQ_SSC1 = 39

	// True Random Number Generator
	IRQ_TRNG = 45

	// Advanced Interrupt Controller
	IRQ_IRQ = 47

	// Fuse Controller
	IRQ_FUSE = 48

	// Highest interrupt number on this device.
	IRQ_max = 48
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export FIQ_IRQHandler
func interruptFIQ() {
	callHandlers(IRQ_FIQ)
}

//export PMC_IRQHandler
func interruptPMC() {
	callHandlers(IRQ_PMC)
}

//export DBGU_IRQHandler
func interruptDBGU() {
	callHandlers(IRQ_DBGU)
}

//export PIOA_IRQHandler
func interruptPIOA() {
	callHandlers(IRQ_PIOA)
}

//export PIOB_IRQHandler
func interruptPIOB() {
	callHandlers(IRQ_PIOB)
}

//export PIOC_IRQHandler
func interruptPIOC() {
	callHandlers(IRQ_PIOC)
}

//export PIOD_IRQHandler
func interruptPIOD() {
	callHandlers(IRQ_PIOD)
}

//export PIOE_IRQHandler
func interruptPIOE() {
	callHandlers(IRQ_PIOE)
}

//export SMD_IRQHandler
func interruptSMD() {
	callHandlers(IRQ_SMD)
}

//export USART0_IRQHandler
func interruptUSART0() {
	callHandlers(IRQ_USART0)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export UART0_IRQHandler
func interruptUART0() {
	callHandlers(IRQ_UART0)
}

//export UART1_IRQHandler
func interruptUART1() {
	callHandlers(IRQ_UART1)
}

//export TWI0_IRQHandler
func interruptTWI0() {
	callHandlers(IRQ_TWI0)
}

//export TWI1_IRQHandler
func interruptTWI1() {
	callHandlers(IRQ_TWI1)
}

//export TWI2_IRQHandler
func interruptTWI2() {
	callHandlers(IRQ_TWI2)
}

//export HSMCI0_IRQHandler
func interruptHSMCI0() {
	callHandlers(IRQ_HSMCI0)
}

//export HSMCI1_IRQHandler
func interruptHSMCI1() {
	callHandlers(IRQ_HSMCI1)
}

//export HSMCI2_IRQHandler
func interruptHSMCI2() {
	callHandlers(IRQ_HSMCI2)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export TC0_IRQHandler
func interruptTC0() {
	callHandlers(IRQ_TC0)
}

//export TC1_IRQHandler
func interruptTC1() {
	callHandlers(IRQ_TC1)
}

//export PWM_IRQHandler
func interruptPWM() {
	callHandlers(IRQ_PWM)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export DMAC0_IRQHandler
func interruptDMAC0() {
	callHandlers(IRQ_DMAC0)
}

//export DMAC1_IRQHandler
func interruptDMAC1() {
	callHandlers(IRQ_DMAC1)
}

//export UDPHS_IRQHandler
func interruptUDPHS() {
	callHandlers(IRQ_UDPHS)
}

//export EMAC_IRQHandler
func interruptEMAC() {
	callHandlers(IRQ_EMAC)
}

//export LCDC_IRQHandler
func interruptLCDC() {
	callHandlers(IRQ_LCDC)
}

//export ISI_IRQHandler
func interruptISI() {
	callHandlers(IRQ_ISI)
}

//export SSC0_IRQHandler
func interruptSSC0() {
	callHandlers(IRQ_SSC0)
}

//export SSC1_IRQHandler
func interruptSSC1() {
	callHandlers(IRQ_SSC1)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export IRQ_IRQHandler
func interruptIRQ() {
	callHandlers(IRQ_IRQ)
}

//export FUSE_IRQHandler
func interruptFUSE() {
	callHandlers(IRQ_FUSE)
}

// Peripherals.
var (
	// Software Modem Device
	SMD = (*SMD_Type)(unsafe.Pointer(uintptr(0x400000)))

	// AXI Matrix
	AXIMX = (*AXIMX_Type)(unsafe.Pointer(uintptr(0x800000)))

	// High Speed MultiMedia Card Interface 0
	HSMCI0 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf0000000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0xf0004000)))

	// Synchronous Serial Controller 0
	SSC0 = (*SSC_Type)(unsafe.Pointer(uintptr(0xf0008000)))

	// Timer Counter 0
	TC0 = (*TC_Type)(unsafe.Pointer(uintptr(0xf0010000)))

	// Two-wire Interface 0
	TWI0 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf0014000)))

	// Two-wire Interface 1
	TWI1 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf0018000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0xf001c000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0xf0020000)))

	// Universal Asynchronous Receiver Transmitter 0
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0xf0024000)))

	// Pulse Width Modulation Controller
	PWM = (*PWM_Type)(unsafe.Pointer(uintptr(0xf002c000)))

	// LCD Controller
	LCDC = (*LCDC_Type)(unsafe.Pointer(uintptr(0xf0030000)))

	// Image Sensor Interface
	ISI = (*ISI_Type)(unsafe.Pointer(uintptr(0xf0034000)))

	// Special Function Registers
	SFR = (*SFR_Type)(unsafe.Pointer(uintptr(0xf0038000)))

	// High Speed MultiMedia Card Interface 1
	HSMCI1 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf8000000)))

	// High Speed MultiMedia Card Interface 2
	HSMCI2 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf8004000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0xf8008000)))

	// Synchronous Serial Controller 1
	SSC1 = (*SSC_Type)(unsafe.Pointer(uintptr(0xf800c000)))

	// Analog-to-Digital Converter
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0xf8018000)))

	// Two-wire Interface 2
	TWI2 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf801c000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0xf8020000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0xf8024000)))

	// Universal Asynchronous Receiver Transmitter 1
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0xf8028000)))

	// Ethernet MAC 10/100
	EMAC = (*EMAC_Type)(unsafe.Pointer(uintptr(0xf802c000)))

	// USB High Speed Device Port
	UDPHS = (*UDPHS_Type)(unsafe.Pointer(uintptr(0xf8030000)))

	// True Random Number Generator
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0xf8040000)))

	// Fuse Controller
	FUSE = (*FUSE_Type)(unsafe.Pointer(uintptr(0xffffe400)))

	// DMA Controller 0
	DMAC0 = (*DMAC_Type)(unsafe.Pointer(uintptr(0xffffe600)))

	// DMA Controller 1
	DMAC1 = (*DMAC_Type)(unsafe.Pointer(uintptr(0xffffe800)))

	// AHB Multi-port DDR-SDRAM Controller
	MPDDRC = (*EBI_Type)(unsafe.Pointer(uintptr(0xffffea00)))

	// AHB Bus Matrix
	MATRIX = (*MATRIX_Type)(unsafe.Pointer(uintptr(0xffffec00)))

	// Debug Unit
	DBGU = (*DBGU_Type)(unsafe.Pointer(uintptr(0xffffee00)))

	// Advanced Interrupt Controller
	AIC = (*AIC_Type)(unsafe.Pointer(uintptr(0xfffff000)))

	// Parallel Input/Output Controller A
	PIOA = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff200)))

	// Parallel Input/Output Controller B
	PIOB = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff400)))

	// Parallel Input/Output Controller C
	PIOC = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff600)))

	// Parallel Input/Output Controller D
	PIOD = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff800)))

	// Parallel Input/Output Controller E
	PIOE = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffffa00)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0xfffffc00)))

	// Reset Controller
	RSTC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe00)))

	// Shutdown Controller
	SHDWC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe10)))

	// Periodic Interval Timer
	PIT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe30)))

	// Watchdog Timer
	WDT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe40)))

	// Slow Clock Controller
	SCKC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe50)))

	// Boot Sequence Controller
	BSC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe54)))

	// General Purpose Backup Register
	GPBR = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe60)))

	// Real-time Clock
	RTC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffeb0)))
)

// Software Modem Device
type SMD_Type struct {
}

// AXI Matrix
type AXIMX_Type struct {
	REMAP               volatile.Register32 // 0x0
	_                   [8140]byte
	PERIPH_ID4          volatile.Register32    // 0x1FD0
	PERIPH_ID5          volatile.Register32    // 0x1FD4
	PERIPH_ID6          volatile.Register32    // 0x1FD8
	PERIPH_ID7          volatile.Register32    // 0x1FDC
	PERIPH_ID0          volatile.Register32    // 0x1FE0
	PERIPH_ID1          volatile.Register32    // 0x1FE4
	PERIPH_ID2          volatile.Register32    // 0x1FE8
	PERIPH_ID3          volatile.Register32    // 0x1FEC
	COMP_ID             [4]volatile.Register32 // 0x1FF0
	_                   [12296]byte
	AMIB3_FN_MOD_BM_ISS volatile.Register32 // 0x5008
	_                   [24]byte
	AMIB3_FN_MOD2       volatile.Register32 // 0x5024
	_                   [250072]byte
	ASIB0_READ_QOS      volatile.Register32 // 0x42100
	ASIB0_WRITE_QOS     volatile.Register32 // 0x42104
	_                   [3872]byte
	ASIB1_FN_MOD_AHB    volatile.Register32 // 0x43028
	_                   [212]byte
	ASIB1_READ_QOS      volatile.Register32 // 0x43100
	ASIB1_WRITE_QOS     volatile.Register32 // 0x43104
	ASIB1_FN_MOD        volatile.Register32 // 0x43108
}

// AXIMX.REMAP: Remap Register
func (o *AXIMX_Type) SetREMAP_REMAP0(value uint32) {
	volatile.StoreUint32(&o.REMAP.Reg, volatile.LoadUint32(&o.REMAP.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetREMAP_REMAP0() uint32 {
	return volatile.LoadUint32(&o.REMAP.Reg) & 0x1
}
func (o *AXIMX_Type) SetREMAP_REMAP1(value uint32) {
	volatile.StoreUint32(&o.REMAP.Reg, volatile.LoadUint32(&o.REMAP.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetREMAP_REMAP1() uint32 {
	return (volatile.LoadUint32(&o.REMAP.Reg) & 0x2) >> 1
}

// AXIMX.PERIPH_ID4: Peripheral ID Register 4
func (o *AXIMX_Type) SetPERIPH_ID4_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID4.Reg, volatile.LoadUint32(&o.PERIPH_ID4.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID4_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID4.Reg) & 0xff
}

// AXIMX.PERIPH_ID5: Peripheral ID Register 5
func (o *AXIMX_Type) SetPERIPH_ID5_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID5.Reg, volatile.LoadUint32(&o.PERIPH_ID5.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID5_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID5.Reg) & 0xff
}

// AXIMX.PERIPH_ID6: Peripheral ID Register 6
func (o *AXIMX_Type) SetPERIPH_ID6_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID6.Reg, volatile.LoadUint32(&o.PERIPH_ID6.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID6_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID6.Reg) & 0xff
}

// AXIMX.PERIPH_ID7: Peripheral ID Register 7
func (o *AXIMX_Type) SetPERIPH_ID7_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID7.Reg, volatile.LoadUint32(&o.PERIPH_ID7.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID7_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID7.Reg) & 0xff
}

// AXIMX.PERIPH_ID0: Peripheral ID Register 0
func (o *AXIMX_Type) SetPERIPH_ID0_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID0.Reg, volatile.LoadUint32(&o.PERIPH_ID0.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID0_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID0.Reg) & 0xff
}

// AXIMX.PERIPH_ID1: Peripheral ID Register 1
func (o *AXIMX_Type) SetPERIPH_ID1_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID1.Reg, volatile.LoadUint32(&o.PERIPH_ID1.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID1_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID1.Reg) & 0xff
}

// AXIMX.PERIPH_ID2: Peripheral ID Register 2
func (o *AXIMX_Type) SetPERIPH_ID2_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID2.Reg, volatile.LoadUint32(&o.PERIPH_ID2.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID2_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID2.Reg) & 0xff
}

// AXIMX.PERIPH_ID3: Peripheral ID Register 3
func (o *AXIMX_Type) SetPERIPH_ID3_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID3.Reg, volatile.LoadUint32(&o.PERIPH_ID3.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID3_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID3.Reg) & 0xff
}

// AXIMX.COMP_ID: Component ID Register
func (o *AXIMX_Type) SetCOMP_ID_ID(idx int, value uint32) {
	volatile.StoreUint32(&o.COMP_ID[idx].Reg, volatile.LoadUint32(&o.COMP_ID[idx].Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetCOMP_ID_ID(idx int) uint32 {
	return volatile.LoadUint32(&o.COMP_ID[idx].Reg) & 0xff
}

// AXIMX.AMIB3_FN_MOD_BM_ISS: AMIB3 Bus Matrix Functionality Modification Register
func (o *AXIMX_Type) SetAMIB3_FN_MOD_BM_ISS_RD_ISS(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD_BM_ISS_RD_ISS() uint32 {
	return volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg) & 0x1
}
func (o *AXIMX_Type) SetAMIB3_FN_MOD_BM_ISS_WR_ISS(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD_BM_ISS_WR_ISS() uint32 {
	return (volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg) & 0x2) >> 1
}

// AXIMX.AMIB3_FN_MOD2: AMIB3 Bypass Merge
func (o *AXIMX_Type) SetAMIB3_FN_MOD2_BP_MRG(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD2.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD2_BP_MRG() uint32 {
	return volatile.LoadUint32(&o.AMIB3_FN_MOD2.Reg) & 0x1
}

// AXIMX.ASIB0_READ_QOS: ASIB0 Read Channel QoS Register
func (o *AXIMX_Type) SetASIB0_READ_QOS_RD_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB0_READ_QOS.Reg, volatile.LoadUint32(&o.ASIB0_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB0_READ_QOS_RD_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB0_READ_QOS.Reg) & 0xf
}

// AXIMX.ASIB0_WRITE_QOS: ASIB0 Write Channel QoS Register
func (o *AXIMX_Type) SetASIB0_WRITE_QOS_WR_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB0_WRITE_QOS.Reg, volatile.LoadUint32(&o.ASIB0_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB0_WRITE_QOS_WR_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB0_WRITE_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_FN_MOD_AHB: ASIB1 AHB Functionality Modification Register
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_RD_INCR_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_RD_INCR_OVR() uint32 {
	return volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_WR_INCR_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_WR_INCR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x2) >> 1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_LOCK_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x4)|value<<2)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_LOCK_OVR() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x4) >> 2
}

// AXIMX.ASIB1_READ_QOS: ASIB1 Read Channel QoS Register
func (o *AXIMX_Type) SetASIB1_READ_QOS_RD_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_READ_QOS.Reg, volatile.LoadUint32(&o.ASIB1_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB1_READ_QOS_RD_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_READ_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_WRITE_QOS: ASIB1 Write Channel QoS Register
func (o *AXIMX_Type) SetASIB1_WRITE_QOS_WR_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_WRITE_QOS.Reg, volatile.LoadUint32(&o.ASIB1_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB1_WRITE_QOS_WR_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_WRITE_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_FN_MOD: ASIB1 Issuing Functionality Modification Register
func (o *AXIMX_Type) SetASIB1_FN_MOD_RD_ISS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_RD_ISS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg) & 0x1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_WR_ISS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_WR_ISS() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg) & 0x2) >> 1
}

// High Speed MultiMedia Card Interface 0
type HSMCI_Type struct {
	CR    volatile.Register32    // 0x0
	MR    volatile.Register32    // 0x4
	DTOR  volatile.Register32    // 0x8
	SDCR  volatile.Register32    // 0xC
	ARGR  volatile.Register32    // 0x10
	CMDR  volatile.Register32    // 0x14
	BLKR  volatile.Register32    // 0x18
	CSTOR volatile.Register32    // 0x1C
	RSPR  [4]volatile.Register32 // 0x20
	RDR   volatile.Register32    // 0x30
	TDR   volatile.Register32    // 0x34
	_     [8]byte
	SR    volatile.Register32 // 0x40
	IER   volatile.Register32 // 0x44
	IDR   volatile.Register32 // 0x48
	IMR   volatile.Register32 // 0x4C
	DMA   volatile.Register32 // 0x50
	CFG   volatile.Register32 // 0x54
	_     [140]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
	_     [276]byte
	FIFO  [256]volatile.Register32 // 0x200
}

// HSMCI.CR: Control Register
func (o *HSMCI_Type) SetCR_MCIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCR_MCIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *HSMCI_Type) SetCR_MCIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetCR_MCIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetCR_PWSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetCR_PWSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetCR_PWSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetCR_PWSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *HSMCI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// HSMCI.MR: Mode Register
func (o *HSMCI_Type) SetMR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff)|value)
}
func (o *HSMCI_Type) GetMR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xff
}
func (o *HSMCI_Type) SetMR_PWSDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetMR_PWSDIV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetMR_RDPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetMR_RDPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetMR_WRPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetMR_WRPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetMR_FBYTE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetMR_FBYTE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetMR_PADV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000)|value<<14)
}
func (o *HSMCI_Type) GetMR_PADV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000) >> 14
}
func (o *HSMCI_Type) SetMR_CLKODD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetMR_CLKODD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}

// HSMCI.DTOR: Data Timeout Register
func (o *HSMCI_Type) SetDTOR_DTOCYC(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetDTOR_DTOCYC() uint32 {
	return volatile.LoadUint32(&o.DTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetDTOR_DTOMUL(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetDTOR_DTOMUL() uint32 {
	return (volatile.LoadUint32(&o.DTOR.Reg) & 0x70) >> 4
}

// HSMCI.SDCR: SD/SDIO Card Register
func (o *HSMCI_Type) SetSDCR_SDCSEL(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetSDCR_SDCSEL() uint32 {
	return volatile.LoadUint32(&o.SDCR.Reg) & 0x3
}
func (o *HSMCI_Type) SetSDCR_SDCBUS(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetSDCR_SDCBUS() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0xc0) >> 6
}

// HSMCI.ARGR: Argument Register
func (o *HSMCI_Type) SetARGR(value uint32) {
	volatile.StoreUint32(&o.ARGR.Reg, value)
}
func (o *HSMCI_Type) GetARGR() uint32 {
	return volatile.LoadUint32(&o.ARGR.Reg)
}

// HSMCI.CMDR: Command Register
func (o *HSMCI_Type) SetCMDR_CMDNB(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3f)|value)
}
func (o *HSMCI_Type) GetCMDR_CMDNB() uint32 {
	return volatile.LoadUint32(&o.CMDR.Reg) & 0x3f
}
func (o *HSMCI_Type) SetCMDR_RSPTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetCMDR_RSPTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0xc0) >> 6
}
func (o *HSMCI_Type) SetCMDR_SPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetCMDR_SPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetCMDR_OPDCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetCMDR_OPDCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetCMDR_MAXLAT(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCMDR_MAXLAT() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetCMDR_TRCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x30000)|value<<16)
}
func (o *HSMCI_Type) GetCMDR_TRCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x30000) >> 16
}
func (o *HSMCI_Type) SetCMDR_TRDIR(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetCMDR_TRDIR() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetCMDR_TRTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x380000)|value<<19)
}
func (o *HSMCI_Type) GetCMDR_TRTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x380000) >> 19
}
func (o *HSMCI_Type) SetCMDR_IOSPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3000000)|value<<24)
}
func (o *HSMCI_Type) GetCMDR_IOSPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x3000000) >> 24
}
func (o *HSMCI_Type) SetCMDR_ATACS(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetCMDR_ATACS() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetCMDR_BOOT_ACK(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetCMDR_BOOT_ACK() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x8000000) >> 27
}

// HSMCI.BLKR: Block Register
func (o *HSMCI_Type) SetBLKR_BCNT(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff)|value)
}
func (o *HSMCI_Type) GetBLKR_BCNT() uint32 {
	return volatile.LoadUint32(&o.BLKR.Reg) & 0xffff
}
func (o *HSMCI_Type) SetBLKR_BLKLEN(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSMCI_Type) GetBLKR_BLKLEN() uint32 {
	return (volatile.LoadUint32(&o.BLKR.Reg) & 0xffff0000) >> 16
}

// HSMCI.CSTOR: Completion Signal Timeout Register
func (o *HSMCI_Type) SetCSTOR_CSTOCYC(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetCSTOR_CSTOCYC() uint32 {
	return volatile.LoadUint32(&o.CSTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetCSTOR_CSTOMUL(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetCSTOR_CSTOMUL() uint32 {
	return (volatile.LoadUint32(&o.CSTOR.Reg) & 0x70) >> 4
}

// HSMCI.RSPR: Response Register
func (o *HSMCI_Type) SetRSPR(idx int, value uint32) {
	volatile.StoreUint32(&o.RSPR[idx].Reg, value)
}
func (o *HSMCI_Type) GetRSPR(idx int) uint32 {
	return volatile.LoadUint32(&o.RSPR[idx].Reg)
}

// HSMCI.RDR: Receive Data Register
func (o *HSMCI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *HSMCI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// HSMCI.TDR: Transmit Data Register
func (o *HSMCI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *HSMCI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// HSMCI.SR: Status Register
func (o *HSMCI_Type) SetSR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetSR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *HSMCI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetSR_BLKE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetSR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetSR_DTIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetSR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetSR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetSR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetSR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetSR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetSR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetSR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetSR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetSR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetSR_RINDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetSR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetSR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetSR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetSR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetSR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetSR_RENDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetSR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetSR_RTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetSR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetSR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetSR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetSR_DTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetSR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetSR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetSR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetSR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetSR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetSR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetSR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetSR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetSR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetSR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetSR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetSR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetSR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetSR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetSR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetSR_UNRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetSR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// HSMCI.IER: Interrupt Enable Register
func (o *HSMCI_Type) SetIER_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIER_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *HSMCI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIER_BLKE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIER_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIER_DTIP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIER_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIER_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIER_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIER_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIER_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIER_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIER_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIER_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIER_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIER_RINDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIER_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIER_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIER_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIER_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIER_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIER_RENDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIER_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIER_RTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIER_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIER_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIER_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIER_DTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIER_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIER_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIER_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIER_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIER_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIER_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIER_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIER_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIER_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIER_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIER_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIER_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIER_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIER_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIER_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIER_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIER_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// HSMCI.IDR: Interrupt Disable Register
func (o *HSMCI_Type) SetIDR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIDR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIDR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIDR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIDR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIDR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIDR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIDR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIDR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIDR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIDR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIDR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIDR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIDR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIDR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIDR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIDR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIDR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIDR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIDR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIDR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIDR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIDR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIDR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIDR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIDR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIDR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIDR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIDR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIDR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIDR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIDR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIDR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIDR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIDR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIDR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIDR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIDR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIDR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIDR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIDR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIDR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIDR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIDR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// HSMCI.IMR: Interrupt Mask Register
func (o *HSMCI_Type) SetIMR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIMR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIMR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIMR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIMR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIMR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIMR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIMR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIMR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIMR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIMR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIMR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIMR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIMR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIMR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIMR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIMR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIMR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIMR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIMR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIMR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIMR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIMR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIMR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIMR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIMR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIMR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIMR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIMR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIMR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIMR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIMR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIMR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIMR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIMR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIMR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIMR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIMR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIMR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIMR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIMR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIMR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIMR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIMR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// HSMCI.DMA: DMA Configuration Register
func (o *HSMCI_Type) SetDMA_OFFSET(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetDMA_OFFSET() uint32 {
	return volatile.LoadUint32(&o.DMA.Reg) & 0x3
}
func (o *HSMCI_Type) SetDMA_CHKSIZE(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetDMA_CHKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x70) >> 4
}
func (o *HSMCI_Type) SetDMA_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetDMA_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetDMA_ROPT(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetDMA_ROPT() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x1000) >> 12
}

// HSMCI.CFG: Configuration Register
func (o *HSMCI_Type) SetCFG_FIFOMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCFG_FIFOMODE() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *HSMCI_Type) SetCFG_FERRCTRL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetCFG_FERRCTRL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetCFG_HSMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetCFG_HSMODE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetCFG_LSYNC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCFG_LSYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}

// HSMCI.WPMR: Write Protection Mode Register
func (o *HSMCI_Type) SetWPMR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetWPMR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetWPMR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPMR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// HSMCI.WPSR: Write Protection Status Register
func (o *HSMCI_Type) SetWPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetWPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0xf
}
func (o *HSMCI_Type) SetWPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// HSMCI.FIFO: FIFO Memory Aperture0
func (o *HSMCI_Type) SetFIFO(idx int, value uint32) {
	volatile.StoreUint32(&o.FIFO[idx].Reg, value)
}
func (o *HSMCI_Type) GetFIFO(idx int) uint32 {
	return volatile.LoadUint32(&o.FIFO[idx].Reg)
}

// Serial Peripheral Interface 0
type SPI_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	RDR  volatile.Register32 // 0x8
	TDR  volatile.Register32 // 0xC
	SR   volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
	IDR  volatile.Register32 // 0x18
	IMR  volatile.Register32 // 0x1C
	_    [16]byte
	CSR  [4]volatile.Register32 // 0x30
	_    [164]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// SPI.CR: Control Register
func (o *SPI_Type) SetCR_SPIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR_SPIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SPI_Type) SetCR_SPIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR_SPIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// SPI.MR: Mode Register
func (o *SPI_Type) SetMR_MSTR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMR_MSTR() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *SPI_Type) SetMR_PS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetMR_PS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetMR_PCSDEC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetMR_PCSDEC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetMR_MODFDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetMR_MODFDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetMR_WDRBT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetMR_WDRBT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetMR_LLB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetMR_LLB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetMR_PCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetMR_PCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetMR_DLYBCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetMR_DLYBCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// SPI.RDR: Receive Data Register
func (o *SPI_Type) SetRDR_RD(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRDR_RD() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0xffff
}
func (o *SPI_Type) SetRDR_PCS(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetRDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.RDR.Reg) & 0xf0000) >> 16
}

// SPI.TDR: Transmit Data Register
func (o *SPI_Type) SetTDR_TD(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTDR_TD() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0xffff
}
func (o *SPI_Type) SetTDR_PCS(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetTDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetTDR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetTDR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0x1000000) >> 24
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_RDRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RDRF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TDRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_OVRES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_NSSR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetSR_UNDES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetSR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetSR_SPIENS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetSR_SPIENS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// SPI.IER: Interrupt Enable Register
func (o *SPI_Type) SetIER_RDRF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIER_RDRF() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SPI_Type) SetIER_TDRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIER_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIER_MODF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIER_MODF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIER_OVRES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIER_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIER_NSSR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIER_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIER_UNDES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIER_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}

// SPI.IDR: Interrupt Disable Register
func (o *SPI_Type) SetIDR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIDR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SPI_Type) SetIDR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIDR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIDR_MODF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIDR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIDR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIDR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIDR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIDR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIDR_UNDES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIDR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}

// SPI.IMR: Interrupt Mask Register
func (o *SPI_Type) SetIMR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIMR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SPI_Type) SetIMR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIMR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIMR_MODF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIMR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIMR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIMR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIMR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIMR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIMR_UNDES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIMR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}

// SPI.CSR: Chip Select Register
func (o *SPI_Type) SetCSR_CPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCSR_CPOL(idx int) uint32 {
	return volatile.LoadUint32(&o.CSR[idx].Reg) & 0x1
}
func (o *SPI_Type) SetCSR_NCPHA(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCSR_NCPHA(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCSR_CSNAAT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCSR_CSNAAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCSR_CSAAT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCSR_CSAAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCSR_BITS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCSR_BITS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCSR_SCBR(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetCSR_SCBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff00) >> 8
}
func (o *SPI_Type) SetCSR_DLYBS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *SPI_Type) GetCSR_DLYBS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff0000) >> 16
}
func (o *SPI_Type) SetCSR_DLYBCT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetCSR_DLYBCT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff000000) >> 24
}

// SPI.WPMR: Write Protection Control Register
func (o *SPI_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *SPI_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SPI_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// SPI.WPSR: Write Protection Status Register
func (o *SPI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *SPI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xff00) >> 8
}

// Synchronous Serial Controller 0
type SSC_Type struct {
	CR   volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	_    [8]byte
	RCMR volatile.Register32 // 0x10
	RFMR volatile.Register32 // 0x14
	TCMR volatile.Register32 // 0x18
	TFMR volatile.Register32 // 0x1C
	RHR  volatile.Register32 // 0x20
	THR  volatile.Register32 // 0x24
	_    [8]byte
	RSHR volatile.Register32 // 0x30
	TSHR volatile.Register32 // 0x34
	RC0R volatile.Register32 // 0x38
	RC1R volatile.Register32 // 0x3C
	SR   volatile.Register32 // 0x40
	IER  volatile.Register32 // 0x44
	IDR  volatile.Register32 // 0x48
	IMR  volatile.Register32 // 0x4C
	_    [148]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// SSC.CR: Control Register
func (o *SSC_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetCR_RXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SSC_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *SSC_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}

// SSC.CMR: Clock Mode Register
func (o *SSC_Type) SetCMR_DIV(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xfff)|value)
}
func (o *SSC_Type) GetCMR_DIV() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xfff
}

// SSC.RCMR: Receive Clock Mode Register
func (o *SSC_Type) SetRCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetRCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.RCMR.Reg) & 0x3
}
func (o *SSC_Type) SetRCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetRCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetRCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetRCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetRCMR_START(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRCMR_START() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRCMR_STOP(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1000)|value<<12)
}
func (o *SSC_Type) GetRCMR_STOP() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1000) >> 12
}
func (o *SSC_Type) SetRCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetRCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetRCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetRCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff000000) >> 24
}

// SSC.RFMR: Receive Frame Mode Register
func (o *SSC_Type) SetRFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetRFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.RFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetRFMR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRFMR_LOOP() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetRFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetRFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetRFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetRFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetRFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetRFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetRFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetRFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetRFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000000) >> 28
}

// SSC.TCMR: Transmit Clock Mode Register
func (o *SSC_Type) SetTCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetTCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.TCMR.Reg) & 0x3
}
func (o *SSC_Type) SetTCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetTCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetTCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetTCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetTCMR_START(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTCMR_START() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetTCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetTCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetTCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff000000) >> 24
}

// SSC.TFMR: Transmit Frame Mode Register
func (o *SSC_Type) SetTFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetTFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.TFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetTFMR_DATDEF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTFMR_DATDEF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetTFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetTFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetTFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetTFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetTFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetTFMR_FSDEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x800000)|value<<23)
}
func (o *SSC_Type) GetTFMR_FSDEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x800000) >> 23
}
func (o *SSC_Type) SetTFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetTFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetTFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetTFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000000) >> 28
}

// SSC.RHR: Receive Holding Register
func (o *SSC_Type) SetRHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, value)
}
func (o *SSC_Type) GetRHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg)
}

// SSC.THR: Transmit Holding Register
func (o *SSC_Type) SetTHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, value)
}
func (o *SSC_Type) GetTHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg)
}

// SSC.RSHR: Receive Sync. Holding Register
func (o *SSC_Type) SetRSHR_RSDAT(value uint32) {
	volatile.StoreUint32(&o.RSHR.Reg, volatile.LoadUint32(&o.RSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRSHR_RSDAT() uint32 {
	return volatile.LoadUint32(&o.RSHR.Reg) & 0xffff
}

// SSC.TSHR: Transmit Sync. Holding Register
func (o *SSC_Type) SetTSHR_TSDAT(value uint32) {
	volatile.StoreUint32(&o.TSHR.Reg, volatile.LoadUint32(&o.TSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTSHR_TSDAT() uint32 {
	return volatile.LoadUint32(&o.TSHR.Reg) & 0xffff
}

// SSC.RC0R: Receive Compare 0 Register
func (o *SSC_Type) SetRC0R_CP0(value uint32) {
	volatile.StoreUint32(&o.RC0R.Reg, volatile.LoadUint32(&o.RC0R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC0R_CP0() uint32 {
	return volatile.LoadUint32(&o.RC0R.Reg) & 0xffff
}

// SSC.RC1R: Receive Compare 1 Register
func (o *SSC_Type) SetRC1R_CP1(value uint32) {
	volatile.StoreUint32(&o.RC1R.Reg, volatile.LoadUint32(&o.RC1R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC1R_CP1() uint32 {
	return volatile.LoadUint32(&o.RC1R.Reg) & 0xffff
}

// SSC.SR: Status Register
func (o *SSC_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSC_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetSR_CP0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetSR_CP0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetSR_CP1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetSR_CP1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetSR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetSR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetSR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetSR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *SSC_Type) SetSR_TXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SSC_Type) GetSR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SSC_Type) SetSR_RXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SSC_Type) GetSR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SSC.IER: Interrupt Enable Register
func (o *SSC_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIER_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SSC_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIER_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIER_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIER_CP0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIER_CP0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIER_CP1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIER_CP1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIER_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIER_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIER_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIER_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// SSC.IDR: Interrupt Disable Register
func (o *SSC_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIDR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SSC_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIDR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIDR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIDR_CP0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIDR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIDR_CP1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIDR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIDR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIDR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIDR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIDR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// SSC.IMR: Interrupt Mask Register
func (o *SSC_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SSC_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIMR_CP0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIMR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIMR_CP1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIMR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIMR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIMR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIMR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIMR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// SSC.WPMR: Write Protect Mode Register
func (o *SSC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *SSC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SSC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Timer Counter 0
type TC_Type struct {
	CCR0  volatile.Register32 // 0x0
	CMR0  volatile.Register32 // 0x4
	SMMR0 volatile.Register32 // 0x8
	RAB0  volatile.Register32 // 0xC
	CV0   volatile.Register32 // 0x10
	RA0   volatile.Register32 // 0x14
	RB0   volatile.Register32 // 0x18
	RC0   volatile.Register32 // 0x1C
	SR0   volatile.Register32 // 0x20
	IER0  volatile.Register32 // 0x24
	IDR0  volatile.Register32 // 0x28
	IMR0  volatile.Register32 // 0x2C
	_     [16]byte
	CCR1  volatile.Register32 // 0x40
	CMR1  volatile.Register32 // 0x44
	SMMR1 volatile.Register32 // 0x48
	RAB1  volatile.Register32 // 0x4C
	CV1   volatile.Register32 // 0x50
	RA1   volatile.Register32 // 0x54
	RB1   volatile.Register32 // 0x58
	RC1   volatile.Register32 // 0x5C
	SR1   volatile.Register32 // 0x60
	IER1  volatile.Register32 // 0x64
	IDR1  volatile.Register32 // 0x68
	IMR1  volatile.Register32 // 0x6C
	_     [16]byte
	CCR2  volatile.Register32 // 0x80
	CMR2  volatile.Register32 // 0x84
	SMMR2 volatile.Register32 // 0x88
	RAB2  volatile.Register32 // 0x8C
	CV2   volatile.Register32 // 0x90
	RA2   volatile.Register32 // 0x94
	RB2   volatile.Register32 // 0x98
	RC2   volatile.Register32 // 0x9C
	SR2   volatile.Register32 // 0xA0
	IER2  volatile.Register32 // 0xA4
	IDR2  volatile.Register32 // 0xA8
	IMR2  volatile.Register32 // 0xAC
	_     [16]byte
	BCR   volatile.Register32 // 0xC0
	BMR   volatile.Register32 // 0xC4
	QIER  volatile.Register32 // 0xC8
	QIDR  volatile.Register32 // 0xCC
	QIMR  volatile.Register32 // 0xD0
	QISR  volatile.Register32 // 0xD4
	_     [12]byte
	WPMR  volatile.Register32 // 0xE4
}

// TC.CCR0: Channel Control Register (channel = 0)
func (o *TC_Type) SetCCR0_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR0_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR0.Reg) & 0x1
}
func (o *TC_Type) SetCCR0_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR0_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR0_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR0_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x4) >> 2
}

// TC.CMR0: Channel Mode Register (channel = 0)
func (o *TC_Type) SetCMR0_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR0_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0x7
}
func (o *TC_Type) SetCMR0_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR0_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR0_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR0_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR0_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR0_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR0_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR0_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR0_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR0_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR0_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR0_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR0_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR0_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR0_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR0_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR0_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR0_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR0_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR0_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0xc0000) >> 18
}

// TC.SMMR0: Stepper Motor Mode Register (channel = 0)
func (o *TC_Type) SetSMMR0_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR0.Reg, volatile.LoadUint32(&o.SMMR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR0_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR0.Reg) & 0x1
}
func (o *TC_Type) SetSMMR0_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR0.Reg, volatile.LoadUint32(&o.SMMR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR0_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR0.Reg) & 0x2) >> 1
}

// TC.RAB0: Register AB (channel = 0)
func (o *TC_Type) SetRAB0(value uint32) {
	volatile.StoreUint32(&o.RAB0.Reg, value)
}
func (o *TC_Type) GetRAB0() uint32 {
	return volatile.LoadUint32(&o.RAB0.Reg)
}

// TC.CV0: Counter Value (channel = 0)
func (o *TC_Type) SetCV0(value uint32) {
	volatile.StoreUint32(&o.CV0.Reg, value)
}
func (o *TC_Type) GetCV0() uint32 {
	return volatile.LoadUint32(&o.CV0.Reg)
}

// TC.RA0: Register A (channel = 0)
func (o *TC_Type) SetRA0(value uint32) {
	volatile.StoreUint32(&o.RA0.Reg, value)
}
func (o *TC_Type) GetRA0() uint32 {
	return volatile.LoadUint32(&o.RA0.Reg)
}

// TC.RB0: Register B (channel = 0)
func (o *TC_Type) SetRB0(value uint32) {
	volatile.StoreUint32(&o.RB0.Reg, value)
}
func (o *TC_Type) GetRB0() uint32 {
	return volatile.LoadUint32(&o.RB0.Reg)
}

// TC.RC0: Register C (channel = 0)
func (o *TC_Type) SetRC0(value uint32) {
	volatile.StoreUint32(&o.RC0.Reg, value)
}
func (o *TC_Type) GetRC0() uint32 {
	return volatile.LoadUint32(&o.RC0.Reg)
}

// TC.SR0: Status Register (channel = 0)
func (o *TC_Type) SetSR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR0.Reg) & 0x1
}
func (o *TC_Type) SetSR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR0_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR0_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR0_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR0_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR0_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR0_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40000) >> 18
}

// TC.IER0: Interrupt Enable Register (channel = 0)
func (o *TC_Type) SetIER0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER0.Reg) & 0x1
}
func (o *TC_Type) SetIER0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80) >> 7
}

// TC.IDR0: Interrupt Disable Register (channel = 0)
func (o *TC_Type) SetIDR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR0.Reg) & 0x1
}
func (o *TC_Type) SetIDR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x80) >> 7
}

// TC.IMR0: Interrupt Mask Register (channel = 0)
func (o *TC_Type) SetIMR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR0.Reg) & 0x1
}
func (o *TC_Type) SetIMR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x80) >> 7
}

// TC.CCR1: Channel Control Register (channel = 1)
func (o *TC_Type) SetCCR1_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR1_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0x1
}
func (o *TC_Type) SetCCR1_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR1_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR1_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR1_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4) >> 2
}

// TC.CMR1: Channel Mode Register (channel = 1)
func (o *TC_Type) SetCMR1_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR1_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0x7
}
func (o *TC_Type) SetCMR1_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR1_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR1_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR1_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR1_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR1_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR1_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR1_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR1_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR1_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR1_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR1_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR1_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR1_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR1_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR1_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR1_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR1_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR1_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR1_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0xc0000) >> 18
}

// TC.SMMR1: Stepper Motor Mode Register (channel = 1)
func (o *TC_Type) SetSMMR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR1.Reg, volatile.LoadUint32(&o.SMMR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR1_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR1.Reg) & 0x1
}
func (o *TC_Type) SetSMMR1_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR1.Reg, volatile.LoadUint32(&o.SMMR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR1_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR1.Reg) & 0x2) >> 1
}

// TC.RAB1: Register AB (channel = 1)
func (o *TC_Type) SetRAB1(value uint32) {
	volatile.StoreUint32(&o.RAB1.Reg, value)
}
func (o *TC_Type) GetRAB1() uint32 {
	return volatile.LoadUint32(&o.RAB1.Reg)
}

// TC.CV1: Counter Value (channel = 1)
func (o *TC_Type) SetCV1(value uint32) {
	volatile.StoreUint32(&o.CV1.Reg, value)
}
func (o *TC_Type) GetCV1() uint32 {
	return volatile.LoadUint32(&o.CV1.Reg)
}

// TC.RA1: Register A (channel = 1)
func (o *TC_Type) SetRA1(value uint32) {
	volatile.StoreUint32(&o.RA1.Reg, value)
}
func (o *TC_Type) GetRA1() uint32 {
	return volatile.LoadUint32(&o.RA1.Reg)
}

// TC.RB1: Register B (channel = 1)
func (o *TC_Type) SetRB1(value uint32) {
	volatile.StoreUint32(&o.RB1.Reg, value)
}
func (o *TC_Type) GetRB1() uint32 {
	return volatile.LoadUint32(&o.RB1.Reg)
}

// TC.RC1: Register C (channel = 1)
func (o *TC_Type) SetRC1(value uint32) {
	volatile.StoreUint32(&o.RC1.Reg, value)
}
func (o *TC_Type) GetRC1() uint32 {
	return volatile.LoadUint32(&o.RC1.Reg)
}

// TC.SR1: Status Register (channel = 1)
func (o *TC_Type) SetSR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}
func (o *TC_Type) SetSR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR1_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR1_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR1_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR1_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR1_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR1_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40000) >> 18
}

// TC.IER1: Interrupt Enable Register (channel = 1)
func (o *TC_Type) SetIER1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *TC_Type) SetIER1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80) >> 7
}

// TC.IDR1: Interrupt Disable Register (channel = 1)
func (o *TC_Type) SetIDR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *TC_Type) SetIDR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80) >> 7
}

// TC.IMR1: Interrupt Mask Register (channel = 1)
func (o *TC_Type) SetIMR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *TC_Type) SetIMR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80) >> 7
}

// TC.CCR2: Channel Control Register (channel = 2)
func (o *TC_Type) SetCCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR2_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0x1
}
func (o *TC_Type) SetCCR2_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR2_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR2_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR2_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4) >> 2
}

// TC.CMR2: Channel Mode Register (channel = 2)
func (o *TC_Type) SetCMR2_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR2_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0x7
}
func (o *TC_Type) SetCMR2_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR2_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR2_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR2_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR2_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR2_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR2_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR2_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR2_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR2_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR2_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR2_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR2_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR2_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR2_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR2_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR2_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR2_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR2_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR2_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0xc0000) >> 18
}

// TC.SMMR2: Stepper Motor Mode Register (channel = 2)
func (o *TC_Type) SetSMMR2_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR2.Reg, volatile.LoadUint32(&o.SMMR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR2_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR2.Reg) & 0x1
}
func (o *TC_Type) SetSMMR2_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR2.Reg, volatile.LoadUint32(&o.SMMR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR2_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR2.Reg) & 0x2) >> 1
}

// TC.RAB2: Register AB (channel = 2)
func (o *TC_Type) SetRAB2(value uint32) {
	volatile.StoreUint32(&o.RAB2.Reg, value)
}
func (o *TC_Type) GetRAB2() uint32 {
	return volatile.LoadUint32(&o.RAB2.Reg)
}

// TC.CV2: Counter Value (channel = 2)
func (o *TC_Type) SetCV2(value uint32) {
	volatile.StoreUint32(&o.CV2.Reg, value)
}
func (o *TC_Type) GetCV2() uint32 {
	return volatile.LoadUint32(&o.CV2.Reg)
}

// TC.RA2: Register A (channel = 2)
func (o *TC_Type) SetRA2(value uint32) {
	volatile.StoreUint32(&o.RA2.Reg, value)
}
func (o *TC_Type) GetRA2() uint32 {
	return volatile.LoadUint32(&o.RA2.Reg)
}

// TC.RB2: Register B (channel = 2)
func (o *TC_Type) SetRB2(value uint32) {
	volatile.StoreUint32(&o.RB2.Reg, value)
}
func (o *TC_Type) GetRB2() uint32 {
	return volatile.LoadUint32(&o.RB2.Reg)
}

// TC.RC2: Register C (channel = 2)
func (o *TC_Type) SetRC2(value uint32) {
	volatile.StoreUint32(&o.RC2.Reg, value)
}
func (o *TC_Type) GetRC2() uint32 {
	return volatile.LoadUint32(&o.RC2.Reg)
}

// TC.SR2: Status Register (channel = 2)
func (o *TC_Type) SetSR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR2.Reg) & 0x1
}
func (o *TC_Type) SetSR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR2_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR2_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR2_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR2_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR2_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR2_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40000) >> 18
}

// TC.IER2: Interrupt Enable Register (channel = 2)
func (o *TC_Type) SetIER2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *TC_Type) SetIER2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80) >> 7
}

// TC.IDR2: Interrupt Disable Register (channel = 2)
func (o *TC_Type) SetIDR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *TC_Type) SetIDR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80) >> 7
}

// TC.IMR2: Interrupt Mask Register (channel = 2)
func (o *TC_Type) SetIMR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *TC_Type) SetIMR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80) >> 7
}

// TC.BCR: Block Control Register
func (o *TC_Type) SetBCR_SYNC(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetBCR_SYNC() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// TC.BMR: Block Mode Register
func (o *TC_Type) SetBMR_TC0XC0S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3)|value)
}
func (o *TC_Type) GetBMR_TC0XC0S() uint32 {
	return volatile.LoadUint32(&o.BMR.Reg) & 0x3
}
func (o *TC_Type) SetBMR_TC1XC1S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0xc)|value<<2)
}
func (o *TC_Type) GetBMR_TC1XC1S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0xc) >> 2
}
func (o *TC_Type) SetBMR_TC2XC2S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetBMR_TC2XC2S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetBMR_QDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetBMR_QDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x100) >> 8
}
func (o *TC_Type) SetBMR_POSEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x200)|value<<9)
}
func (o *TC_Type) GetBMR_POSEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x200) >> 9
}
func (o *TC_Type) SetBMR_SPEEDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetBMR_SPEEDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetBMR_QDTRANS(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x800)|value<<11)
}
func (o *TC_Type) GetBMR_QDTRANS() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x800) >> 11
}
func (o *TC_Type) SetBMR_EDGPHA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x1000)|value<<12)
}
func (o *TC_Type) GetBMR_EDGPHA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x1000) >> 12
}
func (o *TC_Type) SetBMR_INVA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x2000)|value<<13)
}
func (o *TC_Type) GetBMR_INVA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x2000) >> 13
}
func (o *TC_Type) SetBMR_INVB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetBMR_INVB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetBMR_INVIDX(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetBMR_INVIDX() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetBMR_SWAP(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetBMR_SWAP() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetBMR_IDXPHB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetBMR_IDXPHB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetBMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x80000)|value<<19)
}
func (o *TC_Type) GetBMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x80000) >> 19
}
func (o *TC_Type) SetBMR_MAXFILT(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3f00000)|value<<20)
}
func (o *TC_Type) GetBMR_MAXFILT() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x3f00000) >> 20
}

// TC.QIER: QDEC Interrupt Enable Register
func (o *TC_Type) SetQIER_IDX(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIER_IDX() uint32 {
	return volatile.LoadUint32(&o.QIER.Reg) & 0x1
}
func (o *TC_Type) SetQIER_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIER_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIER_QERR(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIER_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x4) >> 2
}

// TC.QIDR: QDEC Interrupt Disable Register
func (o *TC_Type) SetQIDR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIDR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIDR.Reg) & 0x1
}
func (o *TC_Type) SetQIDR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIDR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIDR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIDR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x4) >> 2
}

// TC.QIMR: QDEC Interrupt Mask Register
func (o *TC_Type) SetQIMR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIMR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIMR.Reg) & 0x1
}
func (o *TC_Type) SetQIMR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIMR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIMR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIMR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x4) >> 2
}

// TC.QISR: QDEC Interrupt Status Register
func (o *TC_Type) SetQISR_IDX(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQISR_IDX() uint32 {
	return volatile.LoadUint32(&o.QISR.Reg) & 0x1
}
func (o *TC_Type) SetQISR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQISR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQISR_QERR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQISR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetQISR_DIR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetQISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x100) >> 8
}

// TC.WPMR: Write Protect Mode Register
func (o *TC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *TC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Two-wire Interface 0
type TWI_Type struct {
	CR           volatile.Register32 // 0x0
	MMR          volatile.Register32 // 0x4
	SMR          volatile.Register32 // 0x8
	IADR         volatile.Register32 // 0xC
	CWGR         volatile.Register32 // 0x10
	_            [12]byte
	SR           volatile.Register32 // 0x20
	IER          volatile.Register32 // 0x24
	IDR          volatile.Register32 // 0x28
	IMR          volatile.Register32 // 0x2C
	RHR          volatile.Register32 // 0x30
	THR          volatile.Register32 // 0x34
	_            [172]byte
	WPROT_MODE   volatile.Register32 // 0xE4
	WPROT_STATUS volatile.Register32 // 0xE8
}

// TWI.CR: Control Register
func (o *TWI_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TWI_Type) SetCR_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetCR_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetCR_MSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetCR_MSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetCR_MSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetCR_MSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetCR_SVEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetCR_SVEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetCR_SVDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetCR_SVDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetCR_QUICK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetCR_QUICK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// TWI.MMR: Master Mode Register
func (o *TWI_Type) SetMMR_IADRSZ(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x300)|value<<8)
}
func (o *TWI_Type) GetMMR_IADRSZ() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x300) >> 8
}
func (o *TWI_Type) SetMMR_MREAD(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x1000)|value<<12)
}
func (o *TWI_Type) GetMMR_MREAD() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x1000) >> 12
}
func (o *TWI_Type) SetMMR_DADR(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetMMR_DADR() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x7f0000) >> 16
}

// TWI.SMR: Slave Mode Register
func (o *TWI_Type) SetSMR_SADR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetSMR_SADR() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x7f0000) >> 16
}

// TWI.IADR: Internal Address Register
func (o *TWI_Type) SetIADR(value uint32) {
	volatile.StoreUint32(&o.IADR.Reg, volatile.LoadUint32(&o.IADR.Reg)&^(0xffffff)|value)
}
func (o *TWI_Type) GetIADR() uint32 {
	return volatile.LoadUint32(&o.IADR.Reg) & 0xffffff
}

// TWI.CWGR: Clock Waveform Generator Register
func (o *TWI_Type) SetCWGR_CLDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetCWGR_CLDIV() uint32 {
	return volatile.LoadUint32(&o.CWGR.Reg) & 0xff
}
func (o *TWI_Type) SetCWGR_CHDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff00)|value<<8)
}
func (o *TWI_Type) GetCWGR_CHDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0xff00) >> 8
}
func (o *TWI_Type) SetCWGR_CKDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0x70000)|value<<16)
}
func (o *TWI_Type) GetCWGR_CKDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0x70000) >> 16
}

// TWI.SR: Status Register
func (o *TWI_Type) SetSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetSR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TWI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetSR_SVREAD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetSR_SVREAD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetSR_SVACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetSR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetSR_GACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetSR_GACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetSR_NACK(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetSR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetSR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetSR_SCLWS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetSR_SCLWS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetSR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetSR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}

// TWI.IER: Interrupt Enable Register
func (o *TWI_Type) SetIER_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIER_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TWI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIER_SVACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIER_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIER_GACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIER_GACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIER_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIER_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIER_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIER_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIER_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIER_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// TWI.IDR: Interrupt Disable Register
func (o *TWI_Type) SetIDR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIDR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TWI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIDR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIDR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIDR_GACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIDR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIDR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIDR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIDR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIDR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIDR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIDR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// TWI.IMR: Interrupt Mask Register
func (o *TWI_Type) SetIMR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIMR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TWI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIMR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIMR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIMR_GACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIMR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIMR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIMR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIMR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIMR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIMR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIMR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// TWI.RHR: Receive Holding Register
func (o *TWI_Type) SetRHR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetRHR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// TWI.THR: Transmit Holding Register
func (o *TWI_Type) SetTHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetTHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// TWI.WPROT_MODE: Protection Mode Register
func (o *TWI_Type) SetWPROT_MODE_WPROT(value uint32) {
	volatile.StoreUint32(&o.WPROT_MODE.Reg, volatile.LoadUint32(&o.WPROT_MODE.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetWPROT_MODE_WPROT() uint32 {
	return volatile.LoadUint32(&o.WPROT_MODE.Reg) & 0x1
}
func (o *TWI_Type) SetWPROT_MODE_SECURITY_CODE(value uint32) {
	volatile.StoreUint32(&o.WPROT_MODE.Reg, volatile.LoadUint32(&o.WPROT_MODE.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWI_Type) GetWPROT_MODE_SECURITY_CODE() uint32 {
	return (volatile.LoadUint32(&o.WPROT_MODE.Reg) & 0xffffff00) >> 8
}

// TWI.WPROT_STATUS: Protection Status Register
func (o *TWI_Type) SetWPROT_STATUS_WPROTERR(value uint32) {
	volatile.StoreUint32(&o.WPROT_STATUS.Reg, volatile.LoadUint32(&o.WPROT_STATUS.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetWPROT_STATUS_WPROTERR() uint32 {
	return volatile.LoadUint32(&o.WPROT_STATUS.Reg) & 0x1
}
func (o *TWI_Type) SetWPROT_STATUS_WPROTADDR(value uint32) {
	volatile.StoreUint32(&o.WPROT_STATUS.Reg, volatile.LoadUint32(&o.WPROT_STATUS.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWI_Type) GetWPROT_STATUS_WPROTADDR() uint32 {
	return (volatile.LoadUint32(&o.WPROT_STATUS.Reg) & 0xffffff00) >> 8
}

// Universal Synchronous Asynchronous Receiver Transmitter 0
type USART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	CSR  volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	RTOR volatile.Register32 // 0x24
	TTGR volatile.Register32 // 0x28
	_    [20]byte
	FIDI volatile.Register32 // 0x40
	NER  volatile.Register32 // 0x44
	_    [4]byte
	IF   volatile.Register32 // 0x4C
	MAN  volatile.Register32 // 0x50
	_    [144]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// USART.CR: Control Register
func (o *USART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR_STTBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR_STTBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR_STPBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR_STPBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR_STTTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR_STTTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR_SENDA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR_SENDA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR_RSTIT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR_RSTIT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR_RSTNACK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR_RSTNACK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR_RETTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR_RETTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR_RTSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR_RTSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}

// USART.MR: Mode Register
func (o *USART_Type) SetMR_USART_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMR_USART_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xf
}
func (o *USART_Type) SetMR_USCLKS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetMR_USCLKS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetMR_CHRL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc0)|value<<6)
}
func (o *USART_Type) GetMR_CHRL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc0) >> 6
}
func (o *USART_Type) SetMR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetMR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *USART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *USART_Type) SetMR_NBSTOP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetMR_NBSTOP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *USART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}
func (o *USART_Type) SetMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetMR_MODE9(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetMR_MODE9() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetMR_CLKO(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetMR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetMR_OVER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetMR_OVER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetMR_INACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetMR_INACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetMR_DSNACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetMR_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetMR_VAR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetMR_VAR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetMR_INVDATA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetMR_INVDATA() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetMR_MAX_ITERATION(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000000)|value<<24)
}
func (o *USART_Type) GetMR_MAX_ITERATION() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000000) >> 24
}
func (o *USART_Type) SetMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMR_MAN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMR_MAN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMR_MODSYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMR_MODSYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetMR_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetMR_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// USART.IER: Interrupt Enable Register
func (o *USART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *USART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIER_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIER_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIER_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIER_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIER_ITER(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIER_ITER() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIER_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIER_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIER_MANE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIER_MANE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}

// USART.IDR: Interrupt Disable Register
func (o *USART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *USART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIDR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIDR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIDR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIDR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIDR_ITER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIDR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIDR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIDR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIDR_MANE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIDR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}

// USART.IMR: Interrupt Mask Register
func (o *USART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *USART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIMR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIMR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIMR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIMR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIMR_ITER(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIMR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIMR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIMR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIMR_MANE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIMR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}

// USART.CSR: Channel Status Register
func (o *USART_Type) SetCSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *USART_Type) SetCSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCSR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCSR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCSR_PARE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCSR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCSR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCSR_ITER(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCSR_ITER() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCSR_NACK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCSR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCSR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCSR_CTS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCSR_MANERR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetCSR_MANERR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}

// USART.RHR: Receiver Holding Register
func (o *USART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0x1ff
}
func (o *USART_Type) SetRHR_RXSYNH(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetRHR_RXSYNH() uint32 {
	return (volatile.LoadUint32(&o.RHR.Reg) & 0x8000) >> 15
}

// USART.THR: Transmitter Holding Register
func (o *USART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0x1ff
}
func (o *USART_Type) SetTHR_TXSYNH(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetTHR_TXSYNH() uint32 {
	return (volatile.LoadUint32(&o.THR.Reg) & 0x8000) >> 15
}

// USART.BRGR: Baud Rate Generator Register
func (o *USART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}
func (o *USART_Type) SetBRGR_FP(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0x70000)|value<<16)
}
func (o *USART_Type) GetBRGR_FP() uint32 {
	return (volatile.LoadUint32(&o.BRGR.Reg) & 0x70000) >> 16
}

// USART.RTOR: Receiver Time-out Register
func (o *USART_Type) SetRTOR_TO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetRTOR_TO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffff
}

// USART.TTGR: Transmitter Timeguard Register
func (o *USART_Type) SetTTGR_TG(value uint32) {
	volatile.StoreUint32(&o.TTGR.Reg, volatile.LoadUint32(&o.TTGR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetTTGR_TG() uint32 {
	return volatile.LoadUint32(&o.TTGR.Reg) & 0xff
}

// USART.FIDI: FI DI Ratio Register
func (o *USART_Type) SetFIDI_FI_DI_RATIO(value uint32) {
	volatile.StoreUint32(&o.FIDI.Reg, volatile.LoadUint32(&o.FIDI.Reg)&^(0x7ff)|value)
}
func (o *USART_Type) GetFIDI_FI_DI_RATIO() uint32 {
	return volatile.LoadUint32(&o.FIDI.Reg) & 0x7ff
}

// USART.NER: Number of Errors Register
func (o *USART_Type) SetNER_NB_ERRORS(value uint32) {
	volatile.StoreUint32(&o.NER.Reg, volatile.LoadUint32(&o.NER.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetNER_NB_ERRORS() uint32 {
	return volatile.LoadUint32(&o.NER.Reg) & 0xff
}

// USART.IF: IrDA Filter Register
func (o *USART_Type) SetIF_IRDA_FILTER(value uint32) {
	volatile.StoreUint32(&o.IF.Reg, volatile.LoadUint32(&o.IF.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetIF_IRDA_FILTER() uint32 {
	return volatile.LoadUint32(&o.IF.Reg) & 0xff
}

// USART.MAN: Manchester Encoder Decoder Register
func (o *USART_Type) SetMAN_TX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMAN_TX_PL() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xf
}
func (o *USART_Type) SetMAN_TX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x300)|value<<8)
}
func (o *USART_Type) GetMAN_TX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x300) >> 8
}
func (o *USART_Type) SetMAN_TX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetMAN_TX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetMAN_RX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf0000)|value<<16)
}
func (o *USART_Type) GetMAN_RX_PL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf0000) >> 16
}
func (o *USART_Type) SetMAN_RX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x3000000)|value<<24)
}
func (o *USART_Type) GetMAN_RX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x3000000) >> 24
}
func (o *USART_Type) SetMAN_RX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMAN_RX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMAN_ONE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMAN_ONE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMAN_DRIFT(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMAN_DRIFT() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}

// USART.WPMR: Write Protect Mode Register
func (o *USART_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *USART_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// USART.WPSR: Write Protect Status Register
func (o *USART_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *USART_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *USART_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Universal Asynchronous Receiver Transmitter 0
type UART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
}

// UART.CR: Control Register
func (o *UART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// UART.MR: Mode Register
func (o *UART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *UART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *UART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *UART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// UART.IER: Interrupt Enable Register
func (o *UART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *UART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}

// UART.IDR: Interrupt Disable Register
func (o *UART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *UART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}

// UART.IMR: Interrupt Mask Register
func (o *UART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *UART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}

// UART.SR: Status Register
func (o *UART_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *UART_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}

// UART.RHR: Receive Holding Register
func (o *UART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// UART.THR: Transmit Holding Register
func (o *UART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// UART.BRGR: Baud Rate Generator Register
func (o *UART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// Pulse Width Modulation Controller
type PWM_Type struct {
	CLK      volatile.Register32 // 0x0
	ENA      volatile.Register32 // 0x4
	DIS      volatile.Register32 // 0x8
	SR       volatile.Register32 // 0xC
	IER1     volatile.Register32 // 0x10
	IDR1     volatile.Register32 // 0x14
	IMR1     volatile.Register32 // 0x18
	ISR1     volatile.Register32 // 0x1C
	SCM      volatile.Register32 // 0x20
	_        [4]byte
	SCUC     volatile.Register32 // 0x28
	SCUP     volatile.Register32 // 0x2C
	SCUPUPD  volatile.Register32 // 0x30
	IER2     volatile.Register32 // 0x34
	IDR2     volatile.Register32 // 0x38
	IMR2     volatile.Register32 // 0x3C
	ISR2     volatile.Register32 // 0x40
	OOV      volatile.Register32 // 0x44
	OS       volatile.Register32 // 0x48
	OSS      volatile.Register32 // 0x4C
	OSC      volatile.Register32 // 0x50
	OSSUPD   volatile.Register32 // 0x54
	OSCUPD   volatile.Register32 // 0x58
	FMR      volatile.Register32 // 0x5C
	FSR      volatile.Register32 // 0x60
	FCR      volatile.Register32 // 0x64
	FPV      volatile.Register32 // 0x68
	FPE      volatile.Register32 // 0x6C
	_        [12]byte
	ELMR     [2]volatile.Register32 // 0x7C
	_        [44]byte
	SMMR     volatile.Register32 // 0xB0
	_        [48]byte
	WPCR     volatile.Register32 // 0xE4
	WPSR     volatile.Register32 // 0xE8
	_        [68]byte
	CMPV0    volatile.Register32 // 0x130
	CMPVUPD0 volatile.Register32 // 0x134
	CMPM0    volatile.Register32 // 0x138
	CMPMUPD0 volatile.Register32 // 0x13C
	CMPV1    volatile.Register32 // 0x140
	CMPVUPD1 volatile.Register32 // 0x144
	CMPM1    volatile.Register32 // 0x148
	CMPMUPD1 volatile.Register32 // 0x14C
	CMPV2    volatile.Register32 // 0x150
	CMPVUPD2 volatile.Register32 // 0x154
	CMPM2    volatile.Register32 // 0x158
	CMPMUPD2 volatile.Register32 // 0x15C
	CMPV3    volatile.Register32 // 0x160
	CMPVUPD3 volatile.Register32 // 0x164
	CMPM3    volatile.Register32 // 0x168
	CMPMUPD3 volatile.Register32 // 0x16C
	CMPV4    volatile.Register32 // 0x170
	CMPVUPD4 volatile.Register32 // 0x174
	CMPM4    volatile.Register32 // 0x178
	CMPMUPD4 volatile.Register32 // 0x17C
	CMPV5    volatile.Register32 // 0x180
	CMPVUPD5 volatile.Register32 // 0x184
	CMPM5    volatile.Register32 // 0x188
	CMPMUPD5 volatile.Register32 // 0x18C
	CMPV6    volatile.Register32 // 0x190
	CMPVUPD6 volatile.Register32 // 0x194
	CMPM6    volatile.Register32 // 0x198
	CMPMUPD6 volatile.Register32 // 0x19C
	CMPV7    volatile.Register32 // 0x1A0
	CMPVUPD7 volatile.Register32 // 0x1A4
	CMPM7    volatile.Register32 // 0x1A8
	CMPMUPD7 volatile.Register32 // 0x1AC
	_        [80]byte
	CMR0     volatile.Register32 // 0x200
	CDTY0    volatile.Register32 // 0x204
	CDTYUPD0 volatile.Register32 // 0x208
	CPRD0    volatile.Register32 // 0x20C
	CPRDUPD0 volatile.Register32 // 0x210
	CCNT0    volatile.Register32 // 0x214
	DT0      volatile.Register32 // 0x218
	DTUPD0   volatile.Register32 // 0x21C
	CMR1     volatile.Register32 // 0x220
	CDTY1    volatile.Register32 // 0x224
	CDTYUPD1 volatile.Register32 // 0x228
	CPRD1    volatile.Register32 // 0x22C
	CPRDUPD1 volatile.Register32 // 0x230
	CCNT1    volatile.Register32 // 0x234
	DT1      volatile.Register32 // 0x238
	DTUPD1   volatile.Register32 // 0x23C
	CMR2     volatile.Register32 // 0x240
	CDTY2    volatile.Register32 // 0x244
	CDTYUPD2 volatile.Register32 // 0x248
	CPRD2    volatile.Register32 // 0x24C
	CPRDUPD2 volatile.Register32 // 0x250
	CCNT2    volatile.Register32 // 0x254
	DT2      volatile.Register32 // 0x258
	DTUPD2   volatile.Register32 // 0x25C
	CMR3     volatile.Register32 // 0x260
	CDTY3    volatile.Register32 // 0x264
	CDTYUPD3 volatile.Register32 // 0x268
	CPRD3    volatile.Register32 // 0x26C
	CPRDUPD3 volatile.Register32 // 0x270
	CCNT3    volatile.Register32 // 0x274
	DT3      volatile.Register32 // 0x278
	DTUPD3   volatile.Register32 // 0x27C
}

// PWM.CLK: PWM Clock Register
func (o *PWM_Type) SetCLK_DIVA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetCLK_DIVA() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0xff
}
func (o *PWM_Type) SetCLK_PREA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCLK_PREA() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCLK_DIVB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetCLK_DIVB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetCLK_PREB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf000000)|value<<24)
}
func (o *PWM_Type) GetCLK_PREB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf000000) >> 24
}

// PWM.ENA: PWM Enable Register
func (o *PWM_Type) SetENA_CHID0(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENA_CHID0() uint32 {
	return volatile.LoadUint32(&o.ENA.Reg) & 0x1
}
func (o *PWM_Type) SetENA_CHID1(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetENA_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetENA_CHID2(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetENA_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetENA_CHID3(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetENA_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x8) >> 3
}

// PWM.DIS: PWM Disable Register
func (o *PWM_Type) SetDIS_CHID0(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetDIS_CHID0() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}
func (o *PWM_Type) SetDIS_CHID1(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetDIS_CHID1() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetDIS_CHID2(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetDIS_CHID2() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetDIS_CHID3(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetDIS_CHID3() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x8) >> 3
}

// PWM.SR: PWM Status Register
func (o *PWM_Type) SetSR_CHID0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSR_CHID0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *PWM_Type) SetSR_CHID1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSR_CHID2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSR_CHID3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}

// PWM.IER1: PWM Interrupt Enable Register 1
func (o *PWM_Type) SetIER1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *PWM_Type) SetIER1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIER1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIER1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIER1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIER1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80000) >> 19
}

// PWM.IDR1: PWM Interrupt Disable Register 1
func (o *PWM_Type) SetIDR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *PWM_Type) SetIDR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIDR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIDR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIDR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIDR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80000) >> 19
}

// PWM.IMR1: PWM Interrupt Mask Register 1
func (o *PWM_Type) SetIMR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *PWM_Type) SetIMR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIMR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIMR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIMR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIMR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000) >> 19
}

// PWM.ISR1: PWM Interrupt Status Register 1
func (o *PWM_Type) SetISR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg) & 0x1
}
func (o *PWM_Type) SetISR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetISR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetISR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetISR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetISR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x80000) >> 19
}

// PWM.SCM: PWM Sync Channels Mode Register
func (o *PWM_Type) SetSCM_SYNC0(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCM_SYNC0() uint32 {
	return volatile.LoadUint32(&o.SCM.Reg) & 0x1
}
func (o *PWM_Type) SetSCM_SYNC1(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSCM_SYNC1() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSCM_SYNC2(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSCM_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSCM_SYNC3(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSCM_SYNC3() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSCM_UPDM(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x30000)|value<<16)
}
func (o *PWM_Type) GetSCM_UPDM() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x30000) >> 16
}

// PWM.SCUC: PWM Sync Channels Update Control Register
func (o *PWM_Type) SetSCUC_UPDULOCK(value uint32) {
	volatile.StoreUint32(&o.SCUC.Reg, volatile.LoadUint32(&o.SCUC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCUC_UPDULOCK() uint32 {
	return volatile.LoadUint32(&o.SCUC.Reg) & 0x1
}

// PWM.SCUP: PWM Sync Channels Update Period Register
func (o *PWM_Type) SetSCUP_UPR(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUP_UPR() uint32 {
	return volatile.LoadUint32(&o.SCUP.Reg) & 0xf
}
func (o *PWM_Type) SetSCUP_UPRCNT(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSCUP_UPRCNT() uint32 {
	return (volatile.LoadUint32(&o.SCUP.Reg) & 0xf0) >> 4
}

// PWM.SCUPUPD: PWM Sync Channels Update Period Update Register
func (o *PWM_Type) SetSCUPUPD_UPRUPD(value uint32) {
	volatile.StoreUint32(&o.SCUPUPD.Reg, volatile.LoadUint32(&o.SCUPUPD.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUPUPD_UPRUPD() uint32 {
	return volatile.LoadUint32(&o.SCUPUPD.Reg) & 0xf
}

// PWM.IER2: PWM Interrupt Enable Register 2
func (o *PWM_Type) SetIER2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *PWM_Type) SetIER2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIER2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIER2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIER2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIER2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIER2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIER2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIER2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIER2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIER2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIER2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIER2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIER2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIER2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIER2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIER2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIER2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIER2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIER2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIER2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIER2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIER2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIER2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIER2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIER2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800000) >> 23
}

// PWM.IDR2: PWM Interrupt Disable Register 2
func (o *PWM_Type) SetIDR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *PWM_Type) SetIDR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIDR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIDR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIDR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIDR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIDR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIDR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIDR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIDR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIDR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIDR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIDR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIDR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIDR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIDR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIDR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIDR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIDR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIDR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIDR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIDR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIDR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIDR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIDR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIDR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800000) >> 23
}

// PWM.IMR2: PWM Interrupt Mask Register 2
func (o *PWM_Type) SetIMR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *PWM_Type) SetIMR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIMR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIMR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIMR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIMR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIMR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIMR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIMR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIMR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIMR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIMR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIMR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIMR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIMR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIMR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIMR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIMR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIMR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIMR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIMR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIMR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIMR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIMR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIMR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIMR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800000) >> 23
}

// PWM.ISR2: PWM Interrupt Status Register 2
func (o *PWM_Type) SetISR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.ISR2.Reg) & 0x1
}
func (o *PWM_Type) SetISR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetISR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetISR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetISR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetISR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetISR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetISR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetISR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetISR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetISR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetISR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetISR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetISR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetISR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetISR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetISR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetISR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetISR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetISR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetISR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetISR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetISR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetISR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetISR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetISR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800000) >> 23
}

// PWM.OOV: PWM Output Override Value Register
func (o *PWM_Type) SetOOV_OOVH0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOOV_OOVH0() uint32 {
	return volatile.LoadUint32(&o.OOV.Reg) & 0x1
}
func (o *PWM_Type) SetOOV_OOVH1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOOV_OOVH1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOOV_OOVH2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOOV_OOVH2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOOV_OOVH3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOOV_OOVH3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOOV_OOVL0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOOV_OOVL0() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOOV_OOVL1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOOV_OOVL1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOOV_OOVL2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOOV_OOVL2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOOV_OOVL3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOOV_OOVL3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x80000) >> 19
}

// PWM.OS: PWM Output Selection Register
func (o *PWM_Type) SetOS_OSH0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOS_OSH0() uint32 {
	return volatile.LoadUint32(&o.OS.Reg) & 0x1
}
func (o *PWM_Type) SetOS_OSH1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOS_OSH1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOS_OSH2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOS_OSH2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOS_OSH3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOS_OSH3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOS_OSL0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOS_OSL0() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOS_OSL1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOS_OSL1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOS_OSL2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOS_OSL2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOS_OSL3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOS_OSL3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x80000) >> 19
}

// PWM.OSS: PWM Output Selection Set Register
func (o *PWM_Type) SetOSS_OSSH0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSS_OSSH0() uint32 {
	return volatile.LoadUint32(&o.OSS.Reg) & 0x1
}
func (o *PWM_Type) SetOSS_OSSH1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSS_OSSH1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSS_OSSH2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSS_OSSH2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSS_OSSH3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSS_OSSH3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSS_OSSL0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSS_OSSL0() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSS_OSSL1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSS_OSSL1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSS_OSSL2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSS_OSSL2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSS_OSSL3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSS_OSSL3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x80000) >> 19
}

// PWM.OSC: PWM Output Selection Clear Register
func (o *PWM_Type) SetOSC_OSCH0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSC_OSCH0() uint32 {
	return volatile.LoadUint32(&o.OSC.Reg) & 0x1
}
func (o *PWM_Type) SetOSC_OSCH1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSC_OSCH1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSC_OSCH2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSC_OSCH2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSC_OSCH3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSC_OSCH3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSC_OSCL0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSC_OSCL0() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSC_OSCL1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSC_OSCL1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSC_OSCL2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSC_OSCL2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSC_OSCL3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSC_OSCL3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x80000) >> 19
}

// PWM.OSSUPD: PWM Output Selection Set Update Register
func (o *PWM_Type) SetOSSUPD_OSSUPH0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH0() uint32 {
	return volatile.LoadUint32(&o.OSSUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSSUPD_OSSUPH3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSSUPD_OSSUPL0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSSUPD_OSSUPL1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSSUPD_OSSUPL2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSSUPD_OSSUPL3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x80000) >> 19
}

// PWM.OSCUPD: PWM Output Selection Clear Update Register
func (o *PWM_Type) SetOSCUPD_OSCUPH0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH0() uint32 {
	return volatile.LoadUint32(&o.OSCUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSCUPD_OSCUPH3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSCUPD_OSCUPL0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSCUPD_OSCUPL1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSCUPD_OSCUPL2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSCUPD_OSCUPL3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x80000) >> 19
}

// PWM.FMR: PWM Fault Mode Register
func (o *PWM_Type) SetFMR_FPOL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFMR_FPOL() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0xff
}
func (o *PWM_Type) SetFMR_FMOD(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFMR_FMOD() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFMR_FFIL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFMR_FFIL() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff0000) >> 16
}

// PWM.FSR: PWM Fault Status Register
func (o *PWM_Type) SetFSR_FIV(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFSR_FIV() uint32 {
	return volatile.LoadUint32(&o.FSR.Reg) & 0xff
}
func (o *PWM_Type) SetFSR_FS(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFSR_FS() uint32 {
	return (volatile.LoadUint32(&o.FSR.Reg) & 0xff00) >> 8
}

// PWM.FCR: PWM Fault Clear Register
func (o *PWM_Type) SetFCR_FCLR(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFCR_FCLR() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0xff
}

// PWM.FPV: PWM Fault Protection Value Register
func (o *PWM_Type) SetFPV_FPVH0(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetFPV_FPVH0() uint32 {
	return volatile.LoadUint32(&o.FPV.Reg) & 0x1
}
func (o *PWM_Type) SetFPV_FPVH1(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetFPV_FPVH1() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetFPV_FPVH2(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetFPV_FPVH2() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetFPV_FPVH3(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetFPV_FPVH3() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetFPV_FPVL0(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetFPV_FPVL0() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetFPV_FPVL1(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetFPV_FPVL1() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetFPV_FPVL2(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetFPV_FPVL2() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetFPV_FPVL3(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetFPV_FPVL3() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x80000) >> 19
}

// PWM.FPE: PWM Fault Protection Enable Register
func (o *PWM_Type) SetFPE_FPE0(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFPE_FPE0() uint32 {
	return volatile.LoadUint32(&o.FPE.Reg) & 0xff
}
func (o *PWM_Type) SetFPE_FPE1(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFPE_FPE1() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFPE_FPE2(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFPE_FPE2() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetFPE_FPE3(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff000000)|value<<24)
}
func (o *PWM_Type) GetFPE_FPE3() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff000000) >> 24
}

// PWM.ELMR: PWM Event Line 0 Mode Register
func (o *PWM_Type) SetELMR_CSEL0(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetELMR_CSEL0(idx int) uint32 {
	return volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x1
}
func (o *PWM_Type) SetELMR_CSEL1(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetELMR_CSEL1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetELMR_CSEL2(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetELMR_CSEL2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetELMR_CSEL3(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetELMR_CSEL3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetELMR_CSEL4(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetELMR_CSEL4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetELMR_CSEL5(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetELMR_CSEL5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetELMR_CSEL6(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetELMR_CSEL6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetELMR_CSEL7(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetELMR_CSEL7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x80) >> 7
}

// PWM.SMMR: PWM Stepper Motor Mode Register
func (o *PWM_Type) SetSMMR_GCEN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSMMR_GCEN0() uint32 {
	return volatile.LoadUint32(&o.SMMR.Reg) & 0x1
}
func (o *PWM_Type) SetSMMR_GCEN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSMMR_GCEN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSMMR_DOWN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetSMMR_DOWN0() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetSMMR_DOWN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetSMMR_DOWN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x20000) >> 17
}

// PWM.WPCR: PWM Write Protect Control Register
func (o *PWM_Type) SetWPCR_WPCMD(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetWPCR_WPCMD() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x3
}
func (o *PWM_Type) SetWPCR_WPRG0(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPCR_WPRG0() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPCR_WPRG1(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPCR_WPRG1() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPCR_WPRG2(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPCR_WPRG2() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPCR_WPRG3(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPCR_WPRG3() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPCR_WPRG4(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetWPCR_WPRG4() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetWPCR_WPRG5(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPCR_WPRG5() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPCR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PWM_Type) GetWPCR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// PWM.WPSR: PWM Write Protect Status Register
func (o *PWM_Type) SetWPSR_WPSWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetWPSR_WPSWS0() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PWM_Type) SetWPSR_WPSWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetWPSR_WPSWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetWPSR_WPSWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPSR_WPSWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPSR_WPSWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPSR_WPSWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPSR_WPSWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPSR_WPSWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPSR_WPSWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPSR_WPSWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPSR_WPVS() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPSR_WPHWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetWPSR_WPHWS0() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetWPSR_WPHWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetWPSR_WPHWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetWPSR_WPHWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetWPSR_WPHWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetWPSR_WPHWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetWPSR_WPHWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetWPSR_WPHWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetWPSR_WPHWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetWPSR_WPHWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetWPSR_WPHWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff0000) >> 16
}

// PWM.CMPV0: PWM Comparison 0 Value Register
func (o *PWM_Type) SetCMPV0_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV0.Reg, volatile.LoadUint32(&o.CMPV0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV0_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV0.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV0_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV0.Reg, volatile.LoadUint32(&o.CMPV0.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV0_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV0.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD0: PWM Comparison 0 Value Update Register
func (o *PWM_Type) SetCMPVUPD0_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD0.Reg, volatile.LoadUint32(&o.CMPVUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD0_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD0.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD0_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD0.Reg, volatile.LoadUint32(&o.CMPVUPD0.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD0_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD0.Reg) & 0x1000000) >> 24
}

// PWM.CMPM0: PWM Comparison 0 Mode Register
func (o *PWM_Type) SetCMPM0_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM0_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM0.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM0_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM0_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM0_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM0_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM0_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM0_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM0_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM0_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM0_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM0_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD0: PWM Comparison 0 Mode Update Register
func (o *PWM_Type) SetCMPMUPD0_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD0_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD0_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD0_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD0_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD0_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD0_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD0_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf0000) >> 16
}

// PWM.CMPV1: PWM Comparison 1 Value Register
func (o *PWM_Type) SetCMPV1_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV1.Reg, volatile.LoadUint32(&o.CMPV1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV1_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV1.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV1_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV1.Reg, volatile.LoadUint32(&o.CMPV1.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV1_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV1.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD1: PWM Comparison 1 Value Update Register
func (o *PWM_Type) SetCMPVUPD1_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD1.Reg, volatile.LoadUint32(&o.CMPVUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD1_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD1.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD1_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD1.Reg, volatile.LoadUint32(&o.CMPVUPD1.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD1_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD1.Reg) & 0x1000000) >> 24
}

// PWM.CMPM1: PWM Comparison 1 Mode Register
func (o *PWM_Type) SetCMPM1_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM1_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM1.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM1_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM1_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM1_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM1_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM1_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM1_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM1_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM1_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM1_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM1_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD1: PWM Comparison 1 Mode Update Register
func (o *PWM_Type) SetCMPMUPD1_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD1_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD1_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD1_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD1_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD1_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD1_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD1_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf0000) >> 16
}

// PWM.CMPV2: PWM Comparison 2 Value Register
func (o *PWM_Type) SetCMPV2_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV2.Reg, volatile.LoadUint32(&o.CMPV2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV2_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV2.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV2_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV2.Reg, volatile.LoadUint32(&o.CMPV2.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV2_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV2.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD2: PWM Comparison 2 Value Update Register
func (o *PWM_Type) SetCMPVUPD2_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD2.Reg, volatile.LoadUint32(&o.CMPVUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD2_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD2.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD2_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD2.Reg, volatile.LoadUint32(&o.CMPVUPD2.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD2_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD2.Reg) & 0x1000000) >> 24
}

// PWM.CMPM2: PWM Comparison 2 Mode Register
func (o *PWM_Type) SetCMPM2_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM2_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM2.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM2_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM2_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM2_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM2_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM2_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM2_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM2_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM2_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM2_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM2_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD2: PWM Comparison 2 Mode Update Register
func (o *PWM_Type) SetCMPMUPD2_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD2_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD2_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD2_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD2_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD2_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD2_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD2_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf0000) >> 16
}

// PWM.CMPV3: PWM Comparison 3 Value Register
func (o *PWM_Type) SetCMPV3_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV3.Reg, volatile.LoadUint32(&o.CMPV3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV3_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV3.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV3_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV3.Reg, volatile.LoadUint32(&o.CMPV3.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV3_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV3.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD3: PWM Comparison 3 Value Update Register
func (o *PWM_Type) SetCMPVUPD3_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD3.Reg, volatile.LoadUint32(&o.CMPVUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD3_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD3.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD3_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD3.Reg, volatile.LoadUint32(&o.CMPVUPD3.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD3_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD3.Reg) & 0x1000000) >> 24
}

// PWM.CMPM3: PWM Comparison 3 Mode Register
func (o *PWM_Type) SetCMPM3_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM3_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM3.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM3_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM3_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM3_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM3_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM3_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM3_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM3_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM3_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM3_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM3_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD3: PWM Comparison 3 Mode Update Register
func (o *PWM_Type) SetCMPMUPD3_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD3_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD3_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD3_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD3_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD3_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD3_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD3_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf0000) >> 16
}

// PWM.CMPV4: PWM Comparison 4 Value Register
func (o *PWM_Type) SetCMPV4_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV4.Reg, volatile.LoadUint32(&o.CMPV4.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV4_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV4.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV4_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV4.Reg, volatile.LoadUint32(&o.CMPV4.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV4_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV4.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD4: PWM Comparison 4 Value Update Register
func (o *PWM_Type) SetCMPVUPD4_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD4.Reg, volatile.LoadUint32(&o.CMPVUPD4.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD4_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD4.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD4_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD4.Reg, volatile.LoadUint32(&o.CMPVUPD4.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD4_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD4.Reg) & 0x1000000) >> 24
}

// PWM.CMPM4: PWM Comparison 4 Mode Register
func (o *PWM_Type) SetCMPM4_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM4_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM4.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM4_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM4_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM4_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM4_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM4_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM4_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM4_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM4_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM4_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM4_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD4: PWM Comparison 4 Mode Update Register
func (o *PWM_Type) SetCMPMUPD4_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD4_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD4_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD4_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD4_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD4_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD4_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD4_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf0000) >> 16
}

// PWM.CMPV5: PWM Comparison 5 Value Register
func (o *PWM_Type) SetCMPV5_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV5.Reg, volatile.LoadUint32(&o.CMPV5.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV5_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV5.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV5_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV5.Reg, volatile.LoadUint32(&o.CMPV5.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV5_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV5.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD5: PWM Comparison 5 Value Update Register
func (o *PWM_Type) SetCMPVUPD5_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD5.Reg, volatile.LoadUint32(&o.CMPVUPD5.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD5_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD5.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD5_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD5.Reg, volatile.LoadUint32(&o.CMPVUPD5.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD5_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD5.Reg) & 0x1000000) >> 24
}

// PWM.CMPM5: PWM Comparison 5 Mode Register
func (o *PWM_Type) SetCMPM5_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM5_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM5.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM5_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM5_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM5_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM5_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM5_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM5_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM5_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM5_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM5_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM5_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD5: PWM Comparison 5 Mode Update Register
func (o *PWM_Type) SetCMPMUPD5_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD5_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD5_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD5_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD5_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD5_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD5_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD5_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf0000) >> 16
}

// PWM.CMPV6: PWM Comparison 6 Value Register
func (o *PWM_Type) SetCMPV6_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV6.Reg, volatile.LoadUint32(&o.CMPV6.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV6_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV6.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV6_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV6.Reg, volatile.LoadUint32(&o.CMPV6.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV6_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV6.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD6: PWM Comparison 6 Value Update Register
func (o *PWM_Type) SetCMPVUPD6_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD6.Reg, volatile.LoadUint32(&o.CMPVUPD6.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD6_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD6.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD6_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD6.Reg, volatile.LoadUint32(&o.CMPVUPD6.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD6_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD6.Reg) & 0x1000000) >> 24
}

// PWM.CMPM6: PWM Comparison 6 Mode Register
func (o *PWM_Type) SetCMPM6_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM6_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM6.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM6_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM6_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM6_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM6_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM6_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM6_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM6_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM6_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM6_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM6_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD6: PWM Comparison 6 Mode Update Register
func (o *PWM_Type) SetCMPMUPD6_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD6_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD6_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD6_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD6_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD6_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD6_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD6_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf0000) >> 16
}

// PWM.CMPV7: PWM Comparison 7 Value Register
func (o *PWM_Type) SetCMPV7_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV7.Reg, volatile.LoadUint32(&o.CMPV7.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV7_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV7.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV7_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV7.Reg, volatile.LoadUint32(&o.CMPV7.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV7_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV7.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD7: PWM Comparison 7 Value Update Register
func (o *PWM_Type) SetCMPVUPD7_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD7.Reg, volatile.LoadUint32(&o.CMPVUPD7.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD7_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD7.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD7_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD7.Reg, volatile.LoadUint32(&o.CMPVUPD7.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD7_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD7.Reg) & 0x1000000) >> 24
}

// PWM.CMPM7: PWM Comparison 7 Mode Register
func (o *PWM_Type) SetCMPM7_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM7_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM7.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM7_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM7_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM7_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM7_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM7_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM7_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM7_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM7_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM7_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM7_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD7: PWM Comparison 7 Mode Update Register
func (o *PWM_Type) SetCMPMUPD7_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD7_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD7_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD7_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD7_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD7_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD7_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD7_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf0000) >> 16
}

// PWM.CMR0: PWM Channel Mode Register (ch_num = 0)
func (o *PWM_Type) SetCMR0_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR0_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0xf
}
func (o *PWM_Type) SetCMR0_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR0_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR0_CES(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR0_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR0_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR0_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR0_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR0_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR0_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR0_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x40000) >> 18
}

// PWM.CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
func (o *PWM_Type) SetCDTY0_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY0.Reg, volatile.LoadUint32(&o.CDTY0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY0_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY0.Reg) & 0xffffff
}

// PWM.CDTYUPD0: PWM Channel Duty Cycle Update Register (ch_num = 0)
func (o *PWM_Type) SetCDTYUPD0_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD0.Reg, volatile.LoadUint32(&o.CDTYUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD0_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD0.Reg) & 0xffffff
}

// PWM.CPRD0: PWM Channel Period Register (ch_num = 0)
func (o *PWM_Type) SetCPRD0_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD0.Reg, volatile.LoadUint32(&o.CPRD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD0_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD0.Reg) & 0xffffff
}

// PWM.CPRDUPD0: PWM Channel Period Update Register (ch_num = 0)
func (o *PWM_Type) SetCPRDUPD0_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD0.Reg, volatile.LoadUint32(&o.CPRDUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD0_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD0.Reg) & 0xffffff
}

// PWM.CCNT0: PWM Channel Counter Register (ch_num = 0)
func (o *PWM_Type) SetCCNT0_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT0.Reg, volatile.LoadUint32(&o.CCNT0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT0_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT0.Reg) & 0xffffff
}

// PWM.DT0: PWM Channel Dead Time Register (ch_num = 0)
func (o *PWM_Type) SetDT0_DTH(value uint32) {
	volatile.StoreUint32(&o.DT0.Reg, volatile.LoadUint32(&o.DT0.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT0_DTH() uint32 {
	return volatile.LoadUint32(&o.DT0.Reg) & 0xffff
}
func (o *PWM_Type) SetDT0_DTL(value uint32) {
	volatile.StoreUint32(&o.DT0.Reg, volatile.LoadUint32(&o.DT0.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT0_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT0.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD0: PWM Channel Dead Time Update Register (ch_num = 0)
func (o *PWM_Type) SetDTUPD0_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD0.Reg, volatile.LoadUint32(&o.DTUPD0.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD0_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD0.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD0_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD0.Reg, volatile.LoadUint32(&o.DTUPD0.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD0_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD0.Reg) & 0xffff0000) >> 16
}

// PWM.CMR1: PWM Channel Mode Register (ch_num = 1)
func (o *PWM_Type) SetCMR1_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR1_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0xf
}
func (o *PWM_Type) SetCMR1_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR1_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR1_CES(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR1_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR1_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR1_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR1_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR1_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR1_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR1_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x40000) >> 18
}

// PWM.CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
func (o *PWM_Type) SetCDTY1_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY1.Reg, volatile.LoadUint32(&o.CDTY1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY1_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY1.Reg) & 0xffffff
}

// PWM.CDTYUPD1: PWM Channel Duty Cycle Update Register (ch_num = 1)
func (o *PWM_Type) SetCDTYUPD1_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD1.Reg, volatile.LoadUint32(&o.CDTYUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD1_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD1.Reg) & 0xffffff
}

// PWM.CPRD1: PWM Channel Period Register (ch_num = 1)
func (o *PWM_Type) SetCPRD1_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD1.Reg, volatile.LoadUint32(&o.CPRD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD1_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD1.Reg) & 0xffffff
}

// PWM.CPRDUPD1: PWM Channel Period Update Register (ch_num = 1)
func (o *PWM_Type) SetCPRDUPD1_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD1.Reg, volatile.LoadUint32(&o.CPRDUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD1_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD1.Reg) & 0xffffff
}

// PWM.CCNT1: PWM Channel Counter Register (ch_num = 1)
func (o *PWM_Type) SetCCNT1_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT1.Reg, volatile.LoadUint32(&o.CCNT1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT1_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT1.Reg) & 0xffffff
}

// PWM.DT1: PWM Channel Dead Time Register (ch_num = 1)
func (o *PWM_Type) SetDT1_DTH(value uint32) {
	volatile.StoreUint32(&o.DT1.Reg, volatile.LoadUint32(&o.DT1.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT1_DTH() uint32 {
	return volatile.LoadUint32(&o.DT1.Reg) & 0xffff
}
func (o *PWM_Type) SetDT1_DTL(value uint32) {
	volatile.StoreUint32(&o.DT1.Reg, volatile.LoadUint32(&o.DT1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT1_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT1.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD1: PWM Channel Dead Time Update Register (ch_num = 1)
func (o *PWM_Type) SetDTUPD1_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD1.Reg, volatile.LoadUint32(&o.DTUPD1.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD1_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD1.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD1_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD1.Reg, volatile.LoadUint32(&o.DTUPD1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD1_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD1.Reg) & 0xffff0000) >> 16
}

// PWM.CMR2: PWM Channel Mode Register (ch_num = 2)
func (o *PWM_Type) SetCMR2_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR2_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0xf
}
func (o *PWM_Type) SetCMR2_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR2_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR2_CES(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR2_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR2_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR2_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR2_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR2_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR2_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR2_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x40000) >> 18
}

// PWM.CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
func (o *PWM_Type) SetCDTY2_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY2.Reg, volatile.LoadUint32(&o.CDTY2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY2_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY2.Reg) & 0xffffff
}

// PWM.CDTYUPD2: PWM Channel Duty Cycle Update Register (ch_num = 2)
func (o *PWM_Type) SetCDTYUPD2_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD2.Reg, volatile.LoadUint32(&o.CDTYUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD2_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD2.Reg) & 0xffffff
}

// PWM.CPRD2: PWM Channel Period Register (ch_num = 2)
func (o *PWM_Type) SetCPRD2_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD2.Reg, volatile.LoadUint32(&o.CPRD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD2_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD2.Reg) & 0xffffff
}

// PWM.CPRDUPD2: PWM Channel Period Update Register (ch_num = 2)
func (o *PWM_Type) SetCPRDUPD2_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD2.Reg, volatile.LoadUint32(&o.CPRDUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD2_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD2.Reg) & 0xffffff
}

// PWM.CCNT2: PWM Channel Counter Register (ch_num = 2)
func (o *PWM_Type) SetCCNT2_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT2.Reg, volatile.LoadUint32(&o.CCNT2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT2_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT2.Reg) & 0xffffff
}

// PWM.DT2: PWM Channel Dead Time Register (ch_num = 2)
func (o *PWM_Type) SetDT2_DTH(value uint32) {
	volatile.StoreUint32(&o.DT2.Reg, volatile.LoadUint32(&o.DT2.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT2_DTH() uint32 {
	return volatile.LoadUint32(&o.DT2.Reg) & 0xffff
}
func (o *PWM_Type) SetDT2_DTL(value uint32) {
	volatile.StoreUint32(&o.DT2.Reg, volatile.LoadUint32(&o.DT2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT2_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT2.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD2: PWM Channel Dead Time Update Register (ch_num = 2)
func (o *PWM_Type) SetDTUPD2_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD2.Reg, volatile.LoadUint32(&o.DTUPD2.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD2_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD2.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD2_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD2.Reg, volatile.LoadUint32(&o.DTUPD2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD2_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD2.Reg) & 0xffff0000) >> 16
}

// PWM.CMR3: PWM Channel Mode Register (ch_num = 3)
func (o *PWM_Type) SetCMR3_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR3_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR3.Reg) & 0xf
}
func (o *PWM_Type) SetCMR3_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR3_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR3_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR3_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR3_CES(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR3_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR3_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR3_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR3_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR3_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR3_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR3_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x40000) >> 18
}

// PWM.CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
func (o *PWM_Type) SetCDTY3_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY3.Reg, volatile.LoadUint32(&o.CDTY3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY3_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY3.Reg) & 0xffffff
}

// PWM.CDTYUPD3: PWM Channel Duty Cycle Update Register (ch_num = 3)
func (o *PWM_Type) SetCDTYUPD3_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD3.Reg, volatile.LoadUint32(&o.CDTYUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD3_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD3.Reg) & 0xffffff
}

// PWM.CPRD3: PWM Channel Period Register (ch_num = 3)
func (o *PWM_Type) SetCPRD3_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD3.Reg, volatile.LoadUint32(&o.CPRD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD3_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD3.Reg) & 0xffffff
}

// PWM.CPRDUPD3: PWM Channel Period Update Register (ch_num = 3)
func (o *PWM_Type) SetCPRDUPD3_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD3.Reg, volatile.LoadUint32(&o.CPRDUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD3_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD3.Reg) & 0xffffff
}

// PWM.CCNT3: PWM Channel Counter Register (ch_num = 3)
func (o *PWM_Type) SetCCNT3_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT3.Reg, volatile.LoadUint32(&o.CCNT3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT3_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT3.Reg) & 0xffffff
}

// PWM.DT3: PWM Channel Dead Time Register (ch_num = 3)
func (o *PWM_Type) SetDT3_DTH(value uint32) {
	volatile.StoreUint32(&o.DT3.Reg, volatile.LoadUint32(&o.DT3.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT3_DTH() uint32 {
	return volatile.LoadUint32(&o.DT3.Reg) & 0xffff
}
func (o *PWM_Type) SetDT3_DTL(value uint32) {
	volatile.StoreUint32(&o.DT3.Reg, volatile.LoadUint32(&o.DT3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT3_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT3.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD3: PWM Channel Dead Time Update Register (ch_num = 3)
func (o *PWM_Type) SetDTUPD3_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD3.Reg, volatile.LoadUint32(&o.DTUPD3.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD3_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD3.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD3_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD3.Reg, volatile.LoadUint32(&o.DTUPD3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD3_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD3.Reg) & 0xffff0000) >> 16
}

// LCD Controller
type LCDC_Type struct {
	LCDCFG0  volatile.Register32 // 0x0
	LCDCFG1  volatile.Register32 // 0x4
	LCDCFG2  volatile.Register32 // 0x8
	LCDCFG3  volatile.Register32 // 0xC
	LCDCFG4  volatile.Register32 // 0x10
	LCDCFG5  volatile.Register32 // 0x14
	LCDCFG6  volatile.Register32 // 0x18
	_        [4]byte
	LCDEN    volatile.Register32 // 0x20
	LCDDIS   volatile.Register32 // 0x24
	LCDSR    volatile.Register32 // 0x28
	LCDIER   volatile.Register32 // 0x2C
	LCDIDR   volatile.Register32 // 0x30
	LCDIMR   volatile.Register32 // 0x34
	LCDISR   volatile.Register32 // 0x38
	_        [4]byte
	BASECHER volatile.Register32 // 0x40
	BASECHDR volatile.Register32 // 0x44
	BASECHSR volatile.Register32 // 0x48
	BASEIER  volatile.Register32 // 0x4C
	BASEIDR  volatile.Register32 // 0x50
	BASEIMR  volatile.Register32 // 0x54
	BASEISR  volatile.Register32 // 0x58
	BASEHEAD volatile.Register32 // 0x5C
	BASEADDR volatile.Register32 // 0x60
	BASECTRL volatile.Register32 // 0x64
	BASENEXT volatile.Register32 // 0x68
	BASECFG0 volatile.Register32 // 0x6C
	BASECFG1 volatile.Register32 // 0x70
	BASECFG2 volatile.Register32 // 0x74
	BASECFG3 volatile.Register32 // 0x78
	BASECFG4 volatile.Register32 // 0x7C
	BASECFG5 volatile.Register32 // 0x80
	BASECFG6 volatile.Register32 // 0x84
	_        [184]byte
	OVR1CHER volatile.Register32 // 0x140
	OVR1CHDR volatile.Register32 // 0x144
	OVR1CHSR volatile.Register32 // 0x148
	OVR1IER  volatile.Register32 // 0x14C
	OVR1IDR  volatile.Register32 // 0x150
	OVR1IMR  volatile.Register32 // 0x154
	OVR1ISR  volatile.Register32 // 0x158
	OVR1HEAD volatile.Register32 // 0x15C
	OVR1ADDR volatile.Register32 // 0x160
	OVR1CTRL volatile.Register32 // 0x164
	OVR1NEXT volatile.Register32 // 0x168
	OVR1CFG0 volatile.Register32 // 0x16C
	OVR1CFG1 volatile.Register32 // 0x170
	OVR1CFG2 volatile.Register32 // 0x174
	OVR1CFG3 volatile.Register32 // 0x178
	OVR1CFG4 volatile.Register32 // 0x17C
	OVR1CFG5 volatile.Register32 // 0x180
	OVR1CFG6 volatile.Register32 // 0x184
	OVR1CFG7 volatile.Register32 // 0x188
	OVR1CFG8 volatile.Register32 // 0x18C
	OVR1CFG9 volatile.Register32 // 0x190
	_        [172]byte
	OVR2CHER volatile.Register32 // 0x240
	OVR2CHDR volatile.Register32 // 0x244
	OVR2CHSR volatile.Register32 // 0x248
	OVR2IER  volatile.Register32 // 0x24C
	OVR2IDR  volatile.Register32 // 0x250
	OVR2IMR  volatile.Register32 // 0x254
	OVR2ISR  volatile.Register32 // 0x258
	OVR2HEAD volatile.Register32 // 0x25C
	OVR2ADDR volatile.Register32 // 0x260
	OVR2CTRL volatile.Register32 // 0x264
	OVR2NEXT volatile.Register32 // 0x268
	OVR2CFG0 volatile.Register32 // 0x26C
	OVR2CFG1 volatile.Register32 // 0x270
	OVR2CFG2 volatile.Register32 // 0x274
	OVR2CFG3 volatile.Register32 // 0x278
	OVR2CFG4 volatile.Register32 // 0x27C
	OVR2CFG5 volatile.Register32 // 0x280
	OVR2CFG6 volatile.Register32 // 0x284
	OVR2CFG7 volatile.Register32 // 0x288
	OVR2CFG8 volatile.Register32 // 0x28C
	OVR2CFG9 volatile.Register32 // 0x290
	_        [172]byte
	HEOCHER  volatile.Register32 // 0x340
	HEOCHDR  volatile.Register32 // 0x344
	HEOCHSR  volatile.Register32 // 0x348
	HEOIER   volatile.Register32 // 0x34C
	HEOIDR   volatile.Register32 // 0x350
	HEOIMR   volatile.Register32 // 0x354
	HEOISR   volatile.Register32 // 0x358
	HEOHEAD  volatile.Register32 // 0x35C
	HEOADDR  volatile.Register32 // 0x360
	HEOCTRL  volatile.Register32 // 0x364
	HEONEXT  volatile.Register32 // 0x368
	HEOUHEAD volatile.Register32 // 0x36C
	HEOUADDR volatile.Register32 // 0x370
	HEOUCTRL volatile.Register32 // 0x374
	HEOUNEXT volatile.Register32 // 0x378
	HEOVHEAD volatile.Register32 // 0x37C
	HEOVADDR volatile.Register32 // 0x380
	HEOVCTRL volatile.Register32 // 0x384
	HEOVNEXT volatile.Register32 // 0x388
	HEOCFG0  volatile.Register32 // 0x38C
	HEOCFG1  volatile.Register32 // 0x390
	HEOCFG2  volatile.Register32 // 0x394
	HEOCFG3  volatile.Register32 // 0x398
	HEOCFG4  volatile.Register32 // 0x39C
	HEOCFG5  volatile.Register32 // 0x3A0
	HEOCFG6  volatile.Register32 // 0x3A4
	HEOCFG7  volatile.Register32 // 0x3A8
	HEOCFG8  volatile.Register32 // 0x3AC
	HEOCFG9  volatile.Register32 // 0x3B0
	HEOCFG10 volatile.Register32 // 0x3B4
	HEOCFG11 volatile.Register32 // 0x3B8
	HEOCFG12 volatile.Register32 // 0x3BC
	HEOCFG13 volatile.Register32 // 0x3C0
	HEOCFG14 volatile.Register32 // 0x3C4
	HEOCFG15 volatile.Register32 // 0x3C8
	HEOCFG16 volatile.Register32 // 0x3CC
	HEOCFG17 volatile.Register32 // 0x3D0
	HEOCFG18 volatile.Register32 // 0x3D4
	HEOCFG19 volatile.Register32 // 0x3D8
	HEOCFG20 volatile.Register32 // 0x3DC
	HEOCFG21 volatile.Register32 // 0x3E0
	HEOCFG22 volatile.Register32 // 0x3E4
	HEOCFG23 volatile.Register32 // 0x3E8
	HEOCFG24 volatile.Register32 // 0x3EC
	HEOCFG25 volatile.Register32 // 0x3F0
	HEOCFG26 volatile.Register32 // 0x3F4
	HEOCFG27 volatile.Register32 // 0x3F8
	HEOCFG28 volatile.Register32 // 0x3FC
	HEOCFG29 volatile.Register32 // 0x400
	HEOCFG30 volatile.Register32 // 0x404
	HEOCFG31 volatile.Register32 // 0x408
	HEOCFG32 volatile.Register32 // 0x40C
	HEOCFG33 volatile.Register32 // 0x410
	HEOCFG34 volatile.Register32 // 0x414
	HEOCFG35 volatile.Register32 // 0x418
	HEOCFG36 volatile.Register32 // 0x41C
	HEOCFG37 volatile.Register32 // 0x420
	HEOCFG38 volatile.Register32 // 0x424
	HEOCFG39 volatile.Register32 // 0x428
	HEOCFG40 volatile.Register32 // 0x42C
	HEOCFG41 volatile.Register32 // 0x430
	_        [12]byte
	HCRCHER  volatile.Register32 // 0x440
	HCRCHDR  volatile.Register32 // 0x444
	HCRCHSR  volatile.Register32 // 0x448
	HCRIER   volatile.Register32 // 0x44C
	HCRIDR   volatile.Register32 // 0x450
	HCRIMR   volatile.Register32 // 0x454
	HCRISR   volatile.Register32 // 0x458
	HCRHEAD  volatile.Register32 // 0x45C
	HCRADDR  volatile.Register32 // 0x460
	HCRCTRL  volatile.Register32 // 0x464
	HCRNEXT  volatile.Register32 // 0x468
	HCRCFG0  volatile.Register32 // 0x46C
	HCRCFG1  volatile.Register32 // 0x470
	HCRCFG2  volatile.Register32 // 0x474
	HCRCFG3  volatile.Register32 // 0x478
	HCRCFG4  volatile.Register32 // 0x47C
	_        [4]byte
	HCRCFG6  volatile.Register32 // 0x484
	HCRCFG7  volatile.Register32 // 0x488
	HCRCFG8  volatile.Register32 // 0x48C
	HCRCFG9  volatile.Register32 // 0x490
	_        [172]byte
	PPCHER   volatile.Register32 // 0x540
	PPCHDR   volatile.Register32 // 0x544
	PPCHSR   volatile.Register32 // 0x548
	PPIER    volatile.Register32 // 0x54C
	PPIDR    volatile.Register32 // 0x550
	PPIMR    volatile.Register32 // 0x554
	PPISR    volatile.Register32 // 0x558
	PPHEAD   volatile.Register32 // 0x55C
	PPADDR   volatile.Register32 // 0x560
	PPCTRL   volatile.Register32 // 0x564
	PPNEXT   volatile.Register32 // 0x568
	PPCFG0   volatile.Register32 // 0x56C
	PPCFG1   volatile.Register32 // 0x570
	PPCFG2   volatile.Register32 // 0x574
	PPCFG3   volatile.Register32 // 0x578
	PPCFG4   volatile.Register32 // 0x57C
	PPCFG5   volatile.Register32 // 0x580
	_        [124]byte
	BASECLUT [256]volatile.Register32 // 0x600
	OVR1CLUT [256]volatile.Register32 // 0xA00
	OVR2CLUT [256]volatile.Register32 // 0xE00
	HEOCLUT  [256]volatile.Register32 // 0x1200
	HCRCLUT  [256]volatile.Register32 // 0x1600
}

// LCDC.LCDCFG0: LCD Controller Configuration Register 0
func (o *LCDC_Type) SetLCDCFG0_CLKPOL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDCFG0_CLKPOL() uint32 {
	return volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDCFG0_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDCFG0_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDCFG0_CLKPWMSEL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetLCDCFG0_CLKPWMSEL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetLCDCFG0_CGDISBASE(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISBASE() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDCFG0_CGDISOVR1(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISOVR1() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDCFG0_CGDISOVR2(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISOVR2() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDCFG0_CGDISHEO(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISHEO() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDCFG0_CGDISHCR(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISHCR() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDCFG0_CGDISPP(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDCFG0_CGDISPP() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetLCDCFG0_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.LCDCFG0.Reg, volatile.LoadUint32(&o.LCDCFG0.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG0_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG0.Reg) & 0xff0000) >> 16
}

// LCDC.LCDCFG1: LCD Controller Configuration Register 1
func (o *LCDC_Type) SetLCDCFG1_HSPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG1.Reg, volatile.LoadUint32(&o.LCDCFG1.Reg)&^(0x3f)|value)
}
func (o *LCDC_Type) GetLCDCFG1_HSPW() uint32 {
	return volatile.LoadUint32(&o.LCDCFG1.Reg) & 0x3f
}
func (o *LCDC_Type) SetLCDCFG1_VSPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG1.Reg, volatile.LoadUint32(&o.LCDCFG1.Reg)&^(0x3f0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG1_VSPW() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG1.Reg) & 0x3f0000) >> 16
}

// LCDC.LCDCFG2: LCD Controller Configuration Register 2
func (o *LCDC_Type) SetLCDCFG2_VFPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG2.Reg, volatile.LoadUint32(&o.LCDCFG2.Reg)&^(0x3f)|value)
}
func (o *LCDC_Type) GetLCDCFG2_VFPW() uint32 {
	return volatile.LoadUint32(&o.LCDCFG2.Reg) & 0x3f
}
func (o *LCDC_Type) SetLCDCFG2_VBPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG2.Reg, volatile.LoadUint32(&o.LCDCFG2.Reg)&^(0x3f0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG2_VBPW() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG2.Reg) & 0x3f0000) >> 16
}

// LCDC.LCDCFG3: LCD Controller Configuration Register 3
func (o *LCDC_Type) SetLCDCFG3_HFPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG3.Reg, volatile.LoadUint32(&o.LCDCFG3.Reg)&^(0x1ff)|value)
}
func (o *LCDC_Type) GetLCDCFG3_HFPW() uint32 {
	return volatile.LoadUint32(&o.LCDCFG3.Reg) & 0x1ff
}
func (o *LCDC_Type) SetLCDCFG3_HBPW(value uint32) {
	volatile.StoreUint32(&o.LCDCFG3.Reg, volatile.LoadUint32(&o.LCDCFG3.Reg)&^(0x1ff0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG3_HBPW() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG3.Reg) & 0x1ff0000) >> 16
}

// LCDC.LCDCFG4: LCD Controller Configuration Register 4
func (o *LCDC_Type) SetLCDCFG4_PPL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG4.Reg, volatile.LoadUint32(&o.LCDCFG4.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetLCDCFG4_PPL() uint32 {
	return volatile.LoadUint32(&o.LCDCFG4.Reg) & 0x7ff
}
func (o *LCDC_Type) SetLCDCFG4_RPF(value uint32) {
	volatile.StoreUint32(&o.LCDCFG4.Reg, volatile.LoadUint32(&o.LCDCFG4.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG4_RPF() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG4.Reg) & 0x7ff0000) >> 16
}

// LCDC.LCDCFG5: LCD Controller Configuration Register 5
func (o *LCDC_Type) SetLCDCFG5_HSPOL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDCFG5_HSPOL() uint32 {
	return volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDCFG5_VSPOL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDCFG5_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDCFG5_VSPDLYS(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDCFG5_VSPDLYS() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDCFG5_VSPDLYE(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetLCDCFG5_VSPDLYE() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetLCDCFG5_DISPPOL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDCFG5_DISPPOL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDCFG5_DITHER(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCDCFG5_DITHER() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetLCDCFG5_DISPDLY(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x80)|value<<7)
}
func (o *LCDC_Type) GetLCDCFG5_DISPDLY() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x80) >> 7
}
func (o *LCDC_Type) SetLCDCFG5_MODE(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetLCDCFG5_MODE() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x300) >> 8
}
func (o *LCDC_Type) SetLCDCFG5_PP(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDCFG5_PP() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDCFG5_VSPSU(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDCFG5_VSPSU() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDCFG5_VSPHO(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDCFG5_VSPHO() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetLCDCFG5_GUARDTIME(value uint32) {
	volatile.StoreUint32(&o.LCDCFG5.Reg, volatile.LoadUint32(&o.LCDCFG5.Reg)&^(0x1f0000)|value<<16)
}
func (o *LCDC_Type) GetLCDCFG5_GUARDTIME() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG5.Reg) & 0x1f0000) >> 16
}

// LCDC.LCDCFG6: LCD Controller Configuration Register 6
func (o *LCDC_Type) SetLCDCFG6_PWMPS(value uint32) {
	volatile.StoreUint32(&o.LCDCFG6.Reg, volatile.LoadUint32(&o.LCDCFG6.Reg)&^(0x7)|value)
}
func (o *LCDC_Type) GetLCDCFG6_PWMPS() uint32 {
	return volatile.LoadUint32(&o.LCDCFG6.Reg) & 0x7
}
func (o *LCDC_Type) SetLCDCFG6_PWMPOL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG6.Reg, volatile.LoadUint32(&o.LCDCFG6.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDCFG6_PWMPOL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG6.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDCFG6_PWMCVAL(value uint32) {
	volatile.StoreUint32(&o.LCDCFG6.Reg, volatile.LoadUint32(&o.LCDCFG6.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetLCDCFG6_PWMCVAL() uint32 {
	return (volatile.LoadUint32(&o.LCDCFG6.Reg) & 0xff00) >> 8
}

// LCDC.LCDEN: LCD Controller Enable Register
func (o *LCDC_Type) SetLCDEN_CLKEN(value uint32) {
	volatile.StoreUint32(&o.LCDEN.Reg, volatile.LoadUint32(&o.LCDEN.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDEN_CLKEN() uint32 {
	return volatile.LoadUint32(&o.LCDEN.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDEN_SYNCEN(value uint32) {
	volatile.StoreUint32(&o.LCDEN.Reg, volatile.LoadUint32(&o.LCDEN.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDEN_SYNCEN() uint32 {
	return (volatile.LoadUint32(&o.LCDEN.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDEN_DISPEN(value uint32) {
	volatile.StoreUint32(&o.LCDEN.Reg, volatile.LoadUint32(&o.LCDEN.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDEN_DISPEN() uint32 {
	return (volatile.LoadUint32(&o.LCDEN.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDEN_PWMEN(value uint32) {
	volatile.StoreUint32(&o.LCDEN.Reg, volatile.LoadUint32(&o.LCDEN.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetLCDEN_PWMEN() uint32 {
	return (volatile.LoadUint32(&o.LCDEN.Reg) & 0x8) >> 3
}

// LCDC.LCDDIS: LCD Controller Disable Register
func (o *LCDC_Type) SetLCDDIS_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDDIS_CLKDIS() uint32 {
	return volatile.LoadUint32(&o.LCDDIS.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDDIS_SYNCDIS(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDDIS_SYNCDIS() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDDIS_DISPDIS(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDDIS_DISPDIS() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDDIS_PWMDIS(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetLCDDIS_PWMDIS() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetLCDDIS_CLKRST(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDDIS_CLKRST() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDDIS_SYNCRST(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDDIS_SYNCRST() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDDIS_DISPRST(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDDIS_DISPRST() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDDIS_PWMRST(value uint32) {
	volatile.StoreUint32(&o.LCDDIS.Reg, volatile.LoadUint32(&o.LCDDIS.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDDIS_PWMRST() uint32 {
	return (volatile.LoadUint32(&o.LCDDIS.Reg) & 0x800) >> 11
}

// LCDC.LCDSR: LCD Controller Status Register
func (o *LCDC_Type) SetLCDSR_CLKSTS(value uint32) {
	volatile.StoreUint32(&o.LCDSR.Reg, volatile.LoadUint32(&o.LCDSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDSR_CLKSTS() uint32 {
	return volatile.LoadUint32(&o.LCDSR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDSR_LCDSTS(value uint32) {
	volatile.StoreUint32(&o.LCDSR.Reg, volatile.LoadUint32(&o.LCDSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDSR_LCDSTS() uint32 {
	return (volatile.LoadUint32(&o.LCDSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDSR_DISPSTS(value uint32) {
	volatile.StoreUint32(&o.LCDSR.Reg, volatile.LoadUint32(&o.LCDSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDSR_DISPSTS() uint32 {
	return (volatile.LoadUint32(&o.LCDSR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDSR_PWMSTS(value uint32) {
	volatile.StoreUint32(&o.LCDSR.Reg, volatile.LoadUint32(&o.LCDSR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetLCDSR_PWMSTS() uint32 {
	return (volatile.LoadUint32(&o.LCDSR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetLCDSR_SIPSTS(value uint32) {
	volatile.StoreUint32(&o.LCDSR.Reg, volatile.LoadUint32(&o.LCDSR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDSR_SIPSTS() uint32 {
	return (volatile.LoadUint32(&o.LCDSR.Reg) & 0x10) >> 4
}

// LCDC.LCDIER: LCD Controller Interrupt Enable Register
func (o *LCDC_Type) SetLCDIER_SOFIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDIER_SOFIE() uint32 {
	return volatile.LoadUint32(&o.LCDIER.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDIER_DISIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDIER_DISIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDIER_DISPIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDIER_DISPIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDIER_FIFOERRIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDIER_FIFOERRIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDIER_BASEIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDIER_BASEIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDIER_OVR1IE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDIER_OVR1IE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDIER_OVR2IE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDIER_OVR2IE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDIER_HEOIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDIER_HEOIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDIER_HCRIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDIER_HCRIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDIER_PPIE(value uint32) {
	volatile.StoreUint32(&o.LCDIER.Reg, volatile.LoadUint32(&o.LCDIER.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDIER_PPIE() uint32 {
	return (volatile.LoadUint32(&o.LCDIER.Reg) & 0x2000) >> 13
}

// LCDC.LCDIDR: LCD Controller Interrupt Disable Register
func (o *LCDC_Type) SetLCDIDR_SOFID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDIDR_SOFID() uint32 {
	return volatile.LoadUint32(&o.LCDIDR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDIDR_DISID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDIDR_DISID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDIDR_DISPID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDIDR_DISPID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDIDR_FIFOERRID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDIDR_FIFOERRID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDIDR_BASEID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDIDR_BASEID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDIDR_OVR1ID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDIDR_OVR1ID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDIDR_OVR2ID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDIDR_OVR2ID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDIDR_HEOID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDIDR_HEOID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDIDR_HCRID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDIDR_HCRID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDIDR_PPID(value uint32) {
	volatile.StoreUint32(&o.LCDIDR.Reg, volatile.LoadUint32(&o.LCDIDR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDIDR_PPID() uint32 {
	return (volatile.LoadUint32(&o.LCDIDR.Reg) & 0x2000) >> 13
}

// LCDC.LCDIMR: LCD Controller Interrupt Mask Register
func (o *LCDC_Type) SetLCDIMR_SOFIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDIMR_SOFIM() uint32 {
	return volatile.LoadUint32(&o.LCDIMR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDIMR_DISIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDIMR_DISIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDIMR_DISPIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDIMR_DISPIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDIMR_FIFOERRIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDIMR_FIFOERRIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDIMR_BASEIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDIMR_BASEIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDIMR_OVR1IM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDIMR_OVR1IM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDIMR_OVR2IM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDIMR_OVR2IM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDIMR_HEOIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDIMR_HEOIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDIMR_HCRIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDIMR_HCRIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDIMR_PPIM(value uint32) {
	volatile.StoreUint32(&o.LCDIMR.Reg, volatile.LoadUint32(&o.LCDIMR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDIMR_PPIM() uint32 {
	return (volatile.LoadUint32(&o.LCDIMR.Reg) & 0x2000) >> 13
}

// LCDC.LCDISR: LCD Controller Interrupt Status Register
func (o *LCDC_Type) SetLCDISR_SOF(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDISR_SOF() uint32 {
	return volatile.LoadUint32(&o.LCDISR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDISR_DIS(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCDISR_DIS() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCDISR_DISP(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDISR_DISP() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDISR_FIFOERR(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCDISR_FIFOERR() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCDISR_BASE(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDISR_BASE() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDISR_OVR1(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDISR_OVR1() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDISR_OVR2(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDISR_OVR2() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDISR_HEO(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDISR_HEO() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDISR_HCR(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDISR_HCR() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDISR_PP(value uint32) {
	volatile.StoreUint32(&o.LCDISR.Reg, volatile.LoadUint32(&o.LCDISR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetLCDISR_PP() uint32 {
	return (volatile.LoadUint32(&o.LCDISR.Reg) & 0x2000) >> 13
}

// LCDC.BASECHER: Base Layer Channel Enable Register
func (o *LCDC_Type) SetBASECHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.BASECHER.Reg, volatile.LoadUint32(&o.BASECHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.BASECHER.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.BASECHER.Reg, volatile.LoadUint32(&o.BASECHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetBASECHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.BASECHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetBASECHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.BASECHER.Reg, volatile.LoadUint32(&o.BASECHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASECHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.BASECHER.Reg) & 0x4) >> 2
}

// LCDC.BASECHDR: Base Layer Channel Disable Register
func (o *LCDC_Type) SetBASECHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.BASECHDR.Reg, volatile.LoadUint32(&o.BASECHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.BASECHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.BASECHDR.Reg, volatile.LoadUint32(&o.BASECHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetBASECHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.BASECHDR.Reg) & 0x100) >> 8
}

// LCDC.BASECHSR: Base Layer Channel Status Register
func (o *LCDC_Type) SetBASECHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.BASECHSR.Reg, volatile.LoadUint32(&o.BASECHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.BASECHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.BASECHSR.Reg, volatile.LoadUint32(&o.BASECHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetBASECHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.BASECHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetBASECHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.BASECHSR.Reg, volatile.LoadUint32(&o.BASECHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASECHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.BASECHSR.Reg) & 0x4) >> 2
}

// LCDC.BASEIER: Base Layer Interrupt Enable Register
func (o *LCDC_Type) SetBASEIER_DMA(value uint32) {
	volatile.StoreUint32(&o.BASEIER.Reg, volatile.LoadUint32(&o.BASEIER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASEIER_DMA() uint32 {
	return (volatile.LoadUint32(&o.BASEIER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetBASEIER_DSCR(value uint32) {
	volatile.StoreUint32(&o.BASEIER.Reg, volatile.LoadUint32(&o.BASEIER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetBASEIER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.BASEIER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetBASEIER_ADD(value uint32) {
	volatile.StoreUint32(&o.BASEIER.Reg, volatile.LoadUint32(&o.BASEIER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetBASEIER_ADD() uint32 {
	return (volatile.LoadUint32(&o.BASEIER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetBASEIER_DONE(value uint32) {
	volatile.StoreUint32(&o.BASEIER.Reg, volatile.LoadUint32(&o.BASEIER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetBASEIER_DONE() uint32 {
	return (volatile.LoadUint32(&o.BASEIER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetBASEIER_OVR(value uint32) {
	volatile.StoreUint32(&o.BASEIER.Reg, volatile.LoadUint32(&o.BASEIER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetBASEIER_OVR() uint32 {
	return (volatile.LoadUint32(&o.BASEIER.Reg) & 0x40) >> 6
}

// LCDC.BASEIDR: Base Layer Interrupt Disabled Register
func (o *LCDC_Type) SetBASEIDR_DMA(value uint32) {
	volatile.StoreUint32(&o.BASEIDR.Reg, volatile.LoadUint32(&o.BASEIDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASEIDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.BASEIDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetBASEIDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.BASEIDR.Reg, volatile.LoadUint32(&o.BASEIDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetBASEIDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.BASEIDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetBASEIDR_ADD(value uint32) {
	volatile.StoreUint32(&o.BASEIDR.Reg, volatile.LoadUint32(&o.BASEIDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetBASEIDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.BASEIDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetBASEIDR_DONE(value uint32) {
	volatile.StoreUint32(&o.BASEIDR.Reg, volatile.LoadUint32(&o.BASEIDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetBASEIDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.BASEIDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetBASEIDR_OVR(value uint32) {
	volatile.StoreUint32(&o.BASEIDR.Reg, volatile.LoadUint32(&o.BASEIDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetBASEIDR_OVR() uint32 {
	return (volatile.LoadUint32(&o.BASEIDR.Reg) & 0x40) >> 6
}

// LCDC.BASEIMR: Base Layer Interrupt Mask Register
func (o *LCDC_Type) SetBASEIMR_DMA(value uint32) {
	volatile.StoreUint32(&o.BASEIMR.Reg, volatile.LoadUint32(&o.BASEIMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASEIMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.BASEIMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetBASEIMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.BASEIMR.Reg, volatile.LoadUint32(&o.BASEIMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetBASEIMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.BASEIMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetBASEIMR_ADD(value uint32) {
	volatile.StoreUint32(&o.BASEIMR.Reg, volatile.LoadUint32(&o.BASEIMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetBASEIMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.BASEIMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetBASEIMR_DONE(value uint32) {
	volatile.StoreUint32(&o.BASEIMR.Reg, volatile.LoadUint32(&o.BASEIMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetBASEIMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.BASEIMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetBASEIMR_OVR(value uint32) {
	volatile.StoreUint32(&o.BASEIMR.Reg, volatile.LoadUint32(&o.BASEIMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetBASEIMR_OVR() uint32 {
	return (volatile.LoadUint32(&o.BASEIMR.Reg) & 0x40) >> 6
}

// LCDC.BASEISR: Base Layer Interrupt status Register
func (o *LCDC_Type) SetBASEISR_DMA(value uint32) {
	volatile.StoreUint32(&o.BASEISR.Reg, volatile.LoadUint32(&o.BASEISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASEISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.BASEISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetBASEISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.BASEISR.Reg, volatile.LoadUint32(&o.BASEISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetBASEISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.BASEISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetBASEISR_ADD(value uint32) {
	volatile.StoreUint32(&o.BASEISR.Reg, volatile.LoadUint32(&o.BASEISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetBASEISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.BASEISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetBASEISR_DONE(value uint32) {
	volatile.StoreUint32(&o.BASEISR.Reg, volatile.LoadUint32(&o.BASEISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetBASEISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.BASEISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetBASEISR_OVR(value uint32) {
	volatile.StoreUint32(&o.BASEISR.Reg, volatile.LoadUint32(&o.BASEISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetBASEISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.BASEISR.Reg) & 0x40) >> 6
}

// LCDC.BASEHEAD: Base DMA Head Register
func (o *LCDC_Type) SetBASEHEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.BASEHEAD.Reg, volatile.LoadUint32(&o.BASEHEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetBASEHEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.BASEHEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.BASEADDR: Base DMA Address Register
func (o *LCDC_Type) SetBASEADDR(value uint32) {
	volatile.StoreUint32(&o.BASEADDR.Reg, value)
}
func (o *LCDC_Type) GetBASEADDR() uint32 {
	return volatile.LoadUint32(&o.BASEADDR.Reg)
}

// LCDC.BASECTRL: Base DMA Control Register
func (o *LCDC_Type) SetBASECTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.BASECTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECTRL_LFETCH(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetBASECTRL_LFETCH() uint32 {
	return (volatile.LoadUint32(&o.BASECTRL.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetBASECTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetBASECTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.BASECTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetBASECTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetBASECTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.BASECTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetBASECTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetBASECTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.BASECTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetBASECTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.BASECTRL.Reg, volatile.LoadUint32(&o.BASECTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetBASECTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.BASECTRL.Reg) & 0x20) >> 5
}

// LCDC.BASENEXT: Base DMA Next Register
func (o *LCDC_Type) SetBASENEXT(value uint32) {
	volatile.StoreUint32(&o.BASENEXT.Reg, value)
}
func (o *LCDC_Type) GetBASENEXT() uint32 {
	return volatile.LoadUint32(&o.BASENEXT.Reg)
}

// LCDC.BASECFG0: Base Configuration register 0
func (o *LCDC_Type) SetBASECFG0_SIF(value uint32) {
	volatile.StoreUint32(&o.BASECFG0.Reg, volatile.LoadUint32(&o.BASECFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECFG0_SIF() uint32 {
	return volatile.LoadUint32(&o.BASECFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.BASECFG0.Reg, volatile.LoadUint32(&o.BASECFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetBASECFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.BASECFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetBASECFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.BASECFG0.Reg, volatile.LoadUint32(&o.BASECFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetBASECFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.BASECFG0.Reg) & 0x100) >> 8
}

// LCDC.BASECFG1: Base Configuration register 1
func (o *LCDC_Type) SetBASECFG1_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.BASECFG1.Reg, volatile.LoadUint32(&o.BASECFG1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetBASECFG1_CLUTEN() uint32 {
	return volatile.LoadUint32(&o.BASECFG1.Reg) & 0x1
}
func (o *LCDC_Type) SetBASECFG1_RGBMODE(value uint32) {
	volatile.StoreUint32(&o.BASECFG1.Reg, volatile.LoadUint32(&o.BASECFG1.Reg)&^(0xf0)|value<<4)
}
func (o *LCDC_Type) GetBASECFG1_RGBMODE() uint32 {
	return (volatile.LoadUint32(&o.BASECFG1.Reg) & 0xf0) >> 4
}
func (o *LCDC_Type) SetBASECFG1_CLUTMODE(value uint32) {
	volatile.StoreUint32(&o.BASECFG1.Reg, volatile.LoadUint32(&o.BASECFG1.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetBASECFG1_CLUTMODE() uint32 {
	return (volatile.LoadUint32(&o.BASECFG1.Reg) & 0x300) >> 8
}

// LCDC.BASECFG2: Base Configuration register 2
func (o *LCDC_Type) SetBASECFG2(value uint32) {
	volatile.StoreUint32(&o.BASECFG2.Reg, value)
}
func (o *LCDC_Type) GetBASECFG2() uint32 {
	return volatile.LoadUint32(&o.BASECFG2.Reg)
}

// LCDC.BASECFG3: Base Configuration register 3
func (o *LCDC_Type) SetBASECFG3_BDEF(value uint32) {
	volatile.StoreUint32(&o.BASECFG3.Reg, volatile.LoadUint32(&o.BASECFG3.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetBASECFG3_BDEF() uint32 {
	return volatile.LoadUint32(&o.BASECFG3.Reg) & 0xff
}
func (o *LCDC_Type) SetBASECFG3_GDEF(value uint32) {
	volatile.StoreUint32(&o.BASECFG3.Reg, volatile.LoadUint32(&o.BASECFG3.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetBASECFG3_GDEF() uint32 {
	return (volatile.LoadUint32(&o.BASECFG3.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetBASECFG3_RDEF(value uint32) {
	volatile.StoreUint32(&o.BASECFG3.Reg, volatile.LoadUint32(&o.BASECFG3.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetBASECFG3_RDEF() uint32 {
	return (volatile.LoadUint32(&o.BASECFG3.Reg) & 0xff0000) >> 16
}

// LCDC.BASECFG4: Base Configuration register 4
func (o *LCDC_Type) SetBASECFG4_DMA(value uint32) {
	volatile.StoreUint32(&o.BASECFG4.Reg, volatile.LoadUint32(&o.BASECFG4.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetBASECFG4_DMA() uint32 {
	return (volatile.LoadUint32(&o.BASECFG4.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetBASECFG4_REP(value uint32) {
	volatile.StoreUint32(&o.BASECFG4.Reg, volatile.LoadUint32(&o.BASECFG4.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetBASECFG4_REP() uint32 {
	return (volatile.LoadUint32(&o.BASECFG4.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetBASECFG4_DISCEN(value uint32) {
	volatile.StoreUint32(&o.BASECFG4.Reg, volatile.LoadUint32(&o.BASECFG4.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetBASECFG4_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.BASECFG4.Reg) & 0x800) >> 11
}

// LCDC.BASECFG5: Base Configuration register 5
func (o *LCDC_Type) SetBASECFG5_DISCXPOS(value uint32) {
	volatile.StoreUint32(&o.BASECFG5.Reg, volatile.LoadUint32(&o.BASECFG5.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetBASECFG5_DISCXPOS() uint32 {
	return volatile.LoadUint32(&o.BASECFG5.Reg) & 0x7ff
}
func (o *LCDC_Type) SetBASECFG5_DISCYPOS(value uint32) {
	volatile.StoreUint32(&o.BASECFG5.Reg, volatile.LoadUint32(&o.BASECFG5.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetBASECFG5_DISCYPOS() uint32 {
	return (volatile.LoadUint32(&o.BASECFG5.Reg) & 0x7ff0000) >> 16
}

// LCDC.BASECFG6: Base Configuration register 6
func (o *LCDC_Type) SetBASECFG6_DISCXSIZE(value uint32) {
	volatile.StoreUint32(&o.BASECFG6.Reg, volatile.LoadUint32(&o.BASECFG6.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetBASECFG6_DISCXSIZE() uint32 {
	return volatile.LoadUint32(&o.BASECFG6.Reg) & 0x7ff
}
func (o *LCDC_Type) SetBASECFG6_DISCYSIZE(value uint32) {
	volatile.StoreUint32(&o.BASECFG6.Reg, volatile.LoadUint32(&o.BASECFG6.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetBASECFG6_DISCYSIZE() uint32 {
	return (volatile.LoadUint32(&o.BASECFG6.Reg) & 0x7ff0000) >> 16
}

// LCDC.OVR1CHER: Overlay 1 Channel Enable Register
func (o *LCDC_Type) SetOVR1CHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CHER.Reg, volatile.LoadUint32(&o.OVR1CHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.OVR1CHER.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CHER.Reg, volatile.LoadUint32(&o.OVR1CHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR1CHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR1CHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CHER.Reg, volatile.LoadUint32(&o.OVR1CHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1CHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CHER.Reg) & 0x4) >> 2
}

// LCDC.OVR1CHDR: Overlay 1 Channel Disable Register
func (o *LCDC_Type) SetOVR1CHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.OVR1CHDR.Reg, volatile.LoadUint32(&o.OVR1CHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.OVR1CHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.OVR1CHDR.Reg, volatile.LoadUint32(&o.OVR1CHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR1CHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.OVR1CHDR.Reg) & 0x100) >> 8
}

// LCDC.OVR1CHSR: Overlay 1 Channel Status Register
func (o *LCDC_Type) SetOVR1CHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.OVR1CHSR.Reg, volatile.LoadUint32(&o.OVR1CHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.OVR1CHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.OVR1CHSR.Reg, volatile.LoadUint32(&o.OVR1CHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR1CHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.OVR1CHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR1CHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.OVR1CHSR.Reg, volatile.LoadUint32(&o.OVR1CHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1CHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.OVR1CHSR.Reg) & 0x4) >> 2
}

// LCDC.OVR1IER: Overlay 1 Interrupt Enable Register
func (o *LCDC_Type) SetOVR1IER_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR1IER.Reg, volatile.LoadUint32(&o.OVR1IER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1IER_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR1IER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1IER_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR1IER.Reg, volatile.LoadUint32(&o.OVR1IER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1IER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1IER_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR1IER.Reg, volatile.LoadUint32(&o.OVR1IER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1IER_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR1IER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1IER_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR1IER.Reg, volatile.LoadUint32(&o.OVR1IER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1IER_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR1IER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR1IER_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR1IER.Reg, volatile.LoadUint32(&o.OVR1IER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR1IER_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IER.Reg) & 0x40) >> 6
}

// LCDC.OVR1IDR: Overlay 1 Interrupt Disable Register
func (o *LCDC_Type) SetOVR1IDR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR1IDR.Reg, volatile.LoadUint32(&o.OVR1IDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1IDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR1IDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1IDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR1IDR.Reg, volatile.LoadUint32(&o.OVR1IDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1IDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1IDR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR1IDR.Reg, volatile.LoadUint32(&o.OVR1IDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1IDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR1IDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1IDR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR1IDR.Reg, volatile.LoadUint32(&o.OVR1IDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1IDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR1IDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR1IDR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR1IDR.Reg, volatile.LoadUint32(&o.OVR1IDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR1IDR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IDR.Reg) & 0x40) >> 6
}

// LCDC.OVR1IMR: Overlay 1 Interrupt Mask Register
func (o *LCDC_Type) SetOVR1IMR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR1IMR.Reg, volatile.LoadUint32(&o.OVR1IMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1IMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR1IMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1IMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR1IMR.Reg, volatile.LoadUint32(&o.OVR1IMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1IMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1IMR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR1IMR.Reg, volatile.LoadUint32(&o.OVR1IMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1IMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR1IMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1IMR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR1IMR.Reg, volatile.LoadUint32(&o.OVR1IMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1IMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR1IMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR1IMR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR1IMR.Reg, volatile.LoadUint32(&o.OVR1IMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR1IMR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR1IMR.Reg) & 0x40) >> 6
}

// LCDC.OVR1ISR: Overlay 1 Interrupt Status Register
func (o *LCDC_Type) SetOVR1ISR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR1ISR.Reg, volatile.LoadUint32(&o.OVR1ISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1ISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR1ISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1ISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR1ISR.Reg, volatile.LoadUint32(&o.OVR1ISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1ISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR1ISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1ISR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR1ISR.Reg, volatile.LoadUint32(&o.OVR1ISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1ISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR1ISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1ISR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR1ISR.Reg, volatile.LoadUint32(&o.OVR1ISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1ISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR1ISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR1ISR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR1ISR.Reg, volatile.LoadUint32(&o.OVR1ISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR1ISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR1ISR.Reg) & 0x40) >> 6
}

// LCDC.OVR1HEAD: Overlay 1 DMA Head Register
func (o *LCDC_Type) SetOVR1HEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.OVR1HEAD.Reg, volatile.LoadUint32(&o.OVR1HEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetOVR1HEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.OVR1HEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.OVR1ADDR: Overlay 1 DMA Address Register
func (o *LCDC_Type) SetOVR1ADDR(value uint32) {
	volatile.StoreUint32(&o.OVR1ADDR.Reg, value)
}
func (o *LCDC_Type) GetOVR1ADDR() uint32 {
	return volatile.LoadUint32(&o.OVR1ADDR.Reg)
}

// LCDC.OVR1CTRL: Overlay1 DMA Control Register
func (o *LCDC_Type) SetOVR1CTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CTRL_LFETCH(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR1CTRL_LFETCH() uint32 {
	return (volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR1CTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1CTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1CTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1CTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1CTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1CTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1CTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CTRL.Reg, volatile.LoadUint32(&o.OVR1CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1CTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CTRL.Reg) & 0x20) >> 5
}

// LCDC.OVR1NEXT: Overlay1 DMA Next Register
func (o *LCDC_Type) SetOVR1NEXT(value uint32) {
	volatile.StoreUint32(&o.OVR1NEXT.Reg, value)
}
func (o *LCDC_Type) GetOVR1NEXT() uint32 {
	return volatile.LoadUint32(&o.OVR1NEXT.Reg)
}

// LCDC.OVR1CFG0: Overlay 1 Configuration 0 Register
func (o *LCDC_Type) SetOVR1CFG0_SIF(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG0.Reg, volatile.LoadUint32(&o.OVR1CFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CFG0_SIF() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG0.Reg, volatile.LoadUint32(&o.OVR1CFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetOVR1CFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetOVR1CFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG0.Reg, volatile.LoadUint32(&o.OVR1CFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG0.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetOVR1CFG0_ROTDIS(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG0.Reg, volatile.LoadUint32(&o.OVR1CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetOVR1CFG0_ROTDIS() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG0.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetOVR1CFG0_LOCKDIS(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG0.Reg, volatile.LoadUint32(&o.OVR1CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetOVR1CFG0_LOCKDIS() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG0.Reg) & 0x2000) >> 13
}

// LCDC.OVR1CFG1: Overlay 1 Configuration 1 Register
func (o *LCDC_Type) SetOVR1CFG1_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG1.Reg, volatile.LoadUint32(&o.OVR1CFG1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CFG1_CLUTEN() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG1.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CFG1_RGBMODE(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG1.Reg, volatile.LoadUint32(&o.OVR1CFG1.Reg)&^(0xf0)|value<<4)
}
func (o *LCDC_Type) GetOVR1CFG1_RGBMODE() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG1.Reg) & 0xf0) >> 4
}
func (o *LCDC_Type) SetOVR1CFG1_CLUTMODE(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG1.Reg, volatile.LoadUint32(&o.OVR1CFG1.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG1_CLUTMODE() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG1.Reg) & 0x300) >> 8
}

// LCDC.OVR1CFG2: Overlay 1 Configuration 2 Register
func (o *LCDC_Type) SetOVR1CFG2_XPOS(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG2.Reg, volatile.LoadUint32(&o.OVR1CFG2.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetOVR1CFG2_XPOS() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG2.Reg) & 0x7ff
}
func (o *LCDC_Type) SetOVR1CFG2_YPOS(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG2.Reg, volatile.LoadUint32(&o.OVR1CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG2_YPOS() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG2.Reg) & 0x7ff0000) >> 16
}

// LCDC.OVR1CFG3: Overlay 1 Configuration 3 Register
func (o *LCDC_Type) SetOVR1CFG3_XSIZE(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG3.Reg, volatile.LoadUint32(&o.OVR1CFG3.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetOVR1CFG3_XSIZE() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG3.Reg) & 0x7ff
}
func (o *LCDC_Type) SetOVR1CFG3_YSIZE(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG3.Reg, volatile.LoadUint32(&o.OVR1CFG3.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG3_YSIZE() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG3.Reg) & 0x7ff0000) >> 16
}

// LCDC.OVR1CFG4: Overlay 1 Configuration 4 Register
func (o *LCDC_Type) SetOVR1CFG4(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG4.Reg, value)
}
func (o *LCDC_Type) GetOVR1CFG4() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG4.Reg)
}

// LCDC.OVR1CFG5: Overlay 1 Configuration 5 Register
func (o *LCDC_Type) SetOVR1CFG5(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG5.Reg, value)
}
func (o *LCDC_Type) GetOVR1CFG5() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG5.Reg)
}

// LCDC.OVR1CFG6: Overlay 1 Configuration 6 Register
func (o *LCDC_Type) SetOVR1CFG6_BDEF(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG6.Reg, volatile.LoadUint32(&o.OVR1CFG6.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR1CFG6_BDEF() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG6.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR1CFG6_GDEF(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG6.Reg, volatile.LoadUint32(&o.OVR1CFG6.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG6_GDEF() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG6.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR1CFG6_RDEF(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG6.Reg, volatile.LoadUint32(&o.OVR1CFG6.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG6_RDEF() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG6.Reg) & 0xff0000) >> 16
}

// LCDC.OVR1CFG7: Overlay 1 Configuration 7 Register
func (o *LCDC_Type) SetOVR1CFG7_BKEY(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG7.Reg, volatile.LoadUint32(&o.OVR1CFG7.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR1CFG7_BKEY() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG7.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR1CFG7_GKEY(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG7.Reg, volatile.LoadUint32(&o.OVR1CFG7.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG7_GKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG7.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR1CFG7_RKEY(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG7.Reg, volatile.LoadUint32(&o.OVR1CFG7.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG7_RKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG7.Reg) & 0xff0000) >> 16
}

// LCDC.OVR1CFG8: Overlay 1 Configuration 8Register
func (o *LCDC_Type) SetOVR1CFG8_BMASK(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG8.Reg, volatile.LoadUint32(&o.OVR1CFG8.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR1CFG8_BMASK() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG8.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR1CFG8_GMASK(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG8.Reg, volatile.LoadUint32(&o.OVR1CFG8.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG8_GMASK() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG8.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR1CFG8_RMASK(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG8.Reg, volatile.LoadUint32(&o.OVR1CFG8.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG8_RMASK() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG8.Reg) & 0xff0000) >> 16
}

// LCDC.OVR1CFG9: Overlay 1 Configuration 9 Register
func (o *LCDC_Type) SetOVR1CFG9_CRKEY(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR1CFG9_CRKEY() uint32 {
	return volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR1CFG9_INV(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR1CFG9_INV() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR1CFG9_ITER2BL(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR1CFG9_ITER2BL() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR1CFG9_ITER(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR1CFG9_ITER() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR1CFG9_REVALPHA(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR1CFG9_REVALPHA() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR1CFG9_GAEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR1CFG9_GAEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR1CFG9_LAEN(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR1CFG9_LAEN() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetOVR1CFG9_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x80)|value<<7)
}
func (o *LCDC_Type) GetOVR1CFG9_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x80) >> 7
}
func (o *LCDC_Type) SetOVR1CFG9_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR1CFG9_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetOVR1CFG9_REP(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetOVR1CFG9_REP() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetOVR1CFG9_DSTKEY(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetOVR1CFG9_DSTKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetOVR1CFG9_GA(value uint32) {
	volatile.StoreUint32(&o.OVR1CFG9.Reg, volatile.LoadUint32(&o.OVR1CFG9.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CFG9_GA() uint32 {
	return (volatile.LoadUint32(&o.OVR1CFG9.Reg) & 0xff0000) >> 16
}

// LCDC.OVR2CHER: Overlay 2 Channel Enable Register
func (o *LCDC_Type) SetOVR2CHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CHER.Reg, volatile.LoadUint32(&o.OVR2CHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.OVR2CHER.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CHER.Reg, volatile.LoadUint32(&o.OVR2CHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR2CHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR2CHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CHER.Reg, volatile.LoadUint32(&o.OVR2CHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2CHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CHER.Reg) & 0x4) >> 2
}

// LCDC.OVR2CHDR: Overlay 2 Channel Disable Register
func (o *LCDC_Type) SetOVR2CHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.OVR2CHDR.Reg, volatile.LoadUint32(&o.OVR2CHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.OVR2CHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.OVR2CHDR.Reg, volatile.LoadUint32(&o.OVR2CHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR2CHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.OVR2CHDR.Reg) & 0x100) >> 8
}

// LCDC.OVR2CHSR: Overlay 2 Channel Status Register
func (o *LCDC_Type) SetOVR2CHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.OVR2CHSR.Reg, volatile.LoadUint32(&o.OVR2CHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.OVR2CHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.OVR2CHSR.Reg, volatile.LoadUint32(&o.OVR2CHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR2CHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.OVR2CHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR2CHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.OVR2CHSR.Reg, volatile.LoadUint32(&o.OVR2CHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2CHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.OVR2CHSR.Reg) & 0x4) >> 2
}

// LCDC.OVR2IER: Overlay 2 Interrupt Enable Register
func (o *LCDC_Type) SetOVR2IER_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR2IER.Reg, volatile.LoadUint32(&o.OVR2IER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2IER_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR2IER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2IER_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR2IER.Reg, volatile.LoadUint32(&o.OVR2IER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2IER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2IER_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR2IER.Reg, volatile.LoadUint32(&o.OVR2IER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2IER_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR2IER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2IER_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR2IER.Reg, volatile.LoadUint32(&o.OVR2IER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2IER_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR2IER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR2IER_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR2IER.Reg, volatile.LoadUint32(&o.OVR2IER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR2IER_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IER.Reg) & 0x40) >> 6
}

// LCDC.OVR2IDR: Overlay 2 Interrupt Disable Register
func (o *LCDC_Type) SetOVR2IDR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR2IDR.Reg, volatile.LoadUint32(&o.OVR2IDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2IDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR2IDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2IDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR2IDR.Reg, volatile.LoadUint32(&o.OVR2IDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2IDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2IDR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR2IDR.Reg, volatile.LoadUint32(&o.OVR2IDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2IDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR2IDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2IDR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR2IDR.Reg, volatile.LoadUint32(&o.OVR2IDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2IDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR2IDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR2IDR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR2IDR.Reg, volatile.LoadUint32(&o.OVR2IDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR2IDR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IDR.Reg) & 0x40) >> 6
}

// LCDC.OVR2IMR: Overlay 2 Interrupt Mask Register
func (o *LCDC_Type) SetOVR2IMR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR2IMR.Reg, volatile.LoadUint32(&o.OVR2IMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2IMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR2IMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2IMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR2IMR.Reg, volatile.LoadUint32(&o.OVR2IMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2IMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2IMR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR2IMR.Reg, volatile.LoadUint32(&o.OVR2IMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2IMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR2IMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2IMR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR2IMR.Reg, volatile.LoadUint32(&o.OVR2IMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2IMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR2IMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR2IMR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR2IMR.Reg, volatile.LoadUint32(&o.OVR2IMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR2IMR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR2IMR.Reg) & 0x40) >> 6
}

// LCDC.OVR2ISR: Overlay 2 Interrupt status Register
func (o *LCDC_Type) SetOVR2ISR_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR2ISR.Reg, volatile.LoadUint32(&o.OVR2ISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2ISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR2ISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2ISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.OVR2ISR.Reg, volatile.LoadUint32(&o.OVR2ISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2ISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.OVR2ISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2ISR_ADD(value uint32) {
	volatile.StoreUint32(&o.OVR2ISR.Reg, volatile.LoadUint32(&o.OVR2ISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2ISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.OVR2ISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2ISR_DONE(value uint32) {
	volatile.StoreUint32(&o.OVR2ISR.Reg, volatile.LoadUint32(&o.OVR2ISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2ISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.OVR2ISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR2ISR_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR2ISR.Reg, volatile.LoadUint32(&o.OVR2ISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR2ISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR2ISR.Reg) & 0x40) >> 6
}

// LCDC.OVR2HEAD: Overlay 2 DMA Head Register
func (o *LCDC_Type) SetOVR2HEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.OVR2HEAD.Reg, volatile.LoadUint32(&o.OVR2HEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetOVR2HEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.OVR2HEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.OVR2ADDR: Overlay 2 DMA Address Register
func (o *LCDC_Type) SetOVR2ADDR(value uint32) {
	volatile.StoreUint32(&o.OVR2ADDR.Reg, value)
}
func (o *LCDC_Type) GetOVR2ADDR() uint32 {
	return volatile.LoadUint32(&o.OVR2ADDR.Reg)
}

// LCDC.OVR2CTRL: Overlay 2 DMA Control Register
func (o *LCDC_Type) SetOVR2CTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CTRL_LFETCH(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR2CTRL_LFETCH() uint32 {
	return (volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR2CTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2CTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2CTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2CTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2CTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2CTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2CTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CTRL.Reg, volatile.LoadUint32(&o.OVR2CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2CTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CTRL.Reg) & 0x20) >> 5
}

// LCDC.OVR2NEXT: Overlay 2 DMA Next Register
func (o *LCDC_Type) SetOVR2NEXT(value uint32) {
	volatile.StoreUint32(&o.OVR2NEXT.Reg, value)
}
func (o *LCDC_Type) GetOVR2NEXT() uint32 {
	return volatile.LoadUint32(&o.OVR2NEXT.Reg)
}

// LCDC.OVR2CFG0: Overlay 2 Configuration 0 Register
func (o *LCDC_Type) SetOVR2CFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG0.Reg, volatile.LoadUint32(&o.OVR2CFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetOVR2CFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetOVR2CFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG0.Reg, volatile.LoadUint32(&o.OVR2CFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG0.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetOVR2CFG0_ROTDIS(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG0.Reg, volatile.LoadUint32(&o.OVR2CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetOVR2CFG0_ROTDIS() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG0.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetOVR2CFG0_LOCKDIS(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG0.Reg, volatile.LoadUint32(&o.OVR2CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetOVR2CFG0_LOCKDIS() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG0.Reg) & 0x2000) >> 13
}

// LCDC.OVR2CFG1: Overlay 2 Configuration 1 Register
func (o *LCDC_Type) SetOVR2CFG1_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG1.Reg, volatile.LoadUint32(&o.OVR2CFG1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CFG1_CLUTEN() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG1.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CFG1_RGBMODE(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG1.Reg, volatile.LoadUint32(&o.OVR2CFG1.Reg)&^(0xf0)|value<<4)
}
func (o *LCDC_Type) GetOVR2CFG1_RGBMODE() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG1.Reg) & 0xf0) >> 4
}
func (o *LCDC_Type) SetOVR2CFG1_CLUTMODE(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG1.Reg, volatile.LoadUint32(&o.OVR2CFG1.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG1_CLUTMODE() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG1.Reg) & 0x300) >> 8
}

// LCDC.OVR2CFG2: Overlay 2 Configuration 2 Register
func (o *LCDC_Type) SetOVR2CFG2_XPOS(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG2.Reg, volatile.LoadUint32(&o.OVR2CFG2.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetOVR2CFG2_XPOS() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG2.Reg) & 0x7ff
}
func (o *LCDC_Type) SetOVR2CFG2_YPOS(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG2.Reg, volatile.LoadUint32(&o.OVR2CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG2_YPOS() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG2.Reg) & 0x7ff0000) >> 16
}

// LCDC.OVR2CFG3: Overlay 2 Configuration 3 Register
func (o *LCDC_Type) SetOVR2CFG3_XSIZE(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG3.Reg, volatile.LoadUint32(&o.OVR2CFG3.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetOVR2CFG3_XSIZE() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG3.Reg) & 0x7ff
}
func (o *LCDC_Type) SetOVR2CFG3_YSIZE(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG3.Reg, volatile.LoadUint32(&o.OVR2CFG3.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG3_YSIZE() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG3.Reg) & 0x7ff0000) >> 16
}

// LCDC.OVR2CFG4: Overlay 2 Configuration 4 Register
func (o *LCDC_Type) SetOVR2CFG4(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG4.Reg, value)
}
func (o *LCDC_Type) GetOVR2CFG4() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG4.Reg)
}

// LCDC.OVR2CFG5: Overlay 2 Configuration 5 Register
func (o *LCDC_Type) SetOVR2CFG5(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG5.Reg, value)
}
func (o *LCDC_Type) GetOVR2CFG5() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG5.Reg)
}

// LCDC.OVR2CFG6: Overlay 2 Configuration 6 Register
func (o *LCDC_Type) SetOVR2CFG6_BDEF(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG6.Reg, volatile.LoadUint32(&o.OVR2CFG6.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR2CFG6_BDEF() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG6.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR2CFG6_GDEF(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG6.Reg, volatile.LoadUint32(&o.OVR2CFG6.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG6_GDEF() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG6.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR2CFG6_RDEF(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG6.Reg, volatile.LoadUint32(&o.OVR2CFG6.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG6_RDEF() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG6.Reg) & 0xff0000) >> 16
}

// LCDC.OVR2CFG7: Overlay 2 Configuration 7 Register
func (o *LCDC_Type) SetOVR2CFG7_BKEY(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG7.Reg, volatile.LoadUint32(&o.OVR2CFG7.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR2CFG7_BKEY() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG7.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR2CFG7_GKEY(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG7.Reg, volatile.LoadUint32(&o.OVR2CFG7.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG7_GKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG7.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR2CFG7_RKEY(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG7.Reg, volatile.LoadUint32(&o.OVR2CFG7.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG7_RKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG7.Reg) & 0xff0000) >> 16
}

// LCDC.OVR2CFG8: Overlay 2 Configuration 8 Register
func (o *LCDC_Type) SetOVR2CFG8_BMASK(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG8.Reg, volatile.LoadUint32(&o.OVR2CFG8.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR2CFG8_BMASK() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG8.Reg) & 0xff
}
func (o *LCDC_Type) SetOVR2CFG8_GMASK(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG8.Reg, volatile.LoadUint32(&o.OVR2CFG8.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG8_GMASK() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG8.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR2CFG8_RMASK(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG8.Reg, volatile.LoadUint32(&o.OVR2CFG8.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG8_RMASK() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG8.Reg) & 0xff0000) >> 16
}

// LCDC.OVR2CFG9: Overlay 2 Configuration 9 Register
func (o *LCDC_Type) SetOVR2CFG9_CRKEY(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetOVR2CFG9_CRKEY() uint32 {
	return volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x1
}
func (o *LCDC_Type) SetOVR2CFG9_INV(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetOVR2CFG9_INV() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetOVR2CFG9_ITER2BL(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetOVR2CFG9_ITER2BL() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetOVR2CFG9_ITER(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetOVR2CFG9_ITER() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetOVR2CFG9_REVALPHA(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetOVR2CFG9_REVALPHA() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetOVR2CFG9_GAEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetOVR2CFG9_GAEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetOVR2CFG9_LAEN(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetOVR2CFG9_LAEN() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetOVR2CFG9_OVR(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x80)|value<<7)
}
func (o *LCDC_Type) GetOVR2CFG9_OVR() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x80) >> 7
}
func (o *LCDC_Type) SetOVR2CFG9_DMA(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetOVR2CFG9_DMA() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetOVR2CFG9_REP(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetOVR2CFG9_REP() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetOVR2CFG9_DSTKEY(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetOVR2CFG9_DSTKEY() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetOVR2CFG9_GA(value uint32) {
	volatile.StoreUint32(&o.OVR2CFG9.Reg, volatile.LoadUint32(&o.OVR2CFG9.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CFG9_GA() uint32 {
	return (volatile.LoadUint32(&o.OVR2CFG9.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCHER: High-End Overlay Channel Enable Register
func (o *LCDC_Type) SetHEOCHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.HEOCHER.Reg, volatile.LoadUint32(&o.HEOCHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.HEOCHER.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.HEOCHER.Reg, volatile.LoadUint32(&o.HEOCHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHEOCHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHEOCHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.HEOCHER.Reg, volatile.LoadUint32(&o.HEOCHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOCHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCHER.Reg) & 0x4) >> 2
}

// LCDC.HEOCHDR: High-End Overlay Channel Disable Register
func (o *LCDC_Type) SetHEOCHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.HEOCHDR.Reg, volatile.LoadUint32(&o.HEOCHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.HEOCHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.HEOCHDR.Reg, volatile.LoadUint32(&o.HEOCHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHEOCHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.HEOCHDR.Reg) & 0x100) >> 8
}

// LCDC.HEOCHSR: High-End Overlay Channel Status Register
func (o *LCDC_Type) SetHEOCHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.HEOCHSR.Reg, volatile.LoadUint32(&o.HEOCHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.HEOCHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.HEOCHSR.Reg, volatile.LoadUint32(&o.HEOCHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHEOCHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.HEOCHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHEOCHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.HEOCHSR.Reg, volatile.LoadUint32(&o.HEOCHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOCHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.HEOCHSR.Reg) & 0x4) >> 2
}

// LCDC.HEOIER: High-End Overlay Interrupt Enable Register
func (o *LCDC_Type) SetHEOIER_DMA(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOIER_DMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOIER_DSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOIER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOIER_ADD(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOIER_ADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOIER_DONE(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOIER_DONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHEOIER_OVR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHEOIER_OVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHEOIER_UDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHEOIER_UDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHEOIER_UDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetHEOIER_UDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetHEOIER_UADD(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOIER_UADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOIER_UDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetHEOIER_UDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetHEOIER_UOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x4000)|value<<14)
}
func (o *LCDC_Type) GetHEOIER_UOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x4000) >> 14
}
func (o *LCDC_Type) SetHEOIER_VDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x40000)|value<<18)
}
func (o *LCDC_Type) GetHEOIER_VDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x40000) >> 18
}
func (o *LCDC_Type) SetHEOIER_VDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x80000)|value<<19)
}
func (o *LCDC_Type) GetHEOIER_VDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x80000) >> 19
}
func (o *LCDC_Type) SetHEOIER_VADD(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x100000)|value<<20)
}
func (o *LCDC_Type) GetHEOIER_VADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x100000) >> 20
}
func (o *LCDC_Type) SetHEOIER_VDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x200000)|value<<21)
}
func (o *LCDC_Type) GetHEOIER_VDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x200000) >> 21
}
func (o *LCDC_Type) SetHEOIER_VOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIER.Reg, volatile.LoadUint32(&o.HEOIER.Reg)&^(0x400000)|value<<22)
}
func (o *LCDC_Type) GetHEOIER_VOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIER.Reg) & 0x400000) >> 22
}

// LCDC.HEOIDR: High-End Overlay Interrupt Disable Register
func (o *LCDC_Type) SetHEOIDR_DMA(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOIDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOIDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOIDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOIDR_ADD(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOIDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOIDR_DONE(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOIDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHEOIDR_OVR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHEOIDR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHEOIDR_UDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHEOIDR_UDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHEOIDR_UDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetHEOIDR_UDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetHEOIDR_UADD(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOIDR_UADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOIDR_UDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetHEOIDR_UDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetHEOIDR_UOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x4000)|value<<14)
}
func (o *LCDC_Type) GetHEOIDR_UOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x4000) >> 14
}
func (o *LCDC_Type) SetHEOIDR_VDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x40000)|value<<18)
}
func (o *LCDC_Type) GetHEOIDR_VDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x40000) >> 18
}
func (o *LCDC_Type) SetHEOIDR_VDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x80000)|value<<19)
}
func (o *LCDC_Type) GetHEOIDR_VDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x80000) >> 19
}
func (o *LCDC_Type) SetHEOIDR_VADD(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x100000)|value<<20)
}
func (o *LCDC_Type) GetHEOIDR_VADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x100000) >> 20
}
func (o *LCDC_Type) SetHEOIDR_VDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x200000)|value<<21)
}
func (o *LCDC_Type) GetHEOIDR_VDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x200000) >> 21
}
func (o *LCDC_Type) SetHEOIDR_VOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIDR.Reg, volatile.LoadUint32(&o.HEOIDR.Reg)&^(0x400000)|value<<22)
}
func (o *LCDC_Type) GetHEOIDR_VOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIDR.Reg) & 0x400000) >> 22
}

// LCDC.HEOIMR: High-End Overlay Interrupt Mask Register
func (o *LCDC_Type) SetHEOIMR_DMA(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOIMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOIMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOIMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOIMR_ADD(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOIMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOIMR_DONE(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOIMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHEOIMR_OVR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHEOIMR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHEOIMR_UDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHEOIMR_UDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHEOIMR_UDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetHEOIMR_UDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetHEOIMR_UADD(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOIMR_UADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOIMR_UDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetHEOIMR_UDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetHEOIMR_UOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x4000)|value<<14)
}
func (o *LCDC_Type) GetHEOIMR_UOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x4000) >> 14
}
func (o *LCDC_Type) SetHEOIMR_VDMA(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x40000)|value<<18)
}
func (o *LCDC_Type) GetHEOIMR_VDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x40000) >> 18
}
func (o *LCDC_Type) SetHEOIMR_VDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x80000)|value<<19)
}
func (o *LCDC_Type) GetHEOIMR_VDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x80000) >> 19
}
func (o *LCDC_Type) SetHEOIMR_VADD(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x100000)|value<<20)
}
func (o *LCDC_Type) GetHEOIMR_VADD() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x100000) >> 20
}
func (o *LCDC_Type) SetHEOIMR_VDONE(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x200000)|value<<21)
}
func (o *LCDC_Type) GetHEOIMR_VDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x200000) >> 21
}
func (o *LCDC_Type) SetHEOIMR_VOVR(value uint32) {
	volatile.StoreUint32(&o.HEOIMR.Reg, volatile.LoadUint32(&o.HEOIMR.Reg)&^(0x400000)|value<<22)
}
func (o *LCDC_Type) GetHEOIMR_VOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOIMR.Reg) & 0x400000) >> 22
}

// LCDC.HEOISR: High-End Overlay Interrupt Status Register
func (o *LCDC_Type) SetHEOISR_DMA(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOISR_ADD(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOISR_DONE(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHEOISR_OVR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHEOISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHEOISR_UDMA(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHEOISR_UDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHEOISR_UDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetHEOISR_UDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetHEOISR_UADD(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOISR_UADD() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOISR_UDONE(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetHEOISR_UDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x2000) >> 13
}
func (o *LCDC_Type) SetHEOISR_UOVR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x4000)|value<<14)
}
func (o *LCDC_Type) GetHEOISR_UOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x4000) >> 14
}
func (o *LCDC_Type) SetHEOISR_VDMA(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x40000)|value<<18)
}
func (o *LCDC_Type) GetHEOISR_VDMA() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x40000) >> 18
}
func (o *LCDC_Type) SetHEOISR_VDSCR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x80000)|value<<19)
}
func (o *LCDC_Type) GetHEOISR_VDSCR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x80000) >> 19
}
func (o *LCDC_Type) SetHEOISR_VADD(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x100000)|value<<20)
}
func (o *LCDC_Type) GetHEOISR_VADD() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x100000) >> 20
}
func (o *LCDC_Type) SetHEOISR_VDONE(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x200000)|value<<21)
}
func (o *LCDC_Type) GetHEOISR_VDONE() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x200000) >> 21
}
func (o *LCDC_Type) SetHEOISR_VOVR(value uint32) {
	volatile.StoreUint32(&o.HEOISR.Reg, volatile.LoadUint32(&o.HEOISR.Reg)&^(0x400000)|value<<22)
}
func (o *LCDC_Type) GetHEOISR_VOVR() uint32 {
	return (volatile.LoadUint32(&o.HEOISR.Reg) & 0x400000) >> 22
}

// LCDC.HEOHEAD: High-End Overlay DMA Head Register
func (o *LCDC_Type) SetHEOHEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.HEOHEAD.Reg, volatile.LoadUint32(&o.HEOHEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetHEOHEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.HEOHEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.HEOADDR: High-End Overlay DMA Address Register
func (o *LCDC_Type) SetHEOADDR(value uint32) {
	volatile.StoreUint32(&o.HEOADDR.Reg, value)
}
func (o *LCDC_Type) GetHEOADDR() uint32 {
	return volatile.LoadUint32(&o.HEOADDR.Reg)
}

// LCDC.HEOCTRL: High-End Overlay DMA Control Register
func (o *LCDC_Type) SetHEOCTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCTRL_LFETCH(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHEOCTRL_LFETCH() uint32 {
	return (volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHEOCTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOCTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOCTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOCTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOCTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOCTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOCTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.HEOCTRL.Reg, volatile.LoadUint32(&o.HEOCTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOCTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCTRL.Reg) & 0x20) >> 5
}

// LCDC.HEONEXT: High-End Overlay DMA Next Register
func (o *LCDC_Type) SetHEONEXT(value uint32) {
	volatile.StoreUint32(&o.HEONEXT.Reg, value)
}
func (o *LCDC_Type) GetHEONEXT() uint32 {
	return volatile.LoadUint32(&o.HEONEXT.Reg)
}

// LCDC.HEOUHEAD: High-End Overlay U DMA Head Register
func (o *LCDC_Type) SetHEOUHEAD(value uint32) {
	volatile.StoreUint32(&o.HEOUHEAD.Reg, value)
}
func (o *LCDC_Type) GetHEOUHEAD() uint32 {
	return volatile.LoadUint32(&o.HEOUHEAD.Reg)
}

// LCDC.HEOUADDR: High-End Overlay U DMA Address Register
func (o *LCDC_Type) SetHEOUADDR(value uint32) {
	volatile.StoreUint32(&o.HEOUADDR.Reg, value)
}
func (o *LCDC_Type) GetHEOUADDR() uint32 {
	return volatile.LoadUint32(&o.HEOUADDR.Reg)
}

// LCDC.HEOUCTRL: High-End Overlay U DMA control Register
func (o *LCDC_Type) SetHEOUCTRL_UDFETCH(value uint32) {
	volatile.StoreUint32(&o.HEOUCTRL.Reg, volatile.LoadUint32(&o.HEOUCTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOUCTRL_UDFETCH() uint32 {
	return volatile.LoadUint32(&o.HEOUCTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOUCTRL_UDMAIEN(value uint32) {
	volatile.StoreUint32(&o.HEOUCTRL.Reg, volatile.LoadUint32(&o.HEOUCTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOUCTRL_UDMAIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOUCTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOUCTRL_UDSCRIEN(value uint32) {
	volatile.StoreUint32(&o.HEOUCTRL.Reg, volatile.LoadUint32(&o.HEOUCTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOUCTRL_UDSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOUCTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOUCTRL_UADDIEN(value uint32) {
	volatile.StoreUint32(&o.HEOUCTRL.Reg, volatile.LoadUint32(&o.HEOUCTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOUCTRL_UADDIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOUCTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOUCTRL_UDONEIEN(value uint32) {
	volatile.StoreUint32(&o.HEOUCTRL.Reg, volatile.LoadUint32(&o.HEOUCTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOUCTRL_UDONEIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOUCTRL.Reg) & 0x20) >> 5
}

// LCDC.HEOUNEXT: High-End Overlay U DMA Next Register
func (o *LCDC_Type) SetHEOUNEXT(value uint32) {
	volatile.StoreUint32(&o.HEOUNEXT.Reg, value)
}
func (o *LCDC_Type) GetHEOUNEXT() uint32 {
	return volatile.LoadUint32(&o.HEOUNEXT.Reg)
}

// LCDC.HEOVHEAD: High-End Overlay V DMA Head Register
func (o *LCDC_Type) SetHEOVHEAD(value uint32) {
	volatile.StoreUint32(&o.HEOVHEAD.Reg, value)
}
func (o *LCDC_Type) GetHEOVHEAD() uint32 {
	return volatile.LoadUint32(&o.HEOVHEAD.Reg)
}

// LCDC.HEOVADDR: High-End Overlay V DMA Address Register
func (o *LCDC_Type) SetHEOVADDR(value uint32) {
	volatile.StoreUint32(&o.HEOVADDR.Reg, value)
}
func (o *LCDC_Type) GetHEOVADDR() uint32 {
	return volatile.LoadUint32(&o.HEOVADDR.Reg)
}

// LCDC.HEOVCTRL: High-End Overlay V DMA control Register
func (o *LCDC_Type) SetHEOVCTRL_VDFETCH(value uint32) {
	volatile.StoreUint32(&o.HEOVCTRL.Reg, volatile.LoadUint32(&o.HEOVCTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOVCTRL_VDFETCH() uint32 {
	return volatile.LoadUint32(&o.HEOVCTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOVCTRL_VDMAIEN(value uint32) {
	volatile.StoreUint32(&o.HEOVCTRL.Reg, volatile.LoadUint32(&o.HEOVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOVCTRL_VDMAIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOVCTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOVCTRL_VDSCRIEN(value uint32) {
	volatile.StoreUint32(&o.HEOVCTRL.Reg, volatile.LoadUint32(&o.HEOVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOVCTRL_VDSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOVCTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOVCTRL_VADDIEN(value uint32) {
	volatile.StoreUint32(&o.HEOVCTRL.Reg, volatile.LoadUint32(&o.HEOVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOVCTRL_VADDIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOVCTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOVCTRL_VDONEIEN(value uint32) {
	volatile.StoreUint32(&o.HEOVCTRL.Reg, volatile.LoadUint32(&o.HEOVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOVCTRL_VDONEIEN() uint32 {
	return (volatile.LoadUint32(&o.HEOVCTRL.Reg) & 0x20) >> 5
}

// LCDC.HEOVNEXT: High-End Overlay VDMA Next Register
func (o *LCDC_Type) SetHEOVNEXT(value uint32) {
	volatile.StoreUint32(&o.HEOVNEXT.Reg, value)
}
func (o *LCDC_Type) GetHEOVNEXT() uint32 {
	return volatile.LoadUint32(&o.HEOVNEXT.Reg)
}

// LCDC.HEOCFG0: High-End Overlay Configuration Register 0
func (o *LCDC_Type) SetHEOCFG0_SIF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCFG0_SIF() uint32 {
	return volatile.LoadUint32(&o.HEOCFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetHEOCFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetHEOCFG0_BLENUV(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0xc0)|value<<6)
}
func (o *LCDC_Type) GetHEOCFG0_BLENUV() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG0.Reg) & 0xc0) >> 6
}
func (o *LCDC_Type) SetHEOCFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG0.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetHEOCFG0_ROTDIS(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOCFG0_ROTDIS() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG0.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOCFG0_LOCKDIS(value uint32) {
	volatile.StoreUint32(&o.HEOCFG0.Reg, volatile.LoadUint32(&o.HEOCFG0.Reg)&^(0x2000)|value<<13)
}
func (o *LCDC_Type) GetHEOCFG0_LOCKDIS() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG0.Reg) & 0x2000) >> 13
}

// LCDC.HEOCFG1: High-End Overlay Configuration Register 1
func (o *LCDC_Type) SetHEOCFG1_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCFG1_CLUTEN() uint32 {
	return volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCFG1_YUVEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHEOCFG1_YUVEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHEOCFG1_RGBMODE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0xf0)|value<<4)
}
func (o *LCDC_Type) GetHEOCFG1_RGBMODE() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0xf0) >> 4
}
func (o *LCDC_Type) SetHEOCFG1_CLUTMODE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG1_CLUTMODE() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x300) >> 8
}
func (o *LCDC_Type) SetHEOCFG1_YUVMODE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0xf000)|value<<12)
}
func (o *LCDC_Type) GetHEOCFG1_YUVMODE() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0xf000) >> 12
}
func (o *LCDC_Type) SetHEOCFG1_YUV422ROT(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x10000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG1_YUV422ROT() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x10000) >> 16
}
func (o *LCDC_Type) SetHEOCFG1_YUV422SWP(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x20000)|value<<17)
}
func (o *LCDC_Type) GetHEOCFG1_YUV422SWP() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x20000) >> 17
}
func (o *LCDC_Type) SetHEOCFG1_DSCALEOPT(value uint32) {
	volatile.StoreUint32(&o.HEOCFG1.Reg, volatile.LoadUint32(&o.HEOCFG1.Reg)&^(0x100000)|value<<20)
}
func (o *LCDC_Type) GetHEOCFG1_DSCALEOPT() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG1.Reg) & 0x100000) >> 20
}

// LCDC.HEOCFG2: High-End Overlay Configuration Register 2
func (o *LCDC_Type) SetHEOCFG2_XPOS(value uint32) {
	volatile.StoreUint32(&o.HEOCFG2.Reg, volatile.LoadUint32(&o.HEOCFG2.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetHEOCFG2_XPOS() uint32 {
	return volatile.LoadUint32(&o.HEOCFG2.Reg) & 0x7ff
}
func (o *LCDC_Type) SetHEOCFG2_YPOS(value uint32) {
	volatile.StoreUint32(&o.HEOCFG2.Reg, volatile.LoadUint32(&o.HEOCFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG2_YPOS() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG2.Reg) & 0x7ff0000) >> 16
}

// LCDC.HEOCFG3: High-End Overlay Configuration Register 3
func (o *LCDC_Type) SetHEOCFG3_XSIZE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG3.Reg, volatile.LoadUint32(&o.HEOCFG3.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetHEOCFG3_XSIZE() uint32 {
	return volatile.LoadUint32(&o.HEOCFG3.Reg) & 0x7ff
}
func (o *LCDC_Type) SetHEOCFG3_YSIZE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG3.Reg, volatile.LoadUint32(&o.HEOCFG3.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG3_YSIZE() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG3.Reg) & 0x7ff0000) >> 16
}

// LCDC.HEOCFG4: High-End Overlay Configuration Register 4
func (o *LCDC_Type) SetHEOCFG4_XMEMSIZE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG4.Reg, volatile.LoadUint32(&o.HEOCFG4.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetHEOCFG4_XMEMSIZE() uint32 {
	return volatile.LoadUint32(&o.HEOCFG4.Reg) & 0x7ff
}
func (o *LCDC_Type) SetHEOCFG4_YMEMSIZE(value uint32) {
	volatile.StoreUint32(&o.HEOCFG4.Reg, volatile.LoadUint32(&o.HEOCFG4.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG4_YMEMSIZE() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG4.Reg) & 0x7ff0000) >> 16
}

// LCDC.HEOCFG5: High-End Overlay Configuration Register 5
func (o *LCDC_Type) SetHEOCFG5(value uint32) {
	volatile.StoreUint32(&o.HEOCFG5.Reg, value)
}
func (o *LCDC_Type) GetHEOCFG5() uint32 {
	return volatile.LoadUint32(&o.HEOCFG5.Reg)
}

// LCDC.HEOCFG6: High-End Overlay Configuration Register 6
func (o *LCDC_Type) SetHEOCFG6(value uint32) {
	volatile.StoreUint32(&o.HEOCFG6.Reg, value)
}
func (o *LCDC_Type) GetHEOCFG6() uint32 {
	return volatile.LoadUint32(&o.HEOCFG6.Reg)
}

// LCDC.HEOCFG7: High-End Overlay Configuration Register 7
func (o *LCDC_Type) SetHEOCFG7(value uint32) {
	volatile.StoreUint32(&o.HEOCFG7.Reg, value)
}
func (o *LCDC_Type) GetHEOCFG7() uint32 {
	return volatile.LoadUint32(&o.HEOCFG7.Reg)
}

// LCDC.HEOCFG8: High-End Overlay Configuration Register 8
func (o *LCDC_Type) SetHEOCFG8(value uint32) {
	volatile.StoreUint32(&o.HEOCFG8.Reg, value)
}
func (o *LCDC_Type) GetHEOCFG8() uint32 {
	return volatile.LoadUint32(&o.HEOCFG8.Reg)
}

// LCDC.HEOCFG9: High-End Overlay Configuration Register 9
func (o *LCDC_Type) SetHEOCFG9_BDEF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG9.Reg, volatile.LoadUint32(&o.HEOCFG9.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG9_BDEF() uint32 {
	return volatile.LoadUint32(&o.HEOCFG9.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG9_GDEF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG9.Reg, volatile.LoadUint32(&o.HEOCFG9.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG9_GDEF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG9.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG9_RDEF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG9.Reg, volatile.LoadUint32(&o.HEOCFG9.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG9_RDEF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG9.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG10: High-End Overlay Configuration Register 10
func (o *LCDC_Type) SetHEOCFG10_BKEY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG10.Reg, volatile.LoadUint32(&o.HEOCFG10.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG10_BKEY() uint32 {
	return volatile.LoadUint32(&o.HEOCFG10.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG10_GKEY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG10.Reg, volatile.LoadUint32(&o.HEOCFG10.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG10_GKEY() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG10.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG10_RKEY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG10.Reg, volatile.LoadUint32(&o.HEOCFG10.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG10_RKEY() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG10.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG11: High-End Overlay Configuration Register 11
func (o *LCDC_Type) SetHEOCFG11_BMASK(value uint32) {
	volatile.StoreUint32(&o.HEOCFG11.Reg, volatile.LoadUint32(&o.HEOCFG11.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG11_BMASK() uint32 {
	return volatile.LoadUint32(&o.HEOCFG11.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG11_GMASK(value uint32) {
	volatile.StoreUint32(&o.HEOCFG11.Reg, volatile.LoadUint32(&o.HEOCFG11.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG11_GMASK() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG11.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG11_RMASK(value uint32) {
	volatile.StoreUint32(&o.HEOCFG11.Reg, volatile.LoadUint32(&o.HEOCFG11.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG11_RMASK() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG11.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG12: High-End Overlay Configuration Register 12
func (o *LCDC_Type) SetHEOCFG12_CRKEY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHEOCFG12_CRKEY() uint32 {
	return volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x1
}
func (o *LCDC_Type) SetHEOCFG12_INV(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHEOCFG12_INV() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHEOCFG12_ITER2BL(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHEOCFG12_ITER2BL() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHEOCFG12_ITER(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHEOCFG12_ITER() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHEOCFG12_REVALPHA(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHEOCFG12_REVALPHA() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHEOCFG12_GAEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHEOCFG12_GAEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHEOCFG12_LAEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHEOCFG12_LAEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHEOCFG12_OVR(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x80)|value<<7)
}
func (o *LCDC_Type) GetHEOCFG12_OVR() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x80) >> 7
}
func (o *LCDC_Type) SetHEOCFG12_DMA(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG12_DMA() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetHEOCFG12_REP(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetHEOCFG12_REP() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetHEOCFG12_DSTKEY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHEOCFG12_DSTKEY() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHEOCFG12_VIDPRI(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetHEOCFG12_VIDPRI() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetHEOCFG12_GA(value uint32) {
	volatile.StoreUint32(&o.HEOCFG12.Reg, volatile.LoadUint32(&o.HEOCFG12.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG12_GA() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG12.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG13: High-End Overlay Configuration Register 13
func (o *LCDC_Type) SetHEOCFG13_XFACTOR(value uint32) {
	volatile.StoreUint32(&o.HEOCFG13.Reg, volatile.LoadUint32(&o.HEOCFG13.Reg)&^(0x3fff)|value)
}
func (o *LCDC_Type) GetHEOCFG13_XFACTOR() uint32 {
	return volatile.LoadUint32(&o.HEOCFG13.Reg) & 0x3fff
}
func (o *LCDC_Type) SetHEOCFG13_YFACTOR(value uint32) {
	volatile.StoreUint32(&o.HEOCFG13.Reg, volatile.LoadUint32(&o.HEOCFG13.Reg)&^(0x3fff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG13_YFACTOR() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG13.Reg) & 0x3fff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG13_SCALEN(value uint32) {
	volatile.StoreUint32(&o.HEOCFG13.Reg, volatile.LoadUint32(&o.HEOCFG13.Reg)&^(0x80000000)|value<<31)
}
func (o *LCDC_Type) GetHEOCFG13_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG13.Reg) & 0x80000000) >> 31
}

// LCDC.HEOCFG14: High-End Overlay Configuration Register 14
func (o *LCDC_Type) SetHEOCFG14_CSCRY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG14.Reg, volatile.LoadUint32(&o.HEOCFG14.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetHEOCFG14_CSCRY() uint32 {
	return volatile.LoadUint32(&o.HEOCFG14.Reg) & 0x3ff
}
func (o *LCDC_Type) SetHEOCFG14_CSCRU(value uint32) {
	volatile.StoreUint32(&o.HEOCFG14.Reg, volatile.LoadUint32(&o.HEOCFG14.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetHEOCFG14_CSCRU() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG14.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetHEOCFG14_CSCRV(value uint32) {
	volatile.StoreUint32(&o.HEOCFG14.Reg, volatile.LoadUint32(&o.HEOCFG14.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetHEOCFG14_CSCRV() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG14.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetHEOCFG14_CSCYOFF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG14.Reg, volatile.LoadUint32(&o.HEOCFG14.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetHEOCFG14_CSCYOFF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG14.Reg) & 0x40000000) >> 30
}

// LCDC.HEOCFG15: High-End Overlay Configuration Register 15
func (o *LCDC_Type) SetHEOCFG15_CSCGY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG15.Reg, volatile.LoadUint32(&o.HEOCFG15.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetHEOCFG15_CSCGY() uint32 {
	return volatile.LoadUint32(&o.HEOCFG15.Reg) & 0x3ff
}
func (o *LCDC_Type) SetHEOCFG15_CSCGU(value uint32) {
	volatile.StoreUint32(&o.HEOCFG15.Reg, volatile.LoadUint32(&o.HEOCFG15.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetHEOCFG15_CSCGU() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG15.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetHEOCFG15_CSCGV(value uint32) {
	volatile.StoreUint32(&o.HEOCFG15.Reg, volatile.LoadUint32(&o.HEOCFG15.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetHEOCFG15_CSCGV() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG15.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetHEOCFG15_CSCUOFF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG15.Reg, volatile.LoadUint32(&o.HEOCFG15.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetHEOCFG15_CSCUOFF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG15.Reg) & 0x40000000) >> 30
}

// LCDC.HEOCFG16: High-End Overlay Configuration Register 16
func (o *LCDC_Type) SetHEOCFG16_CSCBY(value uint32) {
	volatile.StoreUint32(&o.HEOCFG16.Reg, volatile.LoadUint32(&o.HEOCFG16.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetHEOCFG16_CSCBY() uint32 {
	return volatile.LoadUint32(&o.HEOCFG16.Reg) & 0x3ff
}
func (o *LCDC_Type) SetHEOCFG16_CSCBU(value uint32) {
	volatile.StoreUint32(&o.HEOCFG16.Reg, volatile.LoadUint32(&o.HEOCFG16.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetHEOCFG16_CSCBU() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG16.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetHEOCFG16_CSCBV(value uint32) {
	volatile.StoreUint32(&o.HEOCFG16.Reg, volatile.LoadUint32(&o.HEOCFG16.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetHEOCFG16_CSCBV() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG16.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetHEOCFG16_CSCVOFF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG16.Reg, volatile.LoadUint32(&o.HEOCFG16.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetHEOCFG16_CSCVOFF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG16.Reg) & 0x40000000) >> 30
}

// LCDC.HEOCFG17: High-End Overlay Configuration Register 17
func (o *LCDC_Type) SetHEOCFG17_XPHI0COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG17.Reg, volatile.LoadUint32(&o.HEOCFG17.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG17_XPHI0COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG17.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG17_XPHI0COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG17.Reg, volatile.LoadUint32(&o.HEOCFG17.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG17_XPHI0COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG17.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG17_XPHI0COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG17.Reg, volatile.LoadUint32(&o.HEOCFG17.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG17_XPHI0COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG17.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG17_XPHI0COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG17.Reg, volatile.LoadUint32(&o.HEOCFG17.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG17_XPHI0COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG17.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG18: High-End Overlay Configuration Register 18
func (o *LCDC_Type) SetHEOCFG18_XPHI0COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG18.Reg, volatile.LoadUint32(&o.HEOCFG18.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG18_XPHI0COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG18.Reg) & 0xff
}

// LCDC.HEOCFG19: High-End Overlay Configuration Register 19
func (o *LCDC_Type) SetHEOCFG19_XPHI1COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG19.Reg, volatile.LoadUint32(&o.HEOCFG19.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG19_XPHI1COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG19.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG19_XPHI1COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG19.Reg, volatile.LoadUint32(&o.HEOCFG19.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG19_XPHI1COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG19.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG19_XPHI1COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG19.Reg, volatile.LoadUint32(&o.HEOCFG19.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG19_XPHI1COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG19.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG19_XPHI1COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG19.Reg, volatile.LoadUint32(&o.HEOCFG19.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG19_XPHI1COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG19.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG20: High-End Overlay Configuration Register 20
func (o *LCDC_Type) SetHEOCFG20_XPHI1COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG20.Reg, volatile.LoadUint32(&o.HEOCFG20.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG20_XPHI1COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG20.Reg) & 0xff
}

// LCDC.HEOCFG21: High-End Overlay Configuration Register 21
func (o *LCDC_Type) SetHEOCFG21_XPHI2COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG21.Reg, volatile.LoadUint32(&o.HEOCFG21.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG21_XPHI2COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG21.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG21_XPHI2COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG21.Reg, volatile.LoadUint32(&o.HEOCFG21.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG21_XPHI2COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG21.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG21_XPHI2COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG21.Reg, volatile.LoadUint32(&o.HEOCFG21.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG21_XPHI2COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG21.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG21_XPHI2COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG21.Reg, volatile.LoadUint32(&o.HEOCFG21.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG21_XPHI2COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG21.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG22: High-End Overlay Configuration Register 22
func (o *LCDC_Type) SetHEOCFG22_XPHI2COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG22.Reg, volatile.LoadUint32(&o.HEOCFG22.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG22_XPHI2COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG22.Reg) & 0xff
}

// LCDC.HEOCFG23: High-End Overlay Configuration Register 23
func (o *LCDC_Type) SetHEOCFG23_XPHI3COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG23.Reg, volatile.LoadUint32(&o.HEOCFG23.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG23_XPHI3COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG23.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG23_XPHI3COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG23.Reg, volatile.LoadUint32(&o.HEOCFG23.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG23_XPHI3COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG23.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG23_XPHI3COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG23.Reg, volatile.LoadUint32(&o.HEOCFG23.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG23_XPHI3COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG23.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG23_XPHI3COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG23.Reg, volatile.LoadUint32(&o.HEOCFG23.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG23_XPHI3COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG23.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG24: High-End Overlay Configuration Register 24
func (o *LCDC_Type) SetHEOCFG24_XPHI3COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG24.Reg, volatile.LoadUint32(&o.HEOCFG24.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG24_XPHI3COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG24.Reg) & 0xff
}

// LCDC.HEOCFG25: High-End Overlay Configuration Register 25
func (o *LCDC_Type) SetHEOCFG25_XPHI4COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG25.Reg, volatile.LoadUint32(&o.HEOCFG25.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG25_XPHI4COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG25.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG25_XPHI4COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG25.Reg, volatile.LoadUint32(&o.HEOCFG25.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG25_XPHI4COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG25.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG25_XPHI4COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG25.Reg, volatile.LoadUint32(&o.HEOCFG25.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG25_XPHI4COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG25.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG25_XPHI4COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG25.Reg, volatile.LoadUint32(&o.HEOCFG25.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG25_XPHI4COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG25.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG26: High-End Overlay Configuration Register 26
func (o *LCDC_Type) SetHEOCFG26_XPHI4COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG26.Reg, volatile.LoadUint32(&o.HEOCFG26.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG26_XPHI4COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG26.Reg) & 0xff
}

// LCDC.HEOCFG27: High-End Overlay Configuration Register 27
func (o *LCDC_Type) SetHEOCFG27_XPHI5COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG27.Reg, volatile.LoadUint32(&o.HEOCFG27.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG27_XPHI5COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG27.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG27_XPHI5COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG27.Reg, volatile.LoadUint32(&o.HEOCFG27.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG27_XPHI5COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG27.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG27_XPHI5COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG27.Reg, volatile.LoadUint32(&o.HEOCFG27.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG27_XPHI5COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG27.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG27_XPHI5COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG27.Reg, volatile.LoadUint32(&o.HEOCFG27.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG27_XPHI5COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG27.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG28: High-End Overlay Configuration Register 28
func (o *LCDC_Type) SetHEOCFG28_XPHI5COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG28.Reg, volatile.LoadUint32(&o.HEOCFG28.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG28_XPHI5COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG28.Reg) & 0xff
}

// LCDC.HEOCFG29: High-End Overlay Configuration Register 29
func (o *LCDC_Type) SetHEOCFG29_XPHI6COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG29.Reg, volatile.LoadUint32(&o.HEOCFG29.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG29_XPHI6COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG29.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG29_XPHI6COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG29.Reg, volatile.LoadUint32(&o.HEOCFG29.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG29_XPHI6COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG29.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG29_XPHI6COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG29.Reg, volatile.LoadUint32(&o.HEOCFG29.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG29_XPHI6COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG29.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG29_XPHI6COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG29.Reg, volatile.LoadUint32(&o.HEOCFG29.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG29_XPHI6COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG29.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG30: High-End Overlay Configuration Register 30
func (o *LCDC_Type) SetHEOCFG30_XPHI6COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG30.Reg, volatile.LoadUint32(&o.HEOCFG30.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG30_XPHI6COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG30.Reg) & 0xff
}

// LCDC.HEOCFG31: High-End Overlay Configuration Register 31
func (o *LCDC_Type) SetHEOCFG31_XPHI7COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG31.Reg, volatile.LoadUint32(&o.HEOCFG31.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG31_XPHI7COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG31.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG31_XPHI7COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG31.Reg, volatile.LoadUint32(&o.HEOCFG31.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG31_XPHI7COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG31.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG31_XPHI7COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG31.Reg, volatile.LoadUint32(&o.HEOCFG31.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG31_XPHI7COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG31.Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCFG31_XPHI7COEFF3(value uint32) {
	volatile.StoreUint32(&o.HEOCFG31.Reg, volatile.LoadUint32(&o.HEOCFG31.Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCFG31_XPHI7COEFF3() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG31.Reg) & 0xff000000) >> 24
}

// LCDC.HEOCFG32: High-End Overlay Configuration Register 32
func (o *LCDC_Type) SetHEOCFG32_XPHI7COEFF4(value uint32) {
	volatile.StoreUint32(&o.HEOCFG32.Reg, volatile.LoadUint32(&o.HEOCFG32.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG32_XPHI7COEFF4() uint32 {
	return volatile.LoadUint32(&o.HEOCFG32.Reg) & 0xff
}

// LCDC.HEOCFG33: High-End Overlay Configuration Register 33
func (o *LCDC_Type) SetHEOCFG33_YPHI0COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG33.Reg, volatile.LoadUint32(&o.HEOCFG33.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG33_YPHI0COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG33.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG33_YPHI0COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG33.Reg, volatile.LoadUint32(&o.HEOCFG33.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG33_YPHI0COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG33.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG33_YPHI0COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG33.Reg, volatile.LoadUint32(&o.HEOCFG33.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG33_YPHI0COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG33.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG34: High-End Overlay Configuration Register 34
func (o *LCDC_Type) SetHEOCFG34_YPHI1COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG34.Reg, volatile.LoadUint32(&o.HEOCFG34.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG34_YPHI1COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG34.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG34_YPHI1COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG34.Reg, volatile.LoadUint32(&o.HEOCFG34.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG34_YPHI1COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG34.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG34_YPHI1COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG34.Reg, volatile.LoadUint32(&o.HEOCFG34.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG34_YPHI1COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG34.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG35: High-End Overlay Configuration Register 35
func (o *LCDC_Type) SetHEOCFG35_YPHI2COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG35.Reg, volatile.LoadUint32(&o.HEOCFG35.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG35_YPHI2COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG35.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG35_YPHI2COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG35.Reg, volatile.LoadUint32(&o.HEOCFG35.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG35_YPHI2COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG35.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG35_YPHI2COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG35.Reg, volatile.LoadUint32(&o.HEOCFG35.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG35_YPHI2COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG35.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG36: High-End Overlay Configuration Register 36
func (o *LCDC_Type) SetHEOCFG36_YPHI3COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG36.Reg, volatile.LoadUint32(&o.HEOCFG36.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG36_YPHI3COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG36.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG36_YPHI3COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG36.Reg, volatile.LoadUint32(&o.HEOCFG36.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG36_YPHI3COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG36.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG36_YPHI3COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG36.Reg, volatile.LoadUint32(&o.HEOCFG36.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG36_YPHI3COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG36.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG37: High-End Overlay Configuration Register 37
func (o *LCDC_Type) SetHEOCFG37_YPHI4COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG37.Reg, volatile.LoadUint32(&o.HEOCFG37.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG37_YPHI4COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG37.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG37_YPHI4COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG37.Reg, volatile.LoadUint32(&o.HEOCFG37.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG37_YPHI4COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG37.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG37_YPHI4COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG37.Reg, volatile.LoadUint32(&o.HEOCFG37.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG37_YPHI4COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG37.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG38: High-End Overlay Configuration Register 38
func (o *LCDC_Type) SetHEOCFG38_YPHI5COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG38.Reg, volatile.LoadUint32(&o.HEOCFG38.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG38_YPHI5COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG38.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG38_YPHI5COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG38.Reg, volatile.LoadUint32(&o.HEOCFG38.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG38_YPHI5COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG38.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG38_YPHI5COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG38.Reg, volatile.LoadUint32(&o.HEOCFG38.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG38_YPHI5COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG38.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG39: High-End Overlay Configuration Register 39
func (o *LCDC_Type) SetHEOCFG39_YPHI6COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG39.Reg, volatile.LoadUint32(&o.HEOCFG39.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG39_YPHI6COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG39.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG39_YPHI6COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG39.Reg, volatile.LoadUint32(&o.HEOCFG39.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG39_YPHI6COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG39.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG39_YPHI6COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG39.Reg, volatile.LoadUint32(&o.HEOCFG39.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG39_YPHI6COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG39.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG40: High-End Overlay Configuration Register 40
func (o *LCDC_Type) SetHEOCFG40_YPHI7COEFF0(value uint32) {
	volatile.StoreUint32(&o.HEOCFG40.Reg, volatile.LoadUint32(&o.HEOCFG40.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCFG40_YPHI7COEFF0() uint32 {
	return volatile.LoadUint32(&o.HEOCFG40.Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCFG40_YPHI7COEFF1(value uint32) {
	volatile.StoreUint32(&o.HEOCFG40.Reg, volatile.LoadUint32(&o.HEOCFG40.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCFG40_YPHI7COEFF1() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG40.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCFG40_YPHI7COEFF2(value uint32) {
	volatile.StoreUint32(&o.HEOCFG40.Reg, volatile.LoadUint32(&o.HEOCFG40.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG40_YPHI7COEFF2() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG40.Reg) & 0xff0000) >> 16
}

// LCDC.HEOCFG41: High-End Overlay Configuration Register 41
func (o *LCDC_Type) SetHEOCFG41_XPHIDEF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG41.Reg, volatile.LoadUint32(&o.HEOCFG41.Reg)&^(0x7)|value)
}
func (o *LCDC_Type) GetHEOCFG41_XPHIDEF() uint32 {
	return volatile.LoadUint32(&o.HEOCFG41.Reg) & 0x7
}
func (o *LCDC_Type) SetHEOCFG41_YPHIDEF(value uint32) {
	volatile.StoreUint32(&o.HEOCFG41.Reg, volatile.LoadUint32(&o.HEOCFG41.Reg)&^(0x70000)|value<<16)
}
func (o *LCDC_Type) GetHEOCFG41_YPHIDEF() uint32 {
	return (volatile.LoadUint32(&o.HEOCFG41.Reg) & 0x70000) >> 16
}

// LCDC.HCRCHER: Hardware Cursor Channel Enable Register
func (o *LCDC_Type) SetHCRCHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.HCRCHER.Reg, volatile.LoadUint32(&o.HCRCHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.HCRCHER.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.HCRCHER.Reg, volatile.LoadUint32(&o.HCRCHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHCRCHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHCRCHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.HCRCHER.Reg, volatile.LoadUint32(&o.HCRCHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRCHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCHER.Reg) & 0x4) >> 2
}

// LCDC.HCRCHDR: Hardware Cursor Channel disable Register
func (o *LCDC_Type) SetHCRCHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.HCRCHDR.Reg, volatile.LoadUint32(&o.HCRCHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.HCRCHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.HCRCHDR.Reg, volatile.LoadUint32(&o.HCRCHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHCRCHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.HCRCHDR.Reg) & 0x100) >> 8
}

// LCDC.HCRCHSR: Hardware Cursor Channel Status Register
func (o *LCDC_Type) SetHCRCHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.HCRCHSR.Reg, volatile.LoadUint32(&o.HCRCHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.HCRCHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.HCRCHSR.Reg, volatile.LoadUint32(&o.HCRCHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHCRCHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.HCRCHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHCRCHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.HCRCHSR.Reg, volatile.LoadUint32(&o.HCRCHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRCHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.HCRCHSR.Reg) & 0x4) >> 2
}

// LCDC.HCRIER: Hardware Cursor Interrupt Enable Register
func (o *LCDC_Type) SetHCRIER_DMA(value uint32) {
	volatile.StoreUint32(&o.HCRIER.Reg, volatile.LoadUint32(&o.HCRIER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRIER_DMA() uint32 {
	return (volatile.LoadUint32(&o.HCRIER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRIER_DSCR(value uint32) {
	volatile.StoreUint32(&o.HCRIER.Reg, volatile.LoadUint32(&o.HCRIER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRIER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HCRIER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRIER_ADD(value uint32) {
	volatile.StoreUint32(&o.HCRIER.Reg, volatile.LoadUint32(&o.HCRIER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRIER_ADD() uint32 {
	return (volatile.LoadUint32(&o.HCRIER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRIER_DONE(value uint32) {
	volatile.StoreUint32(&o.HCRIER.Reg, volatile.LoadUint32(&o.HCRIER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRIER_DONE() uint32 {
	return (volatile.LoadUint32(&o.HCRIER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHCRIER_OVR(value uint32) {
	volatile.StoreUint32(&o.HCRIER.Reg, volatile.LoadUint32(&o.HCRIER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHCRIER_OVR() uint32 {
	return (volatile.LoadUint32(&o.HCRIER.Reg) & 0x40) >> 6
}

// LCDC.HCRIDR: Hardware Cursor Interrupt Disable Register
func (o *LCDC_Type) SetHCRIDR_DMA(value uint32) {
	volatile.StoreUint32(&o.HCRIDR.Reg, volatile.LoadUint32(&o.HCRIDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRIDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HCRIDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRIDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HCRIDR.Reg, volatile.LoadUint32(&o.HCRIDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRIDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HCRIDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRIDR_ADD(value uint32) {
	volatile.StoreUint32(&o.HCRIDR.Reg, volatile.LoadUint32(&o.HCRIDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRIDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HCRIDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRIDR_DONE(value uint32) {
	volatile.StoreUint32(&o.HCRIDR.Reg, volatile.LoadUint32(&o.HCRIDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRIDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HCRIDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHCRIDR_OVR(value uint32) {
	volatile.StoreUint32(&o.HCRIDR.Reg, volatile.LoadUint32(&o.HCRIDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHCRIDR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HCRIDR.Reg) & 0x40) >> 6
}

// LCDC.HCRIMR: Hardware Cursor Interrupt Mask Register
func (o *LCDC_Type) SetHCRIMR_DMA(value uint32) {
	volatile.StoreUint32(&o.HCRIMR.Reg, volatile.LoadUint32(&o.HCRIMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRIMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HCRIMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRIMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HCRIMR.Reg, volatile.LoadUint32(&o.HCRIMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRIMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HCRIMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRIMR_ADD(value uint32) {
	volatile.StoreUint32(&o.HCRIMR.Reg, volatile.LoadUint32(&o.HCRIMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRIMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HCRIMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRIMR_DONE(value uint32) {
	volatile.StoreUint32(&o.HCRIMR.Reg, volatile.LoadUint32(&o.HCRIMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRIMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HCRIMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHCRIMR_OVR(value uint32) {
	volatile.StoreUint32(&o.HCRIMR.Reg, volatile.LoadUint32(&o.HCRIMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHCRIMR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HCRIMR.Reg) & 0x40) >> 6
}

// LCDC.HCRISR: Hardware Cursor Interrupt Status Register
func (o *LCDC_Type) SetHCRISR_DMA(value uint32) {
	volatile.StoreUint32(&o.HCRISR.Reg, volatile.LoadUint32(&o.HCRISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.HCRISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.HCRISR.Reg, volatile.LoadUint32(&o.HCRISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.HCRISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRISR_ADD(value uint32) {
	volatile.StoreUint32(&o.HCRISR.Reg, volatile.LoadUint32(&o.HCRISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.HCRISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRISR_DONE(value uint32) {
	volatile.StoreUint32(&o.HCRISR.Reg, volatile.LoadUint32(&o.HCRISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.HCRISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHCRISR_OVR(value uint32) {
	volatile.StoreUint32(&o.HCRISR.Reg, volatile.LoadUint32(&o.HCRISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHCRISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.HCRISR.Reg) & 0x40) >> 6
}

// LCDC.HCRHEAD: Hardware Cursor DMA Head Register
func (o *LCDC_Type) SetHCRHEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.HCRHEAD.Reg, volatile.LoadUint32(&o.HCRHEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetHCRHEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.HCRHEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.HCRADDR: Hardware cursor DMA Address Register
func (o *LCDC_Type) SetHCRADDR(value uint32) {
	volatile.StoreUint32(&o.HCRADDR.Reg, value)
}
func (o *LCDC_Type) GetHCRADDR() uint32 {
	return volatile.LoadUint32(&o.HCRADDR.Reg)
}

// LCDC.HCRCTRL: Hardware Cursor DMA Control Register
func (o *LCDC_Type) SetHCRCTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCTRL_LFETCH(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHCRCTRL_LFETCH() uint32 {
	return (volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHCRCTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRCTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRCTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRCTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRCTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRCTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRCTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.HCRCTRL.Reg, volatile.LoadUint32(&o.HCRCTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRCTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCTRL.Reg) & 0x20) >> 5
}

// LCDC.HCRNEXT: Hardware Cursor DMA NExt Register
func (o *LCDC_Type) SetHCRNEXT(value uint32) {
	volatile.StoreUint32(&o.HCRNEXT.Reg, value)
}
func (o *LCDC_Type) GetHCRNEXT() uint32 {
	return volatile.LoadUint32(&o.HCRNEXT.Reg)
}

// LCDC.HCRCFG0: Hardware Cursor Configuration 0 Register
func (o *LCDC_Type) SetHCRCFG0_SIF(value uint32) {
	volatile.StoreUint32(&o.HCRCFG0.Reg, volatile.LoadUint32(&o.HCRCFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCFG0_SIF() uint32 {
	return volatile.LoadUint32(&o.HCRCFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.HCRCFG0.Reg, volatile.LoadUint32(&o.HCRCFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetHCRCFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetHCRCFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.HCRCFG0.Reg, volatile.LoadUint32(&o.HCRCFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG0.Reg) & 0x100) >> 8
}

// LCDC.HCRCFG1: Hardware Cursor Configuration 1 Register
func (o *LCDC_Type) SetHCRCFG1_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.HCRCFG1.Reg, volatile.LoadUint32(&o.HCRCFG1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCFG1_CLUTEN() uint32 {
	return volatile.LoadUint32(&o.HCRCFG1.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCFG1_RGBMODE(value uint32) {
	volatile.StoreUint32(&o.HCRCFG1.Reg, volatile.LoadUint32(&o.HCRCFG1.Reg)&^(0xf0)|value<<4)
}
func (o *LCDC_Type) GetHCRCFG1_RGBMODE() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG1.Reg) & 0xf0) >> 4
}
func (o *LCDC_Type) SetHCRCFG1_CLUTMODE(value uint32) {
	volatile.StoreUint32(&o.HCRCFG1.Reg, volatile.LoadUint32(&o.HCRCFG1.Reg)&^(0x300)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG1_CLUTMODE() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG1.Reg) & 0x300) >> 8
}

// LCDC.HCRCFG2: Hardware Cursor Configuration 2 Register
func (o *LCDC_Type) SetHCRCFG2_XPOS(value uint32) {
	volatile.StoreUint32(&o.HCRCFG2.Reg, volatile.LoadUint32(&o.HCRCFG2.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetHCRCFG2_XPOS() uint32 {
	return volatile.LoadUint32(&o.HCRCFG2.Reg) & 0x7ff
}
func (o *LCDC_Type) SetHCRCFG2_YPOS(value uint32) {
	volatile.StoreUint32(&o.HCRCFG2.Reg, volatile.LoadUint32(&o.HCRCFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG2_YPOS() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG2.Reg) & 0x7ff0000) >> 16
}

// LCDC.HCRCFG3: Hardware Cursor Configuration 3 Register
func (o *LCDC_Type) SetHCRCFG3_XSIZE(value uint32) {
	volatile.StoreUint32(&o.HCRCFG3.Reg, volatile.LoadUint32(&o.HCRCFG3.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetHCRCFG3_XSIZE() uint32 {
	return volatile.LoadUint32(&o.HCRCFG3.Reg) & 0x7ff
}
func (o *LCDC_Type) SetHCRCFG3_YSIZE(value uint32) {
	volatile.StoreUint32(&o.HCRCFG3.Reg, volatile.LoadUint32(&o.HCRCFG3.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG3_YSIZE() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG3.Reg) & 0x7ff0000) >> 16
}

// LCDC.HCRCFG4: Hardware Cursor Configuration 4 Register
func (o *LCDC_Type) SetHCRCFG4(value uint32) {
	volatile.StoreUint32(&o.HCRCFG4.Reg, value)
}
func (o *LCDC_Type) GetHCRCFG4() uint32 {
	return volatile.LoadUint32(&o.HCRCFG4.Reg)
}

// LCDC.HCRCFG6: Hardware Cursor Configuration 6 Register
func (o *LCDC_Type) SetHCRCFG6_BDEF(value uint32) {
	volatile.StoreUint32(&o.HCRCFG6.Reg, volatile.LoadUint32(&o.HCRCFG6.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHCRCFG6_BDEF() uint32 {
	return volatile.LoadUint32(&o.HCRCFG6.Reg) & 0xff
}
func (o *LCDC_Type) SetHCRCFG6_GDEF(value uint32) {
	volatile.StoreUint32(&o.HCRCFG6.Reg, volatile.LoadUint32(&o.HCRCFG6.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG6_GDEF() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG6.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHCRCFG6_RDEF(value uint32) {
	volatile.StoreUint32(&o.HCRCFG6.Reg, volatile.LoadUint32(&o.HCRCFG6.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG6_RDEF() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG6.Reg) & 0xff0000) >> 16
}

// LCDC.HCRCFG7: Hardware Cursor Configuration 7 Register
func (o *LCDC_Type) SetHCRCFG7_BKEY(value uint32) {
	volatile.StoreUint32(&o.HCRCFG7.Reg, volatile.LoadUint32(&o.HCRCFG7.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHCRCFG7_BKEY() uint32 {
	return volatile.LoadUint32(&o.HCRCFG7.Reg) & 0xff
}
func (o *LCDC_Type) SetHCRCFG7_GKEY(value uint32) {
	volatile.StoreUint32(&o.HCRCFG7.Reg, volatile.LoadUint32(&o.HCRCFG7.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG7_GKEY() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG7.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHCRCFG7_RKEY(value uint32) {
	volatile.StoreUint32(&o.HCRCFG7.Reg, volatile.LoadUint32(&o.HCRCFG7.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG7_RKEY() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG7.Reg) & 0xff0000) >> 16
}

// LCDC.HCRCFG8: Hardware Cursor Configuration 8 Register
func (o *LCDC_Type) SetHCRCFG8_BMASK(value uint32) {
	volatile.StoreUint32(&o.HCRCFG8.Reg, volatile.LoadUint32(&o.HCRCFG8.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHCRCFG8_BMASK() uint32 {
	return volatile.LoadUint32(&o.HCRCFG8.Reg) & 0xff
}
func (o *LCDC_Type) SetHCRCFG8_GMASK(value uint32) {
	volatile.StoreUint32(&o.HCRCFG8.Reg, volatile.LoadUint32(&o.HCRCFG8.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG8_GMASK() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG8.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHCRCFG8_RMASK(value uint32) {
	volatile.StoreUint32(&o.HCRCFG8.Reg, volatile.LoadUint32(&o.HCRCFG8.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG8_RMASK() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG8.Reg) & 0xff0000) >> 16
}

// LCDC.HCRCFG9: Hardware Cursor Configuration 9 Register
func (o *LCDC_Type) SetHCRCFG9_CRKEY(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetHCRCFG9_CRKEY() uint32 {
	return volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x1
}
func (o *LCDC_Type) SetHCRCFG9_INV(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetHCRCFG9_INV() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetHCRCFG9_ITER2BL(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetHCRCFG9_ITER2BL() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetHCRCFG9_ITER(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetHCRCFG9_ITER() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetHCRCFG9_REVALPHA(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetHCRCFG9_REVALPHA() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetHCRCFG9_GAEN(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetHCRCFG9_GAEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetHCRCFG9_LAEN(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetHCRCFG9_LAEN() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x40) >> 6
}
func (o *LCDC_Type) SetHCRCFG9_OVR(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x80)|value<<7)
}
func (o *LCDC_Type) GetHCRCFG9_OVR() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x80) >> 7
}
func (o *LCDC_Type) SetHCRCFG9_DMA(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetHCRCFG9_DMA() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetHCRCFG9_REP(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetHCRCFG9_REP() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetHCRCFG9_DSTKEY(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetHCRCFG9_DSTKEY() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetHCRCFG9_GA(value uint32) {
	volatile.StoreUint32(&o.HCRCFG9.Reg, volatile.LoadUint32(&o.HCRCFG9.Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCFG9_GA() uint32 {
	return (volatile.LoadUint32(&o.HCRCFG9.Reg) & 0xff0000) >> 16
}

// LCDC.PPCHER: Post Processing Channel Enable Register
func (o *LCDC_Type) SetPPCHER_CHEN(value uint32) {
	volatile.StoreUint32(&o.PPCHER.Reg, volatile.LoadUint32(&o.PPCHER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPPCHER_CHEN() uint32 {
	return volatile.LoadUint32(&o.PPCHER.Reg) & 0x1
}
func (o *LCDC_Type) SetPPCHER_UPDATEEN(value uint32) {
	volatile.StoreUint32(&o.PPCHER.Reg, volatile.LoadUint32(&o.PPCHER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetPPCHER_UPDATEEN() uint32 {
	return (volatile.LoadUint32(&o.PPCHER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetPPCHER_A2QEN(value uint32) {
	volatile.StoreUint32(&o.PPCHER.Reg, volatile.LoadUint32(&o.PPCHER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPCHER_A2QEN() uint32 {
	return (volatile.LoadUint32(&o.PPCHER.Reg) & 0x4) >> 2
}

// LCDC.PPCHDR: Post Processing Channel Disable Register
func (o *LCDC_Type) SetPPCHDR_CHDIS(value uint32) {
	volatile.StoreUint32(&o.PPCHDR.Reg, volatile.LoadUint32(&o.PPCHDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPPCHDR_CHDIS() uint32 {
	return volatile.LoadUint32(&o.PPCHDR.Reg) & 0x1
}
func (o *LCDC_Type) SetPPCHDR_CHRST(value uint32) {
	volatile.StoreUint32(&o.PPCHDR.Reg, volatile.LoadUint32(&o.PPCHDR.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetPPCHDR_CHRST() uint32 {
	return (volatile.LoadUint32(&o.PPCHDR.Reg) & 0x100) >> 8
}

// LCDC.PPCHSR: Post Processing Channel Status Register
func (o *LCDC_Type) SetPPCHSR_CHSR(value uint32) {
	volatile.StoreUint32(&o.PPCHSR.Reg, volatile.LoadUint32(&o.PPCHSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPPCHSR_CHSR() uint32 {
	return volatile.LoadUint32(&o.PPCHSR.Reg) & 0x1
}
func (o *LCDC_Type) SetPPCHSR_UPDATESR(value uint32) {
	volatile.StoreUint32(&o.PPCHSR.Reg, volatile.LoadUint32(&o.PPCHSR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetPPCHSR_UPDATESR() uint32 {
	return (volatile.LoadUint32(&o.PPCHSR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetPPCHSR_A2QSR(value uint32) {
	volatile.StoreUint32(&o.PPCHSR.Reg, volatile.LoadUint32(&o.PPCHSR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPCHSR_A2QSR() uint32 {
	return (volatile.LoadUint32(&o.PPCHSR.Reg) & 0x4) >> 2
}

// LCDC.PPIER: Post Processing Interrupt Enable Register
func (o *LCDC_Type) SetPPIER_DMA(value uint32) {
	volatile.StoreUint32(&o.PPIER.Reg, volatile.LoadUint32(&o.PPIER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPIER_DMA() uint32 {
	return (volatile.LoadUint32(&o.PPIER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetPPIER_DSCR(value uint32) {
	volatile.StoreUint32(&o.PPIER.Reg, volatile.LoadUint32(&o.PPIER.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetPPIER_DSCR() uint32 {
	return (volatile.LoadUint32(&o.PPIER.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetPPIER_ADD(value uint32) {
	volatile.StoreUint32(&o.PPIER.Reg, volatile.LoadUint32(&o.PPIER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPIER_ADD() uint32 {
	return (volatile.LoadUint32(&o.PPIER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetPPIER_DONE(value uint32) {
	volatile.StoreUint32(&o.PPIER.Reg, volatile.LoadUint32(&o.PPIER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetPPIER_DONE() uint32 {
	return (volatile.LoadUint32(&o.PPIER.Reg) & 0x20) >> 5
}

// LCDC.PPIDR: Post Processing Interrupt Disable Register
func (o *LCDC_Type) SetPPIDR_DMA(value uint32) {
	volatile.StoreUint32(&o.PPIDR.Reg, volatile.LoadUint32(&o.PPIDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPIDR_DMA() uint32 {
	return (volatile.LoadUint32(&o.PPIDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetPPIDR_DSCR(value uint32) {
	volatile.StoreUint32(&o.PPIDR.Reg, volatile.LoadUint32(&o.PPIDR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetPPIDR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.PPIDR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetPPIDR_ADD(value uint32) {
	volatile.StoreUint32(&o.PPIDR.Reg, volatile.LoadUint32(&o.PPIDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPIDR_ADD() uint32 {
	return (volatile.LoadUint32(&o.PPIDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetPPIDR_DONE(value uint32) {
	volatile.StoreUint32(&o.PPIDR.Reg, volatile.LoadUint32(&o.PPIDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetPPIDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.PPIDR.Reg) & 0x20) >> 5
}

// LCDC.PPIMR: Post Processing Interrupt Mask Register
func (o *LCDC_Type) SetPPIMR_DMA(value uint32) {
	volatile.StoreUint32(&o.PPIMR.Reg, volatile.LoadUint32(&o.PPIMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPIMR_DMA() uint32 {
	return (volatile.LoadUint32(&o.PPIMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetPPIMR_DSCR(value uint32) {
	volatile.StoreUint32(&o.PPIMR.Reg, volatile.LoadUint32(&o.PPIMR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetPPIMR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.PPIMR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetPPIMR_ADD(value uint32) {
	volatile.StoreUint32(&o.PPIMR.Reg, volatile.LoadUint32(&o.PPIMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPIMR_ADD() uint32 {
	return (volatile.LoadUint32(&o.PPIMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetPPIMR_DONE(value uint32) {
	volatile.StoreUint32(&o.PPIMR.Reg, volatile.LoadUint32(&o.PPIMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetPPIMR_DONE() uint32 {
	return (volatile.LoadUint32(&o.PPIMR.Reg) & 0x20) >> 5
}

// LCDC.PPISR: Post Processing Interrupt Status Register
func (o *LCDC_Type) SetPPISR_DMA(value uint32) {
	volatile.StoreUint32(&o.PPISR.Reg, volatile.LoadUint32(&o.PPISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPISR_DMA() uint32 {
	return (volatile.LoadUint32(&o.PPISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetPPISR_DSCR(value uint32) {
	volatile.StoreUint32(&o.PPISR.Reg, volatile.LoadUint32(&o.PPISR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetPPISR_DSCR() uint32 {
	return (volatile.LoadUint32(&o.PPISR.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetPPISR_ADD(value uint32) {
	volatile.StoreUint32(&o.PPISR.Reg, volatile.LoadUint32(&o.PPISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPISR_ADD() uint32 {
	return (volatile.LoadUint32(&o.PPISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetPPISR_DONE(value uint32) {
	volatile.StoreUint32(&o.PPISR.Reg, volatile.LoadUint32(&o.PPISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetPPISR_DONE() uint32 {
	return (volatile.LoadUint32(&o.PPISR.Reg) & 0x20) >> 5
}

// LCDC.PPHEAD: Post Processing Head Register
func (o *LCDC_Type) SetPPHEAD_HEAD(value uint32) {
	volatile.StoreUint32(&o.PPHEAD.Reg, volatile.LoadUint32(&o.PPHEAD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetPPHEAD_HEAD() uint32 {
	return (volatile.LoadUint32(&o.PPHEAD.Reg) & 0xfffffffc) >> 2
}

// LCDC.PPADDR: Post Processing Address Register
func (o *LCDC_Type) SetPPADDR(value uint32) {
	volatile.StoreUint32(&o.PPADDR.Reg, value)
}
func (o *LCDC_Type) GetPPADDR() uint32 {
	return volatile.LoadUint32(&o.PPADDR.Reg)
}

// LCDC.PPCTRL: Post Processing Control Register
func (o *LCDC_Type) SetPPCTRL_DFETCH(value uint32) {
	volatile.StoreUint32(&o.PPCTRL.Reg, volatile.LoadUint32(&o.PPCTRL.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPPCTRL_DFETCH() uint32 {
	return volatile.LoadUint32(&o.PPCTRL.Reg) & 0x1
}
func (o *LCDC_Type) SetPPCTRL_DMAIEN(value uint32) {
	volatile.StoreUint32(&o.PPCTRL.Reg, volatile.LoadUint32(&o.PPCTRL.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetPPCTRL_DMAIEN() uint32 {
	return (volatile.LoadUint32(&o.PPCTRL.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetPPCTRL_DSCRIEN(value uint32) {
	volatile.StoreUint32(&o.PPCTRL.Reg, volatile.LoadUint32(&o.PPCTRL.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetPPCTRL_DSCRIEN() uint32 {
	return (volatile.LoadUint32(&o.PPCTRL.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetPPCTRL_ADDIEN(value uint32) {
	volatile.StoreUint32(&o.PPCTRL.Reg, volatile.LoadUint32(&o.PPCTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPCTRL_ADDIEN() uint32 {
	return (volatile.LoadUint32(&o.PPCTRL.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetPPCTRL_DONEIEN(value uint32) {
	volatile.StoreUint32(&o.PPCTRL.Reg, volatile.LoadUint32(&o.PPCTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetPPCTRL_DONEIEN() uint32 {
	return (volatile.LoadUint32(&o.PPCTRL.Reg) & 0x20) >> 5
}

// LCDC.PPNEXT: Post Processing Next Register
func (o *LCDC_Type) SetPPNEXT(value uint32) {
	volatile.StoreUint32(&o.PPNEXT.Reg, value)
}
func (o *LCDC_Type) GetPPNEXT() uint32 {
	return volatile.LoadUint32(&o.PPNEXT.Reg)
}

// LCDC.PPCFG0: Post Processing Configuration Register 0
func (o *LCDC_Type) SetPPCFG0_SIF(value uint32) {
	volatile.StoreUint32(&o.PPCFG0.Reg, volatile.LoadUint32(&o.PPCFG0.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPPCFG0_SIF() uint32 {
	return volatile.LoadUint32(&o.PPCFG0.Reg) & 0x1
}
func (o *LCDC_Type) SetPPCFG0_BLEN(value uint32) {
	volatile.StoreUint32(&o.PPCFG0.Reg, volatile.LoadUint32(&o.PPCFG0.Reg)&^(0x30)|value<<4)
}
func (o *LCDC_Type) GetPPCFG0_BLEN() uint32 {
	return (volatile.LoadUint32(&o.PPCFG0.Reg) & 0x30) >> 4
}
func (o *LCDC_Type) SetPPCFG0_DLBO(value uint32) {
	volatile.StoreUint32(&o.PPCFG0.Reg, volatile.LoadUint32(&o.PPCFG0.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetPPCFG0_DLBO() uint32 {
	return (volatile.LoadUint32(&o.PPCFG0.Reg) & 0x100) >> 8
}

// LCDC.PPCFG1: Post Processing Configuration Register 1
func (o *LCDC_Type) SetPPCFG1_PPMODE(value uint32) {
	volatile.StoreUint32(&o.PPCFG1.Reg, volatile.LoadUint32(&o.PPCFG1.Reg)&^(0x7)|value)
}
func (o *LCDC_Type) GetPPCFG1_PPMODE() uint32 {
	return volatile.LoadUint32(&o.PPCFG1.Reg) & 0x7
}
func (o *LCDC_Type) SetPPCFG1_ITUBT601(value uint32) {
	volatile.StoreUint32(&o.PPCFG1.Reg, volatile.LoadUint32(&o.PPCFG1.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetPPCFG1_ITUBT601() uint32 {
	return (volatile.LoadUint32(&o.PPCFG1.Reg) & 0x10) >> 4
}

// LCDC.PPCFG2: Post Processing Configuration Register 2
func (o *LCDC_Type) SetPPCFG2(value uint32) {
	volatile.StoreUint32(&o.PPCFG2.Reg, value)
}
func (o *LCDC_Type) GetPPCFG2() uint32 {
	return volatile.LoadUint32(&o.PPCFG2.Reg)
}

// LCDC.PPCFG3: Post Processing Configuration Register 3
func (o *LCDC_Type) SetPPCFG3_CSCYR(value uint32) {
	volatile.StoreUint32(&o.PPCFG3.Reg, volatile.LoadUint32(&o.PPCFG3.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetPPCFG3_CSCYR() uint32 {
	return volatile.LoadUint32(&o.PPCFG3.Reg) & 0x3ff
}
func (o *LCDC_Type) SetPPCFG3_CSCYG(value uint32) {
	volatile.StoreUint32(&o.PPCFG3.Reg, volatile.LoadUint32(&o.PPCFG3.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetPPCFG3_CSCYG() uint32 {
	return (volatile.LoadUint32(&o.PPCFG3.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetPPCFG3_CSCYB(value uint32) {
	volatile.StoreUint32(&o.PPCFG3.Reg, volatile.LoadUint32(&o.PPCFG3.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetPPCFG3_CSCYB() uint32 {
	return (volatile.LoadUint32(&o.PPCFG3.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetPPCFG3_CSCYOFF(value uint32) {
	volatile.StoreUint32(&o.PPCFG3.Reg, volatile.LoadUint32(&o.PPCFG3.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetPPCFG3_CSCYOFF() uint32 {
	return (volatile.LoadUint32(&o.PPCFG3.Reg) & 0x40000000) >> 30
}

// LCDC.PPCFG4: Post Processing Configuration Register 4
func (o *LCDC_Type) SetPPCFG4_CSCUR(value uint32) {
	volatile.StoreUint32(&o.PPCFG4.Reg, volatile.LoadUint32(&o.PPCFG4.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetPPCFG4_CSCUR() uint32 {
	return volatile.LoadUint32(&o.PPCFG4.Reg) & 0x3ff
}
func (o *LCDC_Type) SetPPCFG4_CSCUG(value uint32) {
	volatile.StoreUint32(&o.PPCFG4.Reg, volatile.LoadUint32(&o.PPCFG4.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetPPCFG4_CSCUG() uint32 {
	return (volatile.LoadUint32(&o.PPCFG4.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetPPCFG4_CSCUB(value uint32) {
	volatile.StoreUint32(&o.PPCFG4.Reg, volatile.LoadUint32(&o.PPCFG4.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetPPCFG4_CSCUB() uint32 {
	return (volatile.LoadUint32(&o.PPCFG4.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetPPCFG4_CSCUOFF(value uint32) {
	volatile.StoreUint32(&o.PPCFG4.Reg, volatile.LoadUint32(&o.PPCFG4.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetPPCFG4_CSCUOFF() uint32 {
	return (volatile.LoadUint32(&o.PPCFG4.Reg) & 0x40000000) >> 30
}

// LCDC.PPCFG5: Post Processing Configuration Register 5
func (o *LCDC_Type) SetPPCFG5_CSCVR(value uint32) {
	volatile.StoreUint32(&o.PPCFG5.Reg, volatile.LoadUint32(&o.PPCFG5.Reg)&^(0x3ff)|value)
}
func (o *LCDC_Type) GetPPCFG5_CSCVR() uint32 {
	return volatile.LoadUint32(&o.PPCFG5.Reg) & 0x3ff
}
func (o *LCDC_Type) SetPPCFG5_CSCVG(value uint32) {
	volatile.StoreUint32(&o.PPCFG5.Reg, volatile.LoadUint32(&o.PPCFG5.Reg)&^(0xffc00)|value<<10)
}
func (o *LCDC_Type) GetPPCFG5_CSCVG() uint32 {
	return (volatile.LoadUint32(&o.PPCFG5.Reg) & 0xffc00) >> 10
}
func (o *LCDC_Type) SetPPCFG5_CSCVB(value uint32) {
	volatile.StoreUint32(&o.PPCFG5.Reg, volatile.LoadUint32(&o.PPCFG5.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LCDC_Type) GetPPCFG5_CSCVB() uint32 {
	return (volatile.LoadUint32(&o.PPCFG5.Reg) & 0x3ff00000) >> 20
}
func (o *LCDC_Type) SetPPCFG5_CSCVOFF(value uint32) {
	volatile.StoreUint32(&o.PPCFG5.Reg, volatile.LoadUint32(&o.PPCFG5.Reg)&^(0x40000000)|value<<30)
}
func (o *LCDC_Type) GetPPCFG5_CSCVOFF() uint32 {
	return (volatile.LoadUint32(&o.PPCFG5.Reg) & 0x40000000) >> 30
}

// LCDC.BASECLUT: Base CLUT Register
func (o *LCDC_Type) SetBASECLUT_BCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.BASECLUT[idx].Reg, volatile.LoadUint32(&o.BASECLUT[idx].Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetBASECLUT_BCLUT(idx int) uint32 {
	return volatile.LoadUint32(&o.BASECLUT[idx].Reg) & 0xff
}
func (o *LCDC_Type) SetBASECLUT_GCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.BASECLUT[idx].Reg, volatile.LoadUint32(&o.BASECLUT[idx].Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetBASECLUT_GCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.BASECLUT[idx].Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetBASECLUT_RCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.BASECLUT[idx].Reg, volatile.LoadUint32(&o.BASECLUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetBASECLUT_RCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.BASECLUT[idx].Reg) & 0xff0000) >> 16
}

// LCDC.OVR1CLUT: Overlay 1 CLUT Register
func (o *LCDC_Type) SetOVR1CLUT_BCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR1CLUT[idx].Reg, volatile.LoadUint32(&o.OVR1CLUT[idx].Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR1CLUT_BCLUT(idx int) uint32 {
	return volatile.LoadUint32(&o.OVR1CLUT[idx].Reg) & 0xff
}
func (o *LCDC_Type) SetOVR1CLUT_GCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR1CLUT[idx].Reg, volatile.LoadUint32(&o.OVR1CLUT[idx].Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR1CLUT_GCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR1CLUT[idx].Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR1CLUT_RCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR1CLUT[idx].Reg, volatile.LoadUint32(&o.OVR1CLUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR1CLUT_RCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR1CLUT[idx].Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetOVR1CLUT_ACLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR1CLUT[idx].Reg, volatile.LoadUint32(&o.OVR1CLUT[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetOVR1CLUT_ACLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR1CLUT[idx].Reg) & 0xff000000) >> 24
}

// LCDC.OVR2CLUT: Overlay 2 CLUT Register
func (o *LCDC_Type) SetOVR2CLUT_BCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR2CLUT[idx].Reg, volatile.LoadUint32(&o.OVR2CLUT[idx].Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetOVR2CLUT_BCLUT(idx int) uint32 {
	return volatile.LoadUint32(&o.OVR2CLUT[idx].Reg) & 0xff
}
func (o *LCDC_Type) SetOVR2CLUT_GCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR2CLUT[idx].Reg, volatile.LoadUint32(&o.OVR2CLUT[idx].Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetOVR2CLUT_GCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR2CLUT[idx].Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetOVR2CLUT_RCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR2CLUT[idx].Reg, volatile.LoadUint32(&o.OVR2CLUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetOVR2CLUT_RCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR2CLUT[idx].Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetOVR2CLUT_ACLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.OVR2CLUT[idx].Reg, volatile.LoadUint32(&o.OVR2CLUT[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetOVR2CLUT_ACLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.OVR2CLUT[idx].Reg) & 0xff000000) >> 24
}

// LCDC.HEOCLUT: High End Overlay CLUT Register
func (o *LCDC_Type) SetHEOCLUT_BCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HEOCLUT[idx].Reg, volatile.LoadUint32(&o.HEOCLUT[idx].Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHEOCLUT_BCLUT(idx int) uint32 {
	return volatile.LoadUint32(&o.HEOCLUT[idx].Reg) & 0xff
}
func (o *LCDC_Type) SetHEOCLUT_GCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HEOCLUT[idx].Reg, volatile.LoadUint32(&o.HEOCLUT[idx].Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHEOCLUT_GCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HEOCLUT[idx].Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHEOCLUT_RCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HEOCLUT[idx].Reg, volatile.LoadUint32(&o.HEOCLUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHEOCLUT_RCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HEOCLUT[idx].Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHEOCLUT_ACLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HEOCLUT[idx].Reg, volatile.LoadUint32(&o.HEOCLUT[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHEOCLUT_ACLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HEOCLUT[idx].Reg) & 0xff000000) >> 24
}

// LCDC.HCRCLUT: Hardware Cursor CLUT Register
func (o *LCDC_Type) SetHCRCLUT_BCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HCRCLUT[idx].Reg, volatile.LoadUint32(&o.HCRCLUT[idx].Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetHCRCLUT_BCLUT(idx int) uint32 {
	return volatile.LoadUint32(&o.HCRCLUT[idx].Reg) & 0xff
}
func (o *LCDC_Type) SetHCRCLUT_GCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HCRCLUT[idx].Reg, volatile.LoadUint32(&o.HCRCLUT[idx].Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetHCRCLUT_GCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HCRCLUT[idx].Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetHCRCLUT_RCLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HCRCLUT[idx].Reg, volatile.LoadUint32(&o.HCRCLUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *LCDC_Type) GetHCRCLUT_RCLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HCRCLUT[idx].Reg) & 0xff0000) >> 16
}
func (o *LCDC_Type) SetHCRCLUT_ACLUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HCRCLUT[idx].Reg, volatile.LoadUint32(&o.HCRCLUT[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *LCDC_Type) GetHCRCLUT_ACLUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HCRCLUT[idx].Reg) & 0xff000000) >> 24
}

// Image Sensor Interface
type ISI_Type struct {
	CFG1       volatile.Register32 // 0x0
	CFG2       volatile.Register32 // 0x4
	PSIZE      volatile.Register32 // 0x8
	PDECF      volatile.Register32 // 0xC
	Y2R_SET0   volatile.Register32 // 0x10
	Y2R_SET1   volatile.Register32 // 0x14
	R2Y_SET0   volatile.Register32 // 0x18
	R2Y_SET1   volatile.Register32 // 0x1C
	R2Y_SET2   volatile.Register32 // 0x20
	CR         volatile.Register32 // 0x24
	SR         volatile.Register32 // 0x28
	IER        volatile.Register32 // 0x2C
	IDR        volatile.Register32 // 0x30
	IMR        volatile.Register32 // 0x34
	DMA_CHER   volatile.Register32 // 0x38
	DMA_CHDR   volatile.Register32 // 0x3C
	DMA_CHSR   volatile.Register32 // 0x40
	DMA_P_ADDR volatile.Register32 // 0x44
	DMA_P_CTRL volatile.Register32 // 0x48
	DMA_P_DSCR volatile.Register32 // 0x4C
	DMA_C_ADDR volatile.Register32 // 0x50
	DMA_C_CTRL volatile.Register32 // 0x54
	DMA_C_DSCR volatile.Register32 // 0x58
	_          [136]byte
	WPCR       volatile.Register32 // 0xE4
	WPSR       volatile.Register32 // 0xE8
}

// ISI.CFG1: ISI Configuration 1 Register
func (o *ISI_Type) SetCFG1_HSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCFG1_HSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCFG1_VSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetCFG1_VSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x8) >> 3
}
func (o *ISI_Type) SetCFG1_PIXCLK_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ISI_Type) GetCFG1_PIXCLK_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10) >> 4
}
func (o *ISI_Type) SetCFG1_EMB_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x40)|value<<6)
}
func (o *ISI_Type) GetCFG1_EMB_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x40) >> 6
}
func (o *ISI_Type) SetCFG1_CRC_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ISI_Type) GetCFG1_CRC_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80) >> 7
}
func (o *ISI_Type) SetCFG1_FRATE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x700)|value<<8)
}
func (o *ISI_Type) GetCFG1_FRATE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x700) >> 8
}
func (o *ISI_Type) SetCFG1_DISCR(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG1_DISCR() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG1_FULL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG1_FULL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG1_THMASK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x6000)|value<<13)
}
func (o *ISI_Type) GetCFG1_THMASK() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x6000) >> 13
}
func (o *ISI_Type) SetCFG1_SLD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetCFG1_SLD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetCFG1_SFD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetCFG1_SFD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff000000) >> 24
}

// ISI.CFG2: ISI Configuration 2 Register
func (o *ISI_Type) SetCFG2_IM_VSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff)|value)
}
func (o *ISI_Type) GetCFG2_IM_VSIZE() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff
}
func (o *ISI_Type) SetCFG2_GS_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG2_GS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG2_RGB_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG2_RGB_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG2_GRAYSCALE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetCFG2_GRAYSCALE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetCFG2_RGB_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetCFG2_RGB_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4000) >> 14
}
func (o *ISI_Type) SetCFG2_COL_SPACE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8000)|value<<15)
}
func (o *ISI_Type) GetCFG2_COL_SPACE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8000) >> 15
}
func (o *ISI_Type) SetCFG2_IM_HSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *ISI_Type) GetCFG2_IM_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff0000) >> 16
}
func (o *ISI_Type) SetCFG2_YCC_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *ISI_Type) GetCFG2_YCC_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}
func (o *ISI_Type) SetCFG2_RGB_CFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ISI_Type) GetCFG2_RGB_CFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc0000000) >> 30
}

// ISI.PSIZE: ISI Preview Size Register
func (o *ISI_Type) SetPSIZE_PREV_VSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff)|value)
}
func (o *ISI_Type) GetPSIZE_PREV_VSIZE() uint32 {
	return volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff
}
func (o *ISI_Type) SetPSIZE_PREV_HSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff0000)|value<<16)
}
func (o *ISI_Type) GetPSIZE_PREV_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff0000) >> 16
}

// ISI.PDECF: ISI Preview Decimation Factor Register
func (o *ISI_Type) SetPDECF_DEC_FACTOR(value uint32) {
	volatile.StoreUint32(&o.PDECF.Reg, volatile.LoadUint32(&o.PDECF.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetPDECF_DEC_FACTOR() uint32 {
	return volatile.LoadUint32(&o.PDECF.Reg) & 0xff
}

// ISI.Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
func (o *ISI_Type) SetY2R_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetY2R_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff
}
func (o *ISI_Type) SetY2R_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetY2R_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetY2R_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetY2R_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetY2R_SET0_C3(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetY2R_SET0_C3() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff000000) >> 24
}

// ISI.Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
func (o *ISI_Type) SetY2R_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1ff)|value)
}
func (o *ISI_Type) GetY2R_SET1_C4() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1ff
}
func (o *ISI_Type) SetY2R_SET1_Yoff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetY2R_SET1_Yoff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetY2R_SET1_Croff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetY2R_SET1_Croff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetY2R_SET1_Cboff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetY2R_SET1_Cboff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x4000) >> 14
}

// ISI.R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
func (o *ISI_Type) SetR2Y_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET0_Roff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET0_Roff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
func (o *ISI_Type) SetR2Y_SET1_C3(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET1_C3() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET1_C4() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET1_C5(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET1_C5() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET1_Goff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET1_Goff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
func (o *ISI_Type) SetR2Y_SET2_C6(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET2_C6() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET2_C7(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET2_C7() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET2_C8(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET2_C8() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET2_Boff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET2_Boff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x1000000) >> 24
}

// ISI.CR: ISI Control Register
func (o *ISI_Type) SetCR_ISI_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetCR_ISI_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ISI_Type) SetCR_ISI_DIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetCR_ISI_DIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetCR_ISI_SRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCR_ISI_SRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCR_ISI_CDC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetCR_ISI_CDC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// ISI.SR: ISI Status Register
func (o *ISI_Type) SetSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *ISI_Type) SetSR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetSR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetSR_SRST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetSR_SRST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetSR_CDC_PND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetSR_CDC_PND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *ISI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetSR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetSR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetSR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetSR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetSR_SIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *ISI_Type) GetSR_SIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *ISI_Type) SetSR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetSR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetSR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetSR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetSR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetSR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetSR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetSR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}

// ISI.IER: ISI Interrupt Enable Register
func (o *ISI_Type) SetIER_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIER_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIER_SRST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIER_SRST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIER_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIER_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIER_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIER_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIER_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIER_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIER_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIER_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIER_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIER_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIER_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIER_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIER_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIER_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}

// ISI.IDR: ISI Interrupt Disable Register
func (o *ISI_Type) SetIDR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIDR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIDR_SRST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIDR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIDR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIDR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIDR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIDR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIDR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIDR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIDR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIDR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIDR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIDR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIDR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIDR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIDR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIDR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}

// ISI.IMR: ISI Interrupt Mask Register
func (o *ISI_Type) SetIMR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIMR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIMR_SRST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIMR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIMR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIMR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIMR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIMR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIMR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIMR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIMR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIMR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIMR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIMR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIMR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIMR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIMR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIMR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}

// ISI.DMA_CHER: DMA Channel Enable Register
func (o *ISI_Type) SetDMA_CHER_P_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHER_P_CH_EN() uint32 {
	return volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHER_C_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHER_C_CH_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x2) >> 1
}

// ISI.DMA_CHDR: DMA Channel Disable Register
func (o *ISI_Type) SetDMA_CHDR_P_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHDR_P_CH_DIS() uint32 {
	return volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHDR_C_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHDR_C_CH_DIS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x2) >> 1
}

// ISI.DMA_CHSR: DMA Channel Status Register
func (o *ISI_Type) SetDMA_CHSR_P_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHSR_P_CH_S() uint32 {
	return volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHSR_C_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHSR_C_CH_S() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x2) >> 1
}

// ISI.DMA_P_ADDR: DMA Preview Base Address Register
func (o *ISI_Type) SetDMA_P_ADDR_P_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_ADDR.Reg, volatile.LoadUint32(&o.DMA_P_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_ADDR_P_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_P_CTRL: DMA Preview Control Register
func (o *ISI_Type) SetDMA_P_CTRL_P_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_P_CTRL_P_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_P_DSCR: DMA Preview Descriptor Address Register
func (o *ISI_Type) SetDMA_P_DSCR_P_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_DSCR.Reg, volatile.LoadUint32(&o.DMA_P_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_DSCR_P_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_ADDR: DMA Codec Base Address Register
func (o *ISI_Type) SetDMA_C_ADDR_C_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_ADDR.Reg, volatile.LoadUint32(&o.DMA_C_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_ADDR_C_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_CTRL: DMA Codec Control Register
func (o *ISI_Type) SetDMA_C_CTRL_C_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_C_CTRL_C_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_C_DSCR: DMA Codec Descriptor Address Register
func (o *ISI_Type) SetDMA_C_DSCR_C_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_DSCR.Reg, volatile.LoadUint32(&o.DMA_C_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_DSCR_C_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.WPCR: Write Protection Control Register
func (o *ISI_Type) SetWPCR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetWPCR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x1
}
func (o *ISI_Type) SetWPCR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ISI_Type) GetWPCR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// ISI.WPSR: Write Protection Status Register
func (o *ISI_Type) SetWPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xf)|value)
}
func (o *ISI_Type) GetWPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0xf
}
func (o *ISI_Type) SetWPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ISI_Type) GetWPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Special Function Registers
type SFR_Type struct {
	_          [16]byte
	OHCIICR    volatile.Register32 // 0x10
	OHCIISR    volatile.Register32 // 0x14
	_          [8]byte
	AHB        volatile.Register32 // 0x20
	BRIDGE     volatile.Register32 // 0x24
	SECURE     volatile.Register32 // 0x28
	_          [4]byte
	UTMICKTRIM volatile.Register32 // 0x30
	UTMIHSTRIM volatile.Register32 // 0x34
	UTMIFSTRIM volatile.Register32 // 0x38
	UTMISWAP   volatile.Register32 // 0x3C
	EBICFG     volatile.Register32 // 0x40
}

// SFR.OHCIICR: OHCI Interrupt Configuration Register
func (o *SFR_Type) SetOHCIICR_RES0(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetOHCIICR_RES0() uint32 {
	return volatile.LoadUint32(&o.OHCIICR.Reg) & 0x1
}
func (o *SFR_Type) SetOHCIICR_RES1(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetOHCIICR_RES1() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetOHCIICR_RES2(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetOHCIICR_RES2() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x4) >> 2
}
func (o *SFR_Type) SetOHCIICR_ARIE(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x10)|value<<4)
}
func (o *SFR_Type) GetOHCIICR_ARIE() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x10) >> 4
}
func (o *SFR_Type) SetOHCIICR_APPSTART(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x20)|value<<5)
}
func (o *SFR_Type) GetOHCIICR_APPSTART() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x20) >> 5
}
func (o *SFR_Type) SetOHCIICR_UDPPUDIS(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x800000)|value<<23)
}
func (o *SFR_Type) GetOHCIICR_UDPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x800000) >> 23
}

// SFR.OHCIISR: OHCI Interrupt Status Register
func (o *SFR_Type) SetOHCIISR_RIS0(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetOHCIISR_RIS0() uint32 {
	return volatile.LoadUint32(&o.OHCIISR.Reg) & 0x1
}
func (o *SFR_Type) SetOHCIISR_RIS1(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetOHCIISR_RIS1() uint32 {
	return (volatile.LoadUint32(&o.OHCIISR.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetOHCIISR_RIS2(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetOHCIISR_RIS2() uint32 {
	return (volatile.LoadUint32(&o.OHCIISR.Reg) & 0x4) >> 2
}

// SFR.AHB: AHB Configuration Register
func (o *SFR_Type) SetAHB_PFETCH10(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x400)|value<<10)
}
func (o *SFR_Type) GetAHB_PFETCH10() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x400) >> 10
}
func (o *SFR_Type) SetAHB_PFETCH11(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x800)|value<<11)
}
func (o *SFR_Type) GetAHB_PFETCH11() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x800) >> 11
}
func (o *SFR_Type) SetAHB_PFETCH12(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x1000)|value<<12)
}
func (o *SFR_Type) GetAHB_PFETCH12() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x1000) >> 12
}
func (o *SFR_Type) SetAHB_PFETCH13(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x2000)|value<<13)
}
func (o *SFR_Type) GetAHB_PFETCH13() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x2000) >> 13
}
func (o *SFR_Type) SetAHB_PFETCH14(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x4000)|value<<14)
}
func (o *SFR_Type) GetAHB_PFETCH14() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x4000) >> 14
}
func (o *SFR_Type) SetAHB_DLBOPT10(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x4000000)|value<<26)
}
func (o *SFR_Type) GetAHB_DLBOPT10() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x4000000) >> 26
}
func (o *SFR_Type) SetAHB_DLBOPT11(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x8000000)|value<<27)
}
func (o *SFR_Type) GetAHB_DLBOPT11() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x8000000) >> 27
}
func (o *SFR_Type) SetAHB_DLBOPT12(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x10000000)|value<<28)
}
func (o *SFR_Type) GetAHB_DLBOPT12() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x10000000) >> 28
}
func (o *SFR_Type) SetAHB_DLBOPT13(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x20000000)|value<<29)
}
func (o *SFR_Type) GetAHB_DLBOPT13() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x20000000) >> 29
}
func (o *SFR_Type) SetAHB_DLBOPT14(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x40000000)|value<<30)
}
func (o *SFR_Type) GetAHB_DLBOPT14() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x40000000) >> 30
}

// SFR.BRIDGE: Bridge Configuration Register
func (o *SFR_Type) SetBRIDGE_APBTURBO(value uint32) {
	volatile.StoreUint32(&o.BRIDGE.Reg, volatile.LoadUint32(&o.BRIDGE.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetBRIDGE_APBTURBO() uint32 {
	return volatile.LoadUint32(&o.BRIDGE.Reg) & 0x1
}
func (o *SFR_Type) SetBRIDGE_AXI2AHBSEL(value uint32) {
	volatile.StoreUint32(&o.BRIDGE.Reg, volatile.LoadUint32(&o.BRIDGE.Reg)&^(0x100)|value<<8)
}
func (o *SFR_Type) GetBRIDGE_AXI2AHBSEL() uint32 {
	return (volatile.LoadUint32(&o.BRIDGE.Reg) & 0x100) >> 8
}

// SFR.SECURE: Security Configuration Register
func (o *SFR_Type) SetSECURE_ROM(value uint32) {
	volatile.StoreUint32(&o.SECURE.Reg, volatile.LoadUint32(&o.SECURE.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetSECURE_ROM() uint32 {
	return volatile.LoadUint32(&o.SECURE.Reg) & 0x1
}
func (o *SFR_Type) SetSECURE_FUSE(value uint32) {
	volatile.StoreUint32(&o.SECURE.Reg, volatile.LoadUint32(&o.SECURE.Reg)&^(0x100)|value<<8)
}
func (o *SFR_Type) GetSECURE_FUSE() uint32 {
	return (volatile.LoadUint32(&o.SECURE.Reg) & 0x100) >> 8
}

// SFR.UTMICKTRIM: UTMI Clock Trimming Register
func (o *SFR_Type) SetUTMICKTRIM_FREQ(value uint32) {
	volatile.StoreUint32(&o.UTMICKTRIM.Reg, volatile.LoadUint32(&o.UTMICKTRIM.Reg)&^(0x3)|value)
}
func (o *SFR_Type) GetUTMICKTRIM_FREQ() uint32 {
	return volatile.LoadUint32(&o.UTMICKTRIM.Reg) & 0x3
}
func (o *SFR_Type) SetUTMICKTRIM_VBG(value uint32) {
	volatile.StoreUint32(&o.UTMICKTRIM.Reg, volatile.LoadUint32(&o.UTMICKTRIM.Reg)&^(0xf0000)|value<<16)
}
func (o *SFR_Type) GetUTMICKTRIM_VBG() uint32 {
	return (volatile.LoadUint32(&o.UTMICKTRIM.Reg) & 0xf0000) >> 16
}

// SFR.UTMIHSTRIM: UTMI High Speed Trimming Register
func (o *SFR_Type) SetUTMIHSTRIM_SQUELCH(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x7)|value)
}
func (o *SFR_Type) GetUTMIHSTRIM_SQUELCH() uint32 {
	return volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x7
}
func (o *SFR_Type) SetUTMIHSTRIM_DISC(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x70)|value<<4)
}
func (o *SFR_Type) GetUTMIHSTRIM_DISC() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x70) >> 4
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE0(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x700)|value<<8)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE0() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x700) >> 8
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE1(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x7000)|value<<12)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE1() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x7000) >> 12
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE2(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x70000)|value<<16)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE2() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x70000) >> 16
}

// SFR.UTMIFSTRIM: UTMI Full Speed Trimming Register
func (o *SFR_Type) SetUTMIFSTRIM_RISE(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x7)|value)
}
func (o *SFR_Type) GetUTMIFSTRIM_RISE() uint32 {
	return volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x7
}
func (o *SFR_Type) SetUTMIFSTRIM_FALL(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x70)|value<<4)
}
func (o *SFR_Type) GetUTMIFSTRIM_FALL() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x70) >> 4
}
func (o *SFR_Type) SetUTMIFSTRIM_XCVR(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x300)|value<<8)
}
func (o *SFR_Type) GetUTMIFSTRIM_XCVR() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x300) >> 8
}
func (o *SFR_Type) SetUTMIFSTRIM_ZN(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x70000)|value<<16)
}
func (o *SFR_Type) GetUTMIFSTRIM_ZN() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x70000) >> 16
}
func (o *SFR_Type) SetUTMIFSTRIM_ZP(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x700000)|value<<20)
}
func (o *SFR_Type) GetUTMIFSTRIM_ZP() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x700000) >> 20
}

// SFR.UTMISWAP: UTMI DP/DM Pin Swapping Register
func (o *SFR_Type) SetUTMISWAP_PORT0(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetUTMISWAP_PORT0() uint32 {
	return volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x1
}
func (o *SFR_Type) SetUTMISWAP_PORT1(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetUTMISWAP_PORT1() uint32 {
	return (volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetUTMISWAP_PORT2(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetUTMISWAP_PORT2() uint32 {
	return (volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x4) >> 2
}

// SFR.EBICFG: EBI Configuration Register
func (o *SFR_Type) SetEBICFG_DRIVE0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x3)|value)
}
func (o *SFR_Type) GetEBICFG_DRIVE0() uint32 {
	return volatile.LoadUint32(&o.EBICFG.Reg) & 0x3
}
func (o *SFR_Type) SetEBICFG_PULL0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0xc)|value<<2)
}
func (o *SFR_Type) GetEBICFG_PULL0() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0xc) >> 2
}
func (o *SFR_Type) SetEBICFG_SCH0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x10)|value<<4)
}
func (o *SFR_Type) GetEBICFG_SCH0() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x10) >> 4
}
func (o *SFR_Type) SetEBICFG_DRIVE1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x300)|value<<8)
}
func (o *SFR_Type) GetEBICFG_DRIVE1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x300) >> 8
}
func (o *SFR_Type) SetEBICFG_PULL1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0xc00)|value<<10)
}
func (o *SFR_Type) GetEBICFG_PULL1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0xc00) >> 10
}
func (o *SFR_Type) SetEBICFG_SCH1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x1000)|value<<12)
}
func (o *SFR_Type) GetEBICFG_SCH1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x1000) >> 12
}
func (o *SFR_Type) SetEBICFG_BMS(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x10000)|value<<16)
}
func (o *SFR_Type) GetEBICFG_BMS() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x10000) >> 16
}

// Analog-to-Digital Converter
type ADC_Type struct {
	CR     volatile.Register32 // 0x0
	MR     volatile.Register32 // 0x4
	SEQR1  volatile.Register32 // 0x8
	SEQR2  volatile.Register32 // 0xC
	CHER   volatile.Register32 // 0x10
	CHDR   volatile.Register32 // 0x14
	CHSR   volatile.Register32 // 0x18
	_      [4]byte
	LCDR   volatile.Register32 // 0x20
	IER    volatile.Register32 // 0x24
	IDR    volatile.Register32 // 0x28
	IMR    volatile.Register32 // 0x2C
	ISR    volatile.Register32 // 0x30
	_      [8]byte
	OVER   volatile.Register32     // 0x3C
	EMR    volatile.Register32     // 0x40
	CWR    volatile.Register32     // 0x44
	CGR    volatile.Register32     // 0x48
	COR    volatile.Register32     // 0x4C
	CDR    [12]volatile.Register32 // 0x50
	_      [20]byte
	ACR    volatile.Register32 // 0x94
	_      [24]byte
	TSMR   volatile.Register32 // 0xB0
	XPOSR  volatile.Register32 // 0xB4
	YPOSR  volatile.Register32 // 0xB8
	PRESSR volatile.Register32 // 0xBC
	TRGR   volatile.Register32 // 0xC0
	_      [32]byte
	WPMR   volatile.Register32 // 0xE4
	WPSR   volatile.Register32 // 0xE8
}

// ADC.CR: Control Register
func (o *ADC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ADC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_TSCALIB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_TSCALIB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_AUTOCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCR_AUTOCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}

// ADC.MR: Mode Register
func (o *ADC_Type) SetMR_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe)|value<<1)
}
func (o *ADC_Type) GetMR_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe) >> 1
}
func (o *ADC_Type) SetMR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetMR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetMR_FWUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetMR_FWUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetMR_PRESCAL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetMR_PRESCAL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetMR_STARTUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetMR_STARTUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetMR_SETTLING(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetMR_SETTLING() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetMR_ANACH(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetMR_ANACH() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetMR_TRACKTIM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetMR_TRACKTIM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetMR_USEQ(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetMR_USEQ() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// ADC.SEQR1: Channel Sequence Register 1
func (o *ADC_Type) SetSEQR1_USCH1(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSEQR1_USCH1() uint32 {
	return volatile.LoadUint32(&o.SEQR1.Reg) & 0xf
}
func (o *ADC_Type) SetSEQR1_USCH2(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetSEQR1_USCH2() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetSEQR1_USCH3(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetSEQR1_USCH3() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf00) >> 8
}
func (o *ADC_Type) SetSEQR1_USCH4(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC_Type) GetSEQR1_USCH4() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf000) >> 12
}
func (o *ADC_Type) SetSEQR1_USCH5(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetSEQR1_USCH5() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetSEQR1_USCH6(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf00000)|value<<20)
}
func (o *ADC_Type) GetSEQR1_USCH6() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf00000) >> 20
}
func (o *ADC_Type) SetSEQR1_USCH7(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetSEQR1_USCH7() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetSEQR1_USCH8(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetSEQR1_USCH8() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0000000) >> 28
}

// ADC.SEQR2: Channel Sequence Register 2
func (o *ADC_Type) SetSEQR2_USCH9(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSEQR2_USCH9() uint32 {
	return volatile.LoadUint32(&o.SEQR2.Reg) & 0xf
}
func (o *ADC_Type) SetSEQR2_USCH10(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetSEQR2_USCH10() uint32 {
	return (volatile.LoadUint32(&o.SEQR2.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetSEQR2_USCH11(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetSEQR2_USCH11() uint32 {
	return (volatile.LoadUint32(&o.SEQR2.Reg) & 0xf00) >> 8
}

// ADC.CHER: Channel Enable Register
func (o *ADC_Type) SetCHER_CH0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHER_CH0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *ADC_Type) SetCHER_CH1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHER_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHER_CH2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHER_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHER_CH3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHER_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHER_CH4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHER_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHER_CH5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHER_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHER_CH6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHER_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHER_CH7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHER_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHER_CH8(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHER_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHER_CH9(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHER_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHER_CH10(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHER_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHER_CH11(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHER_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}

// ADC.CHDR: Channel Disable Register
func (o *ADC_Type) SetCHDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *ADC_Type) SetCHDR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHDR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHDR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHDR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHDR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHDR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHDR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHDR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHDR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHDR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHDR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHDR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHDR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHDR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHDR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHDR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHDR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHDR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHDR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHDR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHDR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHDR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}

// ADC.CHSR: Channel Status Register
func (o *ADC_Type) SetCHSR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHSR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *ADC_Type) SetCHSR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHSR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHSR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHSR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHSR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHSR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHSR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHSR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHSR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHSR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHSR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHSR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHSR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHSR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHSR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHSR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHSR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHSR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHSR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHSR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHSR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHSR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}

// ADC.LCDR: Last Converted Data Register
func (o *ADC_Type) SetLCDR_LDATA(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetLCDR_LDATA() uint32 {
	return volatile.LoadUint32(&o.LCDR.Reg) & 0xfff
}
func (o *ADC_Type) SetLCDR_CHNB(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xf000)|value<<12)
}
func (o *ADC_Type) GetLCDR_CHNB() uint32 {
	return (volatile.LoadUint32(&o.LCDR.Reg) & 0xf000) >> 12
}

// ADC.IER: Interrupt Enable Register
func (o *ADC_Type) SetIER_EOC0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_EOC0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *ADC_Type) SetIER_EOC1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_EOC2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOC3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_EOC4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_EOC5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIER_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIER_EOC6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIER_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIER_EOC7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_EOC8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_EOC9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_EOC10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIER_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIER_EOC11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIER_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIER_XRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIER_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIER_YRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIER_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIER_PRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIER_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIER_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIER_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIER_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIER_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIER_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIER_COMPE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIER_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIER_PEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIER_PEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIER_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIER_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}

// ADC.IDR: Interrupt Disable Register
func (o *ADC_Type) SetIDR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIDR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *ADC_Type) SetIDR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIDR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIDR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIDR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIDR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIDR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIDR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIDR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIDR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIDR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIDR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIDR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIDR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIDR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIDR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIDR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIDR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIDR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIDR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIDR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIDR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIDR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIDR_XRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIDR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIDR_YRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIDR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIDR_PRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIDR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIDR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIDR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIDR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIDR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIDR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIDR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIDR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIDR_PEN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIDR_PEN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIDR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIDR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}

// ADC.IMR: Interrupt Mask Register
func (o *ADC_Type) SetIMR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIMR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *ADC_Type) SetIMR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIMR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIMR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIMR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIMR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIMR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIMR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIMR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIMR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIMR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIMR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIMR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIMR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIMR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIMR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIMR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIMR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIMR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIMR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIMR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIMR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIMR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIMR_XRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIMR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIMR_YRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIMR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIMR_PRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIMR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIMR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIMR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIMR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIMR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIMR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIMR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIMR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIMR_PEN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIMR_PEN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIMR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIMR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}

// ADC.ISR: Interrupt Status Register
func (o *ADC_Type) SetISR_EOC0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_EOC0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *ADC_Type) SetISR_EOC1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_EOC2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOC3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_EOC4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_EOC5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetISR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetISR_EOC6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetISR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetISR_EOC7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_EOC8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_EOC9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_EOC10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetISR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetISR_EOC11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetISR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetISR_XRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetISR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetISR_YRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetISR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetISR_PRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetISR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetISR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetISR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetISR_DRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetISR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetISR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetISR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetISR_COMPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetISR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetISR_PEN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetISR_PEN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetISR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetISR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetISR_PENS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetISR_PENS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// ADC.OVER: Overrun Status Register
func (o *ADC_Type) SetOVER_OVRE0(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetOVER_OVRE0() uint32 {
	return volatile.LoadUint32(&o.OVER.Reg) & 0x1
}
func (o *ADC_Type) SetOVER_OVRE1(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetOVER_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetOVER_OVRE2(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetOVER_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetOVER_OVRE3(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetOVER_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetOVER_OVRE4(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetOVER_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetOVER_OVRE5(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetOVER_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetOVER_OVRE6(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetOVER_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetOVER_OVRE7(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetOVER_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetOVER_OVRE8(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetOVER_OVRE8() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetOVER_OVRE9(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetOVER_OVRE9() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetOVER_OVRE10(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetOVER_OVRE10() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetOVER_OVRE11(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetOVER_OVRE11() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x800) >> 11
}

// ADC.EMR: Extended Mode Register
func (o *ADC_Type) SetEMR_CMPMODE(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetEMR_CMPMODE() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x3
}
func (o *ADC_Type) SetEMR_CMPSEL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetEMR_CMPSEL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetEMR_CMPALL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetEMR_CMPALL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetEMR_CMPFILTER(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3000)|value<<12)
}
func (o *ADC_Type) GetEMR_CMPFILTER() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x3000) >> 12
}
func (o *ADC_Type) SetEMR_TAG(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetEMR_TAG() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x1000000) >> 24
}

// ADC.CWR: Compare Window Register
func (o *ADC_Type) SetCWR_LOWTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetCWR_LOWTHRES() uint32 {
	return volatile.LoadUint32(&o.CWR.Reg) & 0xfff
}
func (o *ADC_Type) SetCWR_HIGHTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetCWR_HIGHTHRES() uint32 {
	return (volatile.LoadUint32(&o.CWR.Reg) & 0xfff0000) >> 16
}

// ADC.CGR: Channel Gain Register
func (o *ADC_Type) SetCGR_GAIN0(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCGR_GAIN0() uint32 {
	return volatile.LoadUint32(&o.CGR.Reg) & 0x3
}
func (o *ADC_Type) SetCGR_GAIN1(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc)|value<<2)
}
func (o *ADC_Type) GetCGR_GAIN1() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc) >> 2
}
func (o *ADC_Type) SetCGR_GAIN2(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30)|value<<4)
}
func (o *ADC_Type) GetCGR_GAIN2() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30) >> 4
}
func (o *ADC_Type) SetCGR_GAIN3(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC_Type) GetCGR_GAIN3() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0) >> 6
}
func (o *ADC_Type) SetCGR_GAIN4(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300)|value<<8)
}
func (o *ADC_Type) GetCGR_GAIN4() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300) >> 8
}
func (o *ADC_Type) SetCGR_GAIN5(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCGR_GAIN5() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCGR_GAIN6(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3000)|value<<12)
}
func (o *ADC_Type) GetCGR_GAIN6() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x3000) >> 12
}
func (o *ADC_Type) SetCGR_GAIN7(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc000)|value<<14)
}
func (o *ADC_Type) GetCGR_GAIN7() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc000) >> 14
}
func (o *ADC_Type) SetCGR_GAIN8(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30000)|value<<16)
}
func (o *ADC_Type) GetCGR_GAIN8() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30000) >> 16
}
func (o *ADC_Type) SetCGR_GAIN9(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0000)|value<<18)
}
func (o *ADC_Type) GetCGR_GAIN9() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0000) >> 18
}
func (o *ADC_Type) SetCGR_GAIN10(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetCGR_GAIN10() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetCGR_GAIN11(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00000)|value<<22)
}
func (o *ADC_Type) GetCGR_GAIN11() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00000) >> 22
}

// ADC.COR: Channel Offset Register
func (o *ADC_Type) SetCOR_OFF0(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCOR_OFF0() uint32 {
	return volatile.LoadUint32(&o.COR.Reg) & 0x1
}
func (o *ADC_Type) SetCOR_OFF1(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCOR_OFF1() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCOR_OFF2(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCOR_OFF2() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCOR_OFF3(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCOR_OFF3() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCOR_OFF4(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCOR_OFF4() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCOR_OFF5(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCOR_OFF5() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCOR_OFF6(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCOR_OFF6() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCOR_OFF7(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCOR_OFF7() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCOR_OFF8(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCOR_OFF8() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCOR_OFF9(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCOR_OFF9() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCOR_OFF10(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCOR_OFF10() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCOR_OFF11(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCOR_OFF11() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetCOR_DIFF0(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCOR_DIFF0() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCOR_DIFF1(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetCOR_DIFF1() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetCOR_DIFF2(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetCOR_DIFF2() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetCOR_DIFF3(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetCOR_DIFF3() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetCOR_DIFF4(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCOR_DIFF4() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCOR_DIFF5(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCOR_DIFF5() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCOR_DIFF6(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCOR_DIFF6() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCOR_DIFF7(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCOR_DIFF7() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCOR_DIFF8(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCOR_DIFF8() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCOR_DIFF9(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetCOR_DIFF9() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetCOR_DIFF10(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetCOR_DIFF10() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetCOR_DIFF11(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCOR_DIFF11() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x8000000) >> 27
}

// ADC.CDR: Channel Data Register
func (o *ADC_Type) SetCDR_DATA(idx int, value uint32) {
	volatile.StoreUint32(&o.CDR[idx].Reg, volatile.LoadUint32(&o.CDR[idx].Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetCDR_DATA(idx int) uint32 {
	return volatile.LoadUint32(&o.CDR[idx].Reg) & 0xfff
}

// ADC.ACR: Analog Control Register
func (o *ADC_Type) SetACR_PENDETSENS(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetACR_PENDETSENS() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x3
}

// ADC.TSMR: Touchscreen Mode Register
func (o *ADC_Type) SetTSMR_TSMODE(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetTSMR_TSMODE() uint32 {
	return volatile.LoadUint32(&o.TSMR.Reg) & 0x3
}
func (o *ADC_Type) SetTSMR_TSAV(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x30)|value<<4)
}
func (o *ADC_Type) GetTSMR_TSAV() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x30) >> 4
}
func (o *ADC_Type) SetTSMR_TSFREQ(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetTSMR_TSFREQ() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf00) >> 8
}
func (o *ADC_Type) SetTSMR_TSSCTIM(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetTSMR_TSSCTIM() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetTSMR_NOTSDMA(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetTSMR_NOTSDMA() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetTSMR_PENDET(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetTSMR_PENDET() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetTSMR_PENDBC(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetTSMR_PENDBC() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf0000000) >> 28
}

// ADC.XPOSR: Touchscreen X Position Register
func (o *ADC_Type) SetXPOSR_XPOS(value uint32) {
	volatile.StoreUint32(&o.XPOSR.Reg, volatile.LoadUint32(&o.XPOSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetXPOSR_XPOS() uint32 {
	return volatile.LoadUint32(&o.XPOSR.Reg) & 0xfff
}
func (o *ADC_Type) SetXPOSR_XSCALE(value uint32) {
	volatile.StoreUint32(&o.XPOSR.Reg, volatile.LoadUint32(&o.XPOSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetXPOSR_XSCALE() uint32 {
	return (volatile.LoadUint32(&o.XPOSR.Reg) & 0xfff0000) >> 16
}

// ADC.YPOSR: Touchscreen Y Position Register
func (o *ADC_Type) SetYPOSR_YPOS(value uint32) {
	volatile.StoreUint32(&o.YPOSR.Reg, volatile.LoadUint32(&o.YPOSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetYPOSR_YPOS() uint32 {
	return volatile.LoadUint32(&o.YPOSR.Reg) & 0xfff
}
func (o *ADC_Type) SetYPOSR_YSCALE(value uint32) {
	volatile.StoreUint32(&o.YPOSR.Reg, volatile.LoadUint32(&o.YPOSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetYPOSR_YSCALE() uint32 {
	return (volatile.LoadUint32(&o.YPOSR.Reg) & 0xfff0000) >> 16
}

// ADC.PRESSR: Touchscreen Pressure Register
func (o *ADC_Type) SetPRESSR_Z1(value uint32) {
	volatile.StoreUint32(&o.PRESSR.Reg, volatile.LoadUint32(&o.PRESSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetPRESSR_Z1() uint32 {
	return volatile.LoadUint32(&o.PRESSR.Reg) & 0xfff
}
func (o *ADC_Type) SetPRESSR_Z2(value uint32) {
	volatile.StoreUint32(&o.PRESSR.Reg, volatile.LoadUint32(&o.PRESSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetPRESSR_Z2() uint32 {
	return (volatile.LoadUint32(&o.PRESSR.Reg) & 0xfff0000) >> 16
}

// ADC.TRGR: Trigger Register
func (o *ADC_Type) SetTRGR_TRGMOD(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetTRGR_TRGMOD() uint32 {
	return volatile.LoadUint32(&o.TRGR.Reg) & 0x7
}
func (o *ADC_Type) SetTRGR_TRGPER(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_Type) GetTRGR_TRGPER() uint32 {
	return (volatile.LoadUint32(&o.TRGR.Reg) & 0xffff0000) >> 16
}

// ADC.WPMR: Write Protect Mode Register
func (o *ADC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *ADC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ADC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// ADC.WPSR: Write Protect Status Register
func (o *ADC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *ADC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ADC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Ethernet MAC 10/100
type EMAC_Type struct {
	NCR   volatile.Register32 // 0x0
	NCFGR volatile.Register32 // 0x4
	NSR   volatile.Register32 // 0x8
	_     [8]byte
	TSR   volatile.Register32 // 0x14
	RBQP  volatile.Register32 // 0x18
	TBQP  volatile.Register32 // 0x1C
	RSR   volatile.Register32 // 0x20
	ISR   volatile.Register32 // 0x24
	IER   volatile.Register32 // 0x28
	IDR   volatile.Register32 // 0x2C
	IMR   volatile.Register32 // 0x30
	MAN   volatile.Register32 // 0x34
	PTR   volatile.Register32 // 0x38
	PFR   volatile.Register32 // 0x3C
	FTO   volatile.Register32 // 0x40
	SCF   volatile.Register32 // 0x44
	MCF   volatile.Register32 // 0x48
	FRO   volatile.Register32 // 0x4C
	FCSE  volatile.Register32 // 0x50
	ALE   volatile.Register32 // 0x54
	DTF   volatile.Register32 // 0x58
	LCOL  volatile.Register32 // 0x5C
	ECOL  volatile.Register32 // 0x60
	TUND  volatile.Register32 // 0x64
	CSE   volatile.Register32 // 0x68
	RRE   volatile.Register32 // 0x6C
	ROV   volatile.Register32 // 0x70
	RSE   volatile.Register32 // 0x74
	ELE   volatile.Register32 // 0x78
	RJA   volatile.Register32 // 0x7C
	USF   volatile.Register32 // 0x80
	STE   volatile.Register32 // 0x84
	RLE   volatile.Register32 // 0x88
	_     [4]byte
	HRB   volatile.Register32 // 0x90
	HRT   volatile.Register32 // 0x94
	SA1B  volatile.Register32 // 0x98
	SA1T  volatile.Register32 // 0x9C
	SA2B  volatile.Register32 // 0xA0
	SA2T  volatile.Register32 // 0xA4
	SA3B  volatile.Register32 // 0xA8
	SA3T  volatile.Register32 // 0xAC
	SA4B  volatile.Register32 // 0xB0
	SA4T  volatile.Register32 // 0xB4
	TID   volatile.Register32 // 0xB8
	_     [4]byte
	USRIO volatile.Register32 // 0xC0
	WOL   volatile.Register32 // 0xC4
}

// EMAC.NCR: Network Control Register
func (o *EMAC_Type) SetNCR_LB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCR_LB() uint32 {
	return volatile.LoadUint32(&o.NCR.Reg) & 0x1
}
func (o *EMAC_Type) SetNCR_LLB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCR_LLB() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCR_RE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNCR_RE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetNCR_TE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCR_TE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *EMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *EMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}

// EMAC.NCFGR: Network Configuration Register
func (o *EMAC_Type) SetNCFGR_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCFGR_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFGR.Reg) & 0x1
}
func (o *EMAC_Type) SetNCFGR_FD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCFGR_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCFGR_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCFGR_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCFGR_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCFGR_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCFGR_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCFGR_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCFGR_MTI(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCFGR_MTI() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCFGR_UNI(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCFGR_UNI() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCFGR_BIG(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCFGR_BIG() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCFGR_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc00)|value<<10)
}
func (o *EMAC_Type) GetNCFGR_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc00) >> 10
}
func (o *EMAC_Type) SetNCFGR_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetNCFGR_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetNCFGR_PAE(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetNCFGR_PAE() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetNCFGR_RBOF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc000)|value<<14)
}
func (o *EMAC_Type) GetNCFGR_RBOF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc000) >> 14
}
func (o *EMAC_Type) SetNCFGR_RLCE(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *EMAC_Type) GetNCFGR_RLCE() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000) >> 16
}
func (o *EMAC_Type) SetNCFGR_DRFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *EMAC_Type) GetNCFGR_DRFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000) >> 17
}
func (o *EMAC_Type) SetNCFGR_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40000)|value<<18)
}
func (o *EMAC_Type) GetNCFGR_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40000) >> 18
}
func (o *EMAC_Type) SetNCFGR_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80000)|value<<19)
}
func (o *EMAC_Type) GetNCFGR_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80000) >> 19
}

// EMAC.NSR: Network Status Register
func (o *EMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// EMAC.TSR: Transmit Status Register
func (o *EMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *EMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetTSR_RLES(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetTSR_RLES() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetTSR_TGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetTSR_TGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetTSR_BEX(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetTSR_BEX() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetTSR_COMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetTSR_COMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetTSR_UND(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetTSR_UND() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40) >> 6
}

// EMAC.RBQP: Receive Buffer Queue Pointer Register
func (o *EMAC_Type) SetRBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQP.Reg, volatile.LoadUint32(&o.RBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetRBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.TBQP: Transmit Buffer Queue Pointer Register
func (o *EMAC_Type) SetTBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQP.Reg, volatile.LoadUint32(&o.TBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetTBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.RSR: Receive Status Register
func (o *EMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *EMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetRSR_OVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetRSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}

// EMAC.ISR: Interrupt Status Register
func (o *EMAC_Type) SetISR_MFD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetISR_MFD() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *EMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetISR_TUND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetISR_TUND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetISR_RLEX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetISR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetISR_PFRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetISR_PFRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetISR_WOL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetISR_WOL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}

// EMAC.IER: Interrupt Enable Register
func (o *EMAC_Type) SetIER_MFD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIER_MFD() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *EMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIER_TUND(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIER_TUND() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIER_RLE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIER_RLE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIER_TXERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIER_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIER_PFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIER_PFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIER_WOL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIER_WOL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}

// EMAC.IDR: Interrupt Disable Register
func (o *EMAC_Type) SetIDR_MFD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIDR_MFD() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *EMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIDR_TUND(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIDR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIDR_RLE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIDR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIDR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIDR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIDR_PFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIDR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIDR_WOL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIDR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}

// EMAC.IMR: Interrupt Mask Register
func (o *EMAC_Type) SetIMR_MFD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIMR_MFD() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *EMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIMR_TUND(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIMR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIMR_RLE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIMR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIMR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIMR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIMR_PFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIMR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIMR_WOL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIMR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}

// EMAC.MAN: Phy Maintenance Register
func (o *EMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *EMAC_Type) SetMAN_CODE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *EMAC_Type) GetMAN_CODE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *EMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *EMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *EMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *EMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *EMAC_Type) SetMAN_RW(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *EMAC_Type) GetMAN_RW() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *EMAC_Type) SetMAN_SOF(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xc0000000)|value<<30)
}
func (o *EMAC_Type) GetMAN_SOF() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xc0000000) >> 30
}

// EMAC.PTR: Pause Time Register
func (o *EMAC_Type) SetPTR_PTIME(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, volatile.LoadUint32(&o.PTR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPTR_PTIME() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg) & 0xffff
}

// EMAC.PFR: Pause Frames Received Register
func (o *EMAC_Type) SetPFR_FROK(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPFR_FROK() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// EMAC.FTO: Frames Transmitted Ok Register
func (o *EMAC_Type) SetFTO_FTOK(value uint32) {
	volatile.StoreUint32(&o.FTO.Reg, volatile.LoadUint32(&o.FTO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFTO_FTOK() uint32 {
	return volatile.LoadUint32(&o.FTO.Reg) & 0xffffff
}

// EMAC.SCF: Single Collision Frames Register
func (o *EMAC_Type) SetSCF(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSCF() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0xffff
}

// EMAC.MCF: Multiple Collision Frames Register
func (o *EMAC_Type) SetMCF(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMCF() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0xffff
}

// EMAC.FRO: Frames Received Ok Register
func (o *EMAC_Type) SetFRO_FROK(value uint32) {
	volatile.StoreUint32(&o.FRO.Reg, volatile.LoadUint32(&o.FRO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFRO_FROK() uint32 {
	return volatile.LoadUint32(&o.FRO.Reg) & 0xffffff
}

// EMAC.FCSE: Frame Check Sequence Errors Register
func (o *EMAC_Type) SetFCSE(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetFCSE() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0xff
}

// EMAC.ALE: Alignment Errors Register
func (o *EMAC_Type) SetALE(value uint32) {
	volatile.StoreUint32(&o.ALE.Reg, volatile.LoadUint32(&o.ALE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetALE() uint32 {
	return volatile.LoadUint32(&o.ALE.Reg) & 0xff
}

// EMAC.DTF: Deferred Transmission Frames Register
func (o *EMAC_Type) SetDTF(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetDTF() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0xffff
}

// EMAC.LCOL: Late Collisions Register
func (o *EMAC_Type) SetLCOL(value uint32) {
	volatile.StoreUint32(&o.LCOL.Reg, volatile.LoadUint32(&o.LCOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetLCOL() uint32 {
	return volatile.LoadUint32(&o.LCOL.Reg) & 0xff
}

// EMAC.ECOL: Excessive Collisions Register
func (o *EMAC_Type) SetECOL_EXCOL(value uint32) {
	volatile.StoreUint32(&o.ECOL.Reg, volatile.LoadUint32(&o.ECOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetECOL_EXCOL() uint32 {
	return volatile.LoadUint32(&o.ECOL.Reg) & 0xff
}

// EMAC.TUND: Transmit Underrun Errors Register
func (o *EMAC_Type) SetTUND(value uint32) {
	volatile.StoreUint32(&o.TUND.Reg, volatile.LoadUint32(&o.TUND.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetTUND() uint32 {
	return volatile.LoadUint32(&o.TUND.Reg) & 0xff
}

// EMAC.CSE: Carrier Sense Errors Register
func (o *EMAC_Type) SetCSE(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetCSE() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0xff
}

// EMAC.RRE: Receive Resource Errors Register
func (o *EMAC_Type) SetRRE(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetRRE() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0xffff
}

// EMAC.ROV: Receive Overrun Errors Register
func (o *EMAC_Type) SetROV_ROVR(value uint32) {
	volatile.StoreUint32(&o.ROV.Reg, volatile.LoadUint32(&o.ROV.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetROV_ROVR() uint32 {
	return volatile.LoadUint32(&o.ROV.Reg) & 0xff
}

// EMAC.RSE: Receive Symbol Errors Register
func (o *EMAC_Type) SetRSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0xff
}

// EMAC.ELE: Excessive Length Errors Register
func (o *EMAC_Type) SetELE_EXL(value uint32) {
	volatile.StoreUint32(&o.ELE.Reg, volatile.LoadUint32(&o.ELE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetELE_EXL() uint32 {
	return volatile.LoadUint32(&o.ELE.Reg) & 0xff
}

// EMAC.RJA: Receive Jabbers Register
func (o *EMAC_Type) SetRJA_RJB(value uint32) {
	volatile.StoreUint32(&o.RJA.Reg, volatile.LoadUint32(&o.RJA.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRJA_RJB() uint32 {
	return volatile.LoadUint32(&o.RJA.Reg) & 0xff
}

// EMAC.USF: Undersize Frames Register
func (o *EMAC_Type) SetUSF(value uint32) {
	volatile.StoreUint32(&o.USF.Reg, volatile.LoadUint32(&o.USF.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetUSF() uint32 {
	return volatile.LoadUint32(&o.USF.Reg) & 0xff
}

// EMAC.STE: SQE Test Errors Register
func (o *EMAC_Type) SetSTE_SQER(value uint32) {
	volatile.StoreUint32(&o.STE.Reg, volatile.LoadUint32(&o.STE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetSTE_SQER() uint32 {
	return volatile.LoadUint32(&o.STE.Reg) & 0xff
}

// EMAC.RLE: Received Length Field Mismatch Register
func (o *EMAC_Type) SetRLE_RLFM(value uint32) {
	volatile.StoreUint32(&o.RLE.Reg, volatile.LoadUint32(&o.RLE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRLE_RLFM() uint32 {
	return volatile.LoadUint32(&o.RLE.Reg) & 0xff
}

// EMAC.HRB: Hash Register Bottom [31:0] Register
func (o *EMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *EMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// EMAC.HRT: Hash Register Top [63:32] Register
func (o *EMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *EMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// EMAC.SA1B: Specific Address 1 Bottom Register
func (o *EMAC_Type) SetSA1B(value uint32) {
	volatile.StoreUint32(&o.SA1B.Reg, value)
}
func (o *EMAC_Type) GetSA1B() uint32 {
	return volatile.LoadUint32(&o.SA1B.Reg)
}

// EMAC.SA1T: Specific Address 1 Top Register
func (o *EMAC_Type) SetSA1T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA1T.Reg, volatile.LoadUint32(&o.SA1T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA1T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA1T.Reg) & 0xffff
}

// EMAC.SA2B: Specific Address 2 Bottom Register
func (o *EMAC_Type) SetSA2B(value uint32) {
	volatile.StoreUint32(&o.SA2B.Reg, value)
}
func (o *EMAC_Type) GetSA2B() uint32 {
	return volatile.LoadUint32(&o.SA2B.Reg)
}

// EMAC.SA2T: Specific Address 2 Top Register
func (o *EMAC_Type) SetSA2T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA2T.Reg, volatile.LoadUint32(&o.SA2T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA2T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA2T.Reg) & 0xffff
}

// EMAC.SA3B: Specific Address 3 Bottom Register
func (o *EMAC_Type) SetSA3B(value uint32) {
	volatile.StoreUint32(&o.SA3B.Reg, value)
}
func (o *EMAC_Type) GetSA3B() uint32 {
	return volatile.LoadUint32(&o.SA3B.Reg)
}

// EMAC.SA3T: Specific Address 3 Top Register
func (o *EMAC_Type) SetSA3T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA3T.Reg, volatile.LoadUint32(&o.SA3T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA3T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA3T.Reg) & 0xffff
}

// EMAC.SA4B: Specific Address 4 Bottom Register
func (o *EMAC_Type) SetSA4B(value uint32) {
	volatile.StoreUint32(&o.SA4B.Reg, value)
}
func (o *EMAC_Type) GetSA4B() uint32 {
	return volatile.LoadUint32(&o.SA4B.Reg)
}

// EMAC.SA4T: Specific Address 4 Top Register
func (o *EMAC_Type) SetSA4T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA4T.Reg, volatile.LoadUint32(&o.SA4T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA4T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA4T.Reg) & 0xffff
}

// EMAC.TID: Type ID Checking Register
func (o *EMAC_Type) SetTID(value uint32) {
	volatile.StoreUint32(&o.TID.Reg, volatile.LoadUint32(&o.TID.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetTID() uint32 {
	return volatile.LoadUint32(&o.TID.Reg) & 0xffff
}

// EMAC.USRIO: User Input/Output Register
func (o *EMAC_Type) SetUSRIO_RMII(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetUSRIO_RMII() uint32 {
	return volatile.LoadUint32(&o.USRIO.Reg) & 0x1
}
func (o *EMAC_Type) SetUSRIO_CLKEN(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetUSRIO_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.USRIO.Reg) & 0x2) >> 1
}

// EMAC.WOL: Wake on LAN Register
func (o *EMAC_Type) SetWOL_IP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetWOL_IP() uint32 {
	return volatile.LoadUint32(&o.WOL.Reg) & 0xffff
}
func (o *EMAC_Type) SetWOL_MAG(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x10000)|value<<16)
}
func (o *EMAC_Type) GetWOL_MAG() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x10000) >> 16
}
func (o *EMAC_Type) SetWOL_ARP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x20000)|value<<17)
}
func (o *EMAC_Type) GetWOL_ARP() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x20000) >> 17
}
func (o *EMAC_Type) SetWOL_SA1(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x40000)|value<<18)
}
func (o *EMAC_Type) GetWOL_SA1() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x40000) >> 18
}
func (o *EMAC_Type) SetWOL_MTI(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x80000)|value<<19)
}
func (o *EMAC_Type) GetWOL_MTI() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x80000) >> 19
}

// USB High Speed Device Port
type UDPHS_Type struct {
	CTRL        volatile.Register32 // 0x0
	FNUM        volatile.Register32 // 0x4
	_           [8]byte
	IEN         volatile.Register32 // 0x10
	INTSTA      volatile.Register32 // 0x14
	CLRINT      volatile.Register32 // 0x18
	EPTRST      volatile.Register32 // 0x1C
	_           [192]byte
	TST         volatile.Register32 // 0xE0
	_           [28]byte
	EPTCFG0     volatile.Register32 // 0x100
	EPTCTLENB0  volatile.Register32 // 0x104
	EPTCTLDIS0  volatile.Register32 // 0x108
	EPTCTL0     volatile.Register32 // 0x10C
	_           [4]byte
	EPTSETSTA0  volatile.Register32 // 0x114
	EPTCLRSTA0  volatile.Register32 // 0x118
	EPTSTA0     volatile.Register32 // 0x11C
	EPTCFG1     volatile.Register32 // 0x120
	EPTCTLENB1  volatile.Register32 // 0x124
	EPTCTLDIS1  volatile.Register32 // 0x128
	EPTCTL1     volatile.Register32 // 0x12C
	_           [4]byte
	EPTSETSTA1  volatile.Register32 // 0x134
	EPTCLRSTA1  volatile.Register32 // 0x138
	EPTSTA1     volatile.Register32 // 0x13C
	EPTCFG2     volatile.Register32 // 0x140
	EPTCTLENB2  volatile.Register32 // 0x144
	EPTCTLDIS2  volatile.Register32 // 0x148
	EPTCTL2     volatile.Register32 // 0x14C
	_           [4]byte
	EPTSETSTA2  volatile.Register32 // 0x154
	EPTCLRSTA2  volatile.Register32 // 0x158
	EPTSTA2     volatile.Register32 // 0x15C
	EPTCFG3     volatile.Register32 // 0x160
	EPTCTLENB3  volatile.Register32 // 0x164
	EPTCTLDIS3  volatile.Register32 // 0x168
	EPTCTL3     volatile.Register32 // 0x16C
	_           [4]byte
	EPTSETSTA3  volatile.Register32 // 0x174
	EPTCLRSTA3  volatile.Register32 // 0x178
	EPTSTA3     volatile.Register32 // 0x17C
	EPTCFG4     volatile.Register32 // 0x180
	EPTCTLENB4  volatile.Register32 // 0x184
	EPTCTLDIS4  volatile.Register32 // 0x188
	EPTCTL4     volatile.Register32 // 0x18C
	_           [4]byte
	EPTSETSTA4  volatile.Register32 // 0x194
	EPTCLRSTA4  volatile.Register32 // 0x198
	EPTSTA4     volatile.Register32 // 0x19C
	EPTCFG5     volatile.Register32 // 0x1A0
	EPTCTLENB5  volatile.Register32 // 0x1A4
	EPTCTLDIS5  volatile.Register32 // 0x1A8
	EPTCTL5     volatile.Register32 // 0x1AC
	_           [4]byte
	EPTSETSTA5  volatile.Register32 // 0x1B4
	EPTCLRSTA5  volatile.Register32 // 0x1B8
	EPTSTA5     volatile.Register32 // 0x1BC
	EPTCFG6     volatile.Register32 // 0x1C0
	EPTCTLENB6  volatile.Register32 // 0x1C4
	EPTCTLDIS6  volatile.Register32 // 0x1C8
	EPTCTL6     volatile.Register32 // 0x1CC
	_           [4]byte
	EPTSETSTA6  volatile.Register32 // 0x1D4
	EPTCLRSTA6  volatile.Register32 // 0x1D8
	EPTSTA6     volatile.Register32 // 0x1DC
	EPTCFG7     volatile.Register32 // 0x1E0
	EPTCTLENB7  volatile.Register32 // 0x1E4
	EPTCTLDIS7  volatile.Register32 // 0x1E8
	EPTCTL7     volatile.Register32 // 0x1EC
	_           [4]byte
	EPTSETSTA7  volatile.Register32 // 0x1F4
	EPTCLRSTA7  volatile.Register32 // 0x1F8
	EPTSTA7     volatile.Register32 // 0x1FC
	EPTCFG8     volatile.Register32 // 0x200
	EPTCTLENB8  volatile.Register32 // 0x204
	EPTCTLDIS8  volatile.Register32 // 0x208
	EPTCTL8     volatile.Register32 // 0x20C
	_           [4]byte
	EPTSETSTA8  volatile.Register32 // 0x214
	EPTCLRSTA8  volatile.Register32 // 0x218
	EPTSTA8     volatile.Register32 // 0x21C
	EPTCFG9     volatile.Register32 // 0x220
	EPTCTLENB9  volatile.Register32 // 0x224
	EPTCTLDIS9  volatile.Register32 // 0x228
	EPTCTL9     volatile.Register32 // 0x22C
	_           [4]byte
	EPTSETSTA9  volatile.Register32 // 0x234
	EPTCLRSTA9  volatile.Register32 // 0x238
	EPTSTA9     volatile.Register32 // 0x23C
	EPTCFG10    volatile.Register32 // 0x240
	EPTCTLENB10 volatile.Register32 // 0x244
	EPTCTLDIS10 volatile.Register32 // 0x248
	EPTCTL10    volatile.Register32 // 0x24C
	_           [4]byte
	EPTSETSTA10 volatile.Register32 // 0x254
	EPTCLRSTA10 volatile.Register32 // 0x258
	EPTSTA10    volatile.Register32 // 0x25C
	EPTCFG11    volatile.Register32 // 0x260
	EPTCTLENB11 volatile.Register32 // 0x264
	EPTCTLDIS11 volatile.Register32 // 0x268
	EPTCTL11    volatile.Register32 // 0x26C
	_           [4]byte
	EPTSETSTA11 volatile.Register32 // 0x274
	EPTCLRSTA11 volatile.Register32 // 0x278
	EPTSTA11    volatile.Register32 // 0x27C
	EPTCFG12    volatile.Register32 // 0x280
	EPTCTLENB12 volatile.Register32 // 0x284
	EPTCTLDIS12 volatile.Register32 // 0x288
	EPTCTL12    volatile.Register32 // 0x28C
	_           [4]byte
	EPTSETSTA12 volatile.Register32 // 0x294
	EPTCLRSTA12 volatile.Register32 // 0x298
	EPTSTA12    volatile.Register32 // 0x29C
	EPTCFG13    volatile.Register32 // 0x2A0
	EPTCTLENB13 volatile.Register32 // 0x2A4
	EPTCTLDIS13 volatile.Register32 // 0x2A8
	EPTCTL13    volatile.Register32 // 0x2AC
	_           [4]byte
	EPTSETSTA13 volatile.Register32 // 0x2B4
	EPTCLRSTA13 volatile.Register32 // 0x2B8
	EPTSTA13    volatile.Register32 // 0x2BC
	EPTCFG14    volatile.Register32 // 0x2C0
	EPTCTLENB14 volatile.Register32 // 0x2C4
	EPTCTLDIS14 volatile.Register32 // 0x2C8
	EPTCTL14    volatile.Register32 // 0x2CC
	_           [4]byte
	EPTSETSTA14 volatile.Register32 // 0x2D4
	EPTCLRSTA14 volatile.Register32 // 0x2D8
	EPTSTA14    volatile.Register32 // 0x2DC
	EPTCFG15    volatile.Register32 // 0x2E0
	EPTCTLENB15 volatile.Register32 // 0x2E4
	EPTCTLDIS15 volatile.Register32 // 0x2E8
	EPTCTL15    volatile.Register32 // 0x2EC
	_           [4]byte
	EPTSETSTA15 volatile.Register32 // 0x2F4
	EPTCLRSTA15 volatile.Register32 // 0x2F8
	EPTSTA15    volatile.Register32 // 0x2FC
	DMANXTDSC0  volatile.Register32 // 0x300
	DMAADDRESS0 volatile.Register32 // 0x304
	DMACONTROL0 volatile.Register32 // 0x308
	DMASTATUS0  volatile.Register32 // 0x30C
	DMANXTDSC1  volatile.Register32 // 0x310
	DMAADDRESS1 volatile.Register32 // 0x314
	DMACONTROL1 volatile.Register32 // 0x318
	DMASTATUS1  volatile.Register32 // 0x31C
	DMANXTDSC2  volatile.Register32 // 0x320
	DMAADDRESS2 volatile.Register32 // 0x324
	DMACONTROL2 volatile.Register32 // 0x328
	DMASTATUS2  volatile.Register32 // 0x32C
	DMANXTDSC3  volatile.Register32 // 0x330
	DMAADDRESS3 volatile.Register32 // 0x334
	DMACONTROL3 volatile.Register32 // 0x338
	DMASTATUS3  volatile.Register32 // 0x33C
	DMANXTDSC4  volatile.Register32 // 0x340
	DMAADDRESS4 volatile.Register32 // 0x344
	DMACONTROL4 volatile.Register32 // 0x348
	DMASTATUS4  volatile.Register32 // 0x34C
	DMANXTDSC5  volatile.Register32 // 0x350
	DMAADDRESS5 volatile.Register32 // 0x354
	DMACONTROL5 volatile.Register32 // 0x358
	DMASTATUS5  volatile.Register32 // 0x35C
	DMANXTDSC6  volatile.Register32 // 0x360
	DMAADDRESS6 volatile.Register32 // 0x364
	DMACONTROL6 volatile.Register32 // 0x368
	DMASTATUS6  volatile.Register32 // 0x36C
}

// UDPHS.CTRL: UDPHS Control Register
func (o *UDPHS_Type) SetCTRL_DEV_ADDR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f)|value)
}
func (o *UDPHS_Type) GetCTRL_DEV_ADDR() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x7f
}
func (o *UDPHS_Type) SetCTRL_FADDR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCTRL_FADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetCTRL_EN_UDPHS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetCTRL_EN_UDPHS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetCTRL_DETACH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetCTRL_DETACH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetCTRL_REWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetCTRL_REWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetCTRL_PULLD_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetCTRL_PULLD_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}

// UDPHS.FNUM: UDPHS Frame Number Register
func (o *UDPHS_Type) SetFNUM_MICRO_FRAME_NUM(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetFNUM_MICRO_FRAME_NUM() uint32 {
	return volatile.LoadUint32(&o.FNUM.Reg) & 0x7
}
func (o *UDPHS_Type) SetFNUM_FRAME_NUMBER(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *UDPHS_Type) GetFNUM_FRAME_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x3ff8) >> 3
}
func (o *UDPHS_Type) SetFNUM_FNUM_ERR(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetFNUM_FNUM_ERR() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x80000000) >> 31
}

// UDPHS.IEN: UDPHS Interrupt Enable Register
func (o *UDPHS_Type) SetIEN_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetIEN_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetIEN_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetIEN_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetIEN_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetIEN_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetIEN_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetIEN_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetIEN_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetIEN_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetIEN_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetIEN_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetIEN_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetIEN_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetIEN_EPT_0(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetIEN_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetIEN_EPT_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetIEN_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetIEN_EPT_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetIEN_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetIEN_EPT_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetIEN_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetIEN_EPT_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetIEN_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetIEN_EPT_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetIEN_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetIEN_EPT_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetIEN_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetIEN_EPT_7(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetIEN_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetIEN_EPT_8(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10000)|value<<16)
}
func (o *UDPHS_Type) GetIEN_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10000) >> 16
}
func (o *UDPHS_Type) SetIEN_EPT_9(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20000)|value<<17)
}
func (o *UDPHS_Type) GetIEN_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20000) >> 17
}
func (o *UDPHS_Type) SetIEN_EPT_10(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetIEN_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetIEN_EPT_11(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80000)|value<<19)
}
func (o *UDPHS_Type) GetIEN_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80000) >> 19
}
func (o *UDPHS_Type) SetIEN_EPT_12(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x100000)|value<<20)
}
func (o *UDPHS_Type) GetIEN_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x100000) >> 20
}
func (o *UDPHS_Type) SetIEN_EPT_13(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x200000)|value<<21)
}
func (o *UDPHS_Type) GetIEN_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x200000) >> 21
}
func (o *UDPHS_Type) SetIEN_EPT_14(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x400000)|value<<22)
}
func (o *UDPHS_Type) GetIEN_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x400000) >> 22
}
func (o *UDPHS_Type) SetIEN_EPT_15(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x800000)|value<<23)
}
func (o *UDPHS_Type) GetIEN_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x800000) >> 23
}
func (o *UDPHS_Type) SetIEN_DMA_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetIEN_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetIEN_DMA_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetIEN_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetIEN_DMA_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetIEN_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetIEN_DMA_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetIEN_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetIEN_DMA_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetIEN_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetIEN_DMA_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetIEN_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40000000) >> 30
}
func (o *UDPHS_Type) SetIEN_DMA_7(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetIEN_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80000000) >> 31
}

// UDPHS.INTSTA: UDPHS Interrupt Status Register
func (o *UDPHS_Type) SetINTSTA_SPEED(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetINTSTA_SPEED() uint32 {
	return volatile.LoadUint32(&o.INTSTA.Reg) & 0x1
}
func (o *UDPHS_Type) SetINTSTA_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetINTSTA_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetINTSTA_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetINTSTA_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetINTSTA_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetINTSTA_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetINTSTA_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetINTSTA_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetINTSTA_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetINTSTA_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetINTSTA_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetINTSTA_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetINTSTA_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetINTSTA_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetINTSTA_EPT_0(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetINTSTA_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetINTSTA_EPT_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetINTSTA_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetINTSTA_EPT_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetINTSTA_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetINTSTA_EPT_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetINTSTA_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetINTSTA_EPT_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetINTSTA_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetINTSTA_EPT_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetINTSTA_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetINTSTA_EPT_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetINTSTA_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetINTSTA_EPT_7(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetINTSTA_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetINTSTA_EPT_8(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10000)|value<<16)
}
func (o *UDPHS_Type) GetINTSTA_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10000) >> 16
}
func (o *UDPHS_Type) SetINTSTA_EPT_9(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20000)|value<<17)
}
func (o *UDPHS_Type) GetINTSTA_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20000) >> 17
}
func (o *UDPHS_Type) SetINTSTA_EPT_10(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetINTSTA_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetINTSTA_EPT_11(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80000)|value<<19)
}
func (o *UDPHS_Type) GetINTSTA_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80000) >> 19
}
func (o *UDPHS_Type) SetINTSTA_EPT_12(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x100000)|value<<20)
}
func (o *UDPHS_Type) GetINTSTA_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x100000) >> 20
}
func (o *UDPHS_Type) SetINTSTA_EPT_13(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x200000)|value<<21)
}
func (o *UDPHS_Type) GetINTSTA_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x200000) >> 21
}
func (o *UDPHS_Type) SetINTSTA_EPT_14(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x400000)|value<<22)
}
func (o *UDPHS_Type) GetINTSTA_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x400000) >> 22
}
func (o *UDPHS_Type) SetINTSTA_EPT_15(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x800000)|value<<23)
}
func (o *UDPHS_Type) GetINTSTA_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x800000) >> 23
}
func (o *UDPHS_Type) SetINTSTA_DMA_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetINTSTA_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetINTSTA_DMA_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetINTSTA_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetINTSTA_DMA_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetINTSTA_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetINTSTA_DMA_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetINTSTA_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetINTSTA_DMA_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetINTSTA_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetINTSTA_DMA_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetINTSTA_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40000000) >> 30
}
func (o *UDPHS_Type) SetINTSTA_DMA_7(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetINTSTA_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80000000) >> 31
}

// UDPHS.CLRINT: UDPHS Clear Interrupt Register
func (o *UDPHS_Type) SetCLRINT_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetCLRINT_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetCLRINT_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetCLRINT_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetCLRINT_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetCLRINT_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetCLRINT_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetCLRINT_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetCLRINT_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetCLRINT_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetCLRINT_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetCLRINT_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetCLRINT_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCLRINT_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x80) >> 7
}

// UDPHS.EPTRST: UDPHS Endpoints Reset Register
func (o *UDPHS_Type) SetEPTRST_EPT_0(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTRST_EPT_0() uint32 {
	return volatile.LoadUint32(&o.EPTRST.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTRST_EPT_1(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTRST_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTRST_EPT_2(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetEPTRST_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetEPTRST_EPT_3(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTRST_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTRST_EPT_4(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTRST_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTRST_EPT_5(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTRST_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTRST_EPT_6(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTRST_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTRST_EPT_7(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetEPTRST_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetEPTRST_EPT_8(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTRST_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTRST_EPT_9(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTRST_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTRST_EPT_10(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTRST_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTRST_EPT_11(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTRST_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTRST_EPT_12(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTRST_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTRST_EPT_13(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTRST_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTRST_EPT_14(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTRST_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTRST_EPT_15(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTRST_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x8000) >> 15
}

// UDPHS.TST: UDPHS Test Register
func (o *UDPHS_Type) SetTST_SPEED_CFG(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x3)|value)
}
func (o *UDPHS_Type) GetTST_SPEED_CFG() uint32 {
	return volatile.LoadUint32(&o.TST.Reg) & 0x3
}
func (o *UDPHS_Type) SetTST_TST_J(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetTST_TST_J() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetTST_TST_K(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetTST_TST_K() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetTST_TST_PKT(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetTST_TST_PKT() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetTST_OPMODE2(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetTST_OPMODE2() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x20) >> 5
}

// UDPHS.EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCFG0_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG0_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG0_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG0_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG0_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLENB0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLDIS0_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTL0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSETSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCLRSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA0_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA0_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA0_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA0_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA0_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA0_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA0_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA0_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCFG1_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG1_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG1_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG1_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG1_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLENB1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLDIS1_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTL1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSETSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCLRSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA1_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA1_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA1_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA1_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA1_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA1_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA1_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA1_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCFG2_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG2_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG2_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG2_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG2_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLENB2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLDIS2_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTL2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSETSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCLRSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA2_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA2_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA2_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA2_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA2_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA2_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA2_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA2_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCFG3_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG3_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG3_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG3_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG3_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLENB3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLDIS3_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTL3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSETSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCLRSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA3_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA3_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA3_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA3_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA3_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA3_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA3_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA3_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCFG4_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG4_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG4_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG4_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG4_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLENB4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLDIS4_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTL4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSETSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCLRSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA4_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA4_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA4_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA4_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA4_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA4_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA4_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA4_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCFG5_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG5_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG5_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG5_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG5_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLENB5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLDIS5_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTL5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSETSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCLRSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA5_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA5_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA5_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA5_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA5_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA5_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA5_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA5_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCFG6_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG6_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG6_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG6_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG6_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLENB6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLDIS6_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTL6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSETSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCLRSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA6_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA6_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA6_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA6_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA6_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA6_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA6_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA6_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG7: UDPHS Endpoint Configuration Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCFG7_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG7_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG7_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG7_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG7_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB7: UDPHS Endpoint Control Enable Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTLENB7_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB7_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS7: UDPHS Endpoint Control Disable Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTLDIS7_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL7: UDPHS Endpoint Control Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTL7_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL7_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA7: UDPHS Endpoint Set Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTSETSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA7: UDPHS Endpoint Clear Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCLRSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA7_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA7: UDPHS Endpoint Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA7_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA7_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA7_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA7_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA7_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA7_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA7_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA7_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG8: UDPHS Endpoint Configuration Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCFG8_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG8_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG8_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG8_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG8_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB8: UDPHS Endpoint Control Enable Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTLENB8_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB8_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS8: UDPHS Endpoint Control Disable Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTLDIS8_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL8: UDPHS Endpoint Control Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTL8_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL8_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA8: UDPHS Endpoint Set Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTSETSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA8: UDPHS Endpoint Clear Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCLRSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA8_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA8: UDPHS Endpoint Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA8_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA8_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA8_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA8_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA8_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA8_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA8_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA8_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG9: UDPHS Endpoint Configuration Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCFG9_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG9_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG9_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG9_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG9_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB9: UDPHS Endpoint Control Enable Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTLENB9_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB9_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS9: UDPHS Endpoint Control Disable Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTLDIS9_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL9: UDPHS Endpoint Control Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTL9_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL9_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA9: UDPHS Endpoint Set Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTSETSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA9: UDPHS Endpoint Clear Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCLRSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA9_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA9: UDPHS Endpoint Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA9_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA9_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA9_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA9_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA9_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA9_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA9_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA9_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG10: UDPHS Endpoint Configuration Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCFG10_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG10_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG10_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG10_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG10_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB10: UDPHS Endpoint Control Enable Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTLENB10_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB10_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS10: UDPHS Endpoint Control Disable Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTLDIS10_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL10: UDPHS Endpoint Control Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTL10_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL10_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA10: UDPHS Endpoint Set Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTSETSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA10: UDPHS Endpoint Clear Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCLRSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA10_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA10: UDPHS Endpoint Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA10_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA10_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA10_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA10_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA10_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA10_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA10_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA10_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG11: UDPHS Endpoint Configuration Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCFG11_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG11_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG11_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG11_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG11_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB11: UDPHS Endpoint Control Enable Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTLENB11_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB11_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS11: UDPHS Endpoint Control Disable Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTLDIS11_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL11: UDPHS Endpoint Control Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTL11_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL11_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA11: UDPHS Endpoint Set Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTSETSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA11: UDPHS Endpoint Clear Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCLRSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA11_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA11: UDPHS Endpoint Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA11_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA11_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA11_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA11_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA11_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA11_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA11_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA11_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG12: UDPHS Endpoint Configuration Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCFG12_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG12_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG12_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG12_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG12_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB12: UDPHS Endpoint Control Enable Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTLENB12_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB12_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS12: UDPHS Endpoint Control Disable Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTLDIS12_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL12: UDPHS Endpoint Control Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTL12_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL12_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA12: UDPHS Endpoint Set Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTSETSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA12: UDPHS Endpoint Clear Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCLRSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA12_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA12: UDPHS Endpoint Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA12_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA12_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA12_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA12_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA12_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA12_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA12_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA12_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG13: UDPHS Endpoint Configuration Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCFG13_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG13_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG13_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG13_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG13_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB13: UDPHS Endpoint Control Enable Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTLENB13_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB13_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS13: UDPHS Endpoint Control Disable Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTLDIS13_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL13: UDPHS Endpoint Control Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTL13_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL13_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA13: UDPHS Endpoint Set Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTSETSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA13: UDPHS Endpoint Clear Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCLRSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA13_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA13: UDPHS Endpoint Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA13_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA13_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA13_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA13_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA13_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA13_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA13_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA13_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG14: UDPHS Endpoint Configuration Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCFG14_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG14_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG14_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG14_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG14_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB14: UDPHS Endpoint Control Enable Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTLENB14_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB14_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS14: UDPHS Endpoint Control Disable Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTLDIS14_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL14: UDPHS Endpoint Control Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTL14_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL14_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA14: UDPHS Endpoint Set Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTSETSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA14: UDPHS Endpoint Clear Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCLRSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA14_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA14: UDPHS Endpoint Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA14_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA14_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA14_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA14_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA14_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA14_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA14_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA14_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG15: UDPHS Endpoint Configuration Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCFG15_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG15_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG15_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG15_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG15_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB15: UDPHS Endpoint Control Enable Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTLENB15_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB15_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS15: UDPHS Endpoint Control Disable Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTLDIS15_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL15: UDPHS Endpoint Control Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTL15_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL15_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA15: UDPHS Endpoint Set Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTSETSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA15: UDPHS Endpoint Clear Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCLRSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA15_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA15: UDPHS Endpoint Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA15_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA15_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA15_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA15_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA15_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA15_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA15_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA15_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x80000000) >> 31
}

// UDPHS.DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
func (o *UDPHS_Type) SetDMANXTDSC0(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC0.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC0() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC0.Reg)
}

// UDPHS.DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
func (o *UDPHS_Type) SetDMAADDRESS0(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS0.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS0() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS0.Reg)
}

// UDPHS.DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
func (o *UDPHS_Type) SetDMACONTROL0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL0_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL0_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL0_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL0_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL0_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL0_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL0_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL0_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL0_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL0_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS0_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS0_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS0_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS0_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS0_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS0_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
func (o *UDPHS_Type) SetDMANXTDSC1(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC1.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC1() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC1.Reg)
}

// UDPHS.DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
func (o *UDPHS_Type) SetDMAADDRESS1(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS1.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS1() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS1.Reg)
}

// UDPHS.DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
func (o *UDPHS_Type) SetDMACONTROL1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL1_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL1_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL1_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL1_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL1_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL1_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL1_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL1_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL1_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL1_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS1_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS1_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS1_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS1_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS1_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS1_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
func (o *UDPHS_Type) SetDMANXTDSC2(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC2.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC2() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC2.Reg)
}

// UDPHS.DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
func (o *UDPHS_Type) SetDMAADDRESS2(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS2.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS2() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS2.Reg)
}

// UDPHS.DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
func (o *UDPHS_Type) SetDMACONTROL2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL2_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL2_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL2_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL2_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL2_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL2_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL2_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL2_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL2_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL2_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS2_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS2_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS2_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS2_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS2_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS2_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
func (o *UDPHS_Type) SetDMANXTDSC3(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC3.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC3() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC3.Reg)
}

// UDPHS.DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
func (o *UDPHS_Type) SetDMAADDRESS3(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS3.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS3() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS3.Reg)
}

// UDPHS.DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
func (o *UDPHS_Type) SetDMACONTROL3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL3_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL3_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL3_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL3_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL3_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL3_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL3_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL3_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL3_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL3_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS3_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS3_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS3_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS3_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS3_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS3_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
func (o *UDPHS_Type) SetDMANXTDSC4(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC4.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC4() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC4.Reg)
}

// UDPHS.DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
func (o *UDPHS_Type) SetDMAADDRESS4(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS4.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS4() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS4.Reg)
}

// UDPHS.DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
func (o *UDPHS_Type) SetDMACONTROL4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL4_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL4_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL4_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL4_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL4_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL4_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL4_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL4_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL4_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL4_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS4_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS4_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS4_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS4_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS4_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS4_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
func (o *UDPHS_Type) SetDMANXTDSC5(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC5.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC5() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC5.Reg)
}

// UDPHS.DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
func (o *UDPHS_Type) SetDMAADDRESS5(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS5.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS5() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS5.Reg)
}

// UDPHS.DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
func (o *UDPHS_Type) SetDMACONTROL5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL5_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL5_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL5_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL5_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL5_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL5_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL5_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL5_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL5_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL5_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS5_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS5_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS5_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS5_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS5_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS5_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC6: UDPHS DMA Next Descriptor Address Register (channel = 6)
func (o *UDPHS_Type) SetDMANXTDSC6(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC6.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC6() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC6.Reg)
}

// UDPHS.DMAADDRESS6: UDPHS DMA Channel Address Register (channel = 6)
func (o *UDPHS_Type) SetDMAADDRESS6(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS6.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS6() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS6.Reg)
}

// UDPHS.DMACONTROL6: UDPHS DMA Channel Control Register (channel = 6)
func (o *UDPHS_Type) SetDMACONTROL6_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL6_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL6_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL6_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL6_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL6_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL6_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL6_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL6_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL6_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL6_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL6_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL6_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL6_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS6: UDPHS DMA Channel Status Register (channel = 6)
func (o *UDPHS_Type) SetDMASTATUS6_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS6_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS6_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS6_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS6_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS6_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS6_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS6_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS6_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS6_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS6_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS6_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0xffff0000) >> 16
}

// True Random Number Generator
type TRNG_Type struct {
	CR    volatile.Register32 // 0x0
	_     [12]byte
	IER   volatile.Register32 // 0x10
	IDR   volatile.Register32 // 0x14
	IMR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	_     [48]byte
	ODATA volatile.Register32 // 0x50
}

// TRNG.CR: Control Register
func (o *TRNG_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TRNG_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TRNG_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffffff00) >> 8
}

// TRNG.IER: Interrupt Enable Register
func (o *TRNG_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// TRNG.IDR: Interrupt Disable Register
func (o *TRNG_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// TRNG.IMR: Interrupt Mask Register
func (o *TRNG_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// TRNG.ISR: Interrupt Status Register
func (o *TRNG_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// TRNG.ODATA: Output Data Register
func (o *TRNG_Type) SetODATA(value uint32) {
	volatile.StoreUint32(&o.ODATA.Reg, value)
}
func (o *TRNG_Type) GetODATA() uint32 {
	return volatile.LoadUint32(&o.ODATA.Reg)
}

// Fuse Controller
type FUSE_Type struct {
	CR volatile.Register32    // 0x0
	MR volatile.Register32    // 0x4
	IR volatile.Register32    // 0x8
	DR volatile.Register32    // 0xC
	SR [8]volatile.Register32 // 0x10
}

// FUSE.CR: Fuse Control Register
func (o *FUSE_Type) SetCR_WRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetCR_WRQ() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *FUSE_Type) SetCR_RRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *FUSE_Type) GetCR_RRQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *FUSE_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *FUSE_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}

// FUSE.MR: Fuse Mode Register
func (o *FUSE_Type) SetMR_MSK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetMR_MSK() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}

// FUSE.IR: Fuse Index Register
func (o *FUSE_Type) SetIR_WS(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetIR_WS() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *FUSE_Type) SetIR_RS(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *FUSE_Type) GetIR_RS() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *FUSE_Type) SetIR_WSEL(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xf00)|value<<8)
}
func (o *FUSE_Type) GetIR_WSEL() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xf00) >> 8
}

// FUSE.DR: Fuse Data Register
func (o *FUSE_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *FUSE_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// FUSE.SR: Fuse Status Register
func (o *FUSE_Type) SetSR(idx int, value uint32) {
	volatile.StoreUint32(&o.SR[idx].Reg, value)
}
func (o *FUSE_Type) GetSR(idx int) uint32 {
	return volatile.LoadUint32(&o.SR[idx].Reg)
}

// DMA Controller 0
type DMAC_Type struct {
	GCFG   volatile.Register32 // 0x0
	EN     volatile.Register32 // 0x4
	SREQ   volatile.Register32 // 0x8
	CREQ   volatile.Register32 // 0xC
	LAST   volatile.Register32 // 0x10
	_      [4]byte
	EBCIER volatile.Register32 // 0x18
	EBCIDR volatile.Register32 // 0x1C
	EBCIMR volatile.Register32 // 0x20
	EBCISR volatile.Register32 // 0x24
	CHER   volatile.Register32 // 0x28
	CHDR   volatile.Register32 // 0x2C
	CHSR   volatile.Register32 // 0x30
	_      [8]byte
	SADDR0 volatile.Register32 // 0x3C
	DADDR0 volatile.Register32 // 0x40
	DSCR0  volatile.Register32 // 0x44
	CTRLA0 volatile.Register32 // 0x48
	CTRLB0 volatile.Register32 // 0x4C
	CFG0   volatile.Register32 // 0x50
	SPIP0  volatile.Register32 // 0x54
	DPIP0  volatile.Register32 // 0x58
	_      [8]byte
	SADDR1 volatile.Register32 // 0x64
	DADDR1 volatile.Register32 // 0x68
	DSCR1  volatile.Register32 // 0x6C
	CTRLA1 volatile.Register32 // 0x70
	CTRLB1 volatile.Register32 // 0x74
	CFG1   volatile.Register32 // 0x78
	SPIP1  volatile.Register32 // 0x7C
	DPIP1  volatile.Register32 // 0x80
	_      [8]byte
	SADDR2 volatile.Register32 // 0x8C
	DADDR2 volatile.Register32 // 0x90
	DSCR2  volatile.Register32 // 0x94
	CTRLA2 volatile.Register32 // 0x98
	CTRLB2 volatile.Register32 // 0x9C
	CFG2   volatile.Register32 // 0xA0
	SPIP2  volatile.Register32 // 0xA4
	DPIP2  volatile.Register32 // 0xA8
	_      [8]byte
	SADDR3 volatile.Register32 // 0xB4
	DADDR3 volatile.Register32 // 0xB8
	DSCR3  volatile.Register32 // 0xBC
	CTRLA3 volatile.Register32 // 0xC0
	CTRLB3 volatile.Register32 // 0xC4
	CFG3   volatile.Register32 // 0xC8
	SPIP3  volatile.Register32 // 0xCC
	DPIP3  volatile.Register32 // 0xD0
	_      [8]byte
	SADDR4 volatile.Register32 // 0xDC
	DADDR4 volatile.Register32 // 0xE0
	DSCR4  volatile.Register32 // 0xE4
	CTRLA4 volatile.Register32 // 0xE8
	CTRLB4 volatile.Register32 // 0xEC
	CFG4   volatile.Register32 // 0xF0
	SPIP4  volatile.Register32 // 0xF4
	DPIP4  volatile.Register32 // 0xF8
	_      [8]byte
	SADDR5 volatile.Register32 // 0x104
	DADDR5 volatile.Register32 // 0x108
	DSCR5  volatile.Register32 // 0x10C
	CTRLA5 volatile.Register32 // 0x110
	CTRLB5 volatile.Register32 // 0x114
	CFG5   volatile.Register32 // 0x118
	SPIP5  volatile.Register32 // 0x11C
	DPIP5  volatile.Register32 // 0x120
	_      [8]byte
	SADDR6 volatile.Register32 // 0x12C
	DADDR6 volatile.Register32 // 0x130
	DSCR6  volatile.Register32 // 0x134
	CTRLA6 volatile.Register32 // 0x138
	CTRLB6 volatile.Register32 // 0x13C
	CFG6   volatile.Register32 // 0x140
	SPIP6  volatile.Register32 // 0x144
	DPIP6  volatile.Register32 // 0x148
	_      [8]byte
	SADDR7 volatile.Register32 // 0x154
	DADDR7 volatile.Register32 // 0x158
	DSCR7  volatile.Register32 // 0x15C
	CTRLA7 volatile.Register32 // 0x160
	CTRLB7 volatile.Register32 // 0x164
	CFG7   volatile.Register32 // 0x168
	SPIP7  volatile.Register32 // 0x16C
	DPIP7  volatile.Register32 // 0x170
	_      [112]byte
	WPMR   volatile.Register32 // 0x1E4
	WPSR   volatile.Register32 // 0x1E8
}

// DMAC.GCFG: DMAC Global Configuration Register
func (o *DMAC_Type) SetGCFG_ARB_CFG(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetGCFG_ARB_CFG() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetGCFG_DICEN(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetGCFG_DICEN() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x100) >> 8
}

// DMAC.EN: DMAC Enable Register
func (o *DMAC_Type) SetEN_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEN_ENABLE() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// DMAC.SREQ: DMAC Software Single Request Register
func (o *DMAC_Type) SetSREQ_SSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetSREQ_SSREQ0() uint32 {
	return volatile.LoadUint32(&o.SREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetSREQ_DSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetSREQ_DSREQ0() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetSREQ_SSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetSREQ_SSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetSREQ_DSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetSREQ_DSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetSREQ_SSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetSREQ_SSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetSREQ_DSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetSREQ_DSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetSREQ_SSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetSREQ_SSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetSREQ_DSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetSREQ_DSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetSREQ_SSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetSREQ_SSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetSREQ_DSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetSREQ_DSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetSREQ_SSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetSREQ_SSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetSREQ_DSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetSREQ_DSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetSREQ_SSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetSREQ_SSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetSREQ_DSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetSREQ_DSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetSREQ_SSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetSREQ_SSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetSREQ_DSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetSREQ_DSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8000) >> 15
}

// DMAC.CREQ: DMAC Software Chunk Transfer Request Register
func (o *DMAC_Type) SetCREQ_SCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCREQ_SCREQ0() uint32 {
	return volatile.LoadUint32(&o.CREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetCREQ_DCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCREQ_DCREQ0() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCREQ_SCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCREQ_SCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCREQ_DCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCREQ_DCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCREQ_SCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCREQ_SCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCREQ_DCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCREQ_DCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCREQ_SCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCREQ_SCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCREQ_DCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCREQ_DCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCREQ_SCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCREQ_SCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCREQ_DCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCREQ_DCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCREQ_SCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCREQ_SCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCREQ_DCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCREQ_DCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCREQ_SCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCREQ_SCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCREQ_DCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCREQ_DCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCREQ_SCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCREQ_SCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCREQ_DCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCREQ_DCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8000) >> 15
}

// DMAC.LAST: DMAC Software Last Transfer Flag Register
func (o *DMAC_Type) SetLAST_SLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetLAST_SLAST0() uint32 {
	return volatile.LoadUint32(&o.LAST.Reg) & 0x1
}
func (o *DMAC_Type) SetLAST_DLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetLAST_DLAST0() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetLAST_SLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetLAST_SLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetLAST_DLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetLAST_DLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetLAST_SLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetLAST_SLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetLAST_DLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetLAST_DLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetLAST_SLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetLAST_SLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetLAST_DLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetLAST_DLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetLAST_SLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetLAST_SLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetLAST_DLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetLAST_DLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetLAST_SLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetLAST_SLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetLAST_DLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetLAST_DLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetLAST_SLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetLAST_SLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetLAST_DLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetLAST_DLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetLAST_SLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetLAST_SLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetLAST_DLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetLAST_DLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8000) >> 15
}

// DMAC.EBCIER: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Enable register.
func (o *DMAC_Type) SetEBCIER_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIER_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIER.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIER_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIER_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIER_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIER_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIER_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIER_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIER_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIER_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIER_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIER_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIER_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIER_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIER_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIER_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIER_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIER_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIER_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIER_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIER_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIER_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIER_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIER_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIER_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIER_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIER_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIER_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIER_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIER_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIER_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIER_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIER_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIER_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIER_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIER_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIER_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIER_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIER_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIER_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIER_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIER_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIER_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIER_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIER_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIER_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIER_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIER_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIER_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIER_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIER_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIER_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIER_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIER_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIER_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIER_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIER_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIER_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIER_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIER_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIER_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIER_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIER_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIER_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80000000) >> 31
}

// DMAC.EBCIDR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Disable register.
func (o *DMAC_Type) SetEBCIDR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIDR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIDR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIDR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIDR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIDR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIDR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIDR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIDR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIDR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIDR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIDR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIDR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIDR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIDR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIDR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIDR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIDR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIDR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIDR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIDR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIDR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIDR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIDR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIDR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIDR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIDR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIDR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIDR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIDR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIDR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIDR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIDR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIDR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIDR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIDR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIDR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIDR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIDR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIDR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIDR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIDR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIDR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIDR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIDR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIDR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIDR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIDR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIDR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIDR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIDR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIDR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIDR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIDR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIDR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIDR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIDR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIDR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIDR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIDR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIDR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIDR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIDR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIDR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80000000) >> 31
}

// DMAC.EBCIMR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Mask Register.
func (o *DMAC_Type) SetEBCIMR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIMR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIMR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIMR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIMR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIMR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIMR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIMR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIMR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIMR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIMR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIMR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIMR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIMR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIMR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIMR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIMR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIMR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIMR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIMR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIMR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIMR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIMR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIMR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIMR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIMR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIMR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIMR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIMR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIMR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIMR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIMR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIMR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIMR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIMR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIMR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIMR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIMR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIMR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIMR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIMR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIMR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIMR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIMR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIMR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIMR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIMR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIMR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIMR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIMR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIMR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIMR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIMR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIMR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIMR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIMR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIMR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIMR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIMR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIMR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIMR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIMR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIMR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIMR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80000000) >> 31
}

// DMAC.EBCISR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Status Register.
func (o *DMAC_Type) SetEBCISR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCISR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCISR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCISR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCISR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCISR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCISR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCISR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCISR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCISR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCISR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCISR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCISR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCISR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCISR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCISR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCISR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCISR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCISR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCISR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCISR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCISR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCISR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCISR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCISR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCISR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCISR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCISR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCISR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCISR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCISR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCISR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCISR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCISR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCISR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCISR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCISR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCISR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCISR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCISR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCISR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCISR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCISR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCISR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCISR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCISR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCISR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCISR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCISR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCISR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCISR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCISR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCISR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCISR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCISR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCISR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCISR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCISR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCISR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCISR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCISR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCISR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCISR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCISR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCISR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80000000) >> 31
}

// DMAC.CHER: DMAC Channel Handler Enable Register
func (o *DMAC_Type) SetCHER_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHER_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *DMAC_Type) SetCHER_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHER_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHER_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHER_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHER_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHER_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHER_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHER_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHER_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHER_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHER_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHER_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHER_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHER_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHER_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHER_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHER_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHER_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHER_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHER_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHER_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHER_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHER_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHER_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHER_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHER_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHER_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHER_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHER_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHER_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHER_KEEP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHER_KEEP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHER_KEEP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHER_KEEP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHER_KEEP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHER_KEEP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHER_KEEP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHER_KEEP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHER_KEEP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHER_KEEP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHER_KEEP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHER_KEEP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHER_KEEP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHER_KEEP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHER_KEEP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHER_KEEP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80000000) >> 31
}

// DMAC.CHDR: DMAC Channel Handler Disable Register
func (o *DMAC_Type) SetCHDR_DIS0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHDR_DIS0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHDR_DIS1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHDR_DIS1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHDR_DIS2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHDR_DIS2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHDR_DIS3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHDR_DIS3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHDR_DIS4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHDR_DIS4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHDR_DIS5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHDR_DIS5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHDR_DIS6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHDR_DIS6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHDR_DIS7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHDR_DIS7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHDR_RES0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHDR_RES0() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHDR_RES1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHDR_RES1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHDR_RES2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHDR_RES2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHDR_RES3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHDR_RES3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHDR_RES4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHDR_RES4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHDR_RES5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHDR_RES5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHDR_RES6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHDR_RES6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHDR_RES7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHDR_RES7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8000) >> 15
}

// DMAC.CHSR: DMAC Channel Handler Status Register
func (o *DMAC_Type) SetCHSR_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHSR_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHSR_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHSR_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHSR_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHSR_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHSR_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHSR_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHSR_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHSR_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHSR_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHSR_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHSR_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHSR_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHSR_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHSR_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHSR_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHSR_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHSR_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHSR_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHSR_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHSR_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHSR_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHSR_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHSR_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHSR_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHSR_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHSR_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHSR_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHSR_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHSR_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHSR_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHSR_EMPT0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCHSR_EMPT0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCHSR_EMPT1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetCHSR_EMPT1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetCHSR_EMPT2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetCHSR_EMPT2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetCHSR_EMPT3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetCHSR_EMPT3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetCHSR_EMPT4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCHSR_EMPT4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCHSR_EMPT5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCHSR_EMPT5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCHSR_EMPT6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCHSR_EMPT6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCHSR_EMPT7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetCHSR_EMPT7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetCHSR_STAL0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHSR_STAL0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHSR_STAL1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHSR_STAL1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHSR_STAL2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHSR_STAL2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHSR_STAL3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHSR_STAL3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHSR_STAL4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHSR_STAL4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHSR_STAL5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHSR_STAL5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHSR_STAL6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHSR_STAL6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHSR_STAL7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHSR_STAL7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000000) >> 31
}

// DMAC.SADDR0: DMAC Channel Source Address Register (ch_num = 0)
func (o *DMAC_Type) SetSADDR0(value uint32) {
	volatile.StoreUint32(&o.SADDR0.Reg, value)
}
func (o *DMAC_Type) GetSADDR0() uint32 {
	return volatile.LoadUint32(&o.SADDR0.Reg)
}

// DMAC.DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
func (o *DMAC_Type) SetDADDR0(value uint32) {
	volatile.StoreUint32(&o.DADDR0.Reg, value)
}
func (o *DMAC_Type) GetDADDR0() uint32 {
	return volatile.LoadUint32(&o.DADDR0.Reg)
}

// DMAC.DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
func (o *DMAC_Type) SetDSCR0_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR0_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR0.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR0_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR0_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR0.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA0: DMAC Channel Control A Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLA0_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA0_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA0.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA0_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA0_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA0_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA0_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA0_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA0_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA0_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA0_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA0_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA0_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB0: DMAC Channel Control B Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLB0_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB0_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB0_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB0_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB0_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB0_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB0_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB0_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB0_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB0_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB0_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB0_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB0_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB0_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB0_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB0_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB0_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB0_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB0_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB0_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB0_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB0_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x80000000) >> 31
}

// DMAC.CFG0: DMAC Channel Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetCFG0_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG0_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG0.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG0_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG0_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG0_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG0_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG0_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG0_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG0_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG0_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG0_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG0_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG0_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG0_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG0_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG0_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG0_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG0_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG0_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG0_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG0_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG0_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG0_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG0_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG0_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG0_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP0: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetSPIP0_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP0.Reg, volatile.LoadUint32(&o.SPIP0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP0_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP0.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP0_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP0.Reg, volatile.LoadUint32(&o.SPIP0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP0_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP0.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP0: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetDPIP0_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP0.Reg, volatile.LoadUint32(&o.DPIP0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP0_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP0.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP0_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP0.Reg, volatile.LoadUint32(&o.DPIP0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP0_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP0.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR1: DMAC Channel Source Address Register (ch_num = 1)
func (o *DMAC_Type) SetSADDR1(value uint32) {
	volatile.StoreUint32(&o.SADDR1.Reg, value)
}
func (o *DMAC_Type) GetSADDR1() uint32 {
	return volatile.LoadUint32(&o.SADDR1.Reg)
}

// DMAC.DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
func (o *DMAC_Type) SetDADDR1(value uint32) {
	volatile.StoreUint32(&o.DADDR1.Reg, value)
}
func (o *DMAC_Type) GetDADDR1() uint32 {
	return volatile.LoadUint32(&o.DADDR1.Reg)
}

// DMAC.DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
func (o *DMAC_Type) SetDSCR1_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR1_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR1.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR1_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR1_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR1.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA1: DMAC Channel Control A Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLA1_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA1_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA1.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA1_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA1_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA1_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA1_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA1_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA1_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA1_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA1_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA1_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA1_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB1: DMAC Channel Control B Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLB1_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB1_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB1_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB1_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB1_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB1_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB1_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB1_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB1_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB1_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB1_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB1_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB1_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB1_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB1_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB1_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB1_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB1_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB1_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB1_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB1_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB1_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x80000000) >> 31
}

// DMAC.CFG1: DMAC Channel Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetCFG1_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG1_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG1_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG1_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG1_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG1_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG1_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG1_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG1_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG1_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG1_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG1_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG1_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG1_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG1_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG1_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG1_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG1_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG1_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG1_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG1_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG1_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG1_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG1_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG1_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP1: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetSPIP1_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP1.Reg, volatile.LoadUint32(&o.SPIP1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP1_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP1.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP1_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP1.Reg, volatile.LoadUint32(&o.SPIP1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP1_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP1.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP1: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetDPIP1_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP1.Reg, volatile.LoadUint32(&o.DPIP1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP1_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP1.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP1_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP1.Reg, volatile.LoadUint32(&o.DPIP1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP1_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP1.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR2: DMAC Channel Source Address Register (ch_num = 2)
func (o *DMAC_Type) SetSADDR2(value uint32) {
	volatile.StoreUint32(&o.SADDR2.Reg, value)
}
func (o *DMAC_Type) GetSADDR2() uint32 {
	return volatile.LoadUint32(&o.SADDR2.Reg)
}

// DMAC.DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
func (o *DMAC_Type) SetDADDR2(value uint32) {
	volatile.StoreUint32(&o.DADDR2.Reg, value)
}
func (o *DMAC_Type) GetDADDR2() uint32 {
	return volatile.LoadUint32(&o.DADDR2.Reg)
}

// DMAC.DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
func (o *DMAC_Type) SetDSCR2_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR2_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR2.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR2_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR2_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR2.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA2: DMAC Channel Control A Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLA2_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA2_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA2.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA2_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA2_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA2_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA2_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA2_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA2_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA2_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA2_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA2_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA2_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB2: DMAC Channel Control B Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLB2_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB2_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB2_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB2_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB2_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB2_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB2_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB2_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB2_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB2_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB2_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB2_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB2_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB2_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB2_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB2_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB2_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB2_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB2_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB2_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB2_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB2_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x80000000) >> 31
}

// DMAC.CFG2: DMAC Channel Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetCFG2_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG2_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG2_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG2_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG2_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG2_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG2_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG2_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG2_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG2_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG2_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG2_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG2_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG2_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG2_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG2_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG2_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG2_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG2_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG2_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG2_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG2_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG2_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG2_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG2_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG2_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP2: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetSPIP2_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP2.Reg, volatile.LoadUint32(&o.SPIP2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP2_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP2.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP2_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP2.Reg, volatile.LoadUint32(&o.SPIP2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP2_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP2.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP2: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetDPIP2_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP2.Reg, volatile.LoadUint32(&o.DPIP2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP2_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP2.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP2_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP2.Reg, volatile.LoadUint32(&o.DPIP2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP2_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP2.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR3: DMAC Channel Source Address Register (ch_num = 3)
func (o *DMAC_Type) SetSADDR3(value uint32) {
	volatile.StoreUint32(&o.SADDR3.Reg, value)
}
func (o *DMAC_Type) GetSADDR3() uint32 {
	return volatile.LoadUint32(&o.SADDR3.Reg)
}

// DMAC.DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
func (o *DMAC_Type) SetDADDR3(value uint32) {
	volatile.StoreUint32(&o.DADDR3.Reg, value)
}
func (o *DMAC_Type) GetDADDR3() uint32 {
	return volatile.LoadUint32(&o.DADDR3.Reg)
}

// DMAC.DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
func (o *DMAC_Type) SetDSCR3_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR3_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR3.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR3_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR3_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR3.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA3: DMAC Channel Control A Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLA3_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA3_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA3.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA3_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA3_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA3_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA3_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA3_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA3_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA3_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA3_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA3_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA3_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB3: DMAC Channel Control B Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLB3_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB3_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB3_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB3_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB3_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB3_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB3_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB3_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB3_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB3_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB3_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB3_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB3_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB3_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB3_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB3_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB3_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB3_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB3_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB3_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB3_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB3_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x80000000) >> 31
}

// DMAC.CFG3: DMAC Channel Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetCFG3_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG3_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG3.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG3_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG3_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG3_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG3_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG3_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG3_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG3_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG3_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG3_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG3_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG3_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG3_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG3_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG3_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG3_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG3_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG3_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG3_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG3_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG3_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG3_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG3_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG3_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG3_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP3: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetSPIP3_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP3.Reg, volatile.LoadUint32(&o.SPIP3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP3_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP3.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP3_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP3.Reg, volatile.LoadUint32(&o.SPIP3.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP3_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP3.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP3: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetDPIP3_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP3.Reg, volatile.LoadUint32(&o.DPIP3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP3_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP3.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP3_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP3.Reg, volatile.LoadUint32(&o.DPIP3.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP3_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP3.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR4: DMAC Channel Source Address Register (ch_num = 4)
func (o *DMAC_Type) SetSADDR4(value uint32) {
	volatile.StoreUint32(&o.SADDR4.Reg, value)
}
func (o *DMAC_Type) GetSADDR4() uint32 {
	return volatile.LoadUint32(&o.SADDR4.Reg)
}

// DMAC.DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
func (o *DMAC_Type) SetDADDR4(value uint32) {
	volatile.StoreUint32(&o.DADDR4.Reg, value)
}
func (o *DMAC_Type) GetDADDR4() uint32 {
	return volatile.LoadUint32(&o.DADDR4.Reg)
}

// DMAC.DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
func (o *DMAC_Type) SetDSCR4_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR4_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR4.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR4_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR4_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR4.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA4: DMAC Channel Control A Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLA4_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA4_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA4.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA4_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA4_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA4_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA4_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA4_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA4_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA4_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA4_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA4_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA4_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB4: DMAC Channel Control B Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLB4_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB4_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB4_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB4_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB4_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB4_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB4_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB4_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB4_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB4_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB4_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB4_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB4_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB4_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB4_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB4_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB4_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB4_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB4_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB4_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB4_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB4_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x80000000) >> 31
}

// DMAC.CFG4: DMAC Channel Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetCFG4_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG4_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG4.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG4_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG4_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG4_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG4_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG4_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG4_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG4_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG4_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG4_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG4_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG4_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG4_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG4_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG4_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG4_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG4_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG4_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG4_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG4_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG4_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG4_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG4_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG4_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG4_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP4: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetSPIP4_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP4.Reg, volatile.LoadUint32(&o.SPIP4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP4_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP4.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP4_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP4.Reg, volatile.LoadUint32(&o.SPIP4.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP4_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP4.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP4: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetDPIP4_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP4.Reg, volatile.LoadUint32(&o.DPIP4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP4_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP4.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP4_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP4.Reg, volatile.LoadUint32(&o.DPIP4.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP4_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP4.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR5: DMAC Channel Source Address Register (ch_num = 5)
func (o *DMAC_Type) SetSADDR5(value uint32) {
	volatile.StoreUint32(&o.SADDR5.Reg, value)
}
func (o *DMAC_Type) GetSADDR5() uint32 {
	return volatile.LoadUint32(&o.SADDR5.Reg)
}

// DMAC.DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
func (o *DMAC_Type) SetDADDR5(value uint32) {
	volatile.StoreUint32(&o.DADDR5.Reg, value)
}
func (o *DMAC_Type) GetDADDR5() uint32 {
	return volatile.LoadUint32(&o.DADDR5.Reg)
}

// DMAC.DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
func (o *DMAC_Type) SetDSCR5_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR5_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR5.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR5_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR5_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR5.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA5: DMAC Channel Control A Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLA5_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA5_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA5.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA5_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA5_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA5_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA5_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA5_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA5_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA5_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA5_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA5_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA5_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB5: DMAC Channel Control B Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLB5_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB5_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB5_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB5_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB5_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB5_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB5_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB5_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB5_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB5_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB5_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB5_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB5_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB5_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB5_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB5_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB5_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB5_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB5_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB5_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB5_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB5_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x80000000) >> 31
}

// DMAC.CFG5: DMAC Channel Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetCFG5_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG5_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG5.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG5_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG5_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG5_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG5_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG5_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG5_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG5_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG5_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG5_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG5_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG5_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG5_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG5_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG5_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG5_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG5_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG5_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG5_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG5_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG5_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG5_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG5_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG5_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG5_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP5: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetSPIP5_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP5.Reg, volatile.LoadUint32(&o.SPIP5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP5_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP5.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP5_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP5.Reg, volatile.LoadUint32(&o.SPIP5.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP5_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP5.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP5: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetDPIP5_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP5.Reg, volatile.LoadUint32(&o.DPIP5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP5_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP5.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP5_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP5.Reg, volatile.LoadUint32(&o.DPIP5.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP5_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP5.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR6: DMAC Channel Source Address Register (ch_num = 6)
func (o *DMAC_Type) SetSADDR6(value uint32) {
	volatile.StoreUint32(&o.SADDR6.Reg, value)
}
func (o *DMAC_Type) GetSADDR6() uint32 {
	return volatile.LoadUint32(&o.SADDR6.Reg)
}

// DMAC.DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
func (o *DMAC_Type) SetDADDR6(value uint32) {
	volatile.StoreUint32(&o.DADDR6.Reg, value)
}
func (o *DMAC_Type) GetDADDR6() uint32 {
	return volatile.LoadUint32(&o.DADDR6.Reg)
}

// DMAC.DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
func (o *DMAC_Type) SetDSCR6_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR6_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR6.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR6_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR6_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR6.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA6: DMAC Channel Control A Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLA6_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA6_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA6.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA6_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA6_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA6_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA6_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA6_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA6_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA6_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA6_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA6_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA6_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB6: DMAC Channel Control B Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLB6_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB6_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB6_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB6_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB6_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB6_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB6_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB6_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB6_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB6_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB6_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB6_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB6_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB6_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB6_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB6_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB6_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB6_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB6_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB6_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB6_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB6_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x80000000) >> 31
}

// DMAC.CFG6: DMAC Channel Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetCFG6_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG6_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG6.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG6_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG6_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG6_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG6_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG6_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG6_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG6_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG6_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG6_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG6_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG6_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG6_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG6_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG6_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG6_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG6_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG6_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG6_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG6_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG6_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG6_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG6_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG6_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG6_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP6: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetSPIP6_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP6.Reg, volatile.LoadUint32(&o.SPIP6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP6_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP6.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP6_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP6.Reg, volatile.LoadUint32(&o.SPIP6.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP6_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP6.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP6: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetDPIP6_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP6.Reg, volatile.LoadUint32(&o.DPIP6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP6_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP6.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP6_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP6.Reg, volatile.LoadUint32(&o.DPIP6.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP6_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP6.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR7: DMAC Channel Source Address Register (ch_num = 7)
func (o *DMAC_Type) SetSADDR7(value uint32) {
	volatile.StoreUint32(&o.SADDR7.Reg, value)
}
func (o *DMAC_Type) GetSADDR7() uint32 {
	return volatile.LoadUint32(&o.SADDR7.Reg)
}

// DMAC.DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
func (o *DMAC_Type) SetDADDR7(value uint32) {
	volatile.StoreUint32(&o.DADDR7.Reg, value)
}
func (o *DMAC_Type) GetDADDR7() uint32 {
	return volatile.LoadUint32(&o.DADDR7.Reg)
}

// DMAC.DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
func (o *DMAC_Type) SetDSCR7_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR7_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR7.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR7_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR7_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR7.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA7: DMAC Channel Control A Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLA7_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA7_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA7.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA7_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA7_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA7_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA7_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA7_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA7_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA7_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA7_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA7_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA7_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB7: DMAC Channel Control B Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLB7_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB7_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB7_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB7_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB7_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB7_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB7_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB7_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB7_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB7_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB7_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB7_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB7_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB7_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB7_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB7_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB7_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB7_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB7_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB7_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB7_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB7_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x80000000) >> 31
}

// DMAC.CFG7: DMAC Channel Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetCFG7_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG7_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG7.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG7_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG7_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG7_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG7_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG7_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG7_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG7_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG7_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG7_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG7_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG7_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG7_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG7_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG7_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG7_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG7_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG7_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG7_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG7_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG7_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG7_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG7_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG7_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG7_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP7: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetSPIP7_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP7.Reg, volatile.LoadUint32(&o.SPIP7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP7_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP7.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP7_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP7.Reg, volatile.LoadUint32(&o.SPIP7.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP7_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP7.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP7: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetDPIP7_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP7.Reg, volatile.LoadUint32(&o.DPIP7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP7_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP7.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP7_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP7.Reg, volatile.LoadUint32(&o.DPIP7.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP7_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP7.Reg) & 0x3ff0000) >> 16
}

// DMAC.WPMR: DMAC Write Protect Mode Register
func (o *DMAC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DMAC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// DMAC.WPSR: DMAC Write Protect Status Register
func (o *DMAC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *DMAC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Multi-port DDR-SDRAM Controller
type EBI_Type struct {
	MR             volatile.Register32 // 0x0
	RTR            volatile.Register32 // 0x4
	CR             volatile.Register32 // 0x8
	TPR0           volatile.Register32 // 0xC
	TPR1           volatile.Register32 // 0x10
	TPR2           volatile.Register32 // 0x14
	_              [4]byte
	LPR            volatile.Register32 // 0x1C
	MD             volatile.Register32 // 0x20
	HS             volatile.Register32 // 0x24
	LPDDR2_LPR     volatile.Register32 // 0x28
	LPDDR2_CAL_MR4 volatile.Register32 // 0x2C
	LPDDR2_TIM_CAL volatile.Register32 // 0x30
	IO_CALIBR      volatile.Register32 // 0x34
	_              [12]byte
	SAW            [4]volatile.Register32 // 0x44
	_              [32]byte
	DLL_MO         volatile.Register32    // 0x74
	DLL_SOF        volatile.Register32    // 0x78
	DLL_MS         volatile.Register32    // 0x7C
	DLL_SS         [4]volatile.Register32 // 0x80
	_              [84]byte
	WPCR           volatile.Register32 // 0xE4
	WPSR           volatile.Register32 // 0xE8
}

// EBI.MR: MPDDRC Mode Register
func (o *EBI_Type) SetMR_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMR_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x7
}
func (o *EBI_Type) SetMR_MRS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetMR_MRS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}

// EBI.RTR: MPDDRC Refresh Timer Register
func (o *EBI_Type) SetRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0xfff)|value)
}
func (o *EBI_Type) GetRTR_COUNT() uint32 {
	return volatile.LoadUint32(&o.RTR.Reg) & 0xfff
}
func (o *EBI_Type) SetRTR_ADJ_REF(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetRTR_ADJ_REF() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetRTR_REF_PB(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x20000)|value<<17)
}
func (o *EBI_Type) GetRTR_REF_PB() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x20000) >> 17
}
func (o *EBI_Type) SetRTR_MR4_VALUE(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x700000)|value<<20)
}
func (o *EBI_Type) GetRTR_MR4_VALUE() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x700000) >> 20
}

// EBI.CR: MPDDRC Configuration Register
func (o *EBI_Type) SetCR_NC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetCR_NC() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *EBI_Type) SetCR_NR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc)|value<<2)
}
func (o *EBI_Type) GetCR_NR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc) >> 2
}
func (o *EBI_Type) SetCR_CAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetCR_CAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetCR_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *EBI_Type) GetCR_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *EBI_Type) SetCR_DIC_DS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *EBI_Type) GetCR_DIC_DS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *EBI_Type) SetCR_DIS_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *EBI_Type) GetCR_DIS_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *EBI_Type) SetCR_ZQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *EBI_Type) GetCR_ZQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *EBI_Type) SetCR_OCD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetCR_OCD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000) >> 12
}
func (o *EBI_Type) SetCR_DQMS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetCR_DQMS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetCR_ENRDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *EBI_Type) GetCR_ENRDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *EBI_Type) SetCR_NB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *EBI_Type) GetCR_NB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *EBI_Type) SetCR_NDQS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *EBI_Type) GetCR_NDQS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *EBI_Type) SetCR_DECOD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *EBI_Type) GetCR_DECOD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *EBI_Type) SetCR_UNAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *EBI_Type) GetCR_UNAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}

// EBI.TPR0: MPDDRC Timing Parameter 0 Register
func (o *EBI_Type) SetTPR0_TRAS(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR0_TRAS() uint32 {
	return volatile.LoadUint32(&o.TPR0.Reg) & 0xf
}
func (o *EBI_Type) SetTPR0_TRCD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR0_TRCD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR0_TWR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR0_TWR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR0_TRC(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf000)|value<<12)
}
func (o *EBI_Type) GetTPR0_TRC() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf000) >> 12
}
func (o *EBI_Type) SetTPR0_TRP(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetTPR0_TRP() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetTPR0_TRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetTPR0_TRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00000) >> 20
}
func (o *EBI_Type) SetTPR0_TWTR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EBI_Type) GetTPR0_TWTR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x7000000) >> 24
}
func (o *EBI_Type) SetTPR0_RDC_WRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EBI_Type) GetTPR0_RDC_WRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x8000000) >> 27
}
func (o *EBI_Type) SetTPR0_TMRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *EBI_Type) GetTPR0_TMRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000000) >> 28
}

// EBI.TPR1: MPDDRC Timing Parameter 1 Register
func (o *EBI_Type) SetTPR1_TRFC(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0x7f)|value)
}
func (o *EBI_Type) GetTPR1_TRFC() uint32 {
	return volatile.LoadUint32(&o.TPR1.Reg) & 0x7f
}
func (o *EBI_Type) SetTPR1_TXSNR(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetTPR1_TXSNR() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff00) >> 8
}
func (o *EBI_Type) SetTPR1_TXSRD(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *EBI_Type) GetTPR1_TXSRD() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff0000) >> 16
}
func (o *EBI_Type) SetTPR1_TXP(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetTPR1_TXP() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xf000000) >> 24
}

// EBI.TPR2: MPDDRC Timing Parameter 2 Register
func (o *EBI_Type) SetTPR2_TXARD(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR2_TXARD() uint32 {
	return volatile.LoadUint32(&o.TPR2.Reg) & 0xf
}
func (o *EBI_Type) SetTPR2_TXARDS(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR2_TXARDS() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR2_TRPA(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR2_TRPA() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR2_TRTP(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetTPR2_TRTP() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0x7000) >> 12
}
func (o *EBI_Type) SetTPR2_TFAW(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetTPR2_TFAW() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0000) >> 16
}

// EBI.LPR: MPDDRC Low-power Register
func (o *EBI_Type) SetLPR_LPCB(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetLPR_LPCB() uint32 {
	return volatile.LoadUint32(&o.LPR.Reg) & 0x3
}
func (o *EBI_Type) SetLPR_CLK_FR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetLPR_CLK_FR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetLPR_LPDDR2_PWOFF(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x8)|value<<3)
}
func (o *EBI_Type) GetLPR_LPDDR2_PWOFF() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x8) >> 3
}
func (o *EBI_Type) SetLPR_PASR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetLPR_PASR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetLPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x700)|value<<8)
}
func (o *EBI_Type) GetLPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x700) >> 8
}
func (o *EBI_Type) SetLPR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3000)|value<<12)
}
func (o *EBI_Type) GetLPR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x3000) >> 12
}
func (o *EBI_Type) SetLPR_APDE(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetLPR_APDE() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetLPR_UPD_MR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300000)|value<<20)
}
func (o *EBI_Type) GetLPR_UPD_MR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300000) >> 20
}

// EBI.MD: MPDDRC Memory Device Register
func (o *EBI_Type) SetMD(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMD() uint32 {
	return volatile.LoadUint32(&o.MD.Reg) & 0x7
}
func (o *EBI_Type) SetMD_DBW(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x10)|value<<4)
}
func (o *EBI_Type) GetMD_DBW() uint32 {
	return (volatile.LoadUint32(&o.MD.Reg) & 0x10) >> 4
}

// EBI.HS: MPDDRC High Speed Register
func (o *EBI_Type) SetHS_DIS_ANTICIP_READ(value uint32) {
	volatile.StoreUint32(&o.HS.Reg, volatile.LoadUint32(&o.HS.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetHS_DIS_ANTICIP_READ() uint32 {
	return (volatile.LoadUint32(&o.HS.Reg) & 0x4) >> 2
}

// EBI.LPDDR2_LPR: MPDDRC LPDDR2 Low-power Register
func (o *EBI_Type) SetLPDDR2_LPR_BK_MASK_PASR(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetLPDDR2_LPR_BK_MASK_PASR() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xff
}
func (o *EBI_Type) SetLPDDR2_LPR_SEG_MASK(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xffff00)|value<<8)
}
func (o *EBI_Type) GetLPDDR2_LPR_SEG_MASK() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xffff00) >> 8
}
func (o *EBI_Type) SetLPDDR2_LPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetLPDDR2_LPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xf000000) >> 24
}

// EBI.LPDDR2_CAL_MR4: MPDDRC LPDDR2 Calibration and MR4 Register
func (o *EBI_Type) SetLPDDR2_CAL_MR4_COUNT_CAL(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_CAL_MR4.Reg, volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg)&^(0xffff)|value)
}
func (o *EBI_Type) GetLPDDR2_CAL_MR4_COUNT_CAL() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg) & 0xffff
}
func (o *EBI_Type) SetLPDDR2_CAL_MR4_MR4_READ(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_CAL_MR4.Reg, volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *EBI_Type) GetLPDDR2_CAL_MR4_MR4_READ() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg) & 0xffff0000) >> 16
}

// EBI.LPDDR2_TIM_CAL: MPDDRC LPDDR2 Timing Calibration Register
func (o *EBI_Type) SetLPDDR2_TIM_CAL_ZQCS(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_TIM_CAL.Reg, volatile.LoadUint32(&o.LPDDR2_TIM_CAL.Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetLPDDR2_TIM_CAL_ZQCS() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_TIM_CAL.Reg) & 0xff
}

// EBI.IO_CALIBR: MPDDRC IO Calibration
func (o *EBI_Type) SetIO_CALIBR_RDIV(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetIO_CALIBR_RDIV() uint32 {
	return volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0x7
}
func (o *EBI_Type) SetIO_CALIBR_TZQIO(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0x700)|value<<8)
}
func (o *EBI_Type) GetIO_CALIBR_TZQIO() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0x700) >> 8
}
func (o *EBI_Type) SetIO_CALIBR_CALCODEP(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetIO_CALIBR_CALCODEP() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetIO_CALIBR_CALCODEN(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetIO_CALIBR_CALCODEN() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0xf00000) >> 20
}

// EBI.SAW: MPDDRC Smart Adaptation Wrapper 0 Register
func (o *EBI_Type) SetSAW_FLUSH_MAX(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetSAW_FLUSH_MAX(idx int) uint32 {
	return volatile.LoadUint32(&o.SAW[idx].Reg) & 0xff
}
func (o *EBI_Type) SetSAW_INCR_THRESH(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0x3f00)|value<<8)
}
func (o *EBI_Type) GetSAW_INCR_THRESH(idx int) uint32 {
	return (volatile.LoadUint32(&o.SAW[idx].Reg) & 0x3f00) >> 8
}
func (o *EBI_Type) SetSAW_PFCH_THRESH(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0x3f0000)|value<<16)
}
func (o *EBI_Type) GetSAW_PFCH_THRESH(idx int) uint32 {
	return (volatile.LoadUint32(&o.SAW[idx].Reg) & 0x3f0000) >> 16
}

// EBI.DLL_MO: MPDDRC DLL Master Offset Register
func (o *EBI_Type) SetDLL_MO_MOFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetDLL_MO_MOFF() uint32 {
	return volatile.LoadUint32(&o.DLL_MO.Reg) & 0xf
}
func (o *EBI_Type) SetDLL_MO_CLK90OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0x1f00)|value<<8)
}
func (o *EBI_Type) GetDLL_MO_CLK90OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MO.Reg) & 0x1f00) >> 8
}
func (o *EBI_Type) SetDLL_MO_SELOFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetDLL_MO_SELOFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MO.Reg) & 0x10000) >> 16
}

// EBI.DLL_SOF: MPDDRC DLL Slave Offset Register
func (o *EBI_Type) SetDLL_SOF_S0OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f)|value)
}
func (o *EBI_Type) GetDLL_SOF_S0OFF() uint32 {
	return volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f
}
func (o *EBI_Type) SetDLL_SOF_S1OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f00)|value<<8)
}
func (o *EBI_Type) GetDLL_SOF_S1OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f00) >> 8
}
func (o *EBI_Type) SetDLL_SOF_S2OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f0000)|value<<16)
}
func (o *EBI_Type) GetDLL_SOF_S2OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f0000) >> 16
}
func (o *EBI_Type) SetDLL_SOF_S3OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f000000)|value<<24)
}
func (o *EBI_Type) GetDLL_SOF_S3OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f000000) >> 24
}

// EBI.DLL_MS: MPDDRC DLL Status Master Register
func (o *EBI_Type) SetDLL_MS_MDINC(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetDLL_MS_MDINC() uint32 {
	return volatile.LoadUint32(&o.DLL_MS.Reg) & 0x1
}
func (o *EBI_Type) SetDLL_MS_MDDEC(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x2)|value<<1)
}
func (o *EBI_Type) GetDLL_MS_MDDEC() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0x2) >> 1
}
func (o *EBI_Type) SetDLL_MS_MDOVF(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetDLL_MS_MDOVF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetDLL_MS_MDVAL(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetDLL_MS_MDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0xff00) >> 8
}

// EBI.DLL_SS: MPDDRC DLL Status Slave 0 Register
func (o *EBI_Type) SetDLL_SS_SDCOVF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetDLL_SS_SDCOVF(idx int) uint32 {
	return volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x1
}
func (o *EBI_Type) SetDLL_SS_SDCUDF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x2)|value<<1)
}
func (o *EBI_Type) GetDLL_SS_SDCUDF(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x2) >> 1
}
func (o *EBI_Type) SetDLL_SS_SDERF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetDLL_SS_SDERF(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetDLL_SS_SDVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetDLL_SS_SDVAL(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0xff00) >> 8
}
func (o *EBI_Type) SetDLL_SS_SDCVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *EBI_Type) GetDLL_SS_SDCVAL(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0xff0000) >> 16
}

// EBI.WPCR: MPDDRC Write Protect Control Register
func (o *EBI_Type) SetWPCR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPCR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x1
}
func (o *EBI_Type) SetWPCR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *EBI_Type) GetWPCR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// EBI.WPSR: MPDDRC Write Protect Status Register
func (o *EBI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *EBI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *EBI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Bus Matrix
type MATRIX_Type struct {
	MCFG   [16]volatile.Register32 // 0x0
	SCFG   [16]volatile.Register32 // 0x40
	PRAS0  volatile.Register32     // 0x80
	PRBS0  volatile.Register32     // 0x84
	PRAS1  volatile.Register32     // 0x88
	PRBS1  volatile.Register32     // 0x8C
	PRAS2  volatile.Register32     // 0x90
	PRBS2  volatile.Register32     // 0x94
	PRAS3  volatile.Register32     // 0x98
	PRBS3  volatile.Register32     // 0x9C
	PRAS4  volatile.Register32     // 0xA0
	PRBS4  volatile.Register32     // 0xA4
	PRAS5  volatile.Register32     // 0xA8
	PRBS5  volatile.Register32     // 0xAC
	PRAS6  volatile.Register32     // 0xB0
	PRBS6  volatile.Register32     // 0xB4
	PRAS7  volatile.Register32     // 0xB8
	PRBS7  volatile.Register32     // 0xBC
	PRAS8  volatile.Register32     // 0xC0
	PRBS8  volatile.Register32     // 0xC4
	PRAS9  volatile.Register32     // 0xC8
	PRBS9  volatile.Register32     // 0xCC
	PRAS10 volatile.Register32     // 0xD0
	PRBS10 volatile.Register32     // 0xD4
	PRAS11 volatile.Register32     // 0xD8
	PRBS11 volatile.Register32     // 0xDC
	PRAS12 volatile.Register32     // 0xE0
	PRBS12 volatile.Register32     // 0xE4
	PRAS13 volatile.Register32     // 0xE8
	PRBS13 volatile.Register32     // 0xEC
	PRAS14 volatile.Register32     // 0xF0
	PRBS14 volatile.Register32     // 0xF4
	PRAS15 volatile.Register32     // 0xF8
	PRBS15 volatile.Register32     // 0xFC
	MRCR   volatile.Register32     // 0x100
	_      [12]byte
	SFR    [16]volatile.Register32 // 0x110
	_      [148]byte
	WPMR   volatile.Register32 // 0x1E4
	WPSR   volatile.Register32 // 0x1E8
}

// MATRIX.MCFG: Master Configuration Register
func (o *MATRIX_Type) SetMCFG_ULBT(idx int, value uint32) {
	volatile.StoreUint32(&o.MCFG[idx].Reg, volatile.LoadUint32(&o.MCFG[idx].Reg)&^(0x7)|value)
}
func (o *MATRIX_Type) GetMCFG_ULBT(idx int) uint32 {
	return volatile.LoadUint32(&o.MCFG[idx].Reg) & 0x7
}

// MATRIX.SCFG: Slave Configuration Register
func (o *MATRIX_Type) SetSCFG_SLOT_CYCLE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x1ff)|value)
}
func (o *MATRIX_Type) GetSCFG_SLOT_CYCLE(idx int) uint32 {
	return volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x1ff
}
func (o *MATRIX_Type) SetSCFG_DEFMSTR_TYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetSCFG_DEFMSTR_TYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetSCFG_FIXED_DEFMSTR(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x3c0000)|value<<18)
}
func (o *MATRIX_Type) GetSCFG_FIXED_DEFMSTR(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x3c0000) >> 18
}

// MATRIX.PRAS0: Priority Register A for Slave 0
func (o *MATRIX_Type) SetPRAS0_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS0_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS0_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS0_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS0_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS0_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS0_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS0_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS0_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS0_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS0_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS0_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS0_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS0_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS0_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS0_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS0: Priority Register B for Slave 0
func (o *MATRIX_Type) SetPRBS0_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS0_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS0_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS0_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS0_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS0_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS0_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS0_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS0_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS0_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS0_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS0_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS0_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS0_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS0_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS0_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS1: Priority Register A for Slave 1
func (o *MATRIX_Type) SetPRAS1_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS1_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS1_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS1_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS1_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS1_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS1_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS1_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS1_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS1_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS1_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS1_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS1_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS1_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS1_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS1_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS1: Priority Register B for Slave 1
func (o *MATRIX_Type) SetPRBS1_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS1_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS1_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS1_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS1_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS1_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS1_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS1_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS1_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS1_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS1_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS1_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS1_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS1_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS1_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS1_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS2: Priority Register A for Slave 2
func (o *MATRIX_Type) SetPRAS2_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS2_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS2_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS2_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS2_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS2_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS2_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS2_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS2_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS2_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS2_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS2_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS2_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS2_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS2_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS2_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS2: Priority Register B for Slave 2
func (o *MATRIX_Type) SetPRBS2_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS2_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS2_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS2_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS2_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS2_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS2_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS2_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS2_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS2_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS2_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS2_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS2_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS2_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS2_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS2_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS3: Priority Register A for Slave 3
func (o *MATRIX_Type) SetPRAS3_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS3_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS3_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS3_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS3_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS3_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS3_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS3_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS3_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS3_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS3_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS3_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS3_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS3_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS3_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS3_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS3: Priority Register B for Slave 3
func (o *MATRIX_Type) SetPRBS3_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS3_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS3_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS3_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS3_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS3_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS3_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS3_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS3_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS3_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS3_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS3_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS3_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS3_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS3_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS3_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS4: Priority Register A for Slave 4
func (o *MATRIX_Type) SetPRAS4_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS4_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS4_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS4_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS4_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS4_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS4_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS4_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS4_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS4_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS4_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS4_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS4_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS4_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS4_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS4_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS4: Priority Register B for Slave 4
func (o *MATRIX_Type) SetPRBS4_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS4_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS4_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS4_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS4_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS4_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS4_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS4_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS4_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS4_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS4_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS4_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS4_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS4_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS4_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS4_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS5: Priority Register A for Slave 5
func (o *MATRIX_Type) SetPRAS5_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS5_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS5_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS5_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS5_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS5_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS5_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS5_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS5_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS5_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS5_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS5_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS5_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS5_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS5_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS5_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS5: Priority Register B for Slave 5
func (o *MATRIX_Type) SetPRBS5_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS5_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS5_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS5_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS5_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS5_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS5_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS5_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS5_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS5_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS5_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS5_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS5_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS5_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS5_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS5_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS6: Priority Register A for Slave 6
func (o *MATRIX_Type) SetPRAS6_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS6_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS6_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS6_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS6_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS6_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS6_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS6_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS6_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS6_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS6_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS6_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS6_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS6_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS6_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS6_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS6: Priority Register B for Slave 6
func (o *MATRIX_Type) SetPRBS6_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS6_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS6_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS6_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS6_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS6_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS6_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS6_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS6_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS6_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS6_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS6_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS6_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS6_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS6_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS6_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS7: Priority Register A for Slave 7
func (o *MATRIX_Type) SetPRAS7_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS7_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS7_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS7_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS7_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS7_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS7_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS7_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS7_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS7_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS7_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS7_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS7_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS7_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS7_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS7_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS7: Priority Register B for Slave 7
func (o *MATRIX_Type) SetPRBS7_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS7_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS7_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS7_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS7_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS7_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS7_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS7_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS7_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS7_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS7_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS7_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS7_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS7_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS7_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS7_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS8: Priority Register A for Slave 8
func (o *MATRIX_Type) SetPRAS8_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS8_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS8.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS8_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS8_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS8_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS8_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS8_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS8_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS8_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS8_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS8_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS8_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS8_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS8_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS8_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS8_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS8: Priority Register B for Slave 8
func (o *MATRIX_Type) SetPRBS8_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS8_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS8.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS8_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS8_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS8_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS8_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS8_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS8_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS8_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS8_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS8_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS8_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS8_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS8_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS8_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS8_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS9: Priority Register A for Slave 9
func (o *MATRIX_Type) SetPRAS9_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS9_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS9.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS9_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS9_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS9_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS9_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS9_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS9_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS9_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS9_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS9_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS9_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS9_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS9_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS9_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS9_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS9: Priority Register B for Slave 9
func (o *MATRIX_Type) SetPRBS9_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS9_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS9.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS9_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS9_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS9_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS9_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS9_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS9_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS9_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS9_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS9_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS9_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS9_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS9_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS9_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS9_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS10: Priority Register A for Slave 10
func (o *MATRIX_Type) SetPRAS10_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS10_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS10.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS10_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS10_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS10_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS10_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS10_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS10_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS10_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS10_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS10_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS10_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS10_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS10_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS10_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS10_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS10: Priority Register B for Slave 10
func (o *MATRIX_Type) SetPRBS10_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS10_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS10.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS10_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS10_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS10_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS10_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS10_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS10_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS10_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS10_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS10_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS10_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS10_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS10_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS10_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS10_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS11: Priority Register A for Slave 11
func (o *MATRIX_Type) SetPRAS11_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS11_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS11.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS11_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS11_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS11_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS11_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS11_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS11_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS11_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS11_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS11_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS11_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS11_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS11_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS11_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS11_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS11: Priority Register B for Slave 11
func (o *MATRIX_Type) SetPRBS11_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS11_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS11.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS11_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS11_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS11_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS11_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS11_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS11_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS11_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS11_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS11_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS11_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS11_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS11_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS11_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS11_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS12: Priority Register A for Slave 12
func (o *MATRIX_Type) SetPRAS12_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS12_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS12.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS12_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS12_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS12_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS12_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS12_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS12_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS12_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS12_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS12_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS12_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS12_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS12_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS12_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS12_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS12: Priority Register B for Slave 12
func (o *MATRIX_Type) SetPRBS12_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS12_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS12.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS12_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS12_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS12_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS12_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS12_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS12_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS12_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS12_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS12_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS12_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS12_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS12_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS12_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS12_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS13: Priority Register A for Slave 13
func (o *MATRIX_Type) SetPRAS13_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS13_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS13.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS13_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS13_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS13_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS13_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS13_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS13_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS13_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS13_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS13_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS13_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS13_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS13_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS13_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS13_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS13: Priority Register B for Slave 13
func (o *MATRIX_Type) SetPRBS13_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS13_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS13.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS13_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS13_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS13_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS13_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS13_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS13_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS13_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS13_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS13_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS13_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS13_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS13_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS13_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS13_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS14: Priority Register A for Slave 14
func (o *MATRIX_Type) SetPRAS14_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS14_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS14.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS14_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS14_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS14_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS14_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS14_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS14_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS14_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS14_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS14_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS14_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS14_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS14_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS14_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS14_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS14: Priority Register B for Slave 14
func (o *MATRIX_Type) SetPRBS14_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS14_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS14.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS14_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS14_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS14_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS14_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS14_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS14_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS14_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS14_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS14_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS14_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS14_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS14_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS14_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS14_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS15: Priority Register A for Slave 15
func (o *MATRIX_Type) SetPRAS15_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS15_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS15.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS15_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS15_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS15_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS15_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS15_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS15_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS15_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS15_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS15_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS15_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS15_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS15_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS15_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS15_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS15: Priority Register B for Slave 15
func (o *MATRIX_Type) SetPRBS15_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS15_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS15.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS15_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS15_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS15_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS15_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS15_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS15_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS15_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS15_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS15_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS15_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS15_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS15_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS15_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS15_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30000000) >> 28
}

// MATRIX.MRCR: Master Remap Control Register
func (o *MATRIX_Type) SetMRCR_RCB0(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetMRCR_RCB0() uint32 {
	return volatile.LoadUint32(&o.MRCR.Reg) & 0x1
}
func (o *MATRIX_Type) SetMRCR_RCB1(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2)|value<<1)
}
func (o *MATRIX_Type) GetMRCR_RCB1() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2) >> 1
}
func (o *MATRIX_Type) SetMRCR_RCB2(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4)|value<<2)
}
func (o *MATRIX_Type) GetMRCR_RCB2() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4) >> 2
}
func (o *MATRIX_Type) SetMRCR_RCB3(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8)|value<<3)
}
func (o *MATRIX_Type) GetMRCR_RCB3() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8) >> 3
}
func (o *MATRIX_Type) SetMRCR_RCB4(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetMRCR_RCB4() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x10) >> 4
}
func (o *MATRIX_Type) SetMRCR_RCB5(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x20)|value<<5)
}
func (o *MATRIX_Type) GetMRCR_RCB5() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x20) >> 5
}
func (o *MATRIX_Type) SetMRCR_RCB6(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x40)|value<<6)
}
func (o *MATRIX_Type) GetMRCR_RCB6() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x40) >> 6
}
func (o *MATRIX_Type) SetMRCR_RCB7(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x80)|value<<7)
}
func (o *MATRIX_Type) GetMRCR_RCB7() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x80) >> 7
}
func (o *MATRIX_Type) SetMRCR_RCB8(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x100)|value<<8)
}
func (o *MATRIX_Type) GetMRCR_RCB8() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x100) >> 8
}
func (o *MATRIX_Type) SetMRCR_RCB9(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x200)|value<<9)
}
func (o *MATRIX_Type) GetMRCR_RCB9() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x200) >> 9
}
func (o *MATRIX_Type) SetMRCR_RCB10(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x400)|value<<10)
}
func (o *MATRIX_Type) GetMRCR_RCB10() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x400) >> 10
}
func (o *MATRIX_Type) SetMRCR_RCB11(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x800)|value<<11)
}
func (o *MATRIX_Type) GetMRCR_RCB11() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x800) >> 11
}
func (o *MATRIX_Type) SetMRCR_RCB12(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1000)|value<<12)
}
func (o *MATRIX_Type) GetMRCR_RCB12() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x1000) >> 12
}
func (o *MATRIX_Type) SetMRCR_RCB13(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2000)|value<<13)
}
func (o *MATRIX_Type) GetMRCR_RCB13() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2000) >> 13
}
func (o *MATRIX_Type) SetMRCR_RCB14(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4000)|value<<14)
}
func (o *MATRIX_Type) GetMRCR_RCB14() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4000) >> 14
}
func (o *MATRIX_Type) SetMRCR_RCB15(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8000)|value<<15)
}
func (o *MATRIX_Type) GetMRCR_RCB15() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8000) >> 15
}

// MATRIX.SFR: Special Function Register
func (o *MATRIX_Type) SetSFR(idx int, value uint32) {
	volatile.StoreUint32(&o.SFR[idx].Reg, value)
}
func (o *MATRIX_Type) GetSFR(idx int) uint32 {
	return volatile.LoadUint32(&o.SFR[idx].Reg)
}

// MATRIX.WPMR: Write Protect Mode Register
func (o *MATRIX_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// MATRIX.WPSR: Write Protect Status Register
func (o *MATRIX_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Debug Unit
type DBGU_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	_    [28]byte
	CIDR volatile.Register32 // 0x40
	EXID volatile.Register32 // 0x44
	FNR  volatile.Register32 // 0x48
}

// DBGU.CR: Control Register
func (o *DBGU_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGU_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGU_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DBGU_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// DBGU.MR: Mode Register
func (o *DBGU_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *DBGU_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *DBGU_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *DBGU_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// DBGU.IER: Interrupt Enable Register
func (o *DBGU_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *DBGU_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIER_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIER_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIER_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIER_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// DBGU.IDR: Interrupt Disable Register
func (o *DBGU_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *DBGU_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIDR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIDR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIDR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIDR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// DBGU.IMR: Interrupt Mask Register
func (o *DBGU_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *DBGU_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIMR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIMR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIMR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIMR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// DBGU.SR: Status Register
func (o *DBGU_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *DBGU_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetSR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetSR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetSR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetSR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DBGU.RHR: Receive Holding Register
func (o *DBGU_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// DBGU.THR: Transmit Holding Register
func (o *DBGU_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// DBGU.BRGR: Baud Rate Generator Register
func (o *DBGU_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// DBGU.CIDR: Chip ID Register
func (o *DBGU_Type) SetCIDR_VERSION(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x1f)|value)
}
func (o *DBGU_Type) GetCIDR_VERSION() uint32 {
	return volatile.LoadUint32(&o.CIDR.Reg) & 0x1f
}
func (o *DBGU_Type) SetCIDR_EPROC(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xe0)|value<<5)
}
func (o *DBGU_Type) GetCIDR_EPROC() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xe0) >> 5
}
func (o *DBGU_Type) SetCIDR_NVPSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf00)|value<<8)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf00) >> 8
}
func (o *DBGU_Type) SetCIDR_NVPSIZ2(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf000)|value<<12)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ2() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf000) >> 12
}
func (o *DBGU_Type) SetCIDR_SRAMSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf0000)|value<<16)
}
func (o *DBGU_Type) GetCIDR_SRAMSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf0000) >> 16
}
func (o *DBGU_Type) SetCIDR_ARCH(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xff00000)|value<<20)
}
func (o *DBGU_Type) GetCIDR_ARCH() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xff00000) >> 20
}
func (o *DBGU_Type) SetCIDR_NVPTYP(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x70000000)|value<<28)
}
func (o *DBGU_Type) GetCIDR_NVPTYP() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x70000000) >> 28
}
func (o *DBGU_Type) SetCIDR_EXT(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetCIDR_EXT() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x80000000) >> 31
}

// DBGU.EXID: Chip ID Extension Register
func (o *DBGU_Type) SetEXID(value uint32) {
	volatile.StoreUint32(&o.EXID.Reg, value)
}
func (o *DBGU_Type) GetEXID() uint32 {
	return volatile.LoadUint32(&o.EXID.Reg)
}

// DBGU.FNR: Force NTRST Register
func (o *DBGU_Type) SetFNR_FNTRST(value uint32) {
	volatile.StoreUint32(&o.FNR.Reg, volatile.LoadUint32(&o.FNR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetFNR_FNTRST() uint32 {
	return volatile.LoadUint32(&o.FNR.Reg) & 0x1
}

// Advanced Interrupt Controller
type AIC_Type struct {
	SSR   volatile.Register32 // 0x0
	SMR   volatile.Register32 // 0x4
	SVR   volatile.Register32 // 0x8
	_     [4]byte
	IVR   volatile.Register32 // 0x10
	FVR   volatile.Register32 // 0x14
	ISR   volatile.Register32 // 0x18
	_     [4]byte
	IPR0  volatile.Register32 // 0x20
	IPR1  volatile.Register32 // 0x24
	IPR2  volatile.Register32 // 0x28
	IPR3  volatile.Register32 // 0x2C
	IMR   volatile.Register32 // 0x30
	CISR  volatile.Register32 // 0x34
	EOICR volatile.Register32 // 0x38
	SPU   volatile.Register32 // 0x3C
	IECR  volatile.Register32 // 0x40
	IDCR  volatile.Register32 // 0x44
	ICCR  volatile.Register32 // 0x48
	ISCR  volatile.Register32 // 0x4C
	FFER  volatile.Register32 // 0x50
	FFDR  volatile.Register32 // 0x54
	FFSR  volatile.Register32 // 0x58
	_     [16]byte
	DCR   volatile.Register32 // 0x6C
	_     [116]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// AIC.SSR: Source Select Register
func (o *AIC_Type) SetSSR_INTSEL(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x7f)|value)
}
func (o *AIC_Type) GetSSR_INTSEL() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0x7f
}

// AIC.SMR: Source Mode Register
func (o *AIC_Type) SetSMR_PRIOR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7)|value)
}
func (o *AIC_Type) GetSMR_PRIOR() uint32 {
	return volatile.LoadUint32(&o.SMR.Reg) & 0x7
}
func (o *AIC_Type) SetSMR_SRCTYPE(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x60)|value<<5)
}
func (o *AIC_Type) GetSMR_SRCTYPE() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x60) >> 5
}

// AIC.SVR: Source Vector Register
func (o *AIC_Type) SetSVR(value uint32) {
	volatile.StoreUint32(&o.SVR.Reg, value)
}
func (o *AIC_Type) GetSVR() uint32 {
	return volatile.LoadUint32(&o.SVR.Reg)
}

// AIC.IVR: Interrupt Vector Register
func (o *AIC_Type) SetIVR(value uint32) {
	volatile.StoreUint32(&o.IVR.Reg, value)
}
func (o *AIC_Type) GetIVR() uint32 {
	return volatile.LoadUint32(&o.IVR.Reg)
}

// AIC.FVR: FIQ Interrupt Vector Register
func (o *AIC_Type) SetFVR(value uint32) {
	volatile.StoreUint32(&o.FVR.Reg, value)
}
func (o *AIC_Type) GetFVR() uint32 {
	return volatile.LoadUint32(&o.FVR.Reg)
}

// AIC.ISR: Interrupt Status Register
func (o *AIC_Type) SetISR_IRQID(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x7f)|value)
}
func (o *AIC_Type) GetISR_IRQID() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x7f
}

// AIC.IPR0: Interrupt Pending Register 0
func (o *AIC_Type) SetIPR0_FIQ(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR0_FIQ() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0x1
}
func (o *AIC_Type) SetIPR0_SYS(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR0_SYS() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR0_PID2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR0_PID3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR0_PID4(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR0_PID5(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR0_PID6(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR0_PID7(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR0_PID8(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR0_PID9(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR0_PID10(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR0_PID11(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR0_PID12(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR0_PID13(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR0_PID14(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR0_PID15(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR0_PID16(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR0_PID17(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR0_PID18(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR0_PID19(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR0_PID20(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR0_PID21(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR0_PID22(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR0_PID23(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR0_PID24(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR0_PID25(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR0_PID26(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR0_PID27(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR0_PID28(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR0_PID29(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR0_PID30(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR0_PID31(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80000000) >> 31
}

// AIC.IPR1: Interrupt Pending Register 1
func (o *AIC_Type) SetIPR1_PID32(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR1_PID32() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0x1
}
func (o *AIC_Type) SetIPR1_PID33(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR1_PID34(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR1_PID35(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR1_PID36(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR1_PID37(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR1_PID38(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR1_PID39(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR1_PID40(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR1_PID41(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR1_PID42(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR1_PID43(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR1_PID44(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR1_PID45(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR1_PID46(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR1_PID47(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR1_PID48(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR1_PID49(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR1_PID50(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR1_PID51(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR1_PID52(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR1_PID53(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR1_PID54(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR1_PID55(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR1_PID56(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR1_PID57(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR1_PID58(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR1_PID59(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR1_PID60(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR1_PID61(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR1_PID62(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR1_PID63(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80000000) >> 31
}

// AIC.IPR2: Interrupt Pending Register 2
func (o *AIC_Type) SetIPR2_PID64(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR2_PID64() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0x1
}
func (o *AIC_Type) SetIPR2_PID65(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR2_PID65() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR2_PID66(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR2_PID66() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR2_PID67(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR2_PID67() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR2_PID68(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR2_PID68() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR2_PID69(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR2_PID69() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR2_PID70(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR2_PID70() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR2_PID71(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR2_PID71() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR2_PID72(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR2_PID72() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR2_PID73(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR2_PID73() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR2_PID74(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR2_PID74() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR2_PID75(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR2_PID75() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR2_PID76(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR2_PID76() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR2_PID77(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR2_PID77() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR2_PID78(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR2_PID78() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR2_PID79(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR2_PID79() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR2_PID80(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR2_PID80() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR2_PID81(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR2_PID81() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR2_PID82(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR2_PID82() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR2_PID83(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR2_PID83() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR2_PID84(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR2_PID84() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR2_PID85(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR2_PID85() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR2_PID86(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR2_PID86() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR2_PID87(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR2_PID87() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR2_PID88(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR2_PID88() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR2_PID89(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR2_PID89() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR2_PID90(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR2_PID90() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR2_PID91(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR2_PID91() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR2_PID92(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR2_PID92() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR2_PID93(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR2_PID93() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR2_PID94(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR2_PID94() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR2_PID95(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR2_PID95() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80000000) >> 31
}

// AIC.IPR3: Interrupt Pending Register 3
func (o *AIC_Type) SetIPR3_PID96(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR3_PID96() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0x1
}
func (o *AIC_Type) SetIPR3_PID97(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR3_PID97() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR3_PID98(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR3_PID98() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR3_PID99(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR3_PID99() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR3_PID100(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR3_PID100() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR3_PID101(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR3_PID101() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR3_PID102(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR3_PID102() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR3_PID103(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR3_PID103() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR3_PID104(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR3_PID104() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR3_PID105(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR3_PID105() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR3_PID106(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR3_PID106() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR3_PID107(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR3_PID107() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR3_PID108(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR3_PID108() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR3_PID109(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR3_PID109() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR3_PID110(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR3_PID110() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR3_PID111(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR3_PID111() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR3_PID112(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR3_PID112() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR3_PID113(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR3_PID113() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR3_PID114(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR3_PID114() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR3_PID115(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR3_PID115() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR3_PID116(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR3_PID116() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR3_PID117(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR3_PID117() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR3_PID118(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR3_PID118() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR3_PID119(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR3_PID119() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR3_PID120(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR3_PID120() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR3_PID121(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR3_PID121() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR3_PID122(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR3_PID122() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR3_PID123(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR3_PID123() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR3_PID124(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR3_PID124() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR3_PID125(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR3_PID125() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR3_PID126(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR3_PID126() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR3_PID127(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR3_PID127() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80000000) >> 31
}

// AIC.IMR: Interrupt Mask Register
func (o *AIC_Type) SetIMR_INTM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIMR_INTM() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// AIC.CISR: Core Interrupt Status Register
func (o *AIC_Type) SetCISR_NFIQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetCISR_NFIQ() uint32 {
	return volatile.LoadUint32(&o.CISR.Reg) & 0x1
}
func (o *AIC_Type) SetCISR_NIRQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetCISR_NIRQ() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x2) >> 1
}

// AIC.EOICR: End of Interrupt Command Register
func (o *AIC_Type) SetEOICR_ENDIT(value uint32) {
	volatile.StoreUint32(&o.EOICR.Reg, volatile.LoadUint32(&o.EOICR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetEOICR_ENDIT() uint32 {
	return volatile.LoadUint32(&o.EOICR.Reg) & 0x1
}

// AIC.SPU: Spurious Interrupt Vector Register
func (o *AIC_Type) SetSPU(value uint32) {
	volatile.StoreUint32(&o.SPU.Reg, value)
}
func (o *AIC_Type) GetSPU() uint32 {
	return volatile.LoadUint32(&o.SPU.Reg)
}

// AIC.IECR: Interrupt Enable Command Register
func (o *AIC_Type) SetIECR_INTEN(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIECR_INTEN() uint32 {
	return volatile.LoadUint32(&o.IECR.Reg) & 0x1
}

// AIC.IDCR: Interrupt Disable Command Register
func (o *AIC_Type) SetIDCR_INTD(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIDCR_INTD() uint32 {
	return volatile.LoadUint32(&o.IDCR.Reg) & 0x1
}

// AIC.ICCR: Interrupt Clear Command Register
func (o *AIC_Type) SetICCR_INTCLR(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetICCR_INTCLR() uint32 {
	return volatile.LoadUint32(&o.ICCR.Reg) & 0x1
}

// AIC.ISCR: Interrupt Set Command Register
func (o *AIC_Type) SetISCR_INTSET(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetISCR_INTSET() uint32 {
	return volatile.LoadUint32(&o.ISCR.Reg) & 0x1
}

// AIC.FFER: Fast Forcing Enable Register
func (o *AIC_Type) SetFFER_FFEN(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFER_FFEN() uint32 {
	return volatile.LoadUint32(&o.FFER.Reg) & 0x1
}

// AIC.FFDR: Fast Forcing Disable Register
func (o *AIC_Type) SetFFDR_FFDIS(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFDR_FFDIS() uint32 {
	return volatile.LoadUint32(&o.FFDR.Reg) & 0x1
}

// AIC.FFSR: Fast Forcing Status Register
func (o *AIC_Type) SetFFSR_FFS(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFSR_FFS() uint32 {
	return volatile.LoadUint32(&o.FFSR.Reg) & 0x1
}

// AIC.DCR: Debug Control Register
func (o *AIC_Type) SetDCR_PROT(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetDCR_PROT() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1
}
func (o *AIC_Type) SetDCR_GMSK(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetDCR_GMSK() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x2) >> 1
}

// AIC.WPMR: Write Protect Mode Register
func (o *AIC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *AIC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *AIC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// AIC.WPSR: Write Protect Status Register
func (o *AIC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *AIC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *AIC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Parallel Input/Output Controller A
type PIO_Type struct {
	PER     volatile.Register32 // 0x0
	PDR     volatile.Register32 // 0x4
	PSR     volatile.Register32 // 0x8
	_       [4]byte
	OER     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	OSR     volatile.Register32 // 0x18
	_       [4]byte
	IFER    volatile.Register32 // 0x20
	IFDR    volatile.Register32 // 0x24
	IFSR    volatile.Register32 // 0x28
	_       [4]byte
	SODR    volatile.Register32 // 0x30
	CODR    volatile.Register32 // 0x34
	ODSR    volatile.Register32 // 0x38
	PDSR    volatile.Register32 // 0x3C
	IER     volatile.Register32 // 0x40
	IDR     volatile.Register32 // 0x44
	IMR     volatile.Register32 // 0x48
	ISR     volatile.Register32 // 0x4C
	MDER    volatile.Register32 // 0x50
	MDDR    volatile.Register32 // 0x54
	MDSR    volatile.Register32 // 0x58
	_       [4]byte
	PUDR    volatile.Register32 // 0x60
	PUER    volatile.Register32 // 0x64
	PUSR    volatile.Register32 // 0x68
	_       [4]byte
	ABCDSR  [2]volatile.Register32 // 0x70
	_       [8]byte
	IFSCDR  volatile.Register32 // 0x80
	IFSCER  volatile.Register32 // 0x84
	IFSCSR  volatile.Register32 // 0x88
	SCDR    volatile.Register32 // 0x8C
	PPDDR   volatile.Register32 // 0x90
	PPDER   volatile.Register32 // 0x94
	PPDSR   volatile.Register32 // 0x98
	_       [4]byte
	OWER    volatile.Register32 // 0xA0
	OWDR    volatile.Register32 // 0xA4
	OWSR    volatile.Register32 // 0xA8
	_       [4]byte
	AIMER   volatile.Register32 // 0xB0
	AIMDR   volatile.Register32 // 0xB4
	AIMMR   volatile.Register32 // 0xB8
	_       [4]byte
	ESR     volatile.Register32 // 0xC0
	LSR     volatile.Register32 // 0xC4
	ELSR    volatile.Register32 // 0xC8
	_       [4]byte
	FELLSR  volatile.Register32 // 0xD0
	REHLSR  volatile.Register32 // 0xD4
	FRLHSR  volatile.Register32 // 0xD8
	_       [4]byte
	LOCKSR  volatile.Register32 // 0xE0
	WPMR    volatile.Register32 // 0xE4
	WPSR    volatile.Register32 // 0xE8
	_       [20]byte
	SCHMITT volatile.Register32 // 0x100
	_       [20]byte
	DRIVER1 volatile.Register32 // 0x118
	DRIVER2 volatile.Register32 // 0x11C
}

// PIO.PER: PIO Enable Register
func (o *PIO_Type) SetPER_P0(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPER_P0() uint32 {
	return volatile.LoadUint32(&o.PER.Reg) & 0x1
}
func (o *PIO_Type) SetPER_P1(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPER_P1() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPER_P2(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPER_P2() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPER_P3(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPER_P3() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPER_P4(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPER_P4() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPER_P5(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPER_P5() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPER_P6(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPER_P6() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPER_P7(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPER_P7() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPER_P8(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPER_P8() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPER_P9(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPER_P9() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPER_P10(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPER_P10() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPER_P11(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPER_P11() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPER_P12(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPER_P12() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPER_P13(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPER_P13() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPER_P14(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPER_P14() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPER_P15(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPER_P15() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPER_P16(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPER_P16() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPER_P17(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPER_P17() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPER_P18(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPER_P18() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPER_P19(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPER_P19() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPER_P20(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPER_P20() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPER_P21(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPER_P21() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPER_P22(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPER_P22() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPER_P23(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPER_P23() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPER_P24(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPER_P24() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPER_P25(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPER_P25() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPER_P26(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPER_P26() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPER_P27(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPER_P27() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPER_P28(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPER_P28() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPER_P29(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPER_P29() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPER_P30(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPER_P30() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPER_P31(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPER_P31() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000000) >> 31
}

// PIO.PDR: PIO Disable Register
func (o *PIO_Type) SetPDR_P0(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDR_P0() uint32 {
	return volatile.LoadUint32(&o.PDR.Reg) & 0x1
}
func (o *PIO_Type) SetPDR_P1(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDR_P2(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDR_P3(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDR_P4(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDR_P5(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDR_P6(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDR_P7(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDR_P8(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDR_P9(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDR_P10(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDR_P11(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDR_P12(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDR_P13(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDR_P14(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDR_P15(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDR_P16(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDR_P17(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDR_P18(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDR_P19(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDR_P20(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDR_P21(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDR_P22(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDR_P23(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDR_P24(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDR_P25(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDR_P26(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDR_P27(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDR_P28(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDR_P29(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDR_P30(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDR_P31(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000000) >> 31
}

// PIO.PSR: PIO Status Register
func (o *PIO_Type) SetPSR_P0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPSR_P0() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}
func (o *PIO_Type) SetPSR_P1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPSR_P2(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPSR_P3(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPSR_P4(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPSR_P5(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPSR_P6(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPSR_P7(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPSR_P8(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPSR_P9(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPSR_P10(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPSR_P11(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPSR_P12(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPSR_P13(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPSR_P14(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPSR_P15(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPSR_P16(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPSR_P17(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPSR_P18(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPSR_P19(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPSR_P20(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPSR_P21(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPSR_P22(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPSR_P23(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPSR_P24(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPSR_P25(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPSR_P26(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPSR_P27(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPSR_P28(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPSR_P29(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPSR_P30(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPSR_P31(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000000) >> 31
}

// PIO.OER: Output Enable Register
func (o *PIO_Type) SetOER_P0(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOER_P0() uint32 {
	return volatile.LoadUint32(&o.OER.Reg) & 0x1
}
func (o *PIO_Type) SetOER_P1(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOER_P1() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOER_P2(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOER_P2() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOER_P3(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOER_P3() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOER_P4(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOER_P4() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOER_P5(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOER_P5() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOER_P6(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOER_P6() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOER_P7(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOER_P7() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOER_P8(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOER_P8() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOER_P9(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOER_P9() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOER_P10(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOER_P10() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOER_P11(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOER_P11() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOER_P12(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOER_P12() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOER_P13(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOER_P13() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOER_P14(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOER_P14() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOER_P15(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOER_P15() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOER_P16(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOER_P16() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOER_P17(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOER_P17() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOER_P18(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOER_P18() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOER_P19(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOER_P19() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOER_P20(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOER_P20() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOER_P21(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOER_P21() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOER_P22(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOER_P22() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOER_P23(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOER_P23() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOER_P24(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOER_P24() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOER_P25(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOER_P25() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOER_P26(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOER_P26() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOER_P27(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOER_P27() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOER_P28(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOER_P28() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOER_P29(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOER_P29() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOER_P30(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOER_P30() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOER_P31(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOER_P31() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000000) >> 31
}

// PIO.ODR: Output Disable Register
func (o *PIO_Type) SetODR_P0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODR_P0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}
func (o *PIO_Type) SetODR_P1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODR_P2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODR_P3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODR_P4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODR_P5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODR_P6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODR_P7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODR_P8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODR_P9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODR_P10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODR_P11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODR_P12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODR_P13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODR_P14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODR_P15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODR_P16(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODR_P17(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODR_P18(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODR_P19(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODR_P20(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODR_P21(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODR_P22(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODR_P23(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODR_P24(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODR_P25(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODR_P26(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODR_P27(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODR_P28(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODR_P29(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODR_P30(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODR_P31(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000000) >> 31
}

// PIO.OSR: Output Status Register
func (o *PIO_Type) SetOSR_P0(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOSR_P0() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *PIO_Type) SetOSR_P1(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOSR_P2(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOSR_P3(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOSR_P4(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOSR_P5(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOSR_P6(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOSR_P7(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOSR_P8(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOSR_P9(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOSR_P10(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOSR_P11(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOSR_P12(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOSR_P13(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOSR_P14(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOSR_P15(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOSR_P16(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOSR_P17(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOSR_P18(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOSR_P19(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOSR_P20(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOSR_P21(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOSR_P22(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOSR_P23(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOSR_P24(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOSR_P25(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOSR_P26(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOSR_P27(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOSR_P28(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOSR_P29(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOSR_P30(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOSR_P31(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000000) >> 31
}

// PIO.IFER: Glitch Input Filter Enable Register
func (o *PIO_Type) SetIFER_P0(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFER_P0() uint32 {
	return volatile.LoadUint32(&o.IFER.Reg) & 0x1
}
func (o *PIO_Type) SetIFER_P1(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFER_P2(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFER_P3(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFER_P4(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFER_P5(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFER_P6(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFER_P7(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFER_P8(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFER_P9(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFER_P10(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFER_P11(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFER_P12(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFER_P13(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFER_P14(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFER_P15(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFER_P16(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFER_P17(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFER_P18(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFER_P19(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFER_P20(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFER_P21(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFER_P22(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFER_P23(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFER_P24(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFER_P25(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFER_P26(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFER_P27(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFER_P28(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFER_P29(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFER_P30(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFER_P31(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000000) >> 31
}

// PIO.IFDR: Glitch Input Filter Disable Register
func (o *PIO_Type) SetIFDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSR: Glitch Input Filter Status Register
func (o *PIO_Type) SetIFSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000000) >> 31
}

// PIO.SODR: Set Output Data Register
func (o *PIO_Type) SetSODR_P0(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSODR_P0() uint32 {
	return volatile.LoadUint32(&o.SODR.Reg) & 0x1
}
func (o *PIO_Type) SetSODR_P1(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSODR_P1() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSODR_P2(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSODR_P2() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSODR_P3(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSODR_P3() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSODR_P4(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSODR_P4() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSODR_P5(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSODR_P5() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSODR_P6(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSODR_P6() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSODR_P7(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSODR_P7() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSODR_P8(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSODR_P8() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSODR_P9(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSODR_P9() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSODR_P10(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSODR_P10() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSODR_P11(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSODR_P11() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSODR_P12(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSODR_P12() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSODR_P13(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSODR_P13() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSODR_P14(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSODR_P14() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSODR_P15(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSODR_P15() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSODR_P16(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSODR_P16() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSODR_P17(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSODR_P17() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSODR_P18(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSODR_P18() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSODR_P19(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSODR_P19() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSODR_P20(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSODR_P20() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSODR_P21(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSODR_P21() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSODR_P22(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSODR_P22() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSODR_P23(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSODR_P23() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSODR_P24(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSODR_P24() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSODR_P25(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSODR_P25() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSODR_P26(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSODR_P26() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSODR_P27(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSODR_P27() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSODR_P28(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSODR_P28() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSODR_P29(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSODR_P29() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSODR_P30(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSODR_P30() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSODR_P31(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSODR_P31() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000000) >> 31
}

// PIO.CODR: Clear Output Data Register
func (o *PIO_Type) SetCODR_P0(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetCODR_P0() uint32 {
	return volatile.LoadUint32(&o.CODR.Reg) & 0x1
}
func (o *PIO_Type) SetCODR_P1(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetCODR_P1() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetCODR_P2(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetCODR_P2() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetCODR_P3(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetCODR_P3() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetCODR_P4(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetCODR_P4() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetCODR_P5(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetCODR_P5() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetCODR_P6(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetCODR_P6() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetCODR_P7(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetCODR_P7() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetCODR_P8(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetCODR_P8() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetCODR_P9(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetCODR_P9() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetCODR_P10(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetCODR_P10() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetCODR_P11(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetCODR_P11() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetCODR_P12(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetCODR_P12() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetCODR_P13(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetCODR_P13() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetCODR_P14(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetCODR_P14() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetCODR_P15(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetCODR_P15() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetCODR_P16(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetCODR_P16() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetCODR_P17(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetCODR_P17() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetCODR_P18(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetCODR_P18() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetCODR_P19(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetCODR_P19() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetCODR_P20(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetCODR_P20() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetCODR_P21(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetCODR_P21() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetCODR_P22(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetCODR_P22() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetCODR_P23(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetCODR_P23() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetCODR_P24(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetCODR_P24() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetCODR_P25(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetCODR_P25() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetCODR_P26(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetCODR_P26() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetCODR_P27(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetCODR_P27() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetCODR_P28(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetCODR_P28() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetCODR_P29(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetCODR_P29() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetCODR_P30(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetCODR_P30() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetCODR_P31(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetCODR_P31() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000000) >> 31
}

// PIO.ODSR: Output Data Status Register
func (o *PIO_Type) SetODSR_P0(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODSR_P0() uint32 {
	return volatile.LoadUint32(&o.ODSR.Reg) & 0x1
}
func (o *PIO_Type) SetODSR_P1(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODSR_P2(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODSR_P3(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODSR_P4(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODSR_P5(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODSR_P6(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODSR_P7(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODSR_P8(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODSR_P9(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODSR_P10(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODSR_P11(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODSR_P12(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODSR_P13(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODSR_P14(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODSR_P15(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODSR_P16(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODSR_P17(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODSR_P18(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODSR_P19(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODSR_P20(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODSR_P21(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODSR_P22(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODSR_P23(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODSR_P24(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODSR_P25(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODSR_P26(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODSR_P27(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODSR_P28(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODSR_P29(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODSR_P30(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODSR_P31(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000000) >> 31
}

// PIO.PDSR: Pin Data Status Register
func (o *PIO_Type) SetPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000000) >> 31
}

// PIO.IER: Interrupt Enable Register
func (o *PIO_Type) SetIER_P0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIER_P0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PIO_Type) SetIER_P1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIER_P1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIER_P2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIER_P2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIER_P3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIER_P3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIER_P4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIER_P4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIER_P5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIER_P5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIER_P6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIER_P6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIER_P7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIER_P7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIER_P8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIER_P8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIER_P9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIER_P9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIER_P10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIER_P10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIER_P11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIER_P11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIER_P12(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIER_P12() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIER_P13(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIER_P13() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIER_P14(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIER_P14() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIER_P15(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIER_P15() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIER_P16(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIER_P16() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIER_P17(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIER_P17() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIER_P18(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIER_P18() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIER_P19(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIER_P19() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIER_P20(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIER_P20() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIER_P21(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIER_P21() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIER_P22(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIER_P22() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIER_P23(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIER_P23() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIER_P24(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIER_P24() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIER_P25(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIER_P25() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIER_P26(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIER_P26() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIER_P27(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIER_P27() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIER_P28(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIER_P28() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIER_P29(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIER_P29() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIER_P30(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIER_P30() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIER_P31(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIER_P31() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// PIO.IDR: Interrupt Disable Register
func (o *PIO_Type) SetIDR_P0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIDR_P0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PIO_Type) SetIDR_P1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIDR_P2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIDR_P3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIDR_P4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIDR_P5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIDR_P6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIDR_P7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIDR_P8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIDR_P9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIDR_P10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIDR_P11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIDR_P12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIDR_P13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIDR_P14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIDR_P15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIDR_P16(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIDR_P17(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIDR_P18(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIDR_P19(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIDR_P20(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIDR_P21(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIDR_P22(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIDR_P23(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIDR_P24(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIDR_P25(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIDR_P26(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIDR_P27(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIDR_P28(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIDR_P29(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIDR_P30(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIDR_P31(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// PIO.IMR: Interrupt Mask Register
func (o *PIO_Type) SetIMR_P0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIMR_P0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PIO_Type) SetIMR_P1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIMR_P1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIMR_P2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIMR_P2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIMR_P3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIMR_P3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIMR_P4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIMR_P4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIMR_P5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIMR_P5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIMR_P6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIMR_P6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIMR_P7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIMR_P7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIMR_P8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIMR_P8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIMR_P9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIMR_P9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIMR_P10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIMR_P10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIMR_P11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIMR_P11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIMR_P12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIMR_P12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIMR_P13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIMR_P13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIMR_P14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIMR_P14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIMR_P15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIMR_P15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIMR_P16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIMR_P16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIMR_P17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIMR_P17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIMR_P18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIMR_P18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIMR_P19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIMR_P19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIMR_P20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIMR_P20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIMR_P21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIMR_P21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIMR_P22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIMR_P22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIMR_P23(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIMR_P23() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIMR_P24(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIMR_P24() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIMR_P25(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIMR_P25() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIMR_P26(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIMR_P26() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIMR_P27(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIMR_P27() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIMR_P28(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIMR_P28() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIMR_P29(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIMR_P29() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIMR_P30(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIMR_P30() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIMR_P31(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIMR_P31() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// PIO.ISR: Interrupt Status Register
func (o *PIO_Type) SetISR_P0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetISR_P0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PIO_Type) SetISR_P1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetISR_P1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetISR_P2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetISR_P2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetISR_P3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetISR_P3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetISR_P4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetISR_P4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetISR_P5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetISR_P5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetISR_P6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetISR_P6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetISR_P7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetISR_P7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetISR_P8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetISR_P8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetISR_P9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetISR_P9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetISR_P10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetISR_P10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetISR_P11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetISR_P11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetISR_P12(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetISR_P12() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetISR_P13(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetISR_P13() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetISR_P14(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetISR_P14() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetISR_P15(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetISR_P15() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetISR_P16(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetISR_P16() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetISR_P17(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetISR_P17() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetISR_P18(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetISR_P18() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetISR_P19(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetISR_P19() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetISR_P20(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetISR_P20() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetISR_P21(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetISR_P21() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetISR_P22(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetISR_P22() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetISR_P23(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetISR_P23() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetISR_P24(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetISR_P24() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetISR_P25(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetISR_P25() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetISR_P26(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetISR_P26() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetISR_P27(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetISR_P27() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetISR_P28(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetISR_P28() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetISR_P29(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetISR_P29() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetISR_P30(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetISR_P30() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetISR_P31(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetISR_P31() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// PIO.MDER: Multi-driver Enable Register
func (o *PIO_Type) SetMDER_P0(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDER_P0() uint32 {
	return volatile.LoadUint32(&o.MDER.Reg) & 0x1
}
func (o *PIO_Type) SetMDER_P1(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDER_P1() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDER_P2(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDER_P2() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDER_P3(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDER_P3() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDER_P4(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDER_P4() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDER_P5(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDER_P5() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDER_P6(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDER_P6() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDER_P7(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDER_P7() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDER_P8(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDER_P8() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDER_P9(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDER_P9() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDER_P10(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDER_P10() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDER_P11(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDER_P11() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDER_P12(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDER_P12() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDER_P13(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDER_P13() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDER_P14(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDER_P14() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDER_P15(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDER_P15() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDER_P16(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDER_P16() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDER_P17(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDER_P17() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDER_P18(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDER_P18() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDER_P19(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDER_P19() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDER_P20(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDER_P20() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDER_P21(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDER_P21() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDER_P22(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDER_P22() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDER_P23(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDER_P23() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDER_P24(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDER_P24() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDER_P25(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDER_P25() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDER_P26(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDER_P26() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDER_P27(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDER_P27() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDER_P28(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDER_P28() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDER_P29(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDER_P29() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDER_P30(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDER_P30() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDER_P31(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDER_P31() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000000) >> 31
}

// PIO.MDDR: Multi-driver Disable Register
func (o *PIO_Type) SetMDDR_P0(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDDR_P0() uint32 {
	return volatile.LoadUint32(&o.MDDR.Reg) & 0x1
}
func (o *PIO_Type) SetMDDR_P1(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDDR_P2(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDDR_P3(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDDR_P4(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDDR_P5(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDDR_P6(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDDR_P7(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDDR_P8(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDDR_P9(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDDR_P10(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDDR_P11(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDDR_P12(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDDR_P13(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDDR_P14(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDDR_P15(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDDR_P16(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDDR_P17(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDDR_P18(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDDR_P19(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDDR_P20(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDDR_P21(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDDR_P22(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDDR_P23(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDDR_P24(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDDR_P25(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDDR_P26(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDDR_P27(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDDR_P28(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDDR_P29(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDDR_P30(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDDR_P31(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000000) >> 31
}

// PIO.MDSR: Multi-driver Status Register
func (o *PIO_Type) SetMDSR_P0(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDSR_P0() uint32 {
	return volatile.LoadUint32(&o.MDSR.Reg) & 0x1
}
func (o *PIO_Type) SetMDSR_P1(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDSR_P2(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDSR_P3(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDSR_P4(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDSR_P5(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDSR_P6(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDSR_P7(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDSR_P8(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDSR_P9(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDSR_P10(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDSR_P11(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDSR_P12(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDSR_P13(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDSR_P14(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDSR_P15(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDSR_P16(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDSR_P17(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDSR_P18(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDSR_P19(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDSR_P20(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDSR_P21(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDSR_P22(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDSR_P23(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDSR_P24(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDSR_P25(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDSR_P26(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDSR_P27(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDSR_P28(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDSR_P29(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDSR_P30(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDSR_P31(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000000) >> 31
}

// PIO.PUDR: Pull-up Disable Register
func (o *PIO_Type) SetPUDR_P0(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUDR_P0() uint32 {
	return volatile.LoadUint32(&o.PUDR.Reg) & 0x1
}
func (o *PIO_Type) SetPUDR_P1(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUDR_P2(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUDR_P3(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUDR_P4(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUDR_P5(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUDR_P6(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUDR_P7(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUDR_P8(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUDR_P9(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUDR_P10(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUDR_P11(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUDR_P12(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUDR_P13(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUDR_P14(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUDR_P15(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUDR_P16(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUDR_P17(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUDR_P18(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUDR_P19(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUDR_P20(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUDR_P21(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUDR_P22(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUDR_P23(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUDR_P24(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUDR_P25(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUDR_P26(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUDR_P27(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUDR_P28(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUDR_P29(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUDR_P30(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUDR_P31(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000000) >> 31
}

// PIO.PUER: Pull-up Enable Register
func (o *PIO_Type) SetPUER_P0(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUER_P0() uint32 {
	return volatile.LoadUint32(&o.PUER.Reg) & 0x1
}
func (o *PIO_Type) SetPUER_P1(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUER_P1() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUER_P2(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUER_P2() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUER_P3(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUER_P3() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUER_P4(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUER_P4() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUER_P5(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUER_P5() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUER_P6(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUER_P6() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUER_P7(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUER_P7() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUER_P8(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUER_P8() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUER_P9(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUER_P9() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUER_P10(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUER_P10() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUER_P11(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUER_P11() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUER_P12(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUER_P12() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUER_P13(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUER_P13() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUER_P14(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUER_P14() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUER_P15(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUER_P15() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUER_P16(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUER_P16() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUER_P17(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUER_P17() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUER_P18(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUER_P18() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUER_P19(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUER_P19() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUER_P20(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUER_P20() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUER_P21(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUER_P21() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUER_P22(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUER_P22() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUER_P23(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUER_P23() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUER_P24(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUER_P24() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUER_P25(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUER_P25() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUER_P26(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUER_P26() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUER_P27(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUER_P27() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUER_P28(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUER_P28() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUER_P29(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUER_P29() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUER_P30(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUER_P30() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUER_P31(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUER_P31() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000000) >> 31
}

// PIO.PUSR: Pad Pull-up Status Register
func (o *PIO_Type) SetPUSR_P0(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUSR_P0() uint32 {
	return volatile.LoadUint32(&o.PUSR.Reg) & 0x1
}
func (o *PIO_Type) SetPUSR_P1(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUSR_P2(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUSR_P3(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUSR_P4(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUSR_P5(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUSR_P6(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUSR_P7(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUSR_P8(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUSR_P9(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUSR_P10(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUSR_P11(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUSR_P12(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUSR_P13(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUSR_P14(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUSR_P15(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUSR_P16(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUSR_P17(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUSR_P18(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUSR_P19(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUSR_P20(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUSR_P21(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUSR_P22(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUSR_P23(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUSR_P24(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUSR_P25(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUSR_P26(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUSR_P27(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUSR_P28(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUSR_P29(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUSR_P30(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUSR_P31(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000000) >> 31
}

// PIO.ABCDSR: Peripheral Select Register
func (o *PIO_Type) SetABCDSR_P0(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetABCDSR_P0(idx int) uint32 {
	return volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1
}
func (o *PIO_Type) SetABCDSR_P1(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetABCDSR_P1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetABCDSR_P2(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetABCDSR_P2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetABCDSR_P3(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetABCDSR_P3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetABCDSR_P4(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetABCDSR_P4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetABCDSR_P5(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetABCDSR_P5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetABCDSR_P6(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetABCDSR_P6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetABCDSR_P7(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetABCDSR_P7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetABCDSR_P8(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetABCDSR_P8(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetABCDSR_P9(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetABCDSR_P9(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetABCDSR_P10(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetABCDSR_P10(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetABCDSR_P11(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetABCDSR_P11(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetABCDSR_P12(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetABCDSR_P12(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetABCDSR_P13(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetABCDSR_P13(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetABCDSR_P14(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetABCDSR_P14(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetABCDSR_P15(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetABCDSR_P15(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetABCDSR_P16(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetABCDSR_P16(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetABCDSR_P17(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetABCDSR_P17(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetABCDSR_P18(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetABCDSR_P18(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetABCDSR_P19(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetABCDSR_P19(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetABCDSR_P20(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetABCDSR_P20(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetABCDSR_P21(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetABCDSR_P21(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetABCDSR_P22(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetABCDSR_P22(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetABCDSR_P23(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetABCDSR_P23(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetABCDSR_P24(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetABCDSR_P24(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetABCDSR_P25(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetABCDSR_P25(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetABCDSR_P26(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetABCDSR_P26(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetABCDSR_P27(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetABCDSR_P27(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetABCDSR_P28(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetABCDSR_P28(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetABCDSR_P29(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetABCDSR_P29(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetABCDSR_P30(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetABCDSR_P30(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetABCDSR_P31(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetABCDSR_P31(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000000) >> 31
}

// PIO.IFSCDR: Input Filter Slow Clock Disable Register
func (o *PIO_Type) SetIFSCDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSCER: Input Filter Slow Clock Enable Register
func (o *PIO_Type) SetIFSCER_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCER_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCER.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCER_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCER_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCER_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCER_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCER_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCER_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCER_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCER_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCER_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCER_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCER_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCER_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCER_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCER_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCER_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCER_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCER_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCER_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCER_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCER_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCER_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCER_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCER_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCER_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCER_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCER_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCER_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCER_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCER_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCER_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCER_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000000) >> 31
}

// PIO.IFSCSR: Input Filter Slow Clock Status Register
func (o *PIO_Type) SetIFSCSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000000) >> 31
}

// PIO.SCDR: Slow Clock Divider Debouncing Register
func (o *PIO_Type) SetSCDR_DIV(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x3fff)|value)
}
func (o *PIO_Type) GetSCDR_DIV() uint32 {
	return volatile.LoadUint32(&o.SCDR.Reg) & 0x3fff
}

// PIO.PPDDR: Pad Pull-down Disable Register
func (o *PIO_Type) SetPPDDR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDDR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDDR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDDR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDDR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDDR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDDR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDDR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDDR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDDR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDDR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDDR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDDR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDDR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDDR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDDR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDDR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDDR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDDR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDDR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDDR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDDR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDDR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDDR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDDR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDDR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDDR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDDR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDDR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDDR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDDR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDDR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDDR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDDR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000000) >> 31
}

// PIO.PPDER: Pad Pull-down Enable Register
func (o *PIO_Type) SetPPDER_P0(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDER_P0() uint32 {
	return volatile.LoadUint32(&o.PPDER.Reg) & 0x1
}
func (o *PIO_Type) SetPPDER_P1(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDER_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDER_P2(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDER_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDER_P3(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDER_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDER_P4(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDER_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDER_P5(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDER_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDER_P6(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDER_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDER_P7(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDER_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDER_P8(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDER_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDER_P9(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDER_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDER_P10(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDER_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDER_P11(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDER_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDER_P12(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDER_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDER_P13(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDER_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDER_P14(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDER_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDER_P15(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDER_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDER_P16(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDER_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDER_P17(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDER_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDER_P18(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDER_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDER_P19(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDER_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDER_P20(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDER_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDER_P21(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDER_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDER_P22(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDER_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDER_P23(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDER_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDER_P24(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDER_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDER_P25(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDER_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDER_P26(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDER_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDER_P27(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDER_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDER_P28(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDER_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDER_P29(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDER_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDER_P30(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDER_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDER_P31(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDER_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000000) >> 31
}

// PIO.PPDSR: Pad Pull-down Status Register
func (o *PIO_Type) SetPPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000000) >> 31
}

// PIO.OWER: Output Write Enable
func (o *PIO_Type) SetOWER_P0(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWER_P0() uint32 {
	return volatile.LoadUint32(&o.OWER.Reg) & 0x1
}
func (o *PIO_Type) SetOWER_P1(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWER_P1() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWER_P2(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWER_P2() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWER_P3(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWER_P3() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWER_P4(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWER_P4() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWER_P5(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWER_P5() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWER_P6(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWER_P6() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWER_P7(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWER_P7() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWER_P8(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWER_P8() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWER_P9(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWER_P9() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWER_P10(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWER_P10() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWER_P11(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWER_P11() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWER_P12(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWER_P12() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWER_P13(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWER_P13() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWER_P14(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWER_P14() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWER_P15(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWER_P15() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWER_P16(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWER_P16() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWER_P17(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWER_P17() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWER_P18(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWER_P18() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWER_P19(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWER_P19() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWER_P20(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWER_P20() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWER_P21(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWER_P21() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWER_P22(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWER_P22() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWER_P23(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWER_P23() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWER_P24(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWER_P24() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWER_P25(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWER_P25() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWER_P26(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWER_P26() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWER_P27(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWER_P27() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWER_P28(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWER_P28() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWER_P29(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWER_P29() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWER_P30(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWER_P30() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWER_P31(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWER_P31() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000000) >> 31
}

// PIO.OWDR: Output Write Disable
func (o *PIO_Type) SetOWDR_P0(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWDR_P0() uint32 {
	return volatile.LoadUint32(&o.OWDR.Reg) & 0x1
}
func (o *PIO_Type) SetOWDR_P1(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWDR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWDR_P2(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWDR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWDR_P3(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWDR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWDR_P4(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWDR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWDR_P5(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWDR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWDR_P6(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWDR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWDR_P7(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWDR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWDR_P8(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWDR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWDR_P9(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWDR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWDR_P10(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWDR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWDR_P11(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWDR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWDR_P12(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWDR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWDR_P13(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWDR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWDR_P14(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWDR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWDR_P15(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWDR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWDR_P16(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWDR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWDR_P17(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWDR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWDR_P18(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWDR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWDR_P19(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWDR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWDR_P20(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWDR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWDR_P21(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWDR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWDR_P22(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWDR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWDR_P23(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWDR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWDR_P24(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWDR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWDR_P25(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWDR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWDR_P26(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWDR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWDR_P27(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWDR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWDR_P28(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWDR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWDR_P29(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWDR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWDR_P30(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWDR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWDR_P31(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWDR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000000) >> 31
}

// PIO.OWSR: Output Write Status Register
func (o *PIO_Type) SetOWSR_P0(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWSR_P0() uint32 {
	return volatile.LoadUint32(&o.OWSR.Reg) & 0x1
}
func (o *PIO_Type) SetOWSR_P1(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWSR_P2(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWSR_P3(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWSR_P4(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWSR_P5(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWSR_P6(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWSR_P7(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWSR_P8(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWSR_P9(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWSR_P10(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWSR_P11(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWSR_P12(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWSR_P13(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWSR_P14(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWSR_P15(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWSR_P16(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWSR_P17(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWSR_P18(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWSR_P19(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWSR_P20(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWSR_P21(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWSR_P22(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWSR_P23(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWSR_P24(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWSR_P25(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWSR_P26(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWSR_P27(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWSR_P28(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWSR_P29(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWSR_P30(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWSR_P31(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000000) >> 31
}

// PIO.AIMER: Additional Interrupt Modes Enable Register
func (o *PIO_Type) SetAIMER_P0(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMER_P0() uint32 {
	return volatile.LoadUint32(&o.AIMER.Reg) & 0x1
}
func (o *PIO_Type) SetAIMER_P1(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMER_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMER_P2(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMER_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMER_P3(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMER_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMER_P4(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMER_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMER_P5(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMER_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMER_P6(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMER_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMER_P7(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMER_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMER_P8(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMER_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMER_P9(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMER_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMER_P10(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMER_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMER_P11(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMER_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMER_P12(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMER_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMER_P13(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMER_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMER_P14(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMER_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMER_P15(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMER_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMER_P16(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMER_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMER_P17(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMER_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMER_P18(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMER_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMER_P19(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMER_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMER_P20(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMER_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMER_P21(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMER_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMER_P22(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMER_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMER_P23(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMER_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMER_P24(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMER_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMER_P25(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMER_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMER_P26(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMER_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMER_P27(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMER_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMER_P28(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMER_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMER_P29(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMER_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMER_P30(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMER_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMER_P31(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMER_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000000) >> 31
}

// PIO.AIMDR: Additional Interrupt Modes Disables Register
func (o *PIO_Type) SetAIMDR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMDR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMDR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMDR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMDR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMDR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMDR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMDR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMDR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMDR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMDR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMDR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMDR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMDR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMDR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMDR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMDR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMDR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMDR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMDR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMDR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMDR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMDR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMDR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMDR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMDR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMDR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMDR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMDR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMDR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMDR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMDR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMDR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMDR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMDR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMDR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMDR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMDR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMDR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMDR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMDR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMDR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMDR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMDR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMDR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMDR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMDR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMDR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMDR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMDR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMDR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMDR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMDR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMDR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMDR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMDR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMDR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMDR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMDR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMDR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMDR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMDR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMDR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMDR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMDR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000000) >> 31
}

// PIO.AIMMR: Additional Interrupt Modes Mask Register
func (o *PIO_Type) SetAIMMR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMMR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMMR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMMR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMMR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMMR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMMR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMMR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMMR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMMR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMMR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMMR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMMR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMMR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMMR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMMR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMMR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMMR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMMR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMMR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMMR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMMR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMMR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMMR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMMR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMMR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMMR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMMR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMMR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMMR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMMR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMMR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMMR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMMR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMMR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMMR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMMR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMMR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMMR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMMR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMMR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMMR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMMR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMMR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMMR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMMR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMMR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMMR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMMR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMMR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMMR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMMR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMMR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMMR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMMR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMMR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMMR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMMR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMMR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMMR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMMR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMMR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMMR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMMR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMMR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000000) >> 31
}

// PIO.ESR: Edge Select Register
func (o *PIO_Type) SetESR_P0(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetESR_P0() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x1
}
func (o *PIO_Type) SetESR_P1(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetESR_P1() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetESR_P2(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetESR_P2() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetESR_P3(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetESR_P3() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetESR_P4(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetESR_P4() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetESR_P5(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetESR_P5() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetESR_P6(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetESR_P6() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetESR_P7(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetESR_P7() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetESR_P8(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetESR_P8() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetESR_P9(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetESR_P9() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetESR_P10(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetESR_P10() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetESR_P11(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetESR_P11() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetESR_P12(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetESR_P12() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetESR_P13(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetESR_P13() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetESR_P14(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetESR_P14() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetESR_P15(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetESR_P15() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetESR_P16(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetESR_P16() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetESR_P17(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetESR_P17() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetESR_P18(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetESR_P18() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetESR_P19(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetESR_P19() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetESR_P20(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetESR_P20() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetESR_P21(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetESR_P21() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetESR_P22(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetESR_P22() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetESR_P23(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetESR_P23() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetESR_P24(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetESR_P24() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetESR_P25(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetESR_P25() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetESR_P26(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetESR_P26() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetESR_P27(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetESR_P27() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetESR_P28(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetESR_P28() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetESR_P29(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetESR_P29() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetESR_P30(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetESR_P30() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetESR_P31(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetESR_P31() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000000) >> 31
}

// PIO.LSR: Level Select Register
func (o *PIO_Type) SetLSR_P0(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLSR_P0() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *PIO_Type) SetLSR_P1(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLSR_P2(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLSR_P3(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLSR_P4(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLSR_P5(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLSR_P6(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLSR_P7(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLSR_P8(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLSR_P9(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLSR_P10(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLSR_P11(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLSR_P12(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLSR_P13(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLSR_P14(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLSR_P15(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLSR_P16(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLSR_P17(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLSR_P18(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLSR_P19(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLSR_P20(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLSR_P21(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLSR_P22(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLSR_P23(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLSR_P24(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLSR_P25(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLSR_P26(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLSR_P27(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLSR_P28(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLSR_P29(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLSR_P30(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLSR_P31(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000000) >> 31
}

// PIO.ELSR: Edge/Level Status Register
func (o *PIO_Type) SetELSR_P0(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetELSR_P0() uint32 {
	return volatile.LoadUint32(&o.ELSR.Reg) & 0x1
}
func (o *PIO_Type) SetELSR_P1(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetELSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetELSR_P2(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetELSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetELSR_P3(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetELSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetELSR_P4(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetELSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetELSR_P5(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetELSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetELSR_P6(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetELSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetELSR_P7(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetELSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetELSR_P8(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetELSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetELSR_P9(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetELSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetELSR_P10(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetELSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetELSR_P11(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetELSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetELSR_P12(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetELSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetELSR_P13(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetELSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetELSR_P14(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetELSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetELSR_P15(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetELSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetELSR_P16(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetELSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetELSR_P17(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetELSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetELSR_P18(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetELSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetELSR_P19(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetELSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetELSR_P20(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetELSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetELSR_P21(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetELSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetELSR_P22(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetELSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetELSR_P23(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetELSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetELSR_P24(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetELSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetELSR_P25(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetELSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetELSR_P26(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetELSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetELSR_P27(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetELSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetELSR_P28(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetELSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetELSR_P29(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetELSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetELSR_P30(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetELSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetELSR_P31(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetELSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000000) >> 31
}

// PIO.FELLSR: Falling Edge/Low Level Select Register
func (o *PIO_Type) SetFELLSR_P0(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFELLSR_P0() uint32 {
	return volatile.LoadUint32(&o.FELLSR.Reg) & 0x1
}
func (o *PIO_Type) SetFELLSR_P1(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFELLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFELLSR_P2(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFELLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFELLSR_P3(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFELLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFELLSR_P4(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFELLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFELLSR_P5(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFELLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFELLSR_P6(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFELLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFELLSR_P7(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFELLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFELLSR_P8(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFELLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFELLSR_P9(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFELLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFELLSR_P10(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFELLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFELLSR_P11(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFELLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFELLSR_P12(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFELLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFELLSR_P13(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFELLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFELLSR_P14(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFELLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFELLSR_P15(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFELLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFELLSR_P16(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFELLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFELLSR_P17(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFELLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFELLSR_P18(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFELLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFELLSR_P19(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFELLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFELLSR_P20(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFELLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFELLSR_P21(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFELLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFELLSR_P22(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFELLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFELLSR_P23(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFELLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFELLSR_P24(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFELLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFELLSR_P25(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFELLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFELLSR_P26(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFELLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFELLSR_P27(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFELLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFELLSR_P28(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFELLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFELLSR_P29(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFELLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFELLSR_P30(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFELLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFELLSR_P31(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFELLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000000) >> 31
}

// PIO.REHLSR: Rising Edge/ High Level Select Register
func (o *PIO_Type) SetREHLSR_P0(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetREHLSR_P0() uint32 {
	return volatile.LoadUint32(&o.REHLSR.Reg) & 0x1
}
func (o *PIO_Type) SetREHLSR_P1(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetREHLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetREHLSR_P2(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetREHLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetREHLSR_P3(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetREHLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetREHLSR_P4(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetREHLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetREHLSR_P5(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetREHLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetREHLSR_P6(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetREHLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetREHLSR_P7(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetREHLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetREHLSR_P8(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetREHLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetREHLSR_P9(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetREHLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetREHLSR_P10(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetREHLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetREHLSR_P11(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetREHLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetREHLSR_P12(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetREHLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetREHLSR_P13(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetREHLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetREHLSR_P14(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetREHLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetREHLSR_P15(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetREHLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetREHLSR_P16(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetREHLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetREHLSR_P17(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetREHLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetREHLSR_P18(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetREHLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetREHLSR_P19(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetREHLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetREHLSR_P20(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetREHLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetREHLSR_P21(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetREHLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetREHLSR_P22(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetREHLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetREHLSR_P23(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetREHLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetREHLSR_P24(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetREHLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetREHLSR_P25(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetREHLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetREHLSR_P26(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetREHLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetREHLSR_P27(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetREHLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetREHLSR_P28(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetREHLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetREHLSR_P29(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetREHLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetREHLSR_P30(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetREHLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetREHLSR_P31(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetREHLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000000) >> 31
}

// PIO.FRLHSR: Fall/Rise - Low/High Status Register
func (o *PIO_Type) SetFRLHSR_P0(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFRLHSR_P0() uint32 {
	return volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1
}
func (o *PIO_Type) SetFRLHSR_P1(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFRLHSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFRLHSR_P2(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFRLHSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFRLHSR_P3(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFRLHSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFRLHSR_P4(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFRLHSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFRLHSR_P5(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFRLHSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFRLHSR_P6(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFRLHSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFRLHSR_P7(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFRLHSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFRLHSR_P8(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFRLHSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFRLHSR_P9(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFRLHSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFRLHSR_P10(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFRLHSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFRLHSR_P11(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFRLHSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFRLHSR_P12(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFRLHSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFRLHSR_P13(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFRLHSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFRLHSR_P14(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFRLHSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFRLHSR_P15(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFRLHSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFRLHSR_P16(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFRLHSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFRLHSR_P17(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFRLHSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFRLHSR_P18(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFRLHSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFRLHSR_P19(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFRLHSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFRLHSR_P20(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFRLHSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFRLHSR_P21(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFRLHSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFRLHSR_P22(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFRLHSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFRLHSR_P23(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFRLHSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFRLHSR_P24(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFRLHSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFRLHSR_P25(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFRLHSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFRLHSR_P26(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFRLHSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFRLHSR_P27(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFRLHSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFRLHSR_P28(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFRLHSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFRLHSR_P29(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFRLHSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFRLHSR_P30(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFRLHSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFRLHSR_P31(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFRLHSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000000) >> 31
}

// PIO.LOCKSR: Lock Status
func (o *PIO_Type) SetLOCKSR_P0(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLOCKSR_P0() uint32 {
	return volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1
}
func (o *PIO_Type) SetLOCKSR_P1(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLOCKSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLOCKSR_P2(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLOCKSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLOCKSR_P3(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLOCKSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLOCKSR_P4(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLOCKSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLOCKSR_P5(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLOCKSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLOCKSR_P6(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLOCKSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLOCKSR_P7(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLOCKSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLOCKSR_P8(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLOCKSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLOCKSR_P9(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLOCKSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLOCKSR_P10(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLOCKSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLOCKSR_P11(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLOCKSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLOCKSR_P12(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLOCKSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLOCKSR_P13(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLOCKSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLOCKSR_P14(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLOCKSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLOCKSR_P15(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLOCKSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLOCKSR_P16(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLOCKSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLOCKSR_P17(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLOCKSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLOCKSR_P18(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLOCKSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLOCKSR_P19(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLOCKSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLOCKSR_P20(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLOCKSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLOCKSR_P21(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLOCKSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLOCKSR_P22(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLOCKSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLOCKSR_P23(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLOCKSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLOCKSR_P24(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLOCKSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLOCKSR_P25(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLOCKSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLOCKSR_P26(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLOCKSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLOCKSR_P27(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLOCKSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLOCKSR_P28(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLOCKSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLOCKSR_P29(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLOCKSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLOCKSR_P30(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLOCKSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLOCKSR_P31(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLOCKSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000000) >> 31
}

// PIO.WPMR: Write Protect Mode Register
func (o *PIO_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PIO_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PIO_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PIO.WPSR: Write Protect Status Register
func (o *PIO_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PIO_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PIO_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// PIO.SCHMITT: Schmitt Trigger Register
func (o *PIO_Type) SetSCHMITT_SCHMITT0(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT0() uint32 {
	return volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT1(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT1() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT2(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT2() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSCHMITT_SCHMITT3(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT3() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSCHMITT_SCHMITT4(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT4() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSCHMITT_SCHMITT5(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT5() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSCHMITT_SCHMITT6(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT6() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSCHMITT_SCHMITT7(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT7() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSCHMITT_SCHMITT8(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT8() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSCHMITT_SCHMITT9(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT9() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSCHMITT_SCHMITT10(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT10() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSCHMITT_SCHMITT11(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT11() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSCHMITT_SCHMITT12(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT12() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSCHMITT_SCHMITT13(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT13() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSCHMITT_SCHMITT14(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT14() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSCHMITT_SCHMITT15(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT15() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSCHMITT_SCHMITT16(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT16() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSCHMITT_SCHMITT17(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT17() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSCHMITT_SCHMITT18(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT18() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSCHMITT_SCHMITT19(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT19() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSCHMITT_SCHMITT20(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT20() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSCHMITT_SCHMITT21(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT21() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSCHMITT_SCHMITT22(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT22() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSCHMITT_SCHMITT23(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT23() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSCHMITT_SCHMITT24(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT24() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSCHMITT_SCHMITT25(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT25() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSCHMITT_SCHMITT26(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT26() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSCHMITT_SCHMITT27(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT27() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSCHMITT_SCHMITT28(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT28() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSCHMITT_SCHMITT29(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT29() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSCHMITT_SCHMITT30(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT30() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSCHMITT_SCHMITT31(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT31() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000000) >> 31
}

// PIO.DRIVER1: I/O Drive Register 1
func (o *PIO_Type) SetDRIVER1_LINE0(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3)|value)
}
func (o *PIO_Type) GetDRIVER1_LINE0() uint32 {
	return volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3
}
func (o *PIO_Type) SetDRIVER1_LINE1(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc)|value<<2)
}
func (o *PIO_Type) GetDRIVER1_LINE1() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc) >> 2
}
func (o *PIO_Type) SetDRIVER1_LINE2(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30)|value<<4)
}
func (o *PIO_Type) GetDRIVER1_LINE2() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30) >> 4
}
func (o *PIO_Type) SetDRIVER1_LINE3(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0)|value<<6)
}
func (o *PIO_Type) GetDRIVER1_LINE3() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0) >> 6
}
func (o *PIO_Type) SetDRIVER1_LINE4(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x300)|value<<8)
}
func (o *PIO_Type) GetDRIVER1_LINE4() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x300) >> 8
}
func (o *PIO_Type) SetDRIVER1_LINE5(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc00)|value<<10)
}
func (o *PIO_Type) GetDRIVER1_LINE5() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc00) >> 10
}
func (o *PIO_Type) SetDRIVER1_LINE6(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3000)|value<<12)
}
func (o *PIO_Type) GetDRIVER1_LINE6() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3000) >> 12
}
func (o *PIO_Type) SetDRIVER1_LINE7(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc000)|value<<14)
}
func (o *PIO_Type) GetDRIVER1_LINE7() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc000) >> 14
}
func (o *PIO_Type) SetDRIVER1_LINE8(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30000)|value<<16)
}
func (o *PIO_Type) GetDRIVER1_LINE8() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30000) >> 16
}
func (o *PIO_Type) SetDRIVER1_LINE9(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0000)|value<<18)
}
func (o *PIO_Type) GetDRIVER1_LINE9() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0000) >> 18
}
func (o *PIO_Type) SetDRIVER1_LINE10(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x300000)|value<<20)
}
func (o *PIO_Type) GetDRIVER1_LINE10() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x300000) >> 20
}
func (o *PIO_Type) SetDRIVER1_LINE11(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc00000)|value<<22)
}
func (o *PIO_Type) GetDRIVER1_LINE11() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc00000) >> 22
}
func (o *PIO_Type) SetDRIVER1_LINE12(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3000000)|value<<24)
}
func (o *PIO_Type) GetDRIVER1_LINE12() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3000000) >> 24
}
func (o *PIO_Type) SetDRIVER1_LINE13(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc000000)|value<<26)
}
func (o *PIO_Type) GetDRIVER1_LINE13() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc000000) >> 26
}
func (o *PIO_Type) SetDRIVER1_LINE14(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30000000)|value<<28)
}
func (o *PIO_Type) GetDRIVER1_LINE14() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30000000) >> 28
}
func (o *PIO_Type) SetDRIVER1_LINE15(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0000000)|value<<30)
}
func (o *PIO_Type) GetDRIVER1_LINE15() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0000000) >> 30
}

// PIO.DRIVER2: I/O Drive Register 2
func (o *PIO_Type) SetDRIVER2_LINE16(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3)|value)
}
func (o *PIO_Type) GetDRIVER2_LINE16() uint32 {
	return volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3
}
func (o *PIO_Type) SetDRIVER2_LINE17(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc)|value<<2)
}
func (o *PIO_Type) GetDRIVER2_LINE17() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc) >> 2
}
func (o *PIO_Type) SetDRIVER2_LINE18(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30)|value<<4)
}
func (o *PIO_Type) GetDRIVER2_LINE18() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30) >> 4
}
func (o *PIO_Type) SetDRIVER2_LINE19(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0)|value<<6)
}
func (o *PIO_Type) GetDRIVER2_LINE19() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0) >> 6
}
func (o *PIO_Type) SetDRIVER2_LINE20(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x300)|value<<8)
}
func (o *PIO_Type) GetDRIVER2_LINE20() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x300) >> 8
}
func (o *PIO_Type) SetDRIVER2_LINE21(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc00)|value<<10)
}
func (o *PIO_Type) GetDRIVER2_LINE21() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc00) >> 10
}
func (o *PIO_Type) SetDRIVER2_LINE22(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3000)|value<<12)
}
func (o *PIO_Type) GetDRIVER2_LINE22() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3000) >> 12
}
func (o *PIO_Type) SetDRIVER2_LINE23(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc000)|value<<14)
}
func (o *PIO_Type) GetDRIVER2_LINE23() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc000) >> 14
}
func (o *PIO_Type) SetDRIVER2_LINE24(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30000)|value<<16)
}
func (o *PIO_Type) GetDRIVER2_LINE24() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30000) >> 16
}
func (o *PIO_Type) SetDRIVER2_LINE25(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0000)|value<<18)
}
func (o *PIO_Type) GetDRIVER2_LINE25() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0000) >> 18
}
func (o *PIO_Type) SetDRIVER2_LINE26(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x300000)|value<<20)
}
func (o *PIO_Type) GetDRIVER2_LINE26() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x300000) >> 20
}
func (o *PIO_Type) SetDRIVER2_LINE27(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc00000)|value<<22)
}
func (o *PIO_Type) GetDRIVER2_LINE27() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc00000) >> 22
}
func (o *PIO_Type) SetDRIVER2_LINE28(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3000000)|value<<24)
}
func (o *PIO_Type) GetDRIVER2_LINE28() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3000000) >> 24
}
func (o *PIO_Type) SetDRIVER2_LINE29(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc000000)|value<<26)
}
func (o *PIO_Type) GetDRIVER2_LINE29() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc000000) >> 26
}
func (o *PIO_Type) SetDRIVER2_LINE30(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30000000)|value<<28)
}
func (o *PIO_Type) GetDRIVER2_LINE30() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30000000) >> 28
}
func (o *PIO_Type) SetDRIVER2_LINE31(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0000000)|value<<30)
}
func (o *PIO_Type) GetDRIVER2_LINE31() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0000000) >> 30
}

// Power Management Controller
type PMC_Type struct {
	PMC_SCER    volatile.Register32 // 0x0
	PMC_SCDR    volatile.Register32 // 0x4
	PMC_SCSR    volatile.Register32 // 0x8
	_           [4]byte
	PMC_PCER0   volatile.Register32 // 0x10
	PMC_PCDR0   volatile.Register32 // 0x14
	PMC_PCSR0   volatile.Register32 // 0x18
	CKGR_UCKR   volatile.Register32 // 0x1C
	CKGR_MOR    volatile.Register32 // 0x20
	CKGR_MCFR   volatile.Register32 // 0x24
	CKGR_PLLAR  volatile.Register32 // 0x28
	_           [4]byte
	PMC_MCKR    volatile.Register32 // 0x30
	_           [4]byte
	PMC_USB     volatile.Register32    // 0x38
	PMC_SMD     volatile.Register32    // 0x3C
	PMC_PCK     [3]volatile.Register32 // 0x40
	_           [20]byte
	PMC_IER     volatile.Register32 // 0x60
	PMC_IDR     volatile.Register32 // 0x64
	PMC_SR      volatile.Register32 // 0x68
	PMC_IMR     volatile.Register32 // 0x6C
	_           [16]byte
	PMC_PLLICPR volatile.Register32 // 0x80
	_           [96]byte
	PMC_WPMR    volatile.Register32 // 0xE4
	PMC_WPSR    volatile.Register32 // 0xE8
	_           [20]byte
	PMC_PCER1   volatile.Register32 // 0x100
	PMC_PCDR1   volatile.Register32 // 0x104
	PMC_PCSR1   volatile.Register32 // 0x108
	PMC_PCR     volatile.Register32 // 0x10C
}

// PMC.PMC_SCER: System Clock Enable Register
func (o *PMC_Type) SetPMC_SCER_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCER_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCER_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCER_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCER_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCER_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCER_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCER_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCER_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCER_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCER_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCER_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCER_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCER_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x400) >> 10
}

// PMC.PMC_SCDR: System Clock Disable Register
func (o *PMC_Type) SetPMC_SCDR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCDR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCDR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCDR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCDR_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCDR_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCDR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCDR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCDR_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCDR_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCDR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCDR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCDR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCDR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCDR_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCDR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x400) >> 10
}

// PMC.PMC_SCSR: System Clock Status Register
func (o *PMC_Type) SetPMC_SCSR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCSR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCSR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCSR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCSR_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCSR_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCSR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCSR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCSR_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCSR_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCSR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCSR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCSR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCSR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCSR_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCSR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x400) >> 10
}

// PMC.PMC_PCER0: Peripheral Clock Enable Register 0
func (o *PMC_Type) SetPMC_PCER0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCER0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCER0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCER0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCER0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCER0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCER0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCER0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCER0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCER0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCER0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCER0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCER0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCER0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCER0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCER0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCER0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCER0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCER0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCER0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCER0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCER0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCER0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCER0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCER0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCER0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCER0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCER0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCER0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCER0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCER0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCER0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCER0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCER0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCER0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCER0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCER0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCER0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCER0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCER0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCER0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCER0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCER0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCER0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCER0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCER0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCER0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCER0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCER0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCER0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCER0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCER0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCER0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCER0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCER0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCER0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCER0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCER0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCER0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCER0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCDR0: Peripheral Clock Disable Register 0
func (o *PMC_Type) SetPMC_PCDR0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCDR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCDR0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCDR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCDR0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCDR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCDR0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCDR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCDR0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCDR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCDR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCDR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCDR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCDR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCDR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCDR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCDR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCDR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCDR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCDR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCDR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCDR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCDR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCDR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCDR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCDR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCDR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCDR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCDR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCDR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCDR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCDR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCDR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCDR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCDR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCDR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCDR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCDR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCDR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCDR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCDR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCDR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCDR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCDR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCDR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCDR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCDR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCDR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCDR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCDR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCDR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCDR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCDR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCDR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCDR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCDR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCDR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCDR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCDR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCDR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCSR0: Peripheral Clock Status Register 0
func (o *PMC_Type) SetPMC_PCSR0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCSR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCSR0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCSR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCSR0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCSR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCSR0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCSR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCSR0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCSR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCSR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCSR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCSR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCSR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCSR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCSR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCSR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCSR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCSR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCSR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCSR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCSR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCSR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCSR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCSR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCSR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCSR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCSR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCSR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCSR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCSR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCSR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCSR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCSR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCSR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCSR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCSR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCSR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCSR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCSR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCSR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCSR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCSR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCSR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCSR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCSR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCSR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCSR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCSR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCSR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCSR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCSR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCSR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCSR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCSR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCSR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCSR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCSR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCSR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCSR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80000000) >> 31
}

// PMC.CKGR_UCKR: UTMI Clock Register
func (o *PMC_Type) SetCKGR_UCKR_UPLLEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetCKGR_UCKR_UPLLCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf00000)|value<<20)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf00000) >> 20
}
func (o *PMC_Type) SetCKGR_UCKR_BIASEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_UCKR_BIASCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf0000000) >> 28
}

// PMC.CKGR_MOR: Main Oscillator Register
func (o *PMC_Type) SetCKGR_MOR_MOSCXTEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTEN() uint32 {
	return volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTBY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTBY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetCKGR_MOR_MOSCRCEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCRCEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTST(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff00)|value<<8)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTST() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff00) >> 8
}
func (o *PMC_Type) SetCKGR_MOR_KEY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MOR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff0000) >> 16
}
func (o *PMC_Type) SetCKGR_MOR_MOSCSEL(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCSEL() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_MOR_CFDEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetCKGR_MOR_CFDEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2000000) >> 25
}

// PMC.CKGR_MCFR: Main Clock Frequency Register
func (o *PMC_Type) SetCKGR_MCFR_MAINF(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0xffff)|value)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINF() uint32 {
	return volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0xffff
}
func (o *PMC_Type) SetCKGR_MCFR_MAINFRDY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINFRDY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x10000) >> 16
}

// PMC.CKGR_PLLAR: PLLA Register
func (o *PMC_Type) SetCKGR_PLLAR_DIVA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xff)|value)
}
func (o *PMC_Type) GetCKGR_PLLAR_DIVA() uint32 {
	return volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xff
}
func (o *PMC_Type) SetCKGR_PLLAR_PLLACOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x3f00)|value<<8)
}
func (o *PMC_Type) GetCKGR_PLLAR_PLLACOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x3f00) >> 8
}
func (o *PMC_Type) SetCKGR_PLLAR_OUTA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xc000)|value<<14)
}
func (o *PMC_Type) GetCKGR_PLLAR_OUTA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xc000) >> 14
}
func (o *PMC_Type) SetCKGR_PLLAR_MULA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_PLLAR_MULA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x7ff0000) >> 16
}
func (o *PMC_Type) SetCKGR_PLLAR_STUCKTO1(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetCKGR_PLLAR_STUCKTO1() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x20000000) >> 29
}

// PMC.PMC_MCKR: Master Clock Register
func (o *PMC_Type) SetPMC_MCKR_CSS(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetPMC_MCKR_CSS() uint32 {
	return volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x3
}
func (o *PMC_Type) SetPMC_MCKR_PRES(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetPMC_MCKR_PRES() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x70) >> 4
}
func (o *PMC_Type) SetPMC_MCKR_MDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x300)|value<<8)
}
func (o *PMC_Type) GetPMC_MCKR_MDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x300) >> 8
}
func (o *PMC_Type) SetPMC_MCKR_PLLADIV2(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_MCKR_PLLADIV2() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x1000) >> 12
}

// PMC.PMC_USB: USB Clock Register
func (o *PMC_Type) SetPMC_USB_USBS(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_USB_USBS() uint32 {
	return volatile.LoadUint32(&o.PMC_USB.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_USB_USBDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0xf00)|value<<8)
}
func (o *PMC_Type) GetPMC_USB_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_USB.Reg) & 0xf00) >> 8
}

// PMC.PMC_SMD: Soft Modem Clock Register
func (o *PMC_Type) SetPMC_SMD_SMDS(value uint32) {
	volatile.StoreUint32(&o.PMC_SMD.Reg, volatile.LoadUint32(&o.PMC_SMD.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SMD_SMDS() uint32 {
	return volatile.LoadUint32(&o.PMC_SMD.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SMD_SMDDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_SMD.Reg, volatile.LoadUint32(&o.PMC_SMD.Reg)&^(0x1f00)|value<<8)
}
func (o *PMC_Type) GetPMC_SMD_SMDDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_SMD.Reg) & 0x1f00) >> 8
}

// PMC.PMC_PCK: Programmable Clock 0 Register
func (o *PMC_Type) SetPMC_PCK_CSS(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x7)|value)
}
func (o *PMC_Type) GetPMC_PCK_CSS(idx int) uint32 {
	return volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x7
}
func (o *PMC_Type) SetPMC_PCK_PRES(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetPMC_PCK_PRES(idx int) uint32 {
	return (volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x70) >> 4
}

// PMC.PMC_IER: Interrupt Enable Register
func (o *PMC_Type) SetPMC_IER_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IER_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IER.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IER_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IER_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IER_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IER_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IER_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IER_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IER_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IER_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IER_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IER_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IER_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IER_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IER_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IER_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x40000) >> 18
}

// PMC.PMC_IDR: Interrupt Disable Register
func (o *PMC_Type) SetPMC_IDR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IDR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IDR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IDR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IDR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IDR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IDR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IDR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IDR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IDR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IDR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IDR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IDR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IDR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x40000) >> 18
}

// PMC.PMC_SR: Status Register
func (o *PMC_Type) SetPMC_SR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_SR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_SR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_SR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_SR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_SR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SR_OSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SR_OSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_SR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_SR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_SR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_SR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_SR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_SR_CFDS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_SR_CFDS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_SR_FOS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_SR_FOS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x100000) >> 20
}

// PMC.PMC_IMR: Interrupt Mask Register
func (o *PMC_Type) SetPMC_IMR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IMR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IMR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IMR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IMR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IMR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IMR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IMR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IMR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IMR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IMR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IMR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x40000) >> 18
}

// PMC.PMC_PLLICPR: PLL Charge Pump Current Register
func (o *PMC_Type) SetPMC_PLLICPR_ICPLLA(value uint32) {
	volatile.StoreUint32(&o.PMC_PLLICPR.Reg, volatile.LoadUint32(&o.PMC_PLLICPR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PLLICPR_ICPLLA() uint32 {
	return volatile.LoadUint32(&o.PMC_PLLICPR.Reg) & 0x1
}

// PMC.PMC_WPMR: Write Protect Mode Register
func (o *PMC_Type) SetPMC_WPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.PMC_WPMR.Reg, volatile.LoadUint32(&o.PMC_WPMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_WPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.PMC_WPMR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_WPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.PMC_WPMR.Reg, volatile.LoadUint32(&o.PMC_WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMC_Type) GetPMC_WPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.PMC_WPMR.Reg) & 0xffffff00) >> 8
}

// PMC.PMC_WPSR: Write Protect Status Register
func (o *PMC_Type) SetPMC_WPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.PMC_WPSR.Reg, volatile.LoadUint32(&o.PMC_WPSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_WPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.PMC_WPSR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_WPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.PMC_WPSR.Reg, volatile.LoadUint32(&o.PMC_WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PMC_Type) GetPMC_WPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.PMC_WPSR.Reg) & 0xffff00) >> 8
}

// PMC.PMC_PCER1: Peripheral Clock Enable Register 1
func (o *PMC_Type) SetPMC_PCER1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCER1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCER1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCER1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCER1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCER1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCER1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCER1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCER1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCER1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCER1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCER1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCER1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCER1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCER1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCER1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCER1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCER1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCER1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCER1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCER1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCER1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCER1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCER1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCER1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCER1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCER1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCER1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCER1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCER1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCER1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCER1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCER1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCER1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCER1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCER1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCER1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCER1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCER1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCER1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCER1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCER1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCER1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCER1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCER1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCER1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCER1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCER1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCER1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCER1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCER1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCER1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCER1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCER1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCER1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCER1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCER1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCER1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCER1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCER1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCER1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCER1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCDR1: Peripheral Clock Disable Register 1
func (o *PMC_Type) SetPMC_PCDR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCDR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCDR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCDR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCDR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCDR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCDR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCDR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCDR1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCDR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCDR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCDR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCDR1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCDR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCDR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCDR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCDR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCDR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCDR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCDR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCDR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCDR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCDR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCDR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCDR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCDR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCDR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCDR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCDR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCDR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCDR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCDR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCDR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCDR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCDR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCDR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCDR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCDR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCDR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCDR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCDR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCDR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCDR1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCDR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCDR1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCDR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCDR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCDR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCDR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCDR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCDR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCDR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCDR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCDR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCDR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCDR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCDR1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCDR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCDR1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCDR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCDR1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCDR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCSR1: Peripheral Clock Status Register 1
func (o *PMC_Type) SetPMC_PCSR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCSR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCSR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCSR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCSR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCSR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCSR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCSR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCSR1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCSR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCSR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCSR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCSR1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCSR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCSR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCSR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCSR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCSR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCSR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCSR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCSR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCSR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCSR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCSR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCSR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCSR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCSR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCSR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCSR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCSR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCSR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCSR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCSR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCSR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCSR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCSR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCSR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCSR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCSR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCSR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCSR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCSR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCSR1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCSR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCSR1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCSR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCSR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCSR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCSR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCSR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCSR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCSR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCSR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCSR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCSR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCSR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCSR1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCSR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCSR1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCSR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCSR1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCSR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCR: Peripheral Control Register
func (o *PMC_Type) SetPMC_PCR_PID(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x3f)|value)
}
func (o *PMC_Type) GetPMC_PCR_PID() uint32 {
	return volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x3f
}
func (o *PMC_Type) SetPMC_PCR_CMD(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCR_CMD() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCR_DIV(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x30000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCR_DIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x30000) >> 16
}
func (o *PMC_Type) SetPMC_PCR_EN(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCR_EN() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x10000000) >> 28
}

// Reset Controller
type SYSC_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	MR volatile.Register32 // 0x8
}

// SYSC.CR: Control Register
func (o *SYSC_Type) SetCR_PROCRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetCR_PROCRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SYSC_Type) SetCR_PERRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetCR_PERRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetCR_EXTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetCR_EXTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// SYSC.SR: Status Register
func (o *SYSC_Type) SetSR_URSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSR_URSTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SYSC_Type) SetSR_RSTTYP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x700)|value<<8)
}
func (o *SYSC_Type) GetSR_RSTTYP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x700) >> 8
}
func (o *SYSC_Type) SetSR_NRSTL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetSR_NRSTL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SYSC_Type) SetSR_SRCMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetSR_SRCMP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SYSC.MR: Mode Register
func (o *SYSC_Type) SetMR_ERSTL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *SYSC_Type) GetMR_ERSTL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *SYSC_Type) SetMR_KEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// Constants for SMD: Software Modem Device
const ()

// Constants for AXIMX: AXI Matrix
const (
	// REMAP: Remap Register
	// Position of REMAP0 field.
	AXIMX_REMAP_REMAP0_Pos = 0x0
	// Bit mask of REMAP0 field.
	AXIMX_REMAP_REMAP0_Msk = 0x1
	// Bit REMAP0.
	AXIMX_REMAP_REMAP0 = 0x1
	// Position of REMAP1 field.
	AXIMX_REMAP_REMAP1_Pos = 0x1
	// Bit mask of REMAP1 field.
	AXIMX_REMAP_REMAP1_Msk = 0x2
	// Bit REMAP1.
	AXIMX_REMAP_REMAP1 = 0x2

	// PERIPH_ID4: Peripheral ID Register 4
	// Position of ID field.
	AXIMX_PERIPH_ID4_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID4_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID4_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID4_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID4_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID4_ID_ID2 = 0xb6

	// PERIPH_ID5: Peripheral ID Register 5
	// Position of ID field.
	AXIMX_PERIPH_ID5_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID5_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID5_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID5_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID5_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID5_ID_ID2 = 0xb6

	// PERIPH_ID6: Peripheral ID Register 6
	// Position of ID field.
	AXIMX_PERIPH_ID6_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID6_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID6_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID6_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID6_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID6_ID_ID2 = 0xb6

	// PERIPH_ID7: Peripheral ID Register 7
	// Position of ID field.
	AXIMX_PERIPH_ID7_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID7_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID7_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID7_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID7_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID7_ID_ID2 = 0xb6

	// PERIPH_ID0: Peripheral ID Register 0
	// Position of ID field.
	AXIMX_PERIPH_ID0_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID0_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID0_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID0_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID0_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID0_ID_ID2 = 0xb6

	// PERIPH_ID1: Peripheral ID Register 1
	// Position of ID field.
	AXIMX_PERIPH_ID1_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID1_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID1_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID1_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID1_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID1_ID_ID2 = 0xb6

	// PERIPH_ID2: Peripheral ID Register 2
	// Position of ID field.
	AXIMX_PERIPH_ID2_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID2_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID2_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID2_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID2_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID2_ID_ID2 = 0xb6

	// PERIPH_ID3: Peripheral ID Register 3
	// Position of ID field.
	AXIMX_PERIPH_ID3_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID3_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID3_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID3_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID3_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID3_ID_ID2 = 0xb6

	// COMP_ID: Component ID Register
	// Position of ID field.
	AXIMX_COMP_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_COMP_ID_ID_Msk = 0xff

	// AMIB3_FN_MOD_BM_ISS: AMIB3 Bus Matrix Functionality Modification Register
	// Position of RD_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS_Pos = 0x0
	// Bit mask of RD_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS_Msk = 0x1
	// Bit RD_ISS.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS = 0x1
	// Position of WR_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS_Pos = 0x1
	// Bit mask of WR_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS_Msk = 0x2
	// Bit WR_ISS.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS = 0x2

	// AMIB3_FN_MOD2: AMIB3 Bypass Merge
	// Position of BP_MRG field.
	AXIMX_AMIB3_FN_MOD2_BP_MRG_Pos = 0x0
	// Bit mask of BP_MRG field.
	AXIMX_AMIB3_FN_MOD2_BP_MRG_Msk = 0x1
	// Bit BP_MRG.
	AXIMX_AMIB3_FN_MOD2_BP_MRG = 0x1

	// ASIB0_READ_QOS: ASIB0 Read Channel QoS Register
	// Position of RD_QOS field.
	AXIMX_ASIB0_READ_QOS_RD_QOS_Pos = 0x0
	// Bit mask of RD_QOS field.
	AXIMX_ASIB0_READ_QOS_RD_QOS_Msk = 0xf

	// ASIB0_WRITE_QOS: ASIB0 Write Channel QoS Register
	// Position of WR_QOS field.
	AXIMX_ASIB0_WRITE_QOS_WR_QOS_Pos = 0x0
	// Bit mask of WR_QOS field.
	AXIMX_ASIB0_WRITE_QOS_WR_QOS_Msk = 0xf

	// ASIB1_FN_MOD_AHB: ASIB1 AHB Functionality Modification Register
	// Position of RD_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR_Pos = 0x0
	// Bit mask of RD_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR_Msk = 0x1
	// Bit RD_INCR_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR = 0x1
	// Position of WR_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR_Pos = 0x1
	// Bit mask of WR_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR_Msk = 0x2
	// Bit WR_INCR_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR = 0x2
	// Position of LOCK_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR_Pos = 0x2
	// Bit mask of LOCK_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR_Msk = 0x4
	// Bit LOCK_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR = 0x4

	// ASIB1_READ_QOS: ASIB1 Read Channel QoS Register
	// Position of RD_QOS field.
	AXIMX_ASIB1_READ_QOS_RD_QOS_Pos = 0x0
	// Bit mask of RD_QOS field.
	AXIMX_ASIB1_READ_QOS_RD_QOS_Msk = 0xf

	// ASIB1_WRITE_QOS: ASIB1 Write Channel QoS Register
	// Position of WR_QOS field.
	AXIMX_ASIB1_WRITE_QOS_WR_QOS_Pos = 0x0
	// Bit mask of WR_QOS field.
	AXIMX_ASIB1_WRITE_QOS_WR_QOS_Msk = 0xf

	// ASIB1_FN_MOD: ASIB1 Issuing Functionality Modification Register
	// Position of RD_ISS field.
	AXIMX_ASIB1_FN_MOD_RD_ISS_Pos = 0x0
	// Bit mask of RD_ISS field.
	AXIMX_ASIB1_FN_MOD_RD_ISS_Msk = 0x1
	// Bit RD_ISS.
	AXIMX_ASIB1_FN_MOD_RD_ISS = 0x1
	// Position of WR_ISS field.
	AXIMX_ASIB1_FN_MOD_WR_ISS_Pos = 0x1
	// Bit mask of WR_ISS field.
	AXIMX_ASIB1_FN_MOD_WR_ISS_Msk = 0x2
	// Bit WR_ISS.
	AXIMX_ASIB1_FN_MOD_WR_ISS = 0x2
)

// Constants for HSMCI0: High Speed MultiMedia Card Interface 0
const (
	// CR: Control Register
	// Position of MCIEN field.
	HSMCI_CR_MCIEN_Pos = 0x0
	// Bit mask of MCIEN field.
	HSMCI_CR_MCIEN_Msk = 0x1
	// Bit MCIEN.
	HSMCI_CR_MCIEN = 0x1
	// Position of MCIDIS field.
	HSMCI_CR_MCIDIS_Pos = 0x1
	// Bit mask of MCIDIS field.
	HSMCI_CR_MCIDIS_Msk = 0x2
	// Bit MCIDIS.
	HSMCI_CR_MCIDIS = 0x2
	// Position of PWSEN field.
	HSMCI_CR_PWSEN_Pos = 0x2
	// Bit mask of PWSEN field.
	HSMCI_CR_PWSEN_Msk = 0x4
	// Bit PWSEN.
	HSMCI_CR_PWSEN = 0x4
	// Position of PWSDIS field.
	HSMCI_CR_PWSDIS_Pos = 0x3
	// Bit mask of PWSDIS field.
	HSMCI_CR_PWSDIS_Msk = 0x8
	// Bit PWSDIS.
	HSMCI_CR_PWSDIS = 0x8
	// Position of SWRST field.
	HSMCI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	HSMCI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	HSMCI_CR_SWRST = 0x80

	// MR: Mode Register
	// Position of CLKDIV field.
	HSMCI_MR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	HSMCI_MR_CLKDIV_Msk = 0xff
	// Position of PWSDIV field.
	HSMCI_MR_PWSDIV_Pos = 0x8
	// Bit mask of PWSDIV field.
	HSMCI_MR_PWSDIV_Msk = 0x700
	// Position of RDPROOF field.
	HSMCI_MR_RDPROOF_Pos = 0xb
	// Bit mask of RDPROOF field.
	HSMCI_MR_RDPROOF_Msk = 0x800
	// Bit RDPROOF.
	HSMCI_MR_RDPROOF = 0x800
	// Position of WRPROOF field.
	HSMCI_MR_WRPROOF_Pos = 0xc
	// Bit mask of WRPROOF field.
	HSMCI_MR_WRPROOF_Msk = 0x1000
	// Bit WRPROOF.
	HSMCI_MR_WRPROOF = 0x1000
	// Position of FBYTE field.
	HSMCI_MR_FBYTE_Pos = 0xd
	// Bit mask of FBYTE field.
	HSMCI_MR_FBYTE_Msk = 0x2000
	// Bit FBYTE.
	HSMCI_MR_FBYTE = 0x2000
	// Position of PADV field.
	HSMCI_MR_PADV_Pos = 0xe
	// Bit mask of PADV field.
	HSMCI_MR_PADV_Msk = 0x4000
	// Bit PADV.
	HSMCI_MR_PADV = 0x4000
	// Position of CLKODD field.
	HSMCI_MR_CLKODD_Pos = 0x10
	// Bit mask of CLKODD field.
	HSMCI_MR_CLKODD_Msk = 0x10000
	// Bit CLKODD.
	HSMCI_MR_CLKODD = 0x10000

	// DTOR: Data Timeout Register
	// Position of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Pos = 0x0
	// Bit mask of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Msk = 0xf
	// Position of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Pos = 0x4
	// Bit mask of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Msk = 0x70
	// DTOCYC
	HSMCI_DTOR_DTOMUL_1 = 0x0
	// DTOCYC x 16
	HSMCI_DTOR_DTOMUL_16 = 0x1
	// DTOCYC x 128
	HSMCI_DTOR_DTOMUL_128 = 0x2
	// DTOCYC x 256
	HSMCI_DTOR_DTOMUL_256 = 0x3
	// DTOCYC x 1024
	HSMCI_DTOR_DTOMUL_1024 = 0x4
	// DTOCYC x 4096
	HSMCI_DTOR_DTOMUL_4096 = 0x5
	// DTOCYC x 65536
	HSMCI_DTOR_DTOMUL_65536 = 0x6
	// DTOCYC x 1048576
	HSMCI_DTOR_DTOMUL_1048576 = 0x7

	// SDCR: SD/SDIO Card Register
	// Position of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Pos = 0x0
	// Bit mask of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Msk = 0x3
	// Slot A is selected.
	HSMCI_SDCR_SDCSEL_SLOTA = 0x0
	// Position of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Pos = 0x6
	// Bit mask of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Msk = 0xc0
	// 1 bit
	HSMCI_SDCR_SDCBUS_1 = 0x0
	// 4 bit
	HSMCI_SDCR_SDCBUS_4 = 0x2
	// 8 bit
	HSMCI_SDCR_SDCBUS_8 = 0x3

	// ARGR: Argument Register
	// Position of ARG field.
	HSMCI_ARGR_ARG_Pos = 0x0
	// Bit mask of ARG field.
	HSMCI_ARGR_ARG_Msk = 0xffffffff

	// CMDR: Command Register
	// Position of CMDNB field.
	HSMCI_CMDR_CMDNB_Pos = 0x0
	// Bit mask of CMDNB field.
	HSMCI_CMDR_CMDNB_Msk = 0x3f
	// Position of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Pos = 0x6
	// Bit mask of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Msk = 0xc0
	// No response.
	HSMCI_CMDR_RSPTYP_NORESP = 0x0
	// 48-bit response.
	HSMCI_CMDR_RSPTYP_48_BIT = 0x1
	// 136-bit response.
	HSMCI_CMDR_RSPTYP_136_BIT = 0x2
	// R1b response type
	HSMCI_CMDR_RSPTYP_R1B = 0x3
	// Position of SPCMD field.
	HSMCI_CMDR_SPCMD_Pos = 0x8
	// Bit mask of SPCMD field.
	HSMCI_CMDR_SPCMD_Msk = 0x700
	// Not a special CMD.
	HSMCI_CMDR_SPCMD_STD = 0x0
	// Initialization CMD: 74 clock cycles for initialization sequence.
	HSMCI_CMDR_SPCMD_INIT = 0x1
	// Synchronized CMD: Wait for the end of the current data block transfer before sending the pending command.
	HSMCI_CMDR_SPCMD_SYNC = 0x2
	// CE-ATA Completion Signal disable Command. The host cancels the ability for the device to return a command completion signal on the command line.
	HSMCI_CMDR_SPCMD_CE_ATA = 0x3
	// Interrupt command: Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_CMD = 0x4
	// Interrupt response: Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_RESP = 0x5
	// Boot Operation Request. Start a boot operation mode, the host processor can read boot data from the MMC device directly.
	HSMCI_CMDR_SPCMD_BOR = 0x6
	// End Boot Operation. This command allows the host processor to terminate the boot operation mode.
	HSMCI_CMDR_SPCMD_EBO = 0x7
	// Position of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Pos = 0xb
	// Bit mask of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Msk = 0x800
	// Bit OPDCMD.
	HSMCI_CMDR_OPDCMD = 0x800
	// Push pull command.
	HSMCI_CMDR_OPDCMD_PUSHPULL = 0x0
	// Open drain command.
	HSMCI_CMDR_OPDCMD_OPENDRAIN = 0x1
	// Position of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Pos = 0xc
	// Bit mask of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Msk = 0x1000
	// Bit MAXLAT.
	HSMCI_CMDR_MAXLAT = 0x1000
	// 5-cycle max latency.
	HSMCI_CMDR_MAXLAT_5 = 0x0
	// 64-cycle max latency.
	HSMCI_CMDR_MAXLAT_64 = 0x1
	// Position of TRCMD field.
	HSMCI_CMDR_TRCMD_Pos = 0x10
	// Bit mask of TRCMD field.
	HSMCI_CMDR_TRCMD_Msk = 0x30000
	// No data transfer
	HSMCI_CMDR_TRCMD_NO_DATA = 0x0
	// Start data transfer
	HSMCI_CMDR_TRCMD_START_DATA = 0x1
	// Stop data transfer
	HSMCI_CMDR_TRCMD_STOP_DATA = 0x2
	// Position of TRDIR field.
	HSMCI_CMDR_TRDIR_Pos = 0x12
	// Bit mask of TRDIR field.
	HSMCI_CMDR_TRDIR_Msk = 0x40000
	// Bit TRDIR.
	HSMCI_CMDR_TRDIR = 0x40000
	// Write.
	HSMCI_CMDR_TRDIR_WRITE = 0x0
	// Read.
	HSMCI_CMDR_TRDIR_READ = 0x1
	// Position of TRTYP field.
	HSMCI_CMDR_TRTYP_Pos = 0x13
	// Bit mask of TRTYP field.
	HSMCI_CMDR_TRTYP_Msk = 0x380000
	// MMC/SD Card Single Block
	HSMCI_CMDR_TRTYP_SINGLE = 0x0
	// MMC/SD Card Multiple Block
	HSMCI_CMDR_TRTYP_MULTIPLE = 0x1
	// MMC Stream
	HSMCI_CMDR_TRTYP_STREAM = 0x2
	// SDIO Byte
	HSMCI_CMDR_TRTYP_BYTE = 0x4
	// SDIO Block
	HSMCI_CMDR_TRTYP_BLOCK = 0x5
	// Position of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Pos = 0x18
	// Bit mask of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Msk = 0x3000000
	// Not an SDIO Special Command
	HSMCI_CMDR_IOSPCMD_STD = 0x0
	// SDIO Suspend Command
	HSMCI_CMDR_IOSPCMD_SUSPEND = 0x1
	// SDIO Resume Command
	HSMCI_CMDR_IOSPCMD_RESUME = 0x2
	// Position of ATACS field.
	HSMCI_CMDR_ATACS_Pos = 0x1a
	// Bit mask of ATACS field.
	HSMCI_CMDR_ATACS_Msk = 0x4000000
	// Bit ATACS.
	HSMCI_CMDR_ATACS = 0x4000000
	// Normal operation mode.
	HSMCI_CMDR_ATACS_NORMAL = 0x0
	// This bit indicates that a completion signal is expected within a programmed amount of time (HSMCI_CSTOR).
	HSMCI_CMDR_ATACS_COMPLETION = 0x1
	// Position of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Pos = 0x1b
	// Bit mask of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Msk = 0x8000000
	// Bit BOOT_ACK.
	HSMCI_CMDR_BOOT_ACK = 0x8000000

	// BLKR: Block Register
	// Position of BCNT field.
	HSMCI_BLKR_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	HSMCI_BLKR_BCNT_Msk = 0xffff
	// Position of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Pos = 0x10
	// Bit mask of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Msk = 0xffff0000

	// CSTOR: Completion Signal Timeout Register
	// Position of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Pos = 0x0
	// Bit mask of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Msk = 0xf
	// Position of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Pos = 0x4
	// Bit mask of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Msk = 0x70
	// CSTOCYC x 1
	HSMCI_CSTOR_CSTOMUL_1 = 0x0
	// CSTOCYC x 16
	HSMCI_CSTOR_CSTOMUL_16 = 0x1
	// CSTOCYC x 128
	HSMCI_CSTOR_CSTOMUL_128 = 0x2
	// CSTOCYC x 256
	HSMCI_CSTOR_CSTOMUL_256 = 0x3
	// CSTOCYC x 1024
	HSMCI_CSTOR_CSTOMUL_1024 = 0x4
	// CSTOCYC x 4096
	HSMCI_CSTOR_CSTOMUL_4096 = 0x5
	// CSTOCYC x 65536
	HSMCI_CSTOR_CSTOMUL_65536 = 0x6
	// CSTOCYC x 1048576
	HSMCI_CSTOR_CSTOMUL_1048576 = 0x7

	// RSPR: Response Register
	// Position of RSP field.
	HSMCI_RSPR_RSP_Pos = 0x0
	// Bit mask of RSP field.
	HSMCI_RSPR_RSP_Msk = 0xffffffff

	// RDR: Receive Data Register
	// Position of DATA field.
	HSMCI_RDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_RDR_DATA_Msk = 0xffffffff

	// TDR: Transmit Data Register
	// Position of DATA field.
	HSMCI_TDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_TDR_DATA_Msk = 0xffffffff

	// SR: Status Register
	// Position of CMDRDY field.
	HSMCI_SR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_SR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_SR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_SR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_SR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_SR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_SR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_SR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_SR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_SR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_SR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_SR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_SR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_SR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_SR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_SR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_SR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_SR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_SR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_SR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_SR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_SR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_SR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_SR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_SR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_SR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_SR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_SR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_SR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_SR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_SR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_SR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_SR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_SR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_SR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_SR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_SR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_SR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_SR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_SR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_SR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_SR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_SR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_SR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_SR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_SR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_SR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_SR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_SR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_SR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_SR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_SR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_SR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_SR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_SR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_SR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_SR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_SR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_SR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_SR_UNRE = 0x80000000

	// IER: Interrupt Enable Register
	// Position of CMDRDY field.
	HSMCI_IER_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IER_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IER_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IER_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IER_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IER_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IER_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IER_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IER_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IER_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IER_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IER_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IER_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IER_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IER_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IER_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IER_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IER_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IER_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IER_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IER_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IER_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IER_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IER_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IER_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IER_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IER_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IER_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IER_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IER_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IER_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IER_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IER_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IER_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IER_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IER_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IER_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IER_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IER_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IER_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IER_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IER_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IER_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IER_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IER_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IER_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IER_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IER_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IER_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IER_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IER_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IER_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IER_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IER_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IER_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IER_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IER_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IER_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IER_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IER_UNRE = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of CMDRDY field.
	HSMCI_IDR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IDR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IDR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IDR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IDR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IDR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IDR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IDR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IDR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IDR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IDR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IDR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IDR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IDR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IDR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IDR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IDR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IDR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IDR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IDR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IDR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IDR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IDR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IDR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IDR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IDR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IDR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IDR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IDR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IDR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IDR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IDR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IDR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IDR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IDR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IDR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IDR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IDR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IDR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IDR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IDR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IDR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IDR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IDR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IDR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IDR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IDR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IDR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IDR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IDR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IDR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IDR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IDR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IDR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IDR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IDR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IDR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IDR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IDR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IDR_UNRE = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of CMDRDY field.
	HSMCI_IMR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IMR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IMR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IMR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IMR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IMR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IMR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IMR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IMR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IMR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IMR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IMR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IMR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IMR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IMR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IMR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IMR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IMR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IMR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IMR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IMR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IMR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IMR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IMR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IMR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IMR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IMR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IMR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IMR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IMR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IMR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IMR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IMR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IMR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IMR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IMR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IMR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IMR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IMR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IMR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IMR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IMR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IMR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IMR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IMR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IMR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IMR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IMR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IMR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IMR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IMR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IMR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IMR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IMR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IMR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IMR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IMR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IMR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IMR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IMR_UNRE = 0x80000000

	// DMA: DMA Configuration Register
	// Position of OFFSET field.
	HSMCI_DMA_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	HSMCI_DMA_OFFSET_Msk = 0x3
	// Position of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Pos = 0x4
	// Bit mask of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Msk = 0x70
	// Position of DMAEN field.
	HSMCI_DMA_DMAEN_Pos = 0x8
	// Bit mask of DMAEN field.
	HSMCI_DMA_DMAEN_Msk = 0x100
	// Bit DMAEN.
	HSMCI_DMA_DMAEN = 0x100
	// Position of ROPT field.
	HSMCI_DMA_ROPT_Pos = 0xc
	// Bit mask of ROPT field.
	HSMCI_DMA_ROPT_Msk = 0x1000
	// Bit ROPT.
	HSMCI_DMA_ROPT = 0x1000

	// CFG: Configuration Register
	// Position of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Pos = 0x0
	// Bit mask of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Msk = 0x1
	// Bit FIFOMODE.
	HSMCI_CFG_FIFOMODE = 0x1
	// Position of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Pos = 0x4
	// Bit mask of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Msk = 0x10
	// Bit FERRCTRL.
	HSMCI_CFG_FERRCTRL = 0x10
	// Position of HSMODE field.
	HSMCI_CFG_HSMODE_Pos = 0x8
	// Bit mask of HSMODE field.
	HSMCI_CFG_HSMODE_Msk = 0x100
	// Bit HSMODE.
	HSMCI_CFG_HSMODE = 0x100
	// Position of LSYNC field.
	HSMCI_CFG_LSYNC_Pos = 0xc
	// Bit mask of LSYNC field.
	HSMCI_CFG_LSYNC_Msk = 0x1000
	// Bit LSYNC.
	HSMCI_CFG_LSYNC = 0x1000

	// WPMR: Write Protection Mode Register
	// Position of WP_EN field.
	HSMCI_WPMR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	HSMCI_WPMR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	HSMCI_WPMR_WP_EN = 0x1
	// Position of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WP_VS field.
	HSMCI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	HSMCI_WPSR_WP_VS_Msk = 0xf
	// No Write Protection Violation occurred since the last read of this register (WP_SR)
	HSMCI_WPSR_WP_VS_NONE = 0x0
	// Write Protection detected unauthorized attempt to write a control register had occurred (since the last read.)
	HSMCI_WPSR_WP_VS_WRITE = 0x1
	// Software reset had been performed while Write Protection was enabled (since the last read).
	HSMCI_WPSR_WP_VS_RESET = 0x2
	// Both Write Protection violation and software reset with Write Protection enabled have occurred since the last read.
	HSMCI_WPSR_WP_VS_BOTH = 0x3
	// Position of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Msk = 0xffff00

	// FIFO: FIFO Memory Aperture0
	// Position of DATA field.
	HSMCI_FIFO_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_FIFO_DATA_Msk = 0xffffffff
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// CR: Control Register
	// Position of SPIEN field.
	SPI_CR_SPIEN_Pos = 0x0
	// Bit mask of SPIEN field.
	SPI_CR_SPIEN_Msk = 0x1
	// Bit SPIEN.
	SPI_CR_SPIEN = 0x1
	// Position of SPIDIS field.
	SPI_CR_SPIDIS_Pos = 0x1
	// Bit mask of SPIDIS field.
	SPI_CR_SPIDIS_Msk = 0x2
	// Bit SPIDIS.
	SPI_CR_SPIDIS = 0x2
	// Position of SWRST field.
	SPI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	SPI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	SPI_CR_SWRST = 0x80
	// Position of LASTXFER field.
	SPI_CR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_CR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_CR_LASTXFER = 0x1000000

	// MR: Mode Register
	// Position of MSTR field.
	SPI_MR_MSTR_Pos = 0x0
	// Bit mask of MSTR field.
	SPI_MR_MSTR_Msk = 0x1
	// Bit MSTR.
	SPI_MR_MSTR = 0x1
	// Position of PS field.
	SPI_MR_PS_Pos = 0x1
	// Bit mask of PS field.
	SPI_MR_PS_Msk = 0x2
	// Bit PS.
	SPI_MR_PS = 0x2
	// Position of PCSDEC field.
	SPI_MR_PCSDEC_Pos = 0x2
	// Bit mask of PCSDEC field.
	SPI_MR_PCSDEC_Msk = 0x4
	// Bit PCSDEC.
	SPI_MR_PCSDEC = 0x4
	// Position of MODFDIS field.
	SPI_MR_MODFDIS_Pos = 0x4
	// Bit mask of MODFDIS field.
	SPI_MR_MODFDIS_Msk = 0x10
	// Bit MODFDIS.
	SPI_MR_MODFDIS = 0x10
	// Position of WDRBT field.
	SPI_MR_WDRBT_Pos = 0x5
	// Bit mask of WDRBT field.
	SPI_MR_WDRBT_Msk = 0x20
	// Bit WDRBT.
	SPI_MR_WDRBT = 0x20
	// Position of LLB field.
	SPI_MR_LLB_Pos = 0x7
	// Bit mask of LLB field.
	SPI_MR_LLB_Msk = 0x80
	// Bit LLB.
	SPI_MR_LLB = 0x80
	// Position of PCS field.
	SPI_MR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_MR_PCS_Msk = 0xf0000
	// Position of DLYBCS field.
	SPI_MR_DLYBCS_Pos = 0x18
	// Bit mask of DLYBCS field.
	SPI_MR_DLYBCS_Msk = 0xff000000

	// RDR: Receive Data Register
	// Position of RD field.
	SPI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	SPI_RDR_RD_Msk = 0xffff
	// Position of PCS field.
	SPI_RDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_RDR_PCS_Msk = 0xf0000

	// TDR: Transmit Data Register
	// Position of TD field.
	SPI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	SPI_TDR_TD_Msk = 0xffff
	// Position of PCS field.
	SPI_TDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_TDR_PCS_Msk = 0xf0000
	// Position of LASTXFER field.
	SPI_TDR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_TDR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_TDR_LASTXFER = 0x1000000

	// SR: Status Register
	// Position of RDRF field.
	SPI_SR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_SR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_SR_RDRF = 0x1
	// Position of TDRE field.
	SPI_SR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_SR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_SR_TDRE = 0x2
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_SR_MODF = 0x4
	// Position of OVRES field.
	SPI_SR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_SR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_SR_OVRES = 0x8
	// Position of NSSR field.
	SPI_SR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_SR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_SR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_SR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_SR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_SR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_SR_UNDES = 0x400
	// Position of SPIENS field.
	SPI_SR_SPIENS_Pos = 0x10
	// Bit mask of SPIENS field.
	SPI_SR_SPIENS_Msk = 0x10000
	// Bit SPIENS.
	SPI_SR_SPIENS = 0x10000

	// IER: Interrupt Enable Register
	// Position of RDRF field.
	SPI_IER_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IER_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IER_RDRF = 0x1
	// Position of TDRE field.
	SPI_IER_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IER_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IER_TDRE = 0x2
	// Position of MODF field.
	SPI_IER_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IER_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IER_MODF = 0x4
	// Position of OVRES field.
	SPI_IER_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IER_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IER_OVRES = 0x8
	// Position of NSSR field.
	SPI_IER_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IER_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IER_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IER_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IER_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IER_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IER_UNDES = 0x400

	// IDR: Interrupt Disable Register
	// Position of RDRF field.
	SPI_IDR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IDR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IDR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IDR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IDR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IDR_TDRE = 0x2
	// Position of MODF field.
	SPI_IDR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IDR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IDR_MODF = 0x4
	// Position of OVRES field.
	SPI_IDR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IDR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IDR_OVRES = 0x8
	// Position of NSSR field.
	SPI_IDR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IDR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IDR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IDR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IDR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IDR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IDR_UNDES = 0x400

	// IMR: Interrupt Mask Register
	// Position of RDRF field.
	SPI_IMR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IMR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IMR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IMR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IMR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IMR_TDRE = 0x2
	// Position of MODF field.
	SPI_IMR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IMR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IMR_MODF = 0x4
	// Position of OVRES field.
	SPI_IMR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IMR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IMR_OVRES = 0x8
	// Position of NSSR field.
	SPI_IMR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IMR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IMR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IMR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IMR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IMR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IMR_UNDES = 0x400

	// CSR: Chip Select Register
	// Position of CPOL field.
	SPI_CSR_CPOL_Pos = 0x0
	// Bit mask of CPOL field.
	SPI_CSR_CPOL_Msk = 0x1
	// Bit CPOL.
	SPI_CSR_CPOL = 0x1
	// Position of NCPHA field.
	SPI_CSR_NCPHA_Pos = 0x1
	// Bit mask of NCPHA field.
	SPI_CSR_NCPHA_Msk = 0x2
	// Bit NCPHA.
	SPI_CSR_NCPHA = 0x2
	// Position of CSNAAT field.
	SPI_CSR_CSNAAT_Pos = 0x2
	// Bit mask of CSNAAT field.
	SPI_CSR_CSNAAT_Msk = 0x4
	// Bit CSNAAT.
	SPI_CSR_CSNAAT = 0x4
	// Position of CSAAT field.
	SPI_CSR_CSAAT_Pos = 0x3
	// Bit mask of CSAAT field.
	SPI_CSR_CSAAT_Msk = 0x8
	// Bit CSAAT.
	SPI_CSR_CSAAT = 0x8
	// Position of BITS field.
	SPI_CSR_BITS_Pos = 0x4
	// Bit mask of BITS field.
	SPI_CSR_BITS_Msk = 0xf0
	// 8 bits for transfer
	SPI_CSR_BITS_8_BIT = 0x0
	// 9 bits for transfer
	SPI_CSR_BITS_9_BIT = 0x1
	// 10 bits for transfer
	SPI_CSR_BITS_10_BIT = 0x2
	// 11 bits for transfer
	SPI_CSR_BITS_11_BIT = 0x3
	// 12 bits for transfer
	SPI_CSR_BITS_12_BIT = 0x4
	// 13 bits for transfer
	SPI_CSR_BITS_13_BIT = 0x5
	// 14 bits for transfer
	SPI_CSR_BITS_14_BIT = 0x6
	// 15 bits for transfer
	SPI_CSR_BITS_15_BIT = 0x7
	// 16 bits for transfer
	SPI_CSR_BITS_16_BIT = 0x8
	// Position of SCBR field.
	SPI_CSR_SCBR_Pos = 0x8
	// Bit mask of SCBR field.
	SPI_CSR_SCBR_Msk = 0xff00
	// Position of DLYBS field.
	SPI_CSR_DLYBS_Pos = 0x10
	// Bit mask of DLYBS field.
	SPI_CSR_DLYBS_Msk = 0xff0000
	// Position of DLYBCT field.
	SPI_CSR_DLYBCT_Pos = 0x18
	// Bit mask of DLYBCT field.
	SPI_CSR_DLYBCT_Msk = 0xff000000

	// WPMR: Write Protection Control Register
	// Position of WPEN field.
	SPI_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	SPI_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	SPI_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	SPI_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	SPI_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	SPI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	SPI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	SPI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	SPI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	SPI_WPSR_WPVSRC_Msk = 0xff00
)

// Constants for SSC0: Synchronous Serial Controller 0
const (
	// CR: Control Register
	// Position of RXEN field.
	SSC_CR_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	SSC_CR_RXEN_Msk = 0x1
	// Bit RXEN.
	SSC_CR_RXEN = 0x1
	// Position of RXDIS field.
	SSC_CR_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	SSC_CR_RXDIS_Msk = 0x2
	// Bit RXDIS.
	SSC_CR_RXDIS = 0x2
	// Position of TXEN field.
	SSC_CR_TXEN_Pos = 0x8
	// Bit mask of TXEN field.
	SSC_CR_TXEN_Msk = 0x100
	// Bit TXEN.
	SSC_CR_TXEN = 0x100
	// Position of TXDIS field.
	SSC_CR_TXDIS_Pos = 0x9
	// Bit mask of TXDIS field.
	SSC_CR_TXDIS_Msk = 0x200
	// Bit TXDIS.
	SSC_CR_TXDIS = 0x200
	// Position of SWRST field.
	SSC_CR_SWRST_Pos = 0xf
	// Bit mask of SWRST field.
	SSC_CR_SWRST_Msk = 0x8000
	// Bit SWRST.
	SSC_CR_SWRST = 0x8000

	// CMR: Clock Mode Register
	// Position of DIV field.
	SSC_CMR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SSC_CMR_DIV_Msk = 0xfff

	// RCMR: Receive Clock Mode Register
	// Position of CKS field.
	SSC_RCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_RCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_RCMR_CKS_MCK = 0x0
	// TK Clock signal
	SSC_RCMR_CKS_TK = 0x1
	// RK pin
	SSC_RCMR_CKS_RK = 0x2
	// Position of CKO field.
	SSC_RCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_RCMR_CKO_Msk = 0x1c
	// None, RK pin is an input
	SSC_RCMR_CKO_NONE = 0x0
	// Continuous Receive Clock, RK pin is an output
	SSC_RCMR_CKO_CONTINUOUS = 0x1
	// Receive Clock only during data transfers, RK pin is an output
	SSC_RCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_RCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_RCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_RCMR_CKI = 0x20
	// Position of CKG field.
	SSC_RCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_RCMR_CKG_Msk = 0xc0
	// None
	SSC_RCMR_CKG_CONTINUOUS = 0x0
	// Receive Clock enabled only if RF Pin is Low
	SSC_RCMR_CKG_EN_RF_LOW = 0x1
	// Receive Clock enabled only if RF Pin is High
	SSC_RCMR_CKG_EN_RF_HIGH = 0x2
	// Position of START field.
	SSC_RCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_RCMR_START_Msk = 0xf00
	// Continuous, as soon as the receiver is enabled, and immediately after the end of transfer of the previous data.
	SSC_RCMR_START_CONTINUOUS = 0x0
	// Transmit start
	SSC_RCMR_START_TRANSMIT = 0x1
	// Detection of a low level on RF signal
	SSC_RCMR_START_RF_LOW = 0x2
	// Detection of a high level on RF signal
	SSC_RCMR_START_RF_HIGH = 0x3
	// Detection of a falling edge on RF signal
	SSC_RCMR_START_RF_FALLING = 0x4
	// Detection of a rising edge on RF signal
	SSC_RCMR_START_RF_RISING = 0x5
	// Detection of any level change on RF signal
	SSC_RCMR_START_RF_LEVEL = 0x6
	// Detection of any edge on RF signal
	SSC_RCMR_START_RF_EDGE = 0x7
	// Compare 0
	SSC_RCMR_START_CMP_0 = 0x8
	// Position of STOP field.
	SSC_RCMR_STOP_Pos = 0xc
	// Bit mask of STOP field.
	SSC_RCMR_STOP_Msk = 0x1000
	// Bit STOP.
	SSC_RCMR_STOP = 0x1000
	// Position of STTDLY field.
	SSC_RCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_RCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_RCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_RCMR_PERIOD_Msk = 0xff000000

	// RFMR: Receive Frame Mode Register
	// Position of DATLEN field.
	SSC_RFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_RFMR_DATLEN_Msk = 0x1f
	// Position of LOOP field.
	SSC_RFMR_LOOP_Pos = 0x5
	// Bit mask of LOOP field.
	SSC_RFMR_LOOP_Msk = 0x20
	// Bit LOOP.
	SSC_RFMR_LOOP = 0x20
	// Position of MSBF field.
	SSC_RFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_RFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_RFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_RFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_RFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_RFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_RFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_RFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_RFMR_FSOS_Msk = 0x700000
	// None, RF pin is an input
	SSC_RFMR_FSOS_NONE = 0x0
	// Negative Pulse, RF pin is an output
	SSC_RFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse, RF pin is an output
	SSC_RFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer, RF pin is an output
	SSC_RFMR_FSOS_LOW = 0x3
	// Driven High during data transfer, RF pin is an output
	SSC_RFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer, RF pin is an output
	SSC_RFMR_FSOS_TOGGLING = 0x5
	// Position of FSEDGE field.
	SSC_RFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_RFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_RFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_RFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_RFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Msk = 0xf0000000

	// TCMR: Transmit Clock Mode Register
	// Position of CKS field.
	SSC_TCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_TCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_TCMR_CKS_MCK = 0x0
	// RK Clock signal
	SSC_TCMR_CKS_RK = 0x1
	// TK pin
	SSC_TCMR_CKS_TK = 0x2
	// Position of CKO field.
	SSC_TCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_TCMR_CKO_Msk = 0x1c
	// None, TK pin is an input
	SSC_TCMR_CKO_NONE = 0x0
	// Continuous Transmit Clock, TK pin is an output
	SSC_TCMR_CKO_CONTINUOUS = 0x1
	// Transmit Clock only during data transfers, TK pin is an output
	SSC_TCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_TCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_TCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_TCMR_CKI = 0x20
	// Position of CKG field.
	SSC_TCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_TCMR_CKG_Msk = 0xc0
	// None
	SSC_TCMR_CKG_CONTINUOUS = 0x0
	// Transmit Clock enabled only if TF pin is Low
	SSC_TCMR_CKG_EN_TF_LOW = 0x1
	// Transmit Clock enabled only if TF pin is High
	SSC_TCMR_CKG_EN_TF_HIGH = 0x2
	// Position of START field.
	SSC_TCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_TCMR_START_Msk = 0xf00
	// Continuous, as soon as a word is written in the SSC_THR Register (if Transmit is enabled), and immediately after the end of transfer of the previous data.
	SSC_TCMR_START_CONTINUOUS = 0x0
	// Receive start
	SSC_TCMR_START_RECEIVE = 0x1
	// Detection of a low level on TF signal
	SSC_TCMR_START_TF_LOW = 0x2
	// Detection of a high level on TF signal
	SSC_TCMR_START_TF_HIGH = 0x3
	// Detection of a falling edge on TF signal
	SSC_TCMR_START_TF_FALLING = 0x4
	// Detection of a rising edge on TF signal
	SSC_TCMR_START_TF_RISING = 0x5
	// Detection of any level change on TF signal
	SSC_TCMR_START_TF_LEVEL = 0x6
	// Detection of any edge on TF signal
	SSC_TCMR_START_TF_EDGE = 0x7
	// Position of STTDLY field.
	SSC_TCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_TCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_TCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_TCMR_PERIOD_Msk = 0xff000000

	// TFMR: Transmit Frame Mode Register
	// Position of DATLEN field.
	SSC_TFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_TFMR_DATLEN_Msk = 0x1f
	// Position of DATDEF field.
	SSC_TFMR_DATDEF_Pos = 0x5
	// Bit mask of DATDEF field.
	SSC_TFMR_DATDEF_Msk = 0x20
	// Bit DATDEF.
	SSC_TFMR_DATDEF = 0x20
	// Position of MSBF field.
	SSC_TFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_TFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_TFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_TFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_TFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_TFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_TFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_TFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_TFMR_FSOS_Msk = 0x700000
	// None, TF pin is an input
	SSC_TFMR_FSOS_NONE = 0x0
	// Negative Pulse, TF pin is an output
	SSC_TFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse,TF pin is an output
	SSC_TFMR_FSOS_POSITIVE = 0x2
	// TF pin Driven Low during data transfer
	SSC_TFMR_FSOS_LOW = 0x3
	// TF pin Driven High during data transfer
	SSC_TFMR_FSOS_HIGH = 0x4
	// TF pin Toggles at each start of data transfer
	SSC_TFMR_FSOS_TOGGLING = 0x5
	// Position of FSDEN field.
	SSC_TFMR_FSDEN_Pos = 0x17
	// Bit mask of FSDEN field.
	SSC_TFMR_FSDEN_Msk = 0x800000
	// Bit FSDEN.
	SSC_TFMR_FSDEN = 0x800000
	// Position of FSEDGE field.
	SSC_TFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_TFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_TFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_TFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_TFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Msk = 0xf0000000

	// RHR: Receive Holding Register
	// Position of RDAT field.
	SSC_RHR_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SSC_RHR_RDAT_Msk = 0xffffffff

	// THR: Transmit Holding Register
	// Position of TDAT field.
	SSC_THR_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SSC_THR_TDAT_Msk = 0xffffffff

	// RSHR: Receive Sync. Holding Register
	// Position of RSDAT field.
	SSC_RSHR_RSDAT_Pos = 0x0
	// Bit mask of RSDAT field.
	SSC_RSHR_RSDAT_Msk = 0xffff

	// TSHR: Transmit Sync. Holding Register
	// Position of TSDAT field.
	SSC_TSHR_TSDAT_Pos = 0x0
	// Bit mask of TSDAT field.
	SSC_TSHR_TSDAT_Msk = 0xffff

	// RC0R: Receive Compare 0 Register
	// Position of CP0 field.
	SSC_RC0R_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SSC_RC0R_CP0_Msk = 0xffff

	// RC1R: Receive Compare 1 Register
	// Position of CP1 field.
	SSC_RC1R_CP1_Pos = 0x0
	// Bit mask of CP1 field.
	SSC_RC1R_CP1_Msk = 0xffff

	// SR: Status Register
	// Position of TXRDY field.
	SSC_SR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_SR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_SR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_SR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_SR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_SR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_SR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_SR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_SR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_SR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_SR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_SR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_SR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_SR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_SR_CP0 = 0x100
	// Position of CP1 field.
	SSC_SR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_SR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_SR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_SR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_SR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_SR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_SR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_SR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_SR_RXSYN = 0x800
	// Position of TXEN field.
	SSC_SR_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SSC_SR_TXEN_Msk = 0x10000
	// Bit TXEN.
	SSC_SR_TXEN = 0x10000
	// Position of RXEN field.
	SSC_SR_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SSC_SR_RXEN_Msk = 0x20000
	// Bit RXEN.
	SSC_SR_RXEN = 0x20000

	// IER: Interrupt Enable Register
	// Position of TXRDY field.
	SSC_IER_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IER_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IER_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IER_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IER_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IER_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IER_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IER_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IER_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IER_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IER_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IER_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IER_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IER_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IER_CP0 = 0x100
	// Position of CP1 field.
	SSC_IER_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IER_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IER_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IER_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IER_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IER_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IER_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IER_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IER_RXSYN = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXRDY field.
	SSC_IDR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IDR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IDR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IDR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IDR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IDR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IDR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IDR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IDR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IDR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IDR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IDR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IDR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IDR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IDR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IDR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IDR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IDR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IDR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IDR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IDR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IDR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IDR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IDR_RXSYN = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXRDY field.
	SSC_IMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IMR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IMR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IMR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IMR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IMR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IMR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IMR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IMR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IMR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IMR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IMR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IMR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IMR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IMR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IMR_RXSYN = 0x800

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	SSC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	SSC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	SSC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	SSC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	SSC_WPMR_WPKEY_Msk = 0xffffff00
)

// Constants for TC0: Timer Counter 0
const (
	// CCR0: Channel Control Register (channel = 0)
	// Position of CLKEN field.
	TC_CCR0_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR0_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR0_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR0_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR0_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR0_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR0_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR0_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR0_SWTRG = 0x4

	// CMR0: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR0_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR0_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR0_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR0_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR0_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR0_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR0_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR0_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR0_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR0_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR0_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR0_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR0_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR0_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR0_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR0_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR0_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR0_LDRA_Msk = 0x30000
	// None
	TC_CMR0_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR0_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR0_LDRB_Msk = 0xc0000
	// None
	TC_CMR0_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRB_EDGE = 0x3

	// CMR0_WAVE_EQ_1: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR0_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR0_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR0_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR0_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR0_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR0_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR0_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR0_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR0_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR0_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR0_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR0_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR0_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR0_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR0: Stepper Motor Mode Register (channel = 0)
	// Position of GCEN field.
	TC_SMMR0_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR0_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR0_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR0_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR0_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR0_DOWN = 0x2

	// RAB0: Register AB (channel = 0)
	// Position of RAB field.
	TC_RAB0_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB0_RAB_Msk = 0xffffffff

	// CV0: Counter Value (channel = 0)
	// Position of CV field.
	TC_CV0_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV0_CV_Msk = 0xffffffff

	// RA0: Register A (channel = 0)
	// Position of RA field.
	TC_RA0_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA0_RA_Msk = 0xffffffff

	// RB0: Register B (channel = 0)
	// Position of RB field.
	TC_RB0_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB0_RB_Msk = 0xffffffff

	// RC0: Register C (channel = 0)
	// Position of RC field.
	TC_RC0_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC0_RC_Msk = 0xffffffff

	// SR0: Status Register (channel = 0)
	// Position of COVFS field.
	TC_SR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR0_CPAS = 0x4
	// Position of CPBS field.
	TC_SR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR0_CPBS = 0x8
	// Position of CPCS field.
	TC_SR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR0_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR0_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR0_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR0_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR0_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR0_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR0_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR0_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR0_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR0_MTIOB = 0x40000

	// IER0: Interrupt Enable Register (channel = 0)
	// Position of COVFS field.
	TC_IER0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER0_CPAS = 0x4
	// Position of CPBS field.
	TC_IER0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER0_CPBS = 0x8
	// Position of CPCS field.
	TC_IER0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER0_ETRGS = 0x80

	// IDR0: Interrupt Disable Register (channel = 0)
	// Position of COVFS field.
	TC_IDR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR0_ETRGS = 0x80

	// IMR0: Interrupt Mask Register (channel = 0)
	// Position of COVFS field.
	TC_IMR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR0_ETRGS = 0x80

	// CCR1: Channel Control Register (channel = 1)
	// Position of CLKEN field.
	TC_CCR1_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR1_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR1_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR1_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR1_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR1_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR1_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR1_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR1_SWTRG = 0x4

	// CMR1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR1_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR1_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR1_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR1_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR1_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR1_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR1_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR1_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR1_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR1_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR1_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR1_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR1_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR1_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR1_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR1_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR1_LDRA_Msk = 0x30000
	// None
	TC_CMR1_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR1_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR1_LDRB_Msk = 0xc0000
	// None
	TC_CMR1_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRB_EDGE = 0x3

	// CMR1_WAVE_EQ_1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR1_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR1_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR1_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR1_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR1_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR1_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR1_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR1_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR1_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR1_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR1_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR1_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR1_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR1_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR1: Stepper Motor Mode Register (channel = 1)
	// Position of GCEN field.
	TC_SMMR1_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR1_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR1_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR1_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR1_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR1_DOWN = 0x2

	// RAB1: Register AB (channel = 1)
	// Position of RAB field.
	TC_RAB1_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB1_RAB_Msk = 0xffffffff

	// CV1: Counter Value (channel = 1)
	// Position of CV field.
	TC_CV1_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV1_CV_Msk = 0xffffffff

	// RA1: Register A (channel = 1)
	// Position of RA field.
	TC_RA1_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA1_RA_Msk = 0xffffffff

	// RB1: Register B (channel = 1)
	// Position of RB field.
	TC_RB1_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB1_RB_Msk = 0xffffffff

	// RC1: Register C (channel = 1)
	// Position of RC field.
	TC_RC1_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC1_RC_Msk = 0xffffffff

	// SR1: Status Register (channel = 1)
	// Position of COVFS field.
	TC_SR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR1_CPAS = 0x4
	// Position of CPBS field.
	TC_SR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR1_CPBS = 0x8
	// Position of CPCS field.
	TC_SR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR1_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR1_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR1_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR1_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR1_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR1_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR1_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR1_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR1_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR1_MTIOB = 0x40000

	// IER1: Interrupt Enable Register (channel = 1)
	// Position of COVFS field.
	TC_IER1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER1_CPAS = 0x4
	// Position of CPBS field.
	TC_IER1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER1_CPBS = 0x8
	// Position of CPCS field.
	TC_IER1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER1_ETRGS = 0x80

	// IDR1: Interrupt Disable Register (channel = 1)
	// Position of COVFS field.
	TC_IDR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR1_ETRGS = 0x80

	// IMR1: Interrupt Mask Register (channel = 1)
	// Position of COVFS field.
	TC_IMR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR1_ETRGS = 0x80

	// CCR2: Channel Control Register (channel = 2)
	// Position of CLKEN field.
	TC_CCR2_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR2_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR2_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR2_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR2_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR2_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR2_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR2_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR2_SWTRG = 0x4

	// CMR2: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR2_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR2_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR2_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR2_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR2_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR2_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR2_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR2_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR2_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR2_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR2_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR2_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR2_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR2_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR2_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR2_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR2_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR2_LDRA_Msk = 0x30000
	// None
	TC_CMR2_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR2_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR2_LDRB_Msk = 0xc0000
	// None
	TC_CMR2_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRB_EDGE = 0x3

	// CMR2_WAVE_EQ_1: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR2_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR2_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR2_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR2_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR2_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR2_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR2_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR2_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR2_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR2_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR2_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR2_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR2_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR2_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR2: Stepper Motor Mode Register (channel = 2)
	// Position of GCEN field.
	TC_SMMR2_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR2_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR2_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR2_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR2_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR2_DOWN = 0x2

	// RAB2: Register AB (channel = 2)
	// Position of RAB field.
	TC_RAB2_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB2_RAB_Msk = 0xffffffff

	// CV2: Counter Value (channel = 2)
	// Position of CV field.
	TC_CV2_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV2_CV_Msk = 0xffffffff

	// RA2: Register A (channel = 2)
	// Position of RA field.
	TC_RA2_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA2_RA_Msk = 0xffffffff

	// RB2: Register B (channel = 2)
	// Position of RB field.
	TC_RB2_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB2_RB_Msk = 0xffffffff

	// RC2: Register C (channel = 2)
	// Position of RC field.
	TC_RC2_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC2_RC_Msk = 0xffffffff

	// SR2: Status Register (channel = 2)
	// Position of COVFS field.
	TC_SR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR2_CPAS = 0x4
	// Position of CPBS field.
	TC_SR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR2_CPBS = 0x8
	// Position of CPCS field.
	TC_SR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR2_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR2_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR2_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR2_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR2_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR2_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR2_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR2_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR2_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR2_MTIOB = 0x40000

	// IER2: Interrupt Enable Register (channel = 2)
	// Position of COVFS field.
	TC_IER2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER2_CPAS = 0x4
	// Position of CPBS field.
	TC_IER2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER2_CPBS = 0x8
	// Position of CPCS field.
	TC_IER2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER2_ETRGS = 0x80

	// IDR2: Interrupt Disable Register (channel = 2)
	// Position of COVFS field.
	TC_IDR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR2_ETRGS = 0x80

	// IMR2: Interrupt Mask Register (channel = 2)
	// Position of COVFS field.
	TC_IMR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR2_ETRGS = 0x80

	// BCR: Block Control Register
	// Position of SYNC field.
	TC_BCR_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	TC_BCR_SYNC_Msk = 0x1
	// Bit SYNC.
	TC_BCR_SYNC = 0x1

	// BMR: Block Mode Register
	// Position of TC0XC0S field.
	TC_BMR_TC0XC0S_Pos = 0x0
	// Bit mask of TC0XC0S field.
	TC_BMR_TC0XC0S_Msk = 0x3
	// Signal connected to XC0: TCLK0
	TC_BMR_TC0XC0S_TCLK0 = 0x0
	// Signal connected to XC0: TIOA1
	TC_BMR_TC0XC0S_TIOA1 = 0x2
	// Signal connected to XC0: TIOA2
	TC_BMR_TC0XC0S_TIOA2 = 0x3
	// Position of TC1XC1S field.
	TC_BMR_TC1XC1S_Pos = 0x2
	// Bit mask of TC1XC1S field.
	TC_BMR_TC1XC1S_Msk = 0xc
	// Signal connected to XC1: TCLK1
	TC_BMR_TC1XC1S_TCLK1 = 0x0
	// Signal connected to XC1: TIOA0
	TC_BMR_TC1XC1S_TIOA0 = 0x2
	// Signal connected to XC1: TIOA2
	TC_BMR_TC1XC1S_TIOA2 = 0x3
	// Position of TC2XC2S field.
	TC_BMR_TC2XC2S_Pos = 0x4
	// Bit mask of TC2XC2S field.
	TC_BMR_TC2XC2S_Msk = 0x30
	// Signal connected to XC2: TCLK2
	TC_BMR_TC2XC2S_TCLK2 = 0x0
	// Signal connected to XC2: TIOA1
	TC_BMR_TC2XC2S_TIOA1 = 0x2
	// Signal connected to XC2: TIOA2
	TC_BMR_TC2XC2S_TIOA2 = 0x3
	// Position of QDEN field.
	TC_BMR_QDEN_Pos = 0x8
	// Bit mask of QDEN field.
	TC_BMR_QDEN_Msk = 0x100
	// Bit QDEN.
	TC_BMR_QDEN = 0x100
	// Position of POSEN field.
	TC_BMR_POSEN_Pos = 0x9
	// Bit mask of POSEN field.
	TC_BMR_POSEN_Msk = 0x200
	// Bit POSEN.
	TC_BMR_POSEN = 0x200
	// Position of SPEEDEN field.
	TC_BMR_SPEEDEN_Pos = 0xa
	// Bit mask of SPEEDEN field.
	TC_BMR_SPEEDEN_Msk = 0x400
	// Bit SPEEDEN.
	TC_BMR_SPEEDEN = 0x400
	// Position of QDTRANS field.
	TC_BMR_QDTRANS_Pos = 0xb
	// Bit mask of QDTRANS field.
	TC_BMR_QDTRANS_Msk = 0x800
	// Bit QDTRANS.
	TC_BMR_QDTRANS = 0x800
	// Position of EDGPHA field.
	TC_BMR_EDGPHA_Pos = 0xc
	// Bit mask of EDGPHA field.
	TC_BMR_EDGPHA_Msk = 0x1000
	// Bit EDGPHA.
	TC_BMR_EDGPHA = 0x1000
	// Position of INVA field.
	TC_BMR_INVA_Pos = 0xd
	// Bit mask of INVA field.
	TC_BMR_INVA_Msk = 0x2000
	// Bit INVA.
	TC_BMR_INVA = 0x2000
	// Position of INVB field.
	TC_BMR_INVB_Pos = 0xe
	// Bit mask of INVB field.
	TC_BMR_INVB_Msk = 0x4000
	// Bit INVB.
	TC_BMR_INVB = 0x4000
	// Position of INVIDX field.
	TC_BMR_INVIDX_Pos = 0xf
	// Bit mask of INVIDX field.
	TC_BMR_INVIDX_Msk = 0x8000
	// Bit INVIDX.
	TC_BMR_INVIDX = 0x8000
	// Position of SWAP field.
	TC_BMR_SWAP_Pos = 0x10
	// Bit mask of SWAP field.
	TC_BMR_SWAP_Msk = 0x10000
	// Bit SWAP.
	TC_BMR_SWAP = 0x10000
	// Position of IDXPHB field.
	TC_BMR_IDXPHB_Pos = 0x11
	// Bit mask of IDXPHB field.
	TC_BMR_IDXPHB_Msk = 0x20000
	// Bit IDXPHB.
	TC_BMR_IDXPHB = 0x20000
	// Position of FILTER field.
	TC_BMR_FILTER_Pos = 0x13
	// Bit mask of FILTER field.
	TC_BMR_FILTER_Msk = 0x80000
	// Bit FILTER.
	TC_BMR_FILTER = 0x80000
	// Position of MAXFILT field.
	TC_BMR_MAXFILT_Pos = 0x14
	// Bit mask of MAXFILT field.
	TC_BMR_MAXFILT_Msk = 0x3f00000

	// QIER: QDEC Interrupt Enable Register
	// Position of IDX field.
	TC_QIER_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIER_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIER_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIER_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIER_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIER_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIER_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIER_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIER_QERR = 0x4

	// QIDR: QDEC Interrupt Disable Register
	// Position of IDX field.
	TC_QIDR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIDR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIDR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIDR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIDR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIDR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIDR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIDR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIDR_QERR = 0x4

	// QIMR: QDEC Interrupt Mask Register
	// Position of IDX field.
	TC_QIMR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIMR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIMR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIMR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIMR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIMR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIMR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIMR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIMR_QERR = 0x4

	// QISR: QDEC Interrupt Status Register
	// Position of IDX field.
	TC_QISR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QISR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QISR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QISR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QISR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QISR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QISR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QISR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QISR_QERR = 0x4
	// Position of DIR field.
	TC_QISR_DIR_Pos = 0x8
	// Bit mask of DIR field.
	TC_QISR_DIR_Msk = 0x100
	// Bit DIR.
	TC_QISR_DIR = 0x100

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	TC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	TC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	TC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	TC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	TC_WPMR_WPKEY_Msk = 0xffffff00
)

// Constants for TWI0: Two-wire Interface 0
const (
	// CR: Control Register
	// Position of START field.
	TWI_CR_START_Pos = 0x0
	// Bit mask of START field.
	TWI_CR_START_Msk = 0x1
	// Bit START.
	TWI_CR_START = 0x1
	// Position of STOP field.
	TWI_CR_STOP_Pos = 0x1
	// Bit mask of STOP field.
	TWI_CR_STOP_Msk = 0x2
	// Bit STOP.
	TWI_CR_STOP = 0x2
	// Position of MSEN field.
	TWI_CR_MSEN_Pos = 0x2
	// Bit mask of MSEN field.
	TWI_CR_MSEN_Msk = 0x4
	// Bit MSEN.
	TWI_CR_MSEN = 0x4
	// Position of MSDIS field.
	TWI_CR_MSDIS_Pos = 0x3
	// Bit mask of MSDIS field.
	TWI_CR_MSDIS_Msk = 0x8
	// Bit MSDIS.
	TWI_CR_MSDIS = 0x8
	// Position of SVEN field.
	TWI_CR_SVEN_Pos = 0x4
	// Bit mask of SVEN field.
	TWI_CR_SVEN_Msk = 0x10
	// Bit SVEN.
	TWI_CR_SVEN = 0x10
	// Position of SVDIS field.
	TWI_CR_SVDIS_Pos = 0x5
	// Bit mask of SVDIS field.
	TWI_CR_SVDIS_Msk = 0x20
	// Bit SVDIS.
	TWI_CR_SVDIS = 0x20
	// Position of QUICK field.
	TWI_CR_QUICK_Pos = 0x6
	// Bit mask of QUICK field.
	TWI_CR_QUICK_Msk = 0x40
	// Bit QUICK.
	TWI_CR_QUICK = 0x40
	// Position of SWRST field.
	TWI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	TWI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	TWI_CR_SWRST = 0x80

	// MMR: Master Mode Register
	// Position of IADRSZ field.
	TWI_MMR_IADRSZ_Pos = 0x8
	// Bit mask of IADRSZ field.
	TWI_MMR_IADRSZ_Msk = 0x300
	// No internal device address
	TWI_MMR_IADRSZ_NONE = 0x0
	// One-byte internal device address
	TWI_MMR_IADRSZ_1_BYTE = 0x1
	// Two-byte internal device address
	TWI_MMR_IADRSZ_2_BYTE = 0x2
	// Three-byte internal device address
	TWI_MMR_IADRSZ_3_BYTE = 0x3
	// Position of MREAD field.
	TWI_MMR_MREAD_Pos = 0xc
	// Bit mask of MREAD field.
	TWI_MMR_MREAD_Msk = 0x1000
	// Bit MREAD.
	TWI_MMR_MREAD = 0x1000
	// Position of DADR field.
	TWI_MMR_DADR_Pos = 0x10
	// Bit mask of DADR field.
	TWI_MMR_DADR_Msk = 0x7f0000

	// SMR: Slave Mode Register
	// Position of SADR field.
	TWI_SMR_SADR_Pos = 0x10
	// Bit mask of SADR field.
	TWI_SMR_SADR_Msk = 0x7f0000

	// IADR: Internal Address Register
	// Position of IADR field.
	TWI_IADR_IADR_Pos = 0x0
	// Bit mask of IADR field.
	TWI_IADR_IADR_Msk = 0xffffff

	// CWGR: Clock Waveform Generator Register
	// Position of CLDIV field.
	TWI_CWGR_CLDIV_Pos = 0x0
	// Bit mask of CLDIV field.
	TWI_CWGR_CLDIV_Msk = 0xff
	// Position of CHDIV field.
	TWI_CWGR_CHDIV_Pos = 0x8
	// Bit mask of CHDIV field.
	TWI_CWGR_CHDIV_Msk = 0xff00
	// Position of CKDIV field.
	TWI_CWGR_CKDIV_Pos = 0x10
	// Bit mask of CKDIV field.
	TWI_CWGR_CKDIV_Msk = 0x70000

	// SR: Status Register
	// Position of TXCOMP field.
	TWI_SR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_SR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_SR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_SR_TXRDY = 0x4
	// Position of SVREAD field.
	TWI_SR_SVREAD_Pos = 0x3
	// Bit mask of SVREAD field.
	TWI_SR_SVREAD_Msk = 0x8
	// Bit SVREAD.
	TWI_SR_SVREAD = 0x8
	// Position of SVACC field.
	TWI_SR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_SR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_SR_SVACC = 0x10
	// Position of GACC field.
	TWI_SR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_SR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_SR_GACC = 0x20
	// Position of OVRE field.
	TWI_SR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_SR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_SR_OVRE = 0x40
	// Position of NACK field.
	TWI_SR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_SR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_SR_NACK = 0x100
	// Position of ARBLST field.
	TWI_SR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_SR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_SR_ARBLST = 0x200
	// Position of SCLWS field.
	TWI_SR_SCLWS_Pos = 0xa
	// Bit mask of SCLWS field.
	TWI_SR_SCLWS_Msk = 0x400
	// Bit SCLWS.
	TWI_SR_SCLWS = 0x400
	// Position of EOSACC field.
	TWI_SR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_SR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_SR_EOSACC = 0x800

	// IER: Interrupt Enable Register
	// Position of TXCOMP field.
	TWI_IER_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IER_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IER_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IER_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IER_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IER_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IER_SVACC = 0x10
	// Position of GACC field.
	TWI_IER_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IER_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IER_GACC = 0x20
	// Position of OVRE field.
	TWI_IER_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IER_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IER_OVRE = 0x40
	// Position of NACK field.
	TWI_IER_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IER_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IER_NACK = 0x100
	// Position of ARBLST field.
	TWI_IER_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IER_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IER_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IER_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IER_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IER_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IER_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IER_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IER_EOSACC = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXCOMP field.
	TWI_IDR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IDR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IDR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IDR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IDR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IDR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IDR_SVACC = 0x10
	// Position of GACC field.
	TWI_IDR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IDR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IDR_GACC = 0x20
	// Position of OVRE field.
	TWI_IDR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IDR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IDR_OVRE = 0x40
	// Position of NACK field.
	TWI_IDR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IDR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IDR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IDR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IDR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IDR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IDR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IDR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IDR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IDR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IDR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IDR_EOSACC = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXCOMP field.
	TWI_IMR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IMR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IMR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IMR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IMR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IMR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IMR_SVACC = 0x10
	// Position of GACC field.
	TWI_IMR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IMR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IMR_GACC = 0x20
	// Position of OVRE field.
	TWI_IMR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IMR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IMR_OVRE = 0x40
	// Position of NACK field.
	TWI_IMR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IMR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IMR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IMR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IMR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IMR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IMR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IMR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IMR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IMR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IMR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IMR_EOSACC = 0x800

	// RHR: Receive Holding Register
	// Position of RXDATA field.
	TWI_RHR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	TWI_RHR_RXDATA_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXDATA field.
	TWI_THR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	TWI_THR_TXDATA_Msk = 0xff

	// WPROT_MODE: Protection Mode Register
	// Position of WPROT field.
	TWI_WPROT_MODE_WPROT_Pos = 0x0
	// Bit mask of WPROT field.
	TWI_WPROT_MODE_WPROT_Msk = 0x1
	// Bit WPROT.
	TWI_WPROT_MODE_WPROT = 0x1
	// Position of SECURITY_CODE field.
	TWI_WPROT_MODE_SECURITY_CODE_Pos = 0x8
	// Bit mask of SECURITY_CODE field.
	TWI_WPROT_MODE_SECURITY_CODE_Msk = 0xffffff00

	// WPROT_STATUS: Protection Status Register
	// Position of WPROTERR field.
	TWI_WPROT_STATUS_WPROTERR_Pos = 0x0
	// Bit mask of WPROTERR field.
	TWI_WPROT_STATUS_WPROTERR_Msk = 0x1
	// Bit WPROTERR.
	TWI_WPROT_STATUS_WPROTERR = 0x1
	// Position of WPROTADDR field.
	TWI_WPROT_STATUS_WPROTADDR_Pos = 0x8
	// Bit mask of WPROTADDR field.
	TWI_WPROT_STATUS_WPROTADDR_Msk = 0xffffff00
)

// Constants for USART0: Universal Synchronous Asynchronous Receiver Transmitter 0
const (
	// CR: Control Register
	// Position of RSTRX field.
	USART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_RSTSTA = 0x100
	// Position of STTBRK field.
	USART_CR_STTBRK_Pos = 0x9
	// Bit mask of STTBRK field.
	USART_CR_STTBRK_Msk = 0x200
	// Bit STTBRK.
	USART_CR_STTBRK = 0x200
	// Position of STPBRK field.
	USART_CR_STPBRK_Pos = 0xa
	// Bit mask of STPBRK field.
	USART_CR_STPBRK_Msk = 0x400
	// Bit STPBRK.
	USART_CR_STPBRK = 0x400
	// Position of STTTO field.
	USART_CR_STTTO_Pos = 0xb
	// Bit mask of STTTO field.
	USART_CR_STTTO_Msk = 0x800
	// Bit STTTO.
	USART_CR_STTTO = 0x800
	// Position of SENDA field.
	USART_CR_SENDA_Pos = 0xc
	// Bit mask of SENDA field.
	USART_CR_SENDA_Msk = 0x1000
	// Bit SENDA.
	USART_CR_SENDA = 0x1000
	// Position of RSTIT field.
	USART_CR_RSTIT_Pos = 0xd
	// Bit mask of RSTIT field.
	USART_CR_RSTIT_Msk = 0x2000
	// Bit RSTIT.
	USART_CR_RSTIT = 0x2000
	// Position of RSTNACK field.
	USART_CR_RSTNACK_Pos = 0xe
	// Bit mask of RSTNACK field.
	USART_CR_RSTNACK_Msk = 0x4000
	// Bit RSTNACK.
	USART_CR_RSTNACK = 0x4000
	// Position of RETTO field.
	USART_CR_RETTO_Pos = 0xf
	// Bit mask of RETTO field.
	USART_CR_RETTO_Msk = 0x8000
	// Bit RETTO.
	USART_CR_RETTO = 0x8000
	// Position of RTSEN field.
	USART_CR_RTSEN_Pos = 0x12
	// Bit mask of RTSEN field.
	USART_CR_RTSEN_Msk = 0x40000
	// Bit RTSEN.
	USART_CR_RTSEN = 0x40000
	// Position of RTSDIS field.
	USART_CR_RTSDIS_Pos = 0x13
	// Bit mask of RTSDIS field.
	USART_CR_RTSDIS_Msk = 0x80000
	// Bit RTSDIS.
	USART_CR_RTSDIS = 0x80000

	// CR_SPI_MODE: Control Register
	// Position of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_SPI_MODE_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_SPI_MODE_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_SPI_MODE_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_SPI_MODE_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_SPI_MODE_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_SPI_MODE_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_SPI_MODE_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_SPI_MODE_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_SPI_MODE_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_SPI_MODE_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_SPI_MODE_RSTSTA = 0x100
	// Position of FCS field.
	USART_CR_SPI_MODE_FCS_Pos = 0x12
	// Bit mask of FCS field.
	USART_CR_SPI_MODE_FCS_Msk = 0x40000
	// Bit FCS.
	USART_CR_SPI_MODE_FCS = 0x40000
	// Position of RCS field.
	USART_CR_SPI_MODE_RCS_Pos = 0x13
	// Bit mask of RCS field.
	USART_CR_SPI_MODE_RCS_Msk = 0x80000
	// Bit RCS.
	USART_CR_SPI_MODE_RCS = 0x80000

	// MR: Mode Register
	// Position of USART_MODE field.
	USART_MR_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_USART_MODE_Msk = 0xf
	// Normal mode
	USART_MR_USART_MODE_NORMAL = 0x0
	// RS485
	USART_MR_USART_MODE_RS485 = 0x1
	// Hardware Handshaking
	USART_MR_USART_MODE_HW_HANDSHAKING = 0x2
	// IS07816 Protocol: T = 0
	USART_MR_USART_MODE_IS07816_T_0 = 0x4
	// IS07816 Protocol: T = 1
	USART_MR_USART_MODE_IS07816_T_1 = 0x6
	// IrDA
	USART_MR_USART_MODE_IRDA = 0x8
	// SPI Master
	USART_MR_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=(DIV=8)) is selected
	USART_MR_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_CHRL_Msk = 0xc0
	// Character length is 5 bits
	USART_MR_CHRL_5_BIT = 0x0
	// Character length is 6 bits
	USART_MR_CHRL_6_BIT = 0x1
	// Character length is 7 bits
	USART_MR_CHRL_7_BIT = 0x2
	// Character length is 8 bits
	USART_MR_CHRL_8_BIT = 0x3
	// Position of SYNC field.
	USART_MR_SYNC_Pos = 0x8
	// Bit mask of SYNC field.
	USART_MR_SYNC_Msk = 0x100
	// Bit SYNC.
	USART_MR_SYNC = 0x100
	// Position of PAR field.
	USART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	USART_MR_PAR_Msk = 0xe00
	// Even parity
	USART_MR_PAR_EVEN = 0x0
	// Odd parity
	USART_MR_PAR_ODD = 0x1
	// Parity forced to 0 (Space)
	USART_MR_PAR_SPACE = 0x2
	// Parity forced to 1 (Mark)
	USART_MR_PAR_MARK = 0x3
	// No parity
	USART_MR_PAR_NO = 0x4
	// Multidrop mode
	USART_MR_PAR_MULTIDROP = 0x6
	// Position of NBSTOP field.
	USART_MR_NBSTOP_Pos = 0xc
	// Bit mask of NBSTOP field.
	USART_MR_NBSTOP_Msk = 0x3000
	// 1 stop bit
	USART_MR_NBSTOP_1_BIT = 0x0
	// 1.5 stop bit (SYNC = 0) or reserved (SYNC = 1)
	USART_MR_NBSTOP_1_5_BIT = 0x1
	// 2 stop bits
	USART_MR_NBSTOP_2_BIT = 0x2
	// Position of CHMODE field.
	USART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	USART_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	USART_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo. Receiver input is connected to the TXD pin.
	USART_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback. Transmitter output is connected to the Receiver Input.
	USART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback. RXD pin is internally connected to the TXD pin.
	USART_MR_CHMODE_REMOTE_LOOPBACK = 0x3
	// Position of MSBF field.
	USART_MR_MSBF_Pos = 0x10
	// Bit mask of MSBF field.
	USART_MR_MSBF_Msk = 0x10000
	// Bit MSBF.
	USART_MR_MSBF = 0x10000
	// Position of MODE9 field.
	USART_MR_MODE9_Pos = 0x11
	// Bit mask of MODE9 field.
	USART_MR_MODE9_Msk = 0x20000
	// Bit MODE9.
	USART_MR_MODE9 = 0x20000
	// Position of CLKO field.
	USART_MR_CLKO_Pos = 0x12
	// Bit mask of CLKO field.
	USART_MR_CLKO_Msk = 0x40000
	// Bit CLKO.
	USART_MR_CLKO = 0x40000
	// Position of OVER field.
	USART_MR_OVER_Pos = 0x13
	// Bit mask of OVER field.
	USART_MR_OVER_Msk = 0x80000
	// Bit OVER.
	USART_MR_OVER = 0x80000
	// Position of INACK field.
	USART_MR_INACK_Pos = 0x14
	// Bit mask of INACK field.
	USART_MR_INACK_Msk = 0x100000
	// Bit INACK.
	USART_MR_INACK = 0x100000
	// Position of DSNACK field.
	USART_MR_DSNACK_Pos = 0x15
	// Bit mask of DSNACK field.
	USART_MR_DSNACK_Msk = 0x200000
	// Bit DSNACK.
	USART_MR_DSNACK = 0x200000
	// Position of VAR_SYNC field.
	USART_MR_VAR_SYNC_Pos = 0x16
	// Bit mask of VAR_SYNC field.
	USART_MR_VAR_SYNC_Msk = 0x400000
	// Bit VAR_SYNC.
	USART_MR_VAR_SYNC = 0x400000
	// Position of INVDATA field.
	USART_MR_INVDATA_Pos = 0x17
	// Bit mask of INVDATA field.
	USART_MR_INVDATA_Msk = 0x800000
	// Bit INVDATA.
	USART_MR_INVDATA = 0x800000
	// Position of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Pos = 0x18
	// Bit mask of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Msk = 0x7000000
	// Position of FILTER field.
	USART_MR_FILTER_Pos = 0x1c
	// Bit mask of FILTER field.
	USART_MR_FILTER_Msk = 0x10000000
	// Bit FILTER.
	USART_MR_FILTER = 0x10000000
	// Position of MAN field.
	USART_MR_MAN_Pos = 0x1d
	// Bit mask of MAN field.
	USART_MR_MAN_Msk = 0x20000000
	// Bit MAN.
	USART_MR_MAN = 0x20000000
	// Position of MODSYNC field.
	USART_MR_MODSYNC_Pos = 0x1e
	// Bit mask of MODSYNC field.
	USART_MR_MODSYNC_Msk = 0x40000000
	// Bit MODSYNC.
	USART_MR_MODSYNC = 0x40000000
	// Position of ONEBIT field.
	USART_MR_ONEBIT_Pos = 0x1f
	// Bit mask of ONEBIT field.
	USART_MR_ONEBIT_Msk = 0x80000000
	// Bit ONEBIT.
	USART_MR_ONEBIT = 0x80000000

	// MR_SPI_MODE: Mode Register
	// Position of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Msk = 0xf
	// SPI Master
	USART_MR_SPI_MODE_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_SPI_MODE_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_SPI_MODE_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=(DIV=8)) is selected
	USART_MR_SPI_MODE_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_SPI_MODE_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_SPI_MODE_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_SPI_MODE_CHRL_Msk = 0xc0
	// Character length is 8 bits
	USART_MR_SPI_MODE_CHRL_8_BIT = 0x3
	// Position of CPHA field.
	USART_MR_SPI_MODE_CPHA_Pos = 0x8
	// Bit mask of CPHA field.
	USART_MR_SPI_MODE_CPHA_Msk = 0x100
	// Bit CPHA.
	USART_MR_SPI_MODE_CPHA = 0x100
	// Position of CPOL field.
	USART_MR_SPI_MODE_CPOL_Pos = 0x10
	// Bit mask of CPOL field.
	USART_MR_SPI_MODE_CPOL_Msk = 0x10000
	// Bit CPOL.
	USART_MR_SPI_MODE_CPOL = 0x10000
	// Position of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Pos = 0x14
	// Bit mask of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Msk = 0x100000
	// Bit WRDBT.
	USART_MR_SPI_MODE_WRDBT = 0x100000

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IER_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IER_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IER_RXBRK = 0x4
	// Position of OVRE field.
	USART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_OVRE = 0x20
	// Position of FRAME field.
	USART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IER_FRAME = 0x40
	// Position of PARE field.
	USART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IER_PARE_Msk = 0x80
	// Bit PARE.
	USART_IER_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IER_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IER_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IER_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IER_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IER_ITER_Msk = 0x400
	// Bit ITER.
	USART_IER_ITER = 0x400
	// Position of NACK field.
	USART_IER_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IER_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IER_NACK = 0x2000
	// Position of CTSIC field.
	USART_IER_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IER_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IER_CTSIC = 0x80000
	// Position of MANE field.
	USART_IER_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IER_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IER_MANE = 0x1000000

	// IER_SPI_MODE: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IER_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IER_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IER_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IER_SPI_MODE_UNRE = 0x400

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IDR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IDR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IDR_RXBRK = 0x4
	// Position of OVRE field.
	USART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_OVRE = 0x20
	// Position of FRAME field.
	USART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IDR_FRAME = 0x40
	// Position of PARE field.
	USART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IDR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IDR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IDR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IDR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IDR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IDR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IDR_ITER = 0x400
	// Position of NACK field.
	USART_IDR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IDR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IDR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IDR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IDR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IDR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IDR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IDR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IDR_MANE = 0x1000000

	// IDR_SPI_MODE: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IDR_SPI_MODE_UNRE = 0x400

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IMR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IMR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IMR_RXBRK = 0x4
	// Position of OVRE field.
	USART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_OVRE = 0x20
	// Position of FRAME field.
	USART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IMR_FRAME = 0x40
	// Position of PARE field.
	USART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IMR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IMR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IMR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IMR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IMR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IMR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IMR_ITER = 0x400
	// Position of NACK field.
	USART_IMR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IMR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IMR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IMR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IMR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IMR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IMR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IMR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IMR_MANE = 0x1000000

	// IMR_SPI_MODE: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IMR_SPI_MODE_UNRE = 0x400

	// CSR: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_CSR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_CSR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_CSR_RXBRK = 0x4
	// Position of OVRE field.
	USART_CSR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_OVRE = 0x20
	// Position of FRAME field.
	USART_CSR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_CSR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_CSR_FRAME = 0x40
	// Position of PARE field.
	USART_CSR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_CSR_PARE_Msk = 0x80
	// Bit PARE.
	USART_CSR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_CSR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_CSR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_CSR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_CSR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_CSR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_CSR_ITER_Msk = 0x400
	// Bit ITER.
	USART_CSR_ITER = 0x400
	// Position of NACK field.
	USART_CSR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_CSR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_CSR_NACK = 0x2000
	// Position of CTSIC field.
	USART_CSR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_CSR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_CSR_CTSIC = 0x80000
	// Position of CTS field.
	USART_CSR_CTS_Pos = 0x17
	// Bit mask of CTS field.
	USART_CSR_CTS_Msk = 0x800000
	// Bit CTS.
	USART_CSR_CTS = 0x800000
	// Position of MANERR field.
	USART_CSR_MANERR_Pos = 0x18
	// Bit mask of MANERR field.
	USART_CSR_MANERR_Msk = 0x1000000
	// Bit MANERR.
	USART_CSR_MANERR = 0x1000000

	// CSR_SPI_MODE: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_CSR_SPI_MODE_UNRE = 0x400

	// RHR: Receiver Holding Register
	// Position of RXCHR field.
	USART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	USART_RHR_RXCHR_Msk = 0x1ff
	// Position of RXSYNH field.
	USART_RHR_RXSYNH_Pos = 0xf
	// Bit mask of RXSYNH field.
	USART_RHR_RXSYNH_Msk = 0x8000
	// Bit RXSYNH.
	USART_RHR_RXSYNH = 0x8000

	// THR: Transmitter Holding Register
	// Position of TXCHR field.
	USART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	USART_THR_TXCHR_Msk = 0x1ff
	// Position of TXSYNH field.
	USART_THR_TXSYNH_Pos = 0xf
	// Bit mask of TXSYNH field.
	USART_THR_TXSYNH_Msk = 0x8000
	// Bit TXSYNH.
	USART_THR_TXSYNH = 0x8000

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	USART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	USART_BRGR_CD_Msk = 0xffff
	// Position of FP field.
	USART_BRGR_FP_Pos = 0x10
	// Bit mask of FP field.
	USART_BRGR_FP_Msk = 0x70000

	// RTOR: Receiver Time-out Register
	// Position of TO field.
	USART_RTOR_TO_Pos = 0x0
	// Bit mask of TO field.
	USART_RTOR_TO_Msk = 0xffff

	// TTGR: Transmitter Timeguard Register
	// Position of TG field.
	USART_TTGR_TG_Pos = 0x0
	// Bit mask of TG field.
	USART_TTGR_TG_Msk = 0xff

	// FIDI: FI DI Ratio Register
	// Position of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Pos = 0x0
	// Bit mask of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Msk = 0x7ff

	// NER: Number of Errors Register
	// Position of NB_ERRORS field.
	USART_NER_NB_ERRORS_Pos = 0x0
	// Bit mask of NB_ERRORS field.
	USART_NER_NB_ERRORS_Msk = 0xff

	// IF: IrDA Filter Register
	// Position of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Pos = 0x0
	// Bit mask of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Msk = 0xff

	// MAN: Manchester Encoder Decoder Register
	// Position of TX_PL field.
	USART_MAN_TX_PL_Pos = 0x0
	// Bit mask of TX_PL field.
	USART_MAN_TX_PL_Msk = 0xf
	// Position of TX_PP field.
	USART_MAN_TX_PP_Pos = 0x8
	// Bit mask of TX_PP field.
	USART_MAN_TX_PP_Msk = 0x300
	// The preamble is composed of '1's
	USART_MAN_TX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_TX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_TX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_TX_PP_ONE_ZERO = 0x3
	// Position of TX_MPOL field.
	USART_MAN_TX_MPOL_Pos = 0xc
	// Bit mask of TX_MPOL field.
	USART_MAN_TX_MPOL_Msk = 0x1000
	// Bit TX_MPOL.
	USART_MAN_TX_MPOL = 0x1000
	// Position of RX_PL field.
	USART_MAN_RX_PL_Pos = 0x10
	// Bit mask of RX_PL field.
	USART_MAN_RX_PL_Msk = 0xf0000
	// Position of RX_PP field.
	USART_MAN_RX_PP_Pos = 0x18
	// Bit mask of RX_PP field.
	USART_MAN_RX_PP_Msk = 0x3000000
	// The preamble is composed of '1's
	USART_MAN_RX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_RX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_RX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_RX_PP_ONE_ZERO = 0x3
	// Position of RX_MPOL field.
	USART_MAN_RX_MPOL_Pos = 0x1c
	// Bit mask of RX_MPOL field.
	USART_MAN_RX_MPOL_Msk = 0x10000000
	// Bit RX_MPOL.
	USART_MAN_RX_MPOL = 0x10000000
	// Position of ONE field.
	USART_MAN_ONE_Pos = 0x1d
	// Bit mask of ONE field.
	USART_MAN_ONE_Msk = 0x20000000
	// Bit ONE.
	USART_MAN_ONE = 0x20000000
	// Position of DRIFT field.
	USART_MAN_DRIFT_Pos = 0x1e
	// Bit mask of DRIFT field.
	USART_MAN_DRIFT_Msk = 0x40000000
	// Bit DRIFT.
	USART_MAN_DRIFT = 0x40000000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	USART_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	USART_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	USART_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	USART_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	USART_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	USART_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	USART_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	USART_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	USART_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	USART_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for UART0: Universal Asynchronous Receiver Transmitter 0
const (
	// CR: Control Register
	// Position of RSTRX field.
	UART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	UART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	UART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	UART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	UART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	UART_CR_RSTTX = 0x8
	// Position of RXEN field.
	UART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	UART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	UART_CR_RXEN = 0x10
	// Position of RXDIS field.
	UART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	UART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	UART_CR_RXDIS = 0x20
	// Position of TXEN field.
	UART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	UART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	UART_CR_TXEN = 0x40
	// Position of TXDIS field.
	UART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	UART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	UART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	UART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	UART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	UART_CR_RSTSTA = 0x100

	// MR: Mode Register
	// Position of PAR field.
	UART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	UART_MR_PAR_Msk = 0xe00
	// Even Parity
	UART_MR_PAR_EVEN = 0x0
	// Odd Parity
	UART_MR_PAR_ODD = 0x1
	// Space: parity forced to 0
	UART_MR_PAR_SPACE = 0x2
	// Mark: parity forced to 1
	UART_MR_PAR_MARK = 0x3
	// No Parity
	UART_MR_PAR_NO = 0x4
	// Position of CHMODE field.
	UART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	UART_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	UART_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo
	UART_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback
	UART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback
	UART_MR_CHMODE_REMOTE_LOOPBACK = 0x3

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	UART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IER_TXRDY = 0x2
	// Position of OVRE field.
	UART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IER_OVRE = 0x20
	// Position of FRAME field.
	UART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IER_FRAME = 0x40
	// Position of PARE field.
	UART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IER_PARE_Msk = 0x80
	// Bit PARE.
	UART_IER_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IER_TXEMPTY = 0x200

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	UART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IDR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IDR_OVRE = 0x20
	// Position of FRAME field.
	UART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IDR_FRAME = 0x40
	// Position of PARE field.
	UART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IDR_TXEMPTY = 0x200

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	UART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IMR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IMR_OVRE = 0x20
	// Position of FRAME field.
	UART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IMR_FRAME = 0x40
	// Position of PARE field.
	UART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IMR_TXEMPTY = 0x200

	// SR: Status Register
	// Position of RXRDY field.
	UART_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_SR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_SR_TXRDY = 0x2
	// Position of OVRE field.
	UART_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_SR_OVRE = 0x20
	// Position of FRAME field.
	UART_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_SR_FRAME = 0x40
	// Position of PARE field.
	UART_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_SR_PARE_Msk = 0x80
	// Bit PARE.
	UART_SR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_SR_TXEMPTY = 0x200

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	UART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	UART_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	UART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	UART_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	UART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	UART_BRGR_CD_Msk = 0xffff
)

// Constants for PWM: Pulse Width Modulation Controller
const (
	// CLK: PWM Clock Register
	// Position of DIVA field.
	PWM_CLK_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PWM_CLK_DIVA_Msk = 0xff
	// Position of PREA field.
	PWM_CLK_PREA_Pos = 0x8
	// Bit mask of PREA field.
	PWM_CLK_PREA_Msk = 0xf00
	// Position of DIVB field.
	PWM_CLK_DIVB_Pos = 0x10
	// Bit mask of DIVB field.
	PWM_CLK_DIVB_Msk = 0xff0000
	// Position of PREB field.
	PWM_CLK_PREB_Pos = 0x18
	// Bit mask of PREB field.
	PWM_CLK_PREB_Msk = 0xf000000

	// ENA: PWM Enable Register
	// Position of CHID0 field.
	PWM_ENA_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ENA_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ENA_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ENA_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ENA_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ENA_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ENA_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ENA_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ENA_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ENA_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ENA_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ENA_CHID3 = 0x8

	// DIS: PWM Disable Register
	// Position of CHID0 field.
	PWM_DIS_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_DIS_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_DIS_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_DIS_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_DIS_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_DIS_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_DIS_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_DIS_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_DIS_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_DIS_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_DIS_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_DIS_CHID3 = 0x8

	// SR: PWM Status Register
	// Position of CHID0 field.
	PWM_SR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_SR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_SR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_SR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_SR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_SR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_SR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_SR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_SR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_SR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_SR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_SR_CHID3 = 0x8

	// IER1: PWM Interrupt Enable Register 1
	// Position of CHID0 field.
	PWM_IER1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IER1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IER1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IER1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IER1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IER1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IER1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IER1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IER1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IER1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IER1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IER1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IER1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IER1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IER1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IER1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IER1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IER1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IER1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IER1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IER1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IER1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IER1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IER1_FCHID3 = 0x80000

	// IDR1: PWM Interrupt Disable Register 1
	// Position of CHID0 field.
	PWM_IDR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IDR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IDR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IDR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IDR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IDR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IDR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IDR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IDR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IDR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IDR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IDR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IDR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IDR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IDR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IDR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IDR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IDR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IDR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IDR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IDR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IDR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IDR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IDR1_FCHID3 = 0x80000

	// IMR1: PWM Interrupt Mask Register 1
	// Position of CHID0 field.
	PWM_IMR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IMR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IMR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IMR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IMR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IMR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IMR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IMR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IMR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IMR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IMR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IMR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IMR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IMR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IMR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IMR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IMR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IMR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IMR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IMR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IMR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IMR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IMR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IMR1_FCHID3 = 0x80000

	// ISR1: PWM Interrupt Status Register 1
	// Position of CHID0 field.
	PWM_ISR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ISR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ISR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ISR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ISR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ISR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ISR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ISR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ISR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ISR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ISR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ISR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_ISR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_ISR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_ISR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_ISR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_ISR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_ISR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_ISR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_ISR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_ISR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_ISR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_ISR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_ISR1_FCHID3 = 0x80000

	// SCM: PWM Sync Channels Mode Register
	// Position of SYNC0 field.
	PWM_SCM_SYNC0_Pos = 0x0
	// Bit mask of SYNC0 field.
	PWM_SCM_SYNC0_Msk = 0x1
	// Bit SYNC0.
	PWM_SCM_SYNC0 = 0x1
	// Position of SYNC1 field.
	PWM_SCM_SYNC1_Pos = 0x1
	// Bit mask of SYNC1 field.
	PWM_SCM_SYNC1_Msk = 0x2
	// Bit SYNC1.
	PWM_SCM_SYNC1 = 0x2
	// Position of SYNC2 field.
	PWM_SCM_SYNC2_Pos = 0x2
	// Bit mask of SYNC2 field.
	PWM_SCM_SYNC2_Msk = 0x4
	// Bit SYNC2.
	PWM_SCM_SYNC2 = 0x4
	// Position of SYNC3 field.
	PWM_SCM_SYNC3_Pos = 0x3
	// Bit mask of SYNC3 field.
	PWM_SCM_SYNC3_Msk = 0x8
	// Bit SYNC3.
	PWM_SCM_SYNC3 = 0x8
	// Position of UPDM field.
	PWM_SCM_UPDM_Pos = 0x10
	// Bit mask of UPDM field.
	PWM_SCM_UPDM_Msk = 0x30000
	// Manual write of double buffer registers and manual update of synchronous channels
	PWM_SCM_UPDM_MODE0 = 0x0
	// Manual write of double buffer registers and automatic update of synchronous channels
	PWM_SCM_UPDM_MODE1 = 0x1

	// SCUC: PWM Sync Channels Update Control Register
	// Position of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Pos = 0x0
	// Bit mask of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Msk = 0x1
	// Bit UPDULOCK.
	PWM_SCUC_UPDULOCK = 0x1

	// SCUP: PWM Sync Channels Update Period Register
	// Position of UPR field.
	PWM_SCUP_UPR_Pos = 0x0
	// Bit mask of UPR field.
	PWM_SCUP_UPR_Msk = 0xf
	// Position of UPRCNT field.
	PWM_SCUP_UPRCNT_Pos = 0x4
	// Bit mask of UPRCNT field.
	PWM_SCUP_UPRCNT_Msk = 0xf0

	// SCUPUPD: PWM Sync Channels Update Period Update Register
	// Position of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Pos = 0x0
	// Bit mask of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Msk = 0xf

	// IER2: PWM Interrupt Enable Register 2
	// Position of WRDY field.
	PWM_IER2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IER2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IER2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IER2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IER2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IER2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IER2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IER2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IER2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IER2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IER2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IER2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IER2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IER2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IER2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IER2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IER2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IER2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IER2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IER2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IER2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IER2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IER2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IER2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IER2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IER2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IER2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IER2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IER2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IER2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IER2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IER2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IER2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IER2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IER2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IER2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IER2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IER2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IER2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IER2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IER2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IER2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IER2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IER2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IER2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IER2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IER2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IER2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IER2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IER2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IER2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IER2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IER2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IER2_CMPU7 = 0x800000

	// IDR2: PWM Interrupt Disable Register 2
	// Position of WRDY field.
	PWM_IDR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IDR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IDR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IDR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IDR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IDR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IDR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IDR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IDR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IDR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IDR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IDR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IDR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IDR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IDR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IDR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IDR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IDR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IDR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IDR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IDR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IDR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IDR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IDR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IDR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IDR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IDR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IDR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IDR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IDR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IDR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IDR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IDR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IDR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IDR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IDR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IDR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IDR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IDR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IDR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IDR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IDR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IDR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IDR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IDR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IDR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IDR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IDR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IDR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IDR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IDR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IDR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IDR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IDR2_CMPU7 = 0x800000

	// IMR2: PWM Interrupt Mask Register 2
	// Position of WRDY field.
	PWM_IMR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IMR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IMR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IMR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IMR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IMR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IMR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IMR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IMR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IMR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IMR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IMR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IMR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IMR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IMR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IMR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IMR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IMR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IMR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IMR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IMR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IMR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IMR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IMR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IMR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IMR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IMR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IMR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IMR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IMR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IMR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IMR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IMR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IMR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IMR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IMR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IMR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IMR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IMR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IMR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IMR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IMR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IMR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IMR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IMR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IMR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IMR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IMR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IMR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IMR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IMR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IMR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IMR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IMR2_CMPU7 = 0x800000

	// ISR2: PWM Interrupt Status Register 2
	// Position of WRDY field.
	PWM_ISR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_ISR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_ISR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_ISR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_ISR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_ISR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_ISR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_ISR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_ISR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_ISR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_ISR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_ISR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_ISR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_ISR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_ISR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_ISR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_ISR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_ISR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_ISR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_ISR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_ISR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_ISR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_ISR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_ISR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_ISR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_ISR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_ISR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_ISR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_ISR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_ISR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_ISR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_ISR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_ISR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_ISR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_ISR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_ISR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_ISR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_ISR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_ISR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_ISR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_ISR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_ISR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_ISR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_ISR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_ISR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_ISR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_ISR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_ISR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_ISR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_ISR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_ISR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_ISR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_ISR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_ISR2_CMPU7 = 0x800000

	// OOV: PWM Output Override Value Register
	// Position of OOVH0 field.
	PWM_OOV_OOVH0_Pos = 0x0
	// Bit mask of OOVH0 field.
	PWM_OOV_OOVH0_Msk = 0x1
	// Bit OOVH0.
	PWM_OOV_OOVH0 = 0x1
	// Position of OOVH1 field.
	PWM_OOV_OOVH1_Pos = 0x1
	// Bit mask of OOVH1 field.
	PWM_OOV_OOVH1_Msk = 0x2
	// Bit OOVH1.
	PWM_OOV_OOVH1 = 0x2
	// Position of OOVH2 field.
	PWM_OOV_OOVH2_Pos = 0x2
	// Bit mask of OOVH2 field.
	PWM_OOV_OOVH2_Msk = 0x4
	// Bit OOVH2.
	PWM_OOV_OOVH2 = 0x4
	// Position of OOVH3 field.
	PWM_OOV_OOVH3_Pos = 0x3
	// Bit mask of OOVH3 field.
	PWM_OOV_OOVH3_Msk = 0x8
	// Bit OOVH3.
	PWM_OOV_OOVH3 = 0x8
	// Position of OOVL0 field.
	PWM_OOV_OOVL0_Pos = 0x10
	// Bit mask of OOVL0 field.
	PWM_OOV_OOVL0_Msk = 0x10000
	// Bit OOVL0.
	PWM_OOV_OOVL0 = 0x10000
	// Position of OOVL1 field.
	PWM_OOV_OOVL1_Pos = 0x11
	// Bit mask of OOVL1 field.
	PWM_OOV_OOVL1_Msk = 0x20000
	// Bit OOVL1.
	PWM_OOV_OOVL1 = 0x20000
	// Position of OOVL2 field.
	PWM_OOV_OOVL2_Pos = 0x12
	// Bit mask of OOVL2 field.
	PWM_OOV_OOVL2_Msk = 0x40000
	// Bit OOVL2.
	PWM_OOV_OOVL2 = 0x40000
	// Position of OOVL3 field.
	PWM_OOV_OOVL3_Pos = 0x13
	// Bit mask of OOVL3 field.
	PWM_OOV_OOVL3_Msk = 0x80000
	// Bit OOVL3.
	PWM_OOV_OOVL3 = 0x80000

	// OS: PWM Output Selection Register
	// Position of OSH0 field.
	PWM_OS_OSH0_Pos = 0x0
	// Bit mask of OSH0 field.
	PWM_OS_OSH0_Msk = 0x1
	// Bit OSH0.
	PWM_OS_OSH0 = 0x1
	// Position of OSH1 field.
	PWM_OS_OSH1_Pos = 0x1
	// Bit mask of OSH1 field.
	PWM_OS_OSH1_Msk = 0x2
	// Bit OSH1.
	PWM_OS_OSH1 = 0x2
	// Position of OSH2 field.
	PWM_OS_OSH2_Pos = 0x2
	// Bit mask of OSH2 field.
	PWM_OS_OSH2_Msk = 0x4
	// Bit OSH2.
	PWM_OS_OSH2 = 0x4
	// Position of OSH3 field.
	PWM_OS_OSH3_Pos = 0x3
	// Bit mask of OSH3 field.
	PWM_OS_OSH3_Msk = 0x8
	// Bit OSH3.
	PWM_OS_OSH3 = 0x8
	// Position of OSL0 field.
	PWM_OS_OSL0_Pos = 0x10
	// Bit mask of OSL0 field.
	PWM_OS_OSL0_Msk = 0x10000
	// Bit OSL0.
	PWM_OS_OSL0 = 0x10000
	// Position of OSL1 field.
	PWM_OS_OSL1_Pos = 0x11
	// Bit mask of OSL1 field.
	PWM_OS_OSL1_Msk = 0x20000
	// Bit OSL1.
	PWM_OS_OSL1 = 0x20000
	// Position of OSL2 field.
	PWM_OS_OSL2_Pos = 0x12
	// Bit mask of OSL2 field.
	PWM_OS_OSL2_Msk = 0x40000
	// Bit OSL2.
	PWM_OS_OSL2 = 0x40000
	// Position of OSL3 field.
	PWM_OS_OSL3_Pos = 0x13
	// Bit mask of OSL3 field.
	PWM_OS_OSL3_Msk = 0x80000
	// Bit OSL3.
	PWM_OS_OSL3 = 0x80000

	// OSS: PWM Output Selection Set Register
	// Position of OSSH0 field.
	PWM_OSS_OSSH0_Pos = 0x0
	// Bit mask of OSSH0 field.
	PWM_OSS_OSSH0_Msk = 0x1
	// Bit OSSH0.
	PWM_OSS_OSSH0 = 0x1
	// Position of OSSH1 field.
	PWM_OSS_OSSH1_Pos = 0x1
	// Bit mask of OSSH1 field.
	PWM_OSS_OSSH1_Msk = 0x2
	// Bit OSSH1.
	PWM_OSS_OSSH1 = 0x2
	// Position of OSSH2 field.
	PWM_OSS_OSSH2_Pos = 0x2
	// Bit mask of OSSH2 field.
	PWM_OSS_OSSH2_Msk = 0x4
	// Bit OSSH2.
	PWM_OSS_OSSH2 = 0x4
	// Position of OSSH3 field.
	PWM_OSS_OSSH3_Pos = 0x3
	// Bit mask of OSSH3 field.
	PWM_OSS_OSSH3_Msk = 0x8
	// Bit OSSH3.
	PWM_OSS_OSSH3 = 0x8
	// Position of OSSL0 field.
	PWM_OSS_OSSL0_Pos = 0x10
	// Bit mask of OSSL0 field.
	PWM_OSS_OSSL0_Msk = 0x10000
	// Bit OSSL0.
	PWM_OSS_OSSL0 = 0x10000
	// Position of OSSL1 field.
	PWM_OSS_OSSL1_Pos = 0x11
	// Bit mask of OSSL1 field.
	PWM_OSS_OSSL1_Msk = 0x20000
	// Bit OSSL1.
	PWM_OSS_OSSL1 = 0x20000
	// Position of OSSL2 field.
	PWM_OSS_OSSL2_Pos = 0x12
	// Bit mask of OSSL2 field.
	PWM_OSS_OSSL2_Msk = 0x40000
	// Bit OSSL2.
	PWM_OSS_OSSL2 = 0x40000
	// Position of OSSL3 field.
	PWM_OSS_OSSL3_Pos = 0x13
	// Bit mask of OSSL3 field.
	PWM_OSS_OSSL3_Msk = 0x80000
	// Bit OSSL3.
	PWM_OSS_OSSL3 = 0x80000

	// OSC: PWM Output Selection Clear Register
	// Position of OSCH0 field.
	PWM_OSC_OSCH0_Pos = 0x0
	// Bit mask of OSCH0 field.
	PWM_OSC_OSCH0_Msk = 0x1
	// Bit OSCH0.
	PWM_OSC_OSCH0 = 0x1
	// Position of OSCH1 field.
	PWM_OSC_OSCH1_Pos = 0x1
	// Bit mask of OSCH1 field.
	PWM_OSC_OSCH1_Msk = 0x2
	// Bit OSCH1.
	PWM_OSC_OSCH1 = 0x2
	// Position of OSCH2 field.
	PWM_OSC_OSCH2_Pos = 0x2
	// Bit mask of OSCH2 field.
	PWM_OSC_OSCH2_Msk = 0x4
	// Bit OSCH2.
	PWM_OSC_OSCH2 = 0x4
	// Position of OSCH3 field.
	PWM_OSC_OSCH3_Pos = 0x3
	// Bit mask of OSCH3 field.
	PWM_OSC_OSCH3_Msk = 0x8
	// Bit OSCH3.
	PWM_OSC_OSCH3 = 0x8
	// Position of OSCL0 field.
	PWM_OSC_OSCL0_Pos = 0x10
	// Bit mask of OSCL0 field.
	PWM_OSC_OSCL0_Msk = 0x10000
	// Bit OSCL0.
	PWM_OSC_OSCL0 = 0x10000
	// Position of OSCL1 field.
	PWM_OSC_OSCL1_Pos = 0x11
	// Bit mask of OSCL1 field.
	PWM_OSC_OSCL1_Msk = 0x20000
	// Bit OSCL1.
	PWM_OSC_OSCL1 = 0x20000
	// Position of OSCL2 field.
	PWM_OSC_OSCL2_Pos = 0x12
	// Bit mask of OSCL2 field.
	PWM_OSC_OSCL2_Msk = 0x40000
	// Bit OSCL2.
	PWM_OSC_OSCL2 = 0x40000
	// Position of OSCL3 field.
	PWM_OSC_OSCL3_Pos = 0x13
	// Bit mask of OSCL3 field.
	PWM_OSC_OSCL3_Msk = 0x80000
	// Bit OSCL3.
	PWM_OSC_OSCL3 = 0x80000

	// OSSUPD: PWM Output Selection Set Update Register
	// Position of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Pos = 0x0
	// Bit mask of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Msk = 0x1
	// Bit OSSUPH0.
	PWM_OSSUPD_OSSUPH0 = 0x1
	// Position of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Pos = 0x1
	// Bit mask of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Msk = 0x2
	// Bit OSSUPH1.
	PWM_OSSUPD_OSSUPH1 = 0x2
	// Position of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Pos = 0x2
	// Bit mask of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Msk = 0x4
	// Bit OSSUPH2.
	PWM_OSSUPD_OSSUPH2 = 0x4
	// Position of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Pos = 0x3
	// Bit mask of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Msk = 0x8
	// Bit OSSUPH3.
	PWM_OSSUPD_OSSUPH3 = 0x8
	// Position of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Pos = 0x10
	// Bit mask of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Msk = 0x10000
	// Bit OSSUPL0.
	PWM_OSSUPD_OSSUPL0 = 0x10000
	// Position of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Pos = 0x11
	// Bit mask of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Msk = 0x20000
	// Bit OSSUPL1.
	PWM_OSSUPD_OSSUPL1 = 0x20000
	// Position of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Pos = 0x12
	// Bit mask of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Msk = 0x40000
	// Bit OSSUPL2.
	PWM_OSSUPD_OSSUPL2 = 0x40000
	// Position of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Pos = 0x13
	// Bit mask of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Msk = 0x80000
	// Bit OSSUPL3.
	PWM_OSSUPD_OSSUPL3 = 0x80000

	// OSCUPD: PWM Output Selection Clear Update Register
	// Position of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Pos = 0x0
	// Bit mask of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Msk = 0x1
	// Bit OSCUPH0.
	PWM_OSCUPD_OSCUPH0 = 0x1
	// Position of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Pos = 0x1
	// Bit mask of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Msk = 0x2
	// Bit OSCUPH1.
	PWM_OSCUPD_OSCUPH1 = 0x2
	// Position of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Pos = 0x2
	// Bit mask of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Msk = 0x4
	// Bit OSCUPH2.
	PWM_OSCUPD_OSCUPH2 = 0x4
	// Position of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Pos = 0x3
	// Bit mask of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Msk = 0x8
	// Bit OSCUPH3.
	PWM_OSCUPD_OSCUPH3 = 0x8
	// Position of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Pos = 0x10
	// Bit mask of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Msk = 0x10000
	// Bit OSCUPL0.
	PWM_OSCUPD_OSCUPL0 = 0x10000
	// Position of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Pos = 0x11
	// Bit mask of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Msk = 0x20000
	// Bit OSCUPL1.
	PWM_OSCUPD_OSCUPL1 = 0x20000
	// Position of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Pos = 0x12
	// Bit mask of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Msk = 0x40000
	// Bit OSCUPL2.
	PWM_OSCUPD_OSCUPL2 = 0x40000
	// Position of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Pos = 0x13
	// Bit mask of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Msk = 0x80000
	// Bit OSCUPL3.
	PWM_OSCUPD_OSCUPL3 = 0x80000

	// FMR: PWM Fault Mode Register
	// Position of FPOL field.
	PWM_FMR_FPOL_Pos = 0x0
	// Bit mask of FPOL field.
	PWM_FMR_FPOL_Msk = 0xff
	// Position of FMOD field.
	PWM_FMR_FMOD_Pos = 0x8
	// Bit mask of FMOD field.
	PWM_FMR_FMOD_Msk = 0xff00
	// Position of FFIL field.
	PWM_FMR_FFIL_Pos = 0x10
	// Bit mask of FFIL field.
	PWM_FMR_FFIL_Msk = 0xff0000

	// FSR: PWM Fault Status Register
	// Position of FIV field.
	PWM_FSR_FIV_Pos = 0x0
	// Bit mask of FIV field.
	PWM_FSR_FIV_Msk = 0xff
	// Position of FS field.
	PWM_FSR_FS_Pos = 0x8
	// Bit mask of FS field.
	PWM_FSR_FS_Msk = 0xff00

	// FCR: PWM Fault Clear Register
	// Position of FCLR field.
	PWM_FCR_FCLR_Pos = 0x0
	// Bit mask of FCLR field.
	PWM_FCR_FCLR_Msk = 0xff

	// FPV: PWM Fault Protection Value Register
	// Position of FPVH0 field.
	PWM_FPV_FPVH0_Pos = 0x0
	// Bit mask of FPVH0 field.
	PWM_FPV_FPVH0_Msk = 0x1
	// Bit FPVH0.
	PWM_FPV_FPVH0 = 0x1
	// Position of FPVH1 field.
	PWM_FPV_FPVH1_Pos = 0x1
	// Bit mask of FPVH1 field.
	PWM_FPV_FPVH1_Msk = 0x2
	// Bit FPVH1.
	PWM_FPV_FPVH1 = 0x2
	// Position of FPVH2 field.
	PWM_FPV_FPVH2_Pos = 0x2
	// Bit mask of FPVH2 field.
	PWM_FPV_FPVH2_Msk = 0x4
	// Bit FPVH2.
	PWM_FPV_FPVH2 = 0x4
	// Position of FPVH3 field.
	PWM_FPV_FPVH3_Pos = 0x3
	// Bit mask of FPVH3 field.
	PWM_FPV_FPVH3_Msk = 0x8
	// Bit FPVH3.
	PWM_FPV_FPVH3 = 0x8
	// Position of FPVL0 field.
	PWM_FPV_FPVL0_Pos = 0x10
	// Bit mask of FPVL0 field.
	PWM_FPV_FPVL0_Msk = 0x10000
	// Bit FPVL0.
	PWM_FPV_FPVL0 = 0x10000
	// Position of FPVL1 field.
	PWM_FPV_FPVL1_Pos = 0x11
	// Bit mask of FPVL1 field.
	PWM_FPV_FPVL1_Msk = 0x20000
	// Bit FPVL1.
	PWM_FPV_FPVL1 = 0x20000
	// Position of FPVL2 field.
	PWM_FPV_FPVL2_Pos = 0x12
	// Bit mask of FPVL2 field.
	PWM_FPV_FPVL2_Msk = 0x40000
	// Bit FPVL2.
	PWM_FPV_FPVL2 = 0x40000
	// Position of FPVL3 field.
	PWM_FPV_FPVL3_Pos = 0x13
	// Bit mask of FPVL3 field.
	PWM_FPV_FPVL3_Msk = 0x80000
	// Bit FPVL3.
	PWM_FPV_FPVL3 = 0x80000

	// FPE: PWM Fault Protection Enable Register
	// Position of FPE0 field.
	PWM_FPE_FPE0_Pos = 0x0
	// Bit mask of FPE0 field.
	PWM_FPE_FPE0_Msk = 0xff
	// Position of FPE1 field.
	PWM_FPE_FPE1_Pos = 0x8
	// Bit mask of FPE1 field.
	PWM_FPE_FPE1_Msk = 0xff00
	// Position of FPE2 field.
	PWM_FPE_FPE2_Pos = 0x10
	// Bit mask of FPE2 field.
	PWM_FPE_FPE2_Msk = 0xff0000
	// Position of FPE3 field.
	PWM_FPE_FPE3_Pos = 0x18
	// Bit mask of FPE3 field.
	PWM_FPE_FPE3_Msk = 0xff000000

	// ELMR: PWM Event Line 0 Mode Register
	// Position of CSEL0 field.
	PWM_ELMR_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	PWM_ELMR_CSEL0_Msk = 0x1
	// Bit CSEL0.
	PWM_ELMR_CSEL0 = 0x1
	// Position of CSEL1 field.
	PWM_ELMR_CSEL1_Pos = 0x1
	// Bit mask of CSEL1 field.
	PWM_ELMR_CSEL1_Msk = 0x2
	// Bit CSEL1.
	PWM_ELMR_CSEL1 = 0x2
	// Position of CSEL2 field.
	PWM_ELMR_CSEL2_Pos = 0x2
	// Bit mask of CSEL2 field.
	PWM_ELMR_CSEL2_Msk = 0x4
	// Bit CSEL2.
	PWM_ELMR_CSEL2 = 0x4
	// Position of CSEL3 field.
	PWM_ELMR_CSEL3_Pos = 0x3
	// Bit mask of CSEL3 field.
	PWM_ELMR_CSEL3_Msk = 0x8
	// Bit CSEL3.
	PWM_ELMR_CSEL3 = 0x8
	// Position of CSEL4 field.
	PWM_ELMR_CSEL4_Pos = 0x4
	// Bit mask of CSEL4 field.
	PWM_ELMR_CSEL4_Msk = 0x10
	// Bit CSEL4.
	PWM_ELMR_CSEL4 = 0x10
	// Position of CSEL5 field.
	PWM_ELMR_CSEL5_Pos = 0x5
	// Bit mask of CSEL5 field.
	PWM_ELMR_CSEL5_Msk = 0x20
	// Bit CSEL5.
	PWM_ELMR_CSEL5 = 0x20
	// Position of CSEL6 field.
	PWM_ELMR_CSEL6_Pos = 0x6
	// Bit mask of CSEL6 field.
	PWM_ELMR_CSEL6_Msk = 0x40
	// Bit CSEL6.
	PWM_ELMR_CSEL6 = 0x40
	// Position of CSEL7 field.
	PWM_ELMR_CSEL7_Pos = 0x7
	// Bit mask of CSEL7 field.
	PWM_ELMR_CSEL7_Msk = 0x80
	// Bit CSEL7.
	PWM_ELMR_CSEL7 = 0x80

	// SMMR: PWM Stepper Motor Mode Register
	// Position of GCEN0 field.
	PWM_SMMR_GCEN0_Pos = 0x0
	// Bit mask of GCEN0 field.
	PWM_SMMR_GCEN0_Msk = 0x1
	// Bit GCEN0.
	PWM_SMMR_GCEN0 = 0x1
	// Position of GCEN1 field.
	PWM_SMMR_GCEN1_Pos = 0x1
	// Bit mask of GCEN1 field.
	PWM_SMMR_GCEN1_Msk = 0x2
	// Bit GCEN1.
	PWM_SMMR_GCEN1 = 0x2
	// Position of DOWN0 field.
	PWM_SMMR_DOWN0_Pos = 0x10
	// Bit mask of DOWN0 field.
	PWM_SMMR_DOWN0_Msk = 0x10000
	// Bit DOWN0.
	PWM_SMMR_DOWN0 = 0x10000
	// Position of DOWN1 field.
	PWM_SMMR_DOWN1_Pos = 0x11
	// Bit mask of DOWN1 field.
	PWM_SMMR_DOWN1_Msk = 0x20000
	// Bit DOWN1.
	PWM_SMMR_DOWN1 = 0x20000

	// WPCR: PWM Write Protect Control Register
	// Position of WPCMD field.
	PWM_WPCR_WPCMD_Pos = 0x0
	// Bit mask of WPCMD field.
	PWM_WPCR_WPCMD_Msk = 0x3
	// Position of WPRG0 field.
	PWM_WPCR_WPRG0_Pos = 0x2
	// Bit mask of WPRG0 field.
	PWM_WPCR_WPRG0_Msk = 0x4
	// Bit WPRG0.
	PWM_WPCR_WPRG0 = 0x4
	// Position of WPRG1 field.
	PWM_WPCR_WPRG1_Pos = 0x3
	// Bit mask of WPRG1 field.
	PWM_WPCR_WPRG1_Msk = 0x8
	// Bit WPRG1.
	PWM_WPCR_WPRG1 = 0x8
	// Position of WPRG2 field.
	PWM_WPCR_WPRG2_Pos = 0x4
	// Bit mask of WPRG2 field.
	PWM_WPCR_WPRG2_Msk = 0x10
	// Bit WPRG2.
	PWM_WPCR_WPRG2 = 0x10
	// Position of WPRG3 field.
	PWM_WPCR_WPRG3_Pos = 0x5
	// Bit mask of WPRG3 field.
	PWM_WPCR_WPRG3_Msk = 0x20
	// Bit WPRG3.
	PWM_WPCR_WPRG3 = 0x20
	// Position of WPRG4 field.
	PWM_WPCR_WPRG4_Pos = 0x6
	// Bit mask of WPRG4 field.
	PWM_WPCR_WPRG4_Msk = 0x40
	// Bit WPRG4.
	PWM_WPCR_WPRG4 = 0x40
	// Position of WPRG5 field.
	PWM_WPCR_WPRG5_Pos = 0x7
	// Bit mask of WPRG5 field.
	PWM_WPCR_WPRG5_Msk = 0x80
	// Bit WPRG5.
	PWM_WPCR_WPRG5 = 0x80
	// Position of WPKEY field.
	PWM_WPCR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PWM_WPCR_WPKEY_Msk = 0xffffff00

	// WPSR: PWM Write Protect Status Register
	// Position of WPSWS0 field.
	PWM_WPSR_WPSWS0_Pos = 0x0
	// Bit mask of WPSWS0 field.
	PWM_WPSR_WPSWS0_Msk = 0x1
	// Bit WPSWS0.
	PWM_WPSR_WPSWS0 = 0x1
	// Position of WPSWS1 field.
	PWM_WPSR_WPSWS1_Pos = 0x1
	// Bit mask of WPSWS1 field.
	PWM_WPSR_WPSWS1_Msk = 0x2
	// Bit WPSWS1.
	PWM_WPSR_WPSWS1 = 0x2
	// Position of WPSWS2 field.
	PWM_WPSR_WPSWS2_Pos = 0x2
	// Bit mask of WPSWS2 field.
	PWM_WPSR_WPSWS2_Msk = 0x4
	// Bit WPSWS2.
	PWM_WPSR_WPSWS2 = 0x4
	// Position of WPSWS3 field.
	PWM_WPSR_WPSWS3_Pos = 0x3
	// Bit mask of WPSWS3 field.
	PWM_WPSR_WPSWS3_Msk = 0x8
	// Bit WPSWS3.
	PWM_WPSR_WPSWS3 = 0x8
	// Position of WPSWS4 field.
	PWM_WPSR_WPSWS4_Pos = 0x4
	// Bit mask of WPSWS4 field.
	PWM_WPSR_WPSWS4_Msk = 0x10
	// Bit WPSWS4.
	PWM_WPSR_WPSWS4 = 0x10
	// Position of WPSWS5 field.
	PWM_WPSR_WPSWS5_Pos = 0x5
	// Bit mask of WPSWS5 field.
	PWM_WPSR_WPSWS5_Msk = 0x20
	// Bit WPSWS5.
	PWM_WPSR_WPSWS5 = 0x20
	// Position of WPVS field.
	PWM_WPSR_WPVS_Pos = 0x7
	// Bit mask of WPVS field.
	PWM_WPSR_WPVS_Msk = 0x80
	// Bit WPVS.
	PWM_WPSR_WPVS = 0x80
	// Position of WPHWS0 field.
	PWM_WPSR_WPHWS0_Pos = 0x8
	// Bit mask of WPHWS0 field.
	PWM_WPSR_WPHWS0_Msk = 0x100
	// Bit WPHWS0.
	PWM_WPSR_WPHWS0 = 0x100
	// Position of WPHWS1 field.
	PWM_WPSR_WPHWS1_Pos = 0x9
	// Bit mask of WPHWS1 field.
	PWM_WPSR_WPHWS1_Msk = 0x200
	// Bit WPHWS1.
	PWM_WPSR_WPHWS1 = 0x200
	// Position of WPHWS2 field.
	PWM_WPSR_WPHWS2_Pos = 0xa
	// Bit mask of WPHWS2 field.
	PWM_WPSR_WPHWS2_Msk = 0x400
	// Bit WPHWS2.
	PWM_WPSR_WPHWS2 = 0x400
	// Position of WPHWS3 field.
	PWM_WPSR_WPHWS3_Pos = 0xb
	// Bit mask of WPHWS3 field.
	PWM_WPSR_WPHWS3_Msk = 0x800
	// Bit WPHWS3.
	PWM_WPSR_WPHWS3 = 0x800
	// Position of WPHWS4 field.
	PWM_WPSR_WPHWS4_Pos = 0xc
	// Bit mask of WPHWS4 field.
	PWM_WPSR_WPHWS4_Msk = 0x1000
	// Bit WPHWS4.
	PWM_WPSR_WPHWS4 = 0x1000
	// Position of WPHWS5 field.
	PWM_WPSR_WPHWS5_Pos = 0xd
	// Bit mask of WPHWS5 field.
	PWM_WPSR_WPHWS5_Msk = 0x2000
	// Bit WPHWS5.
	PWM_WPSR_WPHWS5 = 0x2000
	// Position of WPVSRC field.
	PWM_WPSR_WPVSRC_Pos = 0x10
	// Bit mask of WPVSRC field.
	PWM_WPSR_WPVSRC_Msk = 0xffff0000

	// CMPV0: PWM Comparison 0 Value Register
	// Position of CV field.
	PWM_CMPV0_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV0_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV0_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV0_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV0_CVM = 0x1000000

	// CMPVUPD0: PWM Comparison 0 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD0_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD0_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD0_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD0_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD0_CVMUPD = 0x1000000

	// CMPM0: PWM Comparison 0 Mode Register
	// Position of CEN field.
	PWM_CMPM0_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM0_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM0_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM0_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM0_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM0_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM0_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM0_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM0_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM0_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM0_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM0_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM0_CUPRCNT_Msk = 0xf00000

	// CMPMUPD0: PWM Comparison 0 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD0_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD0_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD0_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD0_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD0_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD0_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD0_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD0_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD0_CUPRUPD_Msk = 0xf0000

	// CMPV1: PWM Comparison 1 Value Register
	// Position of CV field.
	PWM_CMPV1_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV1_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV1_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV1_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV1_CVM = 0x1000000

	// CMPVUPD1: PWM Comparison 1 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD1_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD1_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD1_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD1_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD1_CVMUPD = 0x1000000

	// CMPM1: PWM Comparison 1 Mode Register
	// Position of CEN field.
	PWM_CMPM1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM1_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM1_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM1_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM1_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM1_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM1_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM1_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM1_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM1_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM1_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM1_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM1_CUPRCNT_Msk = 0xf00000

	// CMPMUPD1: PWM Comparison 1 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD1_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD1_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD1_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD1_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD1_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD1_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD1_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD1_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD1_CUPRUPD_Msk = 0xf0000

	// CMPV2: PWM Comparison 2 Value Register
	// Position of CV field.
	PWM_CMPV2_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV2_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV2_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV2_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV2_CVM = 0x1000000

	// CMPVUPD2: PWM Comparison 2 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD2_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD2_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD2_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD2_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD2_CVMUPD = 0x1000000

	// CMPM2: PWM Comparison 2 Mode Register
	// Position of CEN field.
	PWM_CMPM2_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM2_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM2_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM2_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM2_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM2_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM2_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM2_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM2_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM2_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM2_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM2_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM2_CUPRCNT_Msk = 0xf00000

	// CMPMUPD2: PWM Comparison 2 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD2_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD2_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD2_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD2_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD2_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD2_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD2_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD2_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD2_CUPRUPD_Msk = 0xf0000

	// CMPV3: PWM Comparison 3 Value Register
	// Position of CV field.
	PWM_CMPV3_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV3_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV3_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV3_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV3_CVM = 0x1000000

	// CMPVUPD3: PWM Comparison 3 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD3_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD3_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD3_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD3_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD3_CVMUPD = 0x1000000

	// CMPM3: PWM Comparison 3 Mode Register
	// Position of CEN field.
	PWM_CMPM3_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM3_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM3_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM3_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM3_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM3_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM3_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM3_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM3_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM3_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM3_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM3_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM3_CUPRCNT_Msk = 0xf00000

	// CMPMUPD3: PWM Comparison 3 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD3_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD3_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD3_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD3_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD3_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD3_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD3_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD3_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD3_CUPRUPD_Msk = 0xf0000

	// CMPV4: PWM Comparison 4 Value Register
	// Position of CV field.
	PWM_CMPV4_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV4_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV4_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV4_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV4_CVM = 0x1000000

	// CMPVUPD4: PWM Comparison 4 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD4_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD4_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD4_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD4_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD4_CVMUPD = 0x1000000

	// CMPM4: PWM Comparison 4 Mode Register
	// Position of CEN field.
	PWM_CMPM4_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM4_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM4_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM4_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM4_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM4_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM4_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM4_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM4_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM4_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM4_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM4_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM4_CUPRCNT_Msk = 0xf00000

	// CMPMUPD4: PWM Comparison 4 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD4_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD4_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD4_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD4_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD4_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD4_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD4_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD4_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD4_CUPRUPD_Msk = 0xf0000

	// CMPV5: PWM Comparison 5 Value Register
	// Position of CV field.
	PWM_CMPV5_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV5_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV5_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV5_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV5_CVM = 0x1000000

	// CMPVUPD5: PWM Comparison 5 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD5_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD5_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD5_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD5_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD5_CVMUPD = 0x1000000

	// CMPM5: PWM Comparison 5 Mode Register
	// Position of CEN field.
	PWM_CMPM5_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM5_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM5_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM5_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM5_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM5_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM5_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM5_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM5_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM5_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM5_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM5_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM5_CUPRCNT_Msk = 0xf00000

	// CMPMUPD5: PWM Comparison 5 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD5_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD5_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD5_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD5_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD5_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD5_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD5_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD5_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD5_CUPRUPD_Msk = 0xf0000

	// CMPV6: PWM Comparison 6 Value Register
	// Position of CV field.
	PWM_CMPV6_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV6_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV6_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV6_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV6_CVM = 0x1000000

	// CMPVUPD6: PWM Comparison 6 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD6_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD6_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD6_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD6_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD6_CVMUPD = 0x1000000

	// CMPM6: PWM Comparison 6 Mode Register
	// Position of CEN field.
	PWM_CMPM6_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM6_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM6_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM6_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM6_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM6_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM6_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM6_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM6_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM6_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM6_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM6_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM6_CUPRCNT_Msk = 0xf00000

	// CMPMUPD6: PWM Comparison 6 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD6_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD6_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD6_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD6_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD6_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD6_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD6_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD6_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD6_CUPRUPD_Msk = 0xf0000

	// CMPV7: PWM Comparison 7 Value Register
	// Position of CV field.
	PWM_CMPV7_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV7_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV7_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV7_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV7_CVM = 0x1000000

	// CMPVUPD7: PWM Comparison 7 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD7_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD7_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD7_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD7_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD7_CVMUPD = 0x1000000

	// CMPM7: PWM Comparison 7 Mode Register
	// Position of CEN field.
	PWM_CMPM7_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM7_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM7_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM7_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM7_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM7_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM7_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM7_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM7_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM7_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM7_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM7_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM7_CUPRCNT_Msk = 0xf00000

	// CMPMUPD7: PWM Comparison 7 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD7_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD7_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD7_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD7_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD7_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD7_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD7_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD7_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD7_CUPRUPD_Msk = 0xf0000

	// CMR0: PWM Channel Mode Register (ch_num = 0)
	// Position of CPRE field.
	PWM_CMR0_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR0_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR0_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR0_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR0_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR0_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR0_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR0_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR0_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR0_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR0_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR0_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR0_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR0_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR0_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR0_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR0_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR0_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR0_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR0_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR0_CPOL = 0x200
	// Position of CES field.
	PWM_CMR0_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR0_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR0_CES = 0x400
	// Position of DTE field.
	PWM_CMR0_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR0_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR0_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR0_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR0_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR0_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR0_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR0_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR0_DTLI = 0x40000

	// CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
	// Position of CDTY field.
	PWM_CDTY0_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY0_CDTY_Msk = 0xffffff

	// CDTYUPD0: PWM Channel Duty Cycle Update Register (ch_num = 0)
	// Position of CDTYUPD field.
	PWM_CDTYUPD0_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD0_CDTYUPD_Msk = 0xffffff

	// CPRD0: PWM Channel Period Register (ch_num = 0)
	// Position of CPRD field.
	PWM_CPRD0_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD0_CPRD_Msk = 0xffffff

	// CPRDUPD0: PWM Channel Period Update Register (ch_num = 0)
	// Position of CPRDUPD field.
	PWM_CPRDUPD0_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD0_CPRDUPD_Msk = 0xffffff

	// CCNT0: PWM Channel Counter Register (ch_num = 0)
	// Position of CNT field.
	PWM_CCNT0_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT0_CNT_Msk = 0xffffff

	// DT0: PWM Channel Dead Time Register (ch_num = 0)
	// Position of DTH field.
	PWM_DT0_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT0_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT0_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT0_DTL_Msk = 0xffff0000

	// DTUPD0: PWM Channel Dead Time Update Register (ch_num = 0)
	// Position of DTHUPD field.
	PWM_DTUPD0_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD0_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD0_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD0_DTLUPD_Msk = 0xffff0000

	// CMR1: PWM Channel Mode Register (ch_num = 1)
	// Position of CPRE field.
	PWM_CMR1_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR1_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR1_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR1_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR1_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR1_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR1_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR1_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR1_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR1_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR1_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR1_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR1_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR1_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR1_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR1_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR1_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR1_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR1_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR1_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR1_CPOL = 0x200
	// Position of CES field.
	PWM_CMR1_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR1_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR1_CES = 0x400
	// Position of DTE field.
	PWM_CMR1_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR1_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR1_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR1_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR1_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR1_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR1_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR1_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR1_DTLI = 0x40000

	// CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
	// Position of CDTY field.
	PWM_CDTY1_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY1_CDTY_Msk = 0xffffff

	// CDTYUPD1: PWM Channel Duty Cycle Update Register (ch_num = 1)
	// Position of CDTYUPD field.
	PWM_CDTYUPD1_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD1_CDTYUPD_Msk = 0xffffff

	// CPRD1: PWM Channel Period Register (ch_num = 1)
	// Position of CPRD field.
	PWM_CPRD1_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD1_CPRD_Msk = 0xffffff

	// CPRDUPD1: PWM Channel Period Update Register (ch_num = 1)
	// Position of CPRDUPD field.
	PWM_CPRDUPD1_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD1_CPRDUPD_Msk = 0xffffff

	// CCNT1: PWM Channel Counter Register (ch_num = 1)
	// Position of CNT field.
	PWM_CCNT1_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT1_CNT_Msk = 0xffffff

	// DT1: PWM Channel Dead Time Register (ch_num = 1)
	// Position of DTH field.
	PWM_DT1_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT1_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT1_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT1_DTL_Msk = 0xffff0000

	// DTUPD1: PWM Channel Dead Time Update Register (ch_num = 1)
	// Position of DTHUPD field.
	PWM_DTUPD1_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD1_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD1_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD1_DTLUPD_Msk = 0xffff0000

	// CMR2: PWM Channel Mode Register (ch_num = 2)
	// Position of CPRE field.
	PWM_CMR2_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR2_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR2_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR2_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR2_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR2_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR2_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR2_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR2_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR2_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR2_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR2_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR2_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR2_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR2_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR2_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR2_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR2_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR2_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR2_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR2_CPOL = 0x200
	// Position of CES field.
	PWM_CMR2_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR2_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR2_CES = 0x400
	// Position of DTE field.
	PWM_CMR2_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR2_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR2_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR2_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR2_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR2_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR2_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR2_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR2_DTLI = 0x40000

	// CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
	// Position of CDTY field.
	PWM_CDTY2_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY2_CDTY_Msk = 0xffffff

	// CDTYUPD2: PWM Channel Duty Cycle Update Register (ch_num = 2)
	// Position of CDTYUPD field.
	PWM_CDTYUPD2_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD2_CDTYUPD_Msk = 0xffffff

	// CPRD2: PWM Channel Period Register (ch_num = 2)
	// Position of CPRD field.
	PWM_CPRD2_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD2_CPRD_Msk = 0xffffff

	// CPRDUPD2: PWM Channel Period Update Register (ch_num = 2)
	// Position of CPRDUPD field.
	PWM_CPRDUPD2_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD2_CPRDUPD_Msk = 0xffffff

	// CCNT2: PWM Channel Counter Register (ch_num = 2)
	// Position of CNT field.
	PWM_CCNT2_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT2_CNT_Msk = 0xffffff

	// DT2: PWM Channel Dead Time Register (ch_num = 2)
	// Position of DTH field.
	PWM_DT2_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT2_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT2_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT2_DTL_Msk = 0xffff0000

	// DTUPD2: PWM Channel Dead Time Update Register (ch_num = 2)
	// Position of DTHUPD field.
	PWM_DTUPD2_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD2_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD2_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD2_DTLUPD_Msk = 0xffff0000

	// CMR3: PWM Channel Mode Register (ch_num = 3)
	// Position of CPRE field.
	PWM_CMR3_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR3_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR3_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR3_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR3_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR3_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR3_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR3_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR3_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR3_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR3_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR3_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR3_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR3_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR3_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR3_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR3_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR3_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR3_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR3_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR3_CPOL = 0x200
	// Position of CES field.
	PWM_CMR3_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR3_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR3_CES = 0x400
	// Position of DTE field.
	PWM_CMR3_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR3_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR3_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR3_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR3_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR3_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR3_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR3_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR3_DTLI = 0x40000

	// CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
	// Position of CDTY field.
	PWM_CDTY3_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY3_CDTY_Msk = 0xffffff

	// CDTYUPD3: PWM Channel Duty Cycle Update Register (ch_num = 3)
	// Position of CDTYUPD field.
	PWM_CDTYUPD3_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD3_CDTYUPD_Msk = 0xffffff

	// CPRD3: PWM Channel Period Register (ch_num = 3)
	// Position of CPRD field.
	PWM_CPRD3_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD3_CPRD_Msk = 0xffffff

	// CPRDUPD3: PWM Channel Period Update Register (ch_num = 3)
	// Position of CPRDUPD field.
	PWM_CPRDUPD3_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD3_CPRDUPD_Msk = 0xffffff

	// CCNT3: PWM Channel Counter Register (ch_num = 3)
	// Position of CNT field.
	PWM_CCNT3_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT3_CNT_Msk = 0xffffff

	// DT3: PWM Channel Dead Time Register (ch_num = 3)
	// Position of DTH field.
	PWM_DT3_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT3_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT3_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT3_DTL_Msk = 0xffff0000

	// DTUPD3: PWM Channel Dead Time Update Register (ch_num = 3)
	// Position of DTHUPD field.
	PWM_DTUPD3_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD3_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD3_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD3_DTLUPD_Msk = 0xffff0000
)

// Constants for LCDC: LCD Controller
const (
	// LCDCFG0: LCD Controller Configuration Register 0
	// Position of CLKPOL field.
	LCDC_LCDCFG0_CLKPOL_Pos = 0x0
	// Bit mask of CLKPOL field.
	LCDC_LCDCFG0_CLKPOL_Msk = 0x1
	// Bit CLKPOL.
	LCDC_LCDCFG0_CLKPOL = 0x1
	// Position of CLKSEL field.
	LCDC_LCDCFG0_CLKSEL_Pos = 0x2
	// Bit mask of CLKSEL field.
	LCDC_LCDCFG0_CLKSEL_Msk = 0x4
	// Bit CLKSEL.
	LCDC_LCDCFG0_CLKSEL = 0x4
	// Position of CLKPWMSEL field.
	LCDC_LCDCFG0_CLKPWMSEL_Pos = 0x3
	// Bit mask of CLKPWMSEL field.
	LCDC_LCDCFG0_CLKPWMSEL_Msk = 0x8
	// Bit CLKPWMSEL.
	LCDC_LCDCFG0_CLKPWMSEL = 0x8
	// Position of CGDISBASE field.
	LCDC_LCDCFG0_CGDISBASE_Pos = 0x8
	// Bit mask of CGDISBASE field.
	LCDC_LCDCFG0_CGDISBASE_Msk = 0x100
	// Bit CGDISBASE.
	LCDC_LCDCFG0_CGDISBASE = 0x100
	// Position of CGDISOVR1 field.
	LCDC_LCDCFG0_CGDISOVR1_Pos = 0x9
	// Bit mask of CGDISOVR1 field.
	LCDC_LCDCFG0_CGDISOVR1_Msk = 0x200
	// Bit CGDISOVR1.
	LCDC_LCDCFG0_CGDISOVR1 = 0x200
	// Position of CGDISOVR2 field.
	LCDC_LCDCFG0_CGDISOVR2_Pos = 0xa
	// Bit mask of CGDISOVR2 field.
	LCDC_LCDCFG0_CGDISOVR2_Msk = 0x400
	// Bit CGDISOVR2.
	LCDC_LCDCFG0_CGDISOVR2 = 0x400
	// Position of CGDISHEO field.
	LCDC_LCDCFG0_CGDISHEO_Pos = 0xb
	// Bit mask of CGDISHEO field.
	LCDC_LCDCFG0_CGDISHEO_Msk = 0x800
	// Bit CGDISHEO.
	LCDC_LCDCFG0_CGDISHEO = 0x800
	// Position of CGDISHCR field.
	LCDC_LCDCFG0_CGDISHCR_Pos = 0xc
	// Bit mask of CGDISHCR field.
	LCDC_LCDCFG0_CGDISHCR_Msk = 0x1000
	// Bit CGDISHCR.
	LCDC_LCDCFG0_CGDISHCR = 0x1000
	// Position of CGDISPP field.
	LCDC_LCDCFG0_CGDISPP_Pos = 0xd
	// Bit mask of CGDISPP field.
	LCDC_LCDCFG0_CGDISPP_Msk = 0x2000
	// Bit CGDISPP.
	LCDC_LCDCFG0_CGDISPP = 0x2000
	// Position of CLKDIV field.
	LCDC_LCDCFG0_CLKDIV_Pos = 0x10
	// Bit mask of CLKDIV field.
	LCDC_LCDCFG0_CLKDIV_Msk = 0xff0000

	// LCDCFG1: LCD Controller Configuration Register 1
	// Position of HSPW field.
	LCDC_LCDCFG1_HSPW_Pos = 0x0
	// Bit mask of HSPW field.
	LCDC_LCDCFG1_HSPW_Msk = 0x3f
	// Position of VSPW field.
	LCDC_LCDCFG1_VSPW_Pos = 0x10
	// Bit mask of VSPW field.
	LCDC_LCDCFG1_VSPW_Msk = 0x3f0000

	// LCDCFG2: LCD Controller Configuration Register 2
	// Position of VFPW field.
	LCDC_LCDCFG2_VFPW_Pos = 0x0
	// Bit mask of VFPW field.
	LCDC_LCDCFG2_VFPW_Msk = 0x3f
	// Position of VBPW field.
	LCDC_LCDCFG2_VBPW_Pos = 0x10
	// Bit mask of VBPW field.
	LCDC_LCDCFG2_VBPW_Msk = 0x3f0000

	// LCDCFG3: LCD Controller Configuration Register 3
	// Position of HFPW field.
	LCDC_LCDCFG3_HFPW_Pos = 0x0
	// Bit mask of HFPW field.
	LCDC_LCDCFG3_HFPW_Msk = 0x1ff
	// Position of HBPW field.
	LCDC_LCDCFG3_HBPW_Pos = 0x10
	// Bit mask of HBPW field.
	LCDC_LCDCFG3_HBPW_Msk = 0x1ff0000

	// LCDCFG4: LCD Controller Configuration Register 4
	// Position of PPL field.
	LCDC_LCDCFG4_PPL_Pos = 0x0
	// Bit mask of PPL field.
	LCDC_LCDCFG4_PPL_Msk = 0x7ff
	// Position of RPF field.
	LCDC_LCDCFG4_RPF_Pos = 0x10
	// Bit mask of RPF field.
	LCDC_LCDCFG4_RPF_Msk = 0x7ff0000

	// LCDCFG5: LCD Controller Configuration Register 5
	// Position of HSPOL field.
	LCDC_LCDCFG5_HSPOL_Pos = 0x0
	// Bit mask of HSPOL field.
	LCDC_LCDCFG5_HSPOL_Msk = 0x1
	// Bit HSPOL.
	LCDC_LCDCFG5_HSPOL = 0x1
	// Position of VSPOL field.
	LCDC_LCDCFG5_VSPOL_Pos = 0x1
	// Bit mask of VSPOL field.
	LCDC_LCDCFG5_VSPOL_Msk = 0x2
	// Bit VSPOL.
	LCDC_LCDCFG5_VSPOL = 0x2
	// Position of VSPDLYS field.
	LCDC_LCDCFG5_VSPDLYS_Pos = 0x2
	// Bit mask of VSPDLYS field.
	LCDC_LCDCFG5_VSPDLYS_Msk = 0x4
	// Bit VSPDLYS.
	LCDC_LCDCFG5_VSPDLYS = 0x4
	// Position of VSPDLYE field.
	LCDC_LCDCFG5_VSPDLYE_Pos = 0x3
	// Bit mask of VSPDLYE field.
	LCDC_LCDCFG5_VSPDLYE_Msk = 0x8
	// Bit VSPDLYE.
	LCDC_LCDCFG5_VSPDLYE = 0x8
	// Position of DISPPOL field.
	LCDC_LCDCFG5_DISPPOL_Pos = 0x4
	// Bit mask of DISPPOL field.
	LCDC_LCDCFG5_DISPPOL_Msk = 0x10
	// Bit DISPPOL.
	LCDC_LCDCFG5_DISPPOL = 0x10
	// Position of DITHER field.
	LCDC_LCDCFG5_DITHER_Pos = 0x6
	// Bit mask of DITHER field.
	LCDC_LCDCFG5_DITHER_Msk = 0x40
	// Bit DITHER.
	LCDC_LCDCFG5_DITHER = 0x40
	// Position of DISPDLY field.
	LCDC_LCDCFG5_DISPDLY_Pos = 0x7
	// Bit mask of DISPDLY field.
	LCDC_LCDCFG5_DISPDLY_Msk = 0x80
	// Bit DISPDLY.
	LCDC_LCDCFG5_DISPDLY = 0x80
	// Position of MODE field.
	LCDC_LCDCFG5_MODE_Pos = 0x8
	// Bit mask of MODE field.
	LCDC_LCDCFG5_MODE_Msk = 0x300
	// LCD output mode is set to 12 bits per pixel
	LCDC_LCDCFG5_MODE_OUTPUT_12BPP = 0x0
	// LCD output mode is set to 16 bits per pixel
	LCDC_LCDCFG5_MODE_OUTPUT_16BPP = 0x1
	// LCD output mode is set to 18 bits per pixel
	LCDC_LCDCFG5_MODE_OUTPUT_18BPP = 0x2
	// LCD output mode is set to 24 bits per pixel
	LCDC_LCDCFG5_MODE_OUTPUT_24BPP = 0x3
	// Position of PP field.
	LCDC_LCDCFG5_PP_Pos = 0xa
	// Bit mask of PP field.
	LCDC_LCDCFG5_PP_Msk = 0x400
	// Bit PP.
	LCDC_LCDCFG5_PP = 0x400
	// Position of VSPSU field.
	LCDC_LCDCFG5_VSPSU_Pos = 0xc
	// Bit mask of VSPSU field.
	LCDC_LCDCFG5_VSPSU_Msk = 0x1000
	// Bit VSPSU.
	LCDC_LCDCFG5_VSPSU = 0x1000
	// Position of VSPHO field.
	LCDC_LCDCFG5_VSPHO_Pos = 0xd
	// Bit mask of VSPHO field.
	LCDC_LCDCFG5_VSPHO_Msk = 0x2000
	// Bit VSPHO.
	LCDC_LCDCFG5_VSPHO = 0x2000
	// Position of GUARDTIME field.
	LCDC_LCDCFG5_GUARDTIME_Pos = 0x10
	// Bit mask of GUARDTIME field.
	LCDC_LCDCFG5_GUARDTIME_Msk = 0x1f0000

	// LCDCFG6: LCD Controller Configuration Register 6
	// Position of PWMPS field.
	LCDC_LCDCFG6_PWMPS_Pos = 0x0
	// Bit mask of PWMPS field.
	LCDC_LCDCFG6_PWMPS_Msk = 0x7
	// Position of PWMPOL field.
	LCDC_LCDCFG6_PWMPOL_Pos = 0x4
	// Bit mask of PWMPOL field.
	LCDC_LCDCFG6_PWMPOL_Msk = 0x10
	// Bit PWMPOL.
	LCDC_LCDCFG6_PWMPOL = 0x10
	// Position of PWMCVAL field.
	LCDC_LCDCFG6_PWMCVAL_Pos = 0x8
	// Bit mask of PWMCVAL field.
	LCDC_LCDCFG6_PWMCVAL_Msk = 0xff00

	// LCDEN: LCD Controller Enable Register
	// Position of CLKEN field.
	LCDC_LCDEN_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	LCDC_LCDEN_CLKEN_Msk = 0x1
	// Bit CLKEN.
	LCDC_LCDEN_CLKEN = 0x1
	// Position of SYNCEN field.
	LCDC_LCDEN_SYNCEN_Pos = 0x1
	// Bit mask of SYNCEN field.
	LCDC_LCDEN_SYNCEN_Msk = 0x2
	// Bit SYNCEN.
	LCDC_LCDEN_SYNCEN = 0x2
	// Position of DISPEN field.
	LCDC_LCDEN_DISPEN_Pos = 0x2
	// Bit mask of DISPEN field.
	LCDC_LCDEN_DISPEN_Msk = 0x4
	// Bit DISPEN.
	LCDC_LCDEN_DISPEN = 0x4
	// Position of PWMEN field.
	LCDC_LCDEN_PWMEN_Pos = 0x3
	// Bit mask of PWMEN field.
	LCDC_LCDEN_PWMEN_Msk = 0x8
	// Bit PWMEN.
	LCDC_LCDEN_PWMEN = 0x8

	// LCDDIS: LCD Controller Disable Register
	// Position of CLKDIS field.
	LCDC_LCDDIS_CLKDIS_Pos = 0x0
	// Bit mask of CLKDIS field.
	LCDC_LCDDIS_CLKDIS_Msk = 0x1
	// Bit CLKDIS.
	LCDC_LCDDIS_CLKDIS = 0x1
	// Position of SYNCDIS field.
	LCDC_LCDDIS_SYNCDIS_Pos = 0x1
	// Bit mask of SYNCDIS field.
	LCDC_LCDDIS_SYNCDIS_Msk = 0x2
	// Bit SYNCDIS.
	LCDC_LCDDIS_SYNCDIS = 0x2
	// Position of DISPDIS field.
	LCDC_LCDDIS_DISPDIS_Pos = 0x2
	// Bit mask of DISPDIS field.
	LCDC_LCDDIS_DISPDIS_Msk = 0x4
	// Bit DISPDIS.
	LCDC_LCDDIS_DISPDIS = 0x4
	// Position of PWMDIS field.
	LCDC_LCDDIS_PWMDIS_Pos = 0x3
	// Bit mask of PWMDIS field.
	LCDC_LCDDIS_PWMDIS_Msk = 0x8
	// Bit PWMDIS.
	LCDC_LCDDIS_PWMDIS = 0x8
	// Position of CLKRST field.
	LCDC_LCDDIS_CLKRST_Pos = 0x8
	// Bit mask of CLKRST field.
	LCDC_LCDDIS_CLKRST_Msk = 0x100
	// Bit CLKRST.
	LCDC_LCDDIS_CLKRST = 0x100
	// Position of SYNCRST field.
	LCDC_LCDDIS_SYNCRST_Pos = 0x9
	// Bit mask of SYNCRST field.
	LCDC_LCDDIS_SYNCRST_Msk = 0x200
	// Bit SYNCRST.
	LCDC_LCDDIS_SYNCRST = 0x200
	// Position of DISPRST field.
	LCDC_LCDDIS_DISPRST_Pos = 0xa
	// Bit mask of DISPRST field.
	LCDC_LCDDIS_DISPRST_Msk = 0x400
	// Bit DISPRST.
	LCDC_LCDDIS_DISPRST = 0x400
	// Position of PWMRST field.
	LCDC_LCDDIS_PWMRST_Pos = 0xb
	// Bit mask of PWMRST field.
	LCDC_LCDDIS_PWMRST_Msk = 0x800
	// Bit PWMRST.
	LCDC_LCDDIS_PWMRST = 0x800

	// LCDSR: LCD Controller Status Register
	// Position of CLKSTS field.
	LCDC_LCDSR_CLKSTS_Pos = 0x0
	// Bit mask of CLKSTS field.
	LCDC_LCDSR_CLKSTS_Msk = 0x1
	// Bit CLKSTS.
	LCDC_LCDSR_CLKSTS = 0x1
	// Position of LCDSTS field.
	LCDC_LCDSR_LCDSTS_Pos = 0x1
	// Bit mask of LCDSTS field.
	LCDC_LCDSR_LCDSTS_Msk = 0x2
	// Bit LCDSTS.
	LCDC_LCDSR_LCDSTS = 0x2
	// Position of DISPSTS field.
	LCDC_LCDSR_DISPSTS_Pos = 0x2
	// Bit mask of DISPSTS field.
	LCDC_LCDSR_DISPSTS_Msk = 0x4
	// Bit DISPSTS.
	LCDC_LCDSR_DISPSTS = 0x4
	// Position of PWMSTS field.
	LCDC_LCDSR_PWMSTS_Pos = 0x3
	// Bit mask of PWMSTS field.
	LCDC_LCDSR_PWMSTS_Msk = 0x8
	// Bit PWMSTS.
	LCDC_LCDSR_PWMSTS = 0x8
	// Position of SIPSTS field.
	LCDC_LCDSR_SIPSTS_Pos = 0x4
	// Bit mask of SIPSTS field.
	LCDC_LCDSR_SIPSTS_Msk = 0x10
	// Bit SIPSTS.
	LCDC_LCDSR_SIPSTS = 0x10

	// LCDIER: LCD Controller Interrupt Enable Register
	// Position of SOFIE field.
	LCDC_LCDIER_SOFIE_Pos = 0x0
	// Bit mask of SOFIE field.
	LCDC_LCDIER_SOFIE_Msk = 0x1
	// Bit SOFIE.
	LCDC_LCDIER_SOFIE = 0x1
	// Position of DISIE field.
	LCDC_LCDIER_DISIE_Pos = 0x1
	// Bit mask of DISIE field.
	LCDC_LCDIER_DISIE_Msk = 0x2
	// Bit DISIE.
	LCDC_LCDIER_DISIE = 0x2
	// Position of DISPIE field.
	LCDC_LCDIER_DISPIE_Pos = 0x2
	// Bit mask of DISPIE field.
	LCDC_LCDIER_DISPIE_Msk = 0x4
	// Bit DISPIE.
	LCDC_LCDIER_DISPIE = 0x4
	// Position of FIFOERRIE field.
	LCDC_LCDIER_FIFOERRIE_Pos = 0x4
	// Bit mask of FIFOERRIE field.
	LCDC_LCDIER_FIFOERRIE_Msk = 0x10
	// Bit FIFOERRIE.
	LCDC_LCDIER_FIFOERRIE = 0x10
	// Position of BASEIE field.
	LCDC_LCDIER_BASEIE_Pos = 0x8
	// Bit mask of BASEIE field.
	LCDC_LCDIER_BASEIE_Msk = 0x100
	// Bit BASEIE.
	LCDC_LCDIER_BASEIE = 0x100
	// Position of OVR1IE field.
	LCDC_LCDIER_OVR1IE_Pos = 0x9
	// Bit mask of OVR1IE field.
	LCDC_LCDIER_OVR1IE_Msk = 0x200
	// Bit OVR1IE.
	LCDC_LCDIER_OVR1IE = 0x200
	// Position of OVR2IE field.
	LCDC_LCDIER_OVR2IE_Pos = 0xa
	// Bit mask of OVR2IE field.
	LCDC_LCDIER_OVR2IE_Msk = 0x400
	// Bit OVR2IE.
	LCDC_LCDIER_OVR2IE = 0x400
	// Position of HEOIE field.
	LCDC_LCDIER_HEOIE_Pos = 0xb
	// Bit mask of HEOIE field.
	LCDC_LCDIER_HEOIE_Msk = 0x800
	// Bit HEOIE.
	LCDC_LCDIER_HEOIE = 0x800
	// Position of HCRIE field.
	LCDC_LCDIER_HCRIE_Pos = 0xc
	// Bit mask of HCRIE field.
	LCDC_LCDIER_HCRIE_Msk = 0x1000
	// Bit HCRIE.
	LCDC_LCDIER_HCRIE = 0x1000
	// Position of PPIE field.
	LCDC_LCDIER_PPIE_Pos = 0xd
	// Bit mask of PPIE field.
	LCDC_LCDIER_PPIE_Msk = 0x2000
	// Bit PPIE.
	LCDC_LCDIER_PPIE = 0x2000

	// LCDIDR: LCD Controller Interrupt Disable Register
	// Position of SOFID field.
	LCDC_LCDIDR_SOFID_Pos = 0x0
	// Bit mask of SOFID field.
	LCDC_LCDIDR_SOFID_Msk = 0x1
	// Bit SOFID.
	LCDC_LCDIDR_SOFID = 0x1
	// Position of DISID field.
	LCDC_LCDIDR_DISID_Pos = 0x1
	// Bit mask of DISID field.
	LCDC_LCDIDR_DISID_Msk = 0x2
	// Bit DISID.
	LCDC_LCDIDR_DISID = 0x2
	// Position of DISPID field.
	LCDC_LCDIDR_DISPID_Pos = 0x2
	// Bit mask of DISPID field.
	LCDC_LCDIDR_DISPID_Msk = 0x4
	// Bit DISPID.
	LCDC_LCDIDR_DISPID = 0x4
	// Position of FIFOERRID field.
	LCDC_LCDIDR_FIFOERRID_Pos = 0x4
	// Bit mask of FIFOERRID field.
	LCDC_LCDIDR_FIFOERRID_Msk = 0x10
	// Bit FIFOERRID.
	LCDC_LCDIDR_FIFOERRID = 0x10
	// Position of BASEID field.
	LCDC_LCDIDR_BASEID_Pos = 0x8
	// Bit mask of BASEID field.
	LCDC_LCDIDR_BASEID_Msk = 0x100
	// Bit BASEID.
	LCDC_LCDIDR_BASEID = 0x100
	// Position of OVR1ID field.
	LCDC_LCDIDR_OVR1ID_Pos = 0x9
	// Bit mask of OVR1ID field.
	LCDC_LCDIDR_OVR1ID_Msk = 0x200
	// Bit OVR1ID.
	LCDC_LCDIDR_OVR1ID = 0x200
	// Position of OVR2ID field.
	LCDC_LCDIDR_OVR2ID_Pos = 0xa
	// Bit mask of OVR2ID field.
	LCDC_LCDIDR_OVR2ID_Msk = 0x400
	// Bit OVR2ID.
	LCDC_LCDIDR_OVR2ID = 0x400
	// Position of HEOID field.
	LCDC_LCDIDR_HEOID_Pos = 0xb
	// Bit mask of HEOID field.
	LCDC_LCDIDR_HEOID_Msk = 0x800
	// Bit HEOID.
	LCDC_LCDIDR_HEOID = 0x800
	// Position of HCRID field.
	LCDC_LCDIDR_HCRID_Pos = 0xc
	// Bit mask of HCRID field.
	LCDC_LCDIDR_HCRID_Msk = 0x1000
	// Bit HCRID.
	LCDC_LCDIDR_HCRID = 0x1000
	// Position of PPID field.
	LCDC_LCDIDR_PPID_Pos = 0xd
	// Bit mask of PPID field.
	LCDC_LCDIDR_PPID_Msk = 0x2000
	// Bit PPID.
	LCDC_LCDIDR_PPID = 0x2000

	// LCDIMR: LCD Controller Interrupt Mask Register
	// Position of SOFIM field.
	LCDC_LCDIMR_SOFIM_Pos = 0x0
	// Bit mask of SOFIM field.
	LCDC_LCDIMR_SOFIM_Msk = 0x1
	// Bit SOFIM.
	LCDC_LCDIMR_SOFIM = 0x1
	// Position of DISIM field.
	LCDC_LCDIMR_DISIM_Pos = 0x1
	// Bit mask of DISIM field.
	LCDC_LCDIMR_DISIM_Msk = 0x2
	// Bit DISIM.
	LCDC_LCDIMR_DISIM = 0x2
	// Position of DISPIM field.
	LCDC_LCDIMR_DISPIM_Pos = 0x2
	// Bit mask of DISPIM field.
	LCDC_LCDIMR_DISPIM_Msk = 0x4
	// Bit DISPIM.
	LCDC_LCDIMR_DISPIM = 0x4
	// Position of FIFOERRIM field.
	LCDC_LCDIMR_FIFOERRIM_Pos = 0x4
	// Bit mask of FIFOERRIM field.
	LCDC_LCDIMR_FIFOERRIM_Msk = 0x10
	// Bit FIFOERRIM.
	LCDC_LCDIMR_FIFOERRIM = 0x10
	// Position of BASEIM field.
	LCDC_LCDIMR_BASEIM_Pos = 0x8
	// Bit mask of BASEIM field.
	LCDC_LCDIMR_BASEIM_Msk = 0x100
	// Bit BASEIM.
	LCDC_LCDIMR_BASEIM = 0x100
	// Position of OVR1IM field.
	LCDC_LCDIMR_OVR1IM_Pos = 0x9
	// Bit mask of OVR1IM field.
	LCDC_LCDIMR_OVR1IM_Msk = 0x200
	// Bit OVR1IM.
	LCDC_LCDIMR_OVR1IM = 0x200
	// Position of OVR2IM field.
	LCDC_LCDIMR_OVR2IM_Pos = 0xa
	// Bit mask of OVR2IM field.
	LCDC_LCDIMR_OVR2IM_Msk = 0x400
	// Bit OVR2IM.
	LCDC_LCDIMR_OVR2IM = 0x400
	// Position of HEOIM field.
	LCDC_LCDIMR_HEOIM_Pos = 0xb
	// Bit mask of HEOIM field.
	LCDC_LCDIMR_HEOIM_Msk = 0x800
	// Bit HEOIM.
	LCDC_LCDIMR_HEOIM = 0x800
	// Position of HCRIM field.
	LCDC_LCDIMR_HCRIM_Pos = 0xc
	// Bit mask of HCRIM field.
	LCDC_LCDIMR_HCRIM_Msk = 0x1000
	// Bit HCRIM.
	LCDC_LCDIMR_HCRIM = 0x1000
	// Position of PPIM field.
	LCDC_LCDIMR_PPIM_Pos = 0xd
	// Bit mask of PPIM field.
	LCDC_LCDIMR_PPIM_Msk = 0x2000
	// Bit PPIM.
	LCDC_LCDIMR_PPIM = 0x2000

	// LCDISR: LCD Controller Interrupt Status Register
	// Position of SOF field.
	LCDC_LCDISR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	LCDC_LCDISR_SOF_Msk = 0x1
	// Bit SOF.
	LCDC_LCDISR_SOF = 0x1
	// Position of DIS field.
	LCDC_LCDISR_DIS_Pos = 0x1
	// Bit mask of DIS field.
	LCDC_LCDISR_DIS_Msk = 0x2
	// Bit DIS.
	LCDC_LCDISR_DIS = 0x2
	// Position of DISP field.
	LCDC_LCDISR_DISP_Pos = 0x2
	// Bit mask of DISP field.
	LCDC_LCDISR_DISP_Msk = 0x4
	// Bit DISP.
	LCDC_LCDISR_DISP = 0x4
	// Position of FIFOERR field.
	LCDC_LCDISR_FIFOERR_Pos = 0x4
	// Bit mask of FIFOERR field.
	LCDC_LCDISR_FIFOERR_Msk = 0x10
	// Bit FIFOERR.
	LCDC_LCDISR_FIFOERR = 0x10
	// Position of BASE field.
	LCDC_LCDISR_BASE_Pos = 0x8
	// Bit mask of BASE field.
	LCDC_LCDISR_BASE_Msk = 0x100
	// Bit BASE.
	LCDC_LCDISR_BASE = 0x100
	// Position of OVR1 field.
	LCDC_LCDISR_OVR1_Pos = 0x9
	// Bit mask of OVR1 field.
	LCDC_LCDISR_OVR1_Msk = 0x200
	// Bit OVR1.
	LCDC_LCDISR_OVR1 = 0x200
	// Position of OVR2 field.
	LCDC_LCDISR_OVR2_Pos = 0xa
	// Bit mask of OVR2 field.
	LCDC_LCDISR_OVR2_Msk = 0x400
	// Bit OVR2.
	LCDC_LCDISR_OVR2 = 0x400
	// Position of HEO field.
	LCDC_LCDISR_HEO_Pos = 0xb
	// Bit mask of HEO field.
	LCDC_LCDISR_HEO_Msk = 0x800
	// Bit HEO.
	LCDC_LCDISR_HEO = 0x800
	// Position of HCR field.
	LCDC_LCDISR_HCR_Pos = 0xc
	// Bit mask of HCR field.
	LCDC_LCDISR_HCR_Msk = 0x1000
	// Bit HCR.
	LCDC_LCDISR_HCR = 0x1000
	// Position of PP field.
	LCDC_LCDISR_PP_Pos = 0xd
	// Bit mask of PP field.
	LCDC_LCDISR_PP_Msk = 0x2000
	// Bit PP.
	LCDC_LCDISR_PP = 0x2000

	// BASECHER: Base Layer Channel Enable Register
	// Position of CHEN field.
	LCDC_BASECHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_BASECHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_BASECHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_BASECHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_BASECHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_BASECHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_BASECHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_BASECHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_BASECHER_A2QEN = 0x4

	// BASECHDR: Base Layer Channel Disable Register
	// Position of CHDIS field.
	LCDC_BASECHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_BASECHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_BASECHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_BASECHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_BASECHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_BASECHDR_CHRST = 0x100

	// BASECHSR: Base Layer Channel Status Register
	// Position of CHSR field.
	LCDC_BASECHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_BASECHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_BASECHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_BASECHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_BASECHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_BASECHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_BASECHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_BASECHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_BASECHSR_A2QSR = 0x4

	// BASEIER: Base Layer Interrupt Enable Register
	// Position of DMA field.
	LCDC_BASEIER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_BASEIER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_BASEIER_DMA = 0x4
	// Position of DSCR field.
	LCDC_BASEIER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_BASEIER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_BASEIER_DSCR = 0x8
	// Position of ADD field.
	LCDC_BASEIER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_BASEIER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_BASEIER_ADD = 0x10
	// Position of DONE field.
	LCDC_BASEIER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_BASEIER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_BASEIER_DONE = 0x20
	// Position of OVR field.
	LCDC_BASEIER_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_BASEIER_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_BASEIER_OVR = 0x40

	// BASEIDR: Base Layer Interrupt Disabled Register
	// Position of DMA field.
	LCDC_BASEIDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_BASEIDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_BASEIDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_BASEIDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_BASEIDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_BASEIDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_BASEIDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_BASEIDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_BASEIDR_ADD = 0x10
	// Position of DONE field.
	LCDC_BASEIDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_BASEIDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_BASEIDR_DONE = 0x20
	// Position of OVR field.
	LCDC_BASEIDR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_BASEIDR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_BASEIDR_OVR = 0x40

	// BASEIMR: Base Layer Interrupt Mask Register
	// Position of DMA field.
	LCDC_BASEIMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_BASEIMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_BASEIMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_BASEIMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_BASEIMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_BASEIMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_BASEIMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_BASEIMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_BASEIMR_ADD = 0x10
	// Position of DONE field.
	LCDC_BASEIMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_BASEIMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_BASEIMR_DONE = 0x20
	// Position of OVR field.
	LCDC_BASEIMR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_BASEIMR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_BASEIMR_OVR = 0x40

	// BASEISR: Base Layer Interrupt status Register
	// Position of DMA field.
	LCDC_BASEISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_BASEISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_BASEISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_BASEISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_BASEISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_BASEISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_BASEISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_BASEISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_BASEISR_ADD = 0x10
	// Position of DONE field.
	LCDC_BASEISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_BASEISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_BASEISR_DONE = 0x20
	// Position of OVR field.
	LCDC_BASEISR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_BASEISR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_BASEISR_OVR = 0x40

	// BASEHEAD: Base DMA Head Register
	// Position of HEAD field.
	LCDC_BASEHEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_BASEHEAD_HEAD_Msk = 0xfffffffc

	// BASEADDR: Base DMA Address Register
	// Position of ADDR field.
	LCDC_BASEADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_BASEADDR_ADDR_Msk = 0xffffffff

	// BASECTRL: Base DMA Control Register
	// Position of DFETCH field.
	LCDC_BASECTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_BASECTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_BASECTRL_DFETCH = 0x1
	// Position of LFETCH field.
	LCDC_BASECTRL_LFETCH_Pos = 0x1
	// Bit mask of LFETCH field.
	LCDC_BASECTRL_LFETCH_Msk = 0x2
	// Bit LFETCH.
	LCDC_BASECTRL_LFETCH = 0x2
	// Position of DMAIEN field.
	LCDC_BASECTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_BASECTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_BASECTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_BASECTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_BASECTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_BASECTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_BASECTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_BASECTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_BASECTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_BASECTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_BASECTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_BASECTRL_DONEIEN = 0x20

	// BASENEXT: Base DMA Next Register
	// Position of NEXT field.
	LCDC_BASENEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_BASENEXT_NEXT_Msk = 0xffffffff

	// BASECFG0: Base Configuration register 0
	// Position of SIF field.
	LCDC_BASECFG0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	LCDC_BASECFG0_SIF_Msk = 0x1
	// Bit SIF.
	LCDC_BASECFG0_SIF = 0x1
	// Position of BLEN field.
	LCDC_BASECFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_BASECFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_BASECFG0_BLEN_AHB_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_BASECFG0_BLEN_AHB_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_BASECFG0_BLEN_AHB_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_BASECFG0_BLEN_AHB_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_BASECFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_BASECFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_BASECFG0_DLBO = 0x100

	// BASECFG1: Base Configuration register 1
	// Position of CLUTEN field.
	LCDC_BASECFG1_CLUTEN_Pos = 0x0
	// Bit mask of CLUTEN field.
	LCDC_BASECFG1_CLUTEN_Msk = 0x1
	// Bit CLUTEN.
	LCDC_BASECFG1_CLUTEN = 0x1
	// Position of RGBMODE field.
	LCDC_BASECFG1_RGBMODE_Pos = 0x4
	// Bit mask of RGBMODE field.
	LCDC_BASECFG1_RGBMODE_Msk = 0xf0
	// 12 bpp RGB 444
	LCDC_BASECFG1_RGBMODE_12BPP_RGB_444 = 0x0
	// 16 bpp ARGB 4444
	LCDC_BASECFG1_RGBMODE_16BPP_ARGB_4444 = 0x1
	// 16 bpp RGBA 4444
	LCDC_BASECFG1_RGBMODE_16BPP_RGBA_4444 = 0x2
	// 16 bpp RGB 565
	LCDC_BASECFG1_RGBMODE_16BPP_RGB_565 = 0x3
	// 16 bpp TRGB 1555
	LCDC_BASECFG1_RGBMODE_16BPP_TRGB_1555 = 0x4
	// 18 bpp RGB 666
	LCDC_BASECFG1_RGBMODE_18BPP_RGB_666 = 0x5
	// 18 bpp RGB 666 PACKED
	LCDC_BASECFG1_RGBMODE_18BPP_RGB_666PACKED = 0x6
	// 19 bpp TRGB 1666
	LCDC_BASECFG1_RGBMODE_19BPP_TRGB_1666 = 0x7
	// 19 bpp TRGB 1666 PACKED
	LCDC_BASECFG1_RGBMODE_19BPP_TRGB_PACKED = 0x8
	// 24 bpp RGB 888
	LCDC_BASECFG1_RGBMODE_24BPP_RGB_888 = 0x9
	// 24 bpp RGB 888 PACKED
	LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED = 0xa
	// 25 bpp TRGB 1888
	LCDC_BASECFG1_RGBMODE_25BPP_TRGB_1888 = 0xb
	// 32 bpp ARGB 8888
	LCDC_BASECFG1_RGBMODE_32BPP_ARGB_8888 = 0xc
	// 32 bpp RGBA 8888
	LCDC_BASECFG1_RGBMODE_32BPP_RGBA_8888 = 0xd
	// Position of CLUTMODE field.
	LCDC_BASECFG1_CLUTMODE_Pos = 0x8
	// Bit mask of CLUTMODE field.
	LCDC_BASECFG1_CLUTMODE_Msk = 0x300
	// color lookup table mode set to 1 bit per pixel
	LCDC_BASECFG1_CLUTMODE_CLUT_1BPP = 0x0
	// color lookup table mode set to 2 bits per pixel
	LCDC_BASECFG1_CLUTMODE_CLUT_2BPP = 0x1
	// color lookup table mode set to 4 bits per pixel
	LCDC_BASECFG1_CLUTMODE_CLUT_4BPP = 0x2
	// color lookup table mode set to 8 bits per pixel
	LCDC_BASECFG1_CLUTMODE_CLUT_8BPP = 0x3

	// BASECFG2: Base Configuration register 2
	// Position of XSTRIDE field.
	LCDC_BASECFG2_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_BASECFG2_XSTRIDE_Msk = 0xffffffff

	// BASECFG3: Base Configuration register 3
	// Position of BDEF field.
	LCDC_BASECFG3_BDEF_Pos = 0x0
	// Bit mask of BDEF field.
	LCDC_BASECFG3_BDEF_Msk = 0xff
	// Position of GDEF field.
	LCDC_BASECFG3_GDEF_Pos = 0x8
	// Bit mask of GDEF field.
	LCDC_BASECFG3_GDEF_Msk = 0xff00
	// Position of RDEF field.
	LCDC_BASECFG3_RDEF_Pos = 0x10
	// Bit mask of RDEF field.
	LCDC_BASECFG3_RDEF_Msk = 0xff0000

	// BASECFG4: Base Configuration register 4
	// Position of DMA field.
	LCDC_BASECFG4_DMA_Pos = 0x8
	// Bit mask of DMA field.
	LCDC_BASECFG4_DMA_Msk = 0x100
	// Bit DMA.
	LCDC_BASECFG4_DMA = 0x100
	// Position of REP field.
	LCDC_BASECFG4_REP_Pos = 0x9
	// Bit mask of REP field.
	LCDC_BASECFG4_REP_Msk = 0x200
	// Bit REP.
	LCDC_BASECFG4_REP = 0x200
	// Position of DISCEN field.
	LCDC_BASECFG4_DISCEN_Pos = 0xb
	// Bit mask of DISCEN field.
	LCDC_BASECFG4_DISCEN_Msk = 0x800
	// Bit DISCEN.
	LCDC_BASECFG4_DISCEN = 0x800

	// BASECFG5: Base Configuration register 5
	// Position of DISCXPOS field.
	LCDC_BASECFG5_DISCXPOS_Pos = 0x0
	// Bit mask of DISCXPOS field.
	LCDC_BASECFG5_DISCXPOS_Msk = 0x7ff
	// Position of DISCYPOS field.
	LCDC_BASECFG5_DISCYPOS_Pos = 0x10
	// Bit mask of DISCYPOS field.
	LCDC_BASECFG5_DISCYPOS_Msk = 0x7ff0000

	// BASECFG6: Base Configuration register 6
	// Position of DISCXSIZE field.
	LCDC_BASECFG6_DISCXSIZE_Pos = 0x0
	// Bit mask of DISCXSIZE field.
	LCDC_BASECFG6_DISCXSIZE_Msk = 0x7ff
	// Position of DISCYSIZE field.
	LCDC_BASECFG6_DISCYSIZE_Pos = 0x10
	// Bit mask of DISCYSIZE field.
	LCDC_BASECFG6_DISCYSIZE_Msk = 0x7ff0000

	// OVR1CHER: Overlay 1 Channel Enable Register
	// Position of CHEN field.
	LCDC_OVR1CHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_OVR1CHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_OVR1CHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_OVR1CHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_OVR1CHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_OVR1CHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_OVR1CHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_OVR1CHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_OVR1CHER_A2QEN = 0x4

	// OVR1CHDR: Overlay 1 Channel Disable Register
	// Position of CHDIS field.
	LCDC_OVR1CHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_OVR1CHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_OVR1CHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_OVR1CHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_OVR1CHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_OVR1CHDR_CHRST = 0x100

	// OVR1CHSR: Overlay 1 Channel Status Register
	// Position of CHSR field.
	LCDC_OVR1CHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_OVR1CHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_OVR1CHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_OVR1CHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_OVR1CHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_OVR1CHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_OVR1CHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_OVR1CHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_OVR1CHSR_A2QSR = 0x4

	// OVR1IER: Overlay 1 Interrupt Enable Register
	// Position of DMA field.
	LCDC_OVR1IER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR1IER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR1IER_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR1IER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR1IER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR1IER_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR1IER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR1IER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR1IER_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR1IER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR1IER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR1IER_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR1IER_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR1IER_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR1IER_OVR = 0x40

	// OVR1IDR: Overlay 1 Interrupt Disable Register
	// Position of DMA field.
	LCDC_OVR1IDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR1IDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR1IDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR1IDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR1IDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR1IDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR1IDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR1IDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR1IDR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR1IDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR1IDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR1IDR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR1IDR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR1IDR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR1IDR_OVR = 0x40

	// OVR1IMR: Overlay 1 Interrupt Mask Register
	// Position of DMA field.
	LCDC_OVR1IMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR1IMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR1IMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR1IMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR1IMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR1IMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR1IMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR1IMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR1IMR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR1IMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR1IMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR1IMR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR1IMR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR1IMR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR1IMR_OVR = 0x40

	// OVR1ISR: Overlay 1 Interrupt Status Register
	// Position of DMA field.
	LCDC_OVR1ISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR1ISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR1ISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR1ISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR1ISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR1ISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR1ISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR1ISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR1ISR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR1ISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR1ISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR1ISR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR1ISR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR1ISR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR1ISR_OVR = 0x40

	// OVR1HEAD: Overlay 1 DMA Head Register
	// Position of HEAD field.
	LCDC_OVR1HEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_OVR1HEAD_HEAD_Msk = 0xfffffffc

	// OVR1ADDR: Overlay 1 DMA Address Register
	// Position of ADDR field.
	LCDC_OVR1ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_OVR1ADDR_ADDR_Msk = 0xffffffff

	// OVR1CTRL: Overlay1 DMA Control Register
	// Position of DFETCH field.
	LCDC_OVR1CTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_OVR1CTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_OVR1CTRL_DFETCH = 0x1
	// Position of LFETCH field.
	LCDC_OVR1CTRL_LFETCH_Pos = 0x1
	// Bit mask of LFETCH field.
	LCDC_OVR1CTRL_LFETCH_Msk = 0x2
	// Bit LFETCH.
	LCDC_OVR1CTRL_LFETCH = 0x2
	// Position of DMAIEN field.
	LCDC_OVR1CTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_OVR1CTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_OVR1CTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_OVR1CTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_OVR1CTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_OVR1CTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_OVR1CTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_OVR1CTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_OVR1CTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_OVR1CTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_OVR1CTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_OVR1CTRL_DONEIEN = 0x20

	// OVR1NEXT: Overlay1 DMA Next Register
	// Position of NEXT field.
	LCDC_OVR1NEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_OVR1NEXT_NEXT_Msk = 0xffffffff

	// OVR1CFG0: Overlay 1 Configuration 0 Register
	// Position of SIF field.
	LCDC_OVR1CFG0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	LCDC_OVR1CFG0_SIF_Msk = 0x1
	// Bit SIF.
	LCDC_OVR1CFG0_SIF = 0x1
	// Position of BLEN field.
	LCDC_OVR1CFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_OVR1CFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR1CFG0_BLEN_AHB_BLEN_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR1CFG0_BLEN_AHB_BLEN_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR1CFG0_BLEN_AHB_BLEN_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR1CFG0_BLEN_AHB_BLEN_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_OVR1CFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_OVR1CFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_OVR1CFG0_DLBO = 0x100
	// Position of ROTDIS field.
	LCDC_OVR1CFG0_ROTDIS_Pos = 0xc
	// Bit mask of ROTDIS field.
	LCDC_OVR1CFG0_ROTDIS_Msk = 0x1000
	// Bit ROTDIS.
	LCDC_OVR1CFG0_ROTDIS = 0x1000
	// Position of LOCKDIS field.
	LCDC_OVR1CFG0_LOCKDIS_Pos = 0xd
	// Bit mask of LOCKDIS field.
	LCDC_OVR1CFG0_LOCKDIS_Msk = 0x2000
	// Bit LOCKDIS.
	LCDC_OVR1CFG0_LOCKDIS = 0x2000

	// OVR1CFG1: Overlay 1 Configuration 1 Register
	// Position of CLUTEN field.
	LCDC_OVR1CFG1_CLUTEN_Pos = 0x0
	// Bit mask of CLUTEN field.
	LCDC_OVR1CFG1_CLUTEN_Msk = 0x1
	// Bit CLUTEN.
	LCDC_OVR1CFG1_CLUTEN = 0x1
	// Position of RGBMODE field.
	LCDC_OVR1CFG1_RGBMODE_Pos = 0x4
	// Bit mask of RGBMODE field.
	LCDC_OVR1CFG1_RGBMODE_Msk = 0xf0
	// 12 bpp RGB 444
	LCDC_OVR1CFG1_RGBMODE_12BPP_RGB_444 = 0x0
	// 16 bpp ARGB 4444
	LCDC_OVR1CFG1_RGBMODE_16BPP_ARGB_4444 = 0x1
	// 16 bpp RGBA 4444
	LCDC_OVR1CFG1_RGBMODE_16BPP_RGBA_4444 = 0x2
	// 16 bpp RGB 565
	LCDC_OVR1CFG1_RGBMODE_16BPP_RGB_565 = 0x3
	// 16 bpp TRGB 1555
	LCDC_OVR1CFG1_RGBMODE_16BPP_TRGB_1555 = 0x4
	// 18 bpp RGB 666
	LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666 = 0x5
	// 18 bpp RGB 666 PACKED
	LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666PACKED = 0x6
	// 19 bpp TRGB 1666
	LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_1666 = 0x7
	// 19 bpp TRGB 1666 PACKED
	LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_PACKED = 0x8
	// 24 bpp RGB 888
	LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888 = 0x9
	// 24 bpp RGB 888 PACKED
	LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888_PACKED = 0xa
	// 25 bpp TRGB 1888
	LCDC_OVR1CFG1_RGBMODE_25BPP_TRGB_1888 = 0xb
	// 32 bpp ARGB 8888
	LCDC_OVR1CFG1_RGBMODE_32BPP_ARGB_8888 = 0xc
	// 32 bpp RGBA 8888
	LCDC_OVR1CFG1_RGBMODE_32BPP_RGBA_8888 = 0xd
	// Position of CLUTMODE field.
	LCDC_OVR1CFG1_CLUTMODE_Pos = 0x8
	// Bit mask of CLUTMODE field.
	LCDC_OVR1CFG1_CLUTMODE_Msk = 0x300
	// color lookup table mode set to 1 bit per pixel
	LCDC_OVR1CFG1_CLUTMODE_CLUT_1BPP = 0x0
	// color lookup table mode set to 2 bits per pixel
	LCDC_OVR1CFG1_CLUTMODE_CLUT_2BPP = 0x1
	// color lookup table mode set to 4 bits per pixel
	LCDC_OVR1CFG1_CLUTMODE_CLUT_4BPP = 0x2
	// color lookup table mode set to 8 bits per pixel
	LCDC_OVR1CFG1_CLUTMODE_CLUT_8BPP = 0x3

	// OVR1CFG2: Overlay 1 Configuration 2 Register
	// Position of XPOS field.
	LCDC_OVR1CFG2_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	LCDC_OVR1CFG2_XPOS_Msk = 0x7ff
	// Position of YPOS field.
	LCDC_OVR1CFG2_YPOS_Pos = 0x10
	// Bit mask of YPOS field.
	LCDC_OVR1CFG2_YPOS_Msk = 0x7ff0000

	// OVR1CFG3: Overlay 1 Configuration 3 Register
	// Position of XSIZE field.
	LCDC_OVR1CFG3_XSIZE_Pos = 0x0
	// Bit mask of XSIZE field.
	LCDC_OVR1CFG3_XSIZE_Msk = 0x7ff
	// Position of YSIZE field.
	LCDC_OVR1CFG3_YSIZE_Pos = 0x10
	// Bit mask of YSIZE field.
	LCDC_OVR1CFG3_YSIZE_Msk = 0x7ff0000

	// OVR1CFG4: Overlay 1 Configuration 4 Register
	// Position of XSTRIDE field.
	LCDC_OVR1CFG4_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_OVR1CFG4_XSTRIDE_Msk = 0xffffffff

	// OVR1CFG5: Overlay 1 Configuration 5 Register
	// Position of PSTRIDE field.
	LCDC_OVR1CFG5_PSTRIDE_Pos = 0x0
	// Bit mask of PSTRIDE field.
	LCDC_OVR1CFG5_PSTRIDE_Msk = 0xffffffff

	// OVR1CFG6: Overlay 1 Configuration 6 Register
	// Position of BDEF field.
	LCDC_OVR1CFG6_BDEF_Pos = 0x0
	// Bit mask of BDEF field.
	LCDC_OVR1CFG6_BDEF_Msk = 0xff
	// Position of GDEF field.
	LCDC_OVR1CFG6_GDEF_Pos = 0x8
	// Bit mask of GDEF field.
	LCDC_OVR1CFG6_GDEF_Msk = 0xff00
	// Position of RDEF field.
	LCDC_OVR1CFG6_RDEF_Pos = 0x10
	// Bit mask of RDEF field.
	LCDC_OVR1CFG6_RDEF_Msk = 0xff0000

	// OVR1CFG7: Overlay 1 Configuration 7 Register
	// Position of BKEY field.
	LCDC_OVR1CFG7_BKEY_Pos = 0x0
	// Bit mask of BKEY field.
	LCDC_OVR1CFG7_BKEY_Msk = 0xff
	// Position of GKEY field.
	LCDC_OVR1CFG7_GKEY_Pos = 0x8
	// Bit mask of GKEY field.
	LCDC_OVR1CFG7_GKEY_Msk = 0xff00
	// Position of RKEY field.
	LCDC_OVR1CFG7_RKEY_Pos = 0x10
	// Bit mask of RKEY field.
	LCDC_OVR1CFG7_RKEY_Msk = 0xff0000

	// OVR1CFG8: Overlay 1 Configuration 8Register
	// Position of BMASK field.
	LCDC_OVR1CFG8_BMASK_Pos = 0x0
	// Bit mask of BMASK field.
	LCDC_OVR1CFG8_BMASK_Msk = 0xff
	// Position of GMASK field.
	LCDC_OVR1CFG8_GMASK_Pos = 0x8
	// Bit mask of GMASK field.
	LCDC_OVR1CFG8_GMASK_Msk = 0xff00
	// Position of RMASK field.
	LCDC_OVR1CFG8_RMASK_Pos = 0x10
	// Bit mask of RMASK field.
	LCDC_OVR1CFG8_RMASK_Msk = 0xff0000

	// OVR1CFG9: Overlay 1 Configuration 9 Register
	// Position of CRKEY field.
	LCDC_OVR1CFG9_CRKEY_Pos = 0x0
	// Bit mask of CRKEY field.
	LCDC_OVR1CFG9_CRKEY_Msk = 0x1
	// Bit CRKEY.
	LCDC_OVR1CFG9_CRKEY = 0x1
	// Position of INV field.
	LCDC_OVR1CFG9_INV_Pos = 0x1
	// Bit mask of INV field.
	LCDC_OVR1CFG9_INV_Msk = 0x2
	// Bit INV.
	LCDC_OVR1CFG9_INV = 0x2
	// Position of ITER2BL field.
	LCDC_OVR1CFG9_ITER2BL_Pos = 0x2
	// Bit mask of ITER2BL field.
	LCDC_OVR1CFG9_ITER2BL_Msk = 0x4
	// Bit ITER2BL.
	LCDC_OVR1CFG9_ITER2BL = 0x4
	// Position of ITER field.
	LCDC_OVR1CFG9_ITER_Pos = 0x3
	// Bit mask of ITER field.
	LCDC_OVR1CFG9_ITER_Msk = 0x8
	// Bit ITER.
	LCDC_OVR1CFG9_ITER = 0x8
	// Position of REVALPHA field.
	LCDC_OVR1CFG9_REVALPHA_Pos = 0x4
	// Bit mask of REVALPHA field.
	LCDC_OVR1CFG9_REVALPHA_Msk = 0x10
	// Bit REVALPHA.
	LCDC_OVR1CFG9_REVALPHA = 0x10
	// Position of GAEN field.
	LCDC_OVR1CFG9_GAEN_Pos = 0x5
	// Bit mask of GAEN field.
	LCDC_OVR1CFG9_GAEN_Msk = 0x20
	// Bit GAEN.
	LCDC_OVR1CFG9_GAEN = 0x20
	// Position of LAEN field.
	LCDC_OVR1CFG9_LAEN_Pos = 0x6
	// Bit mask of LAEN field.
	LCDC_OVR1CFG9_LAEN_Msk = 0x40
	// Bit LAEN.
	LCDC_OVR1CFG9_LAEN = 0x40
	// Position of OVR field.
	LCDC_OVR1CFG9_OVR_Pos = 0x7
	// Bit mask of OVR field.
	LCDC_OVR1CFG9_OVR_Msk = 0x80
	// Bit OVR.
	LCDC_OVR1CFG9_OVR = 0x80
	// Position of DMA field.
	LCDC_OVR1CFG9_DMA_Pos = 0x8
	// Bit mask of DMA field.
	LCDC_OVR1CFG9_DMA_Msk = 0x100
	// Bit DMA.
	LCDC_OVR1CFG9_DMA = 0x100
	// Position of REP field.
	LCDC_OVR1CFG9_REP_Pos = 0x9
	// Bit mask of REP field.
	LCDC_OVR1CFG9_REP_Msk = 0x200
	// Bit REP.
	LCDC_OVR1CFG9_REP = 0x200
	// Position of DSTKEY field.
	LCDC_OVR1CFG9_DSTKEY_Pos = 0xa
	// Bit mask of DSTKEY field.
	LCDC_OVR1CFG9_DSTKEY_Msk = 0x400
	// Bit DSTKEY.
	LCDC_OVR1CFG9_DSTKEY = 0x400
	// Position of GA field.
	LCDC_OVR1CFG9_GA_Pos = 0x10
	// Bit mask of GA field.
	LCDC_OVR1CFG9_GA_Msk = 0xff0000

	// OVR2CHER: Overlay 2 Channel Enable Register
	// Position of CHEN field.
	LCDC_OVR2CHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_OVR2CHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_OVR2CHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_OVR2CHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_OVR2CHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_OVR2CHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_OVR2CHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_OVR2CHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_OVR2CHER_A2QEN = 0x4

	// OVR2CHDR: Overlay 2 Channel Disable Register
	// Position of CHDIS field.
	LCDC_OVR2CHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_OVR2CHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_OVR2CHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_OVR2CHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_OVR2CHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_OVR2CHDR_CHRST = 0x100

	// OVR2CHSR: Overlay 2 Channel Status Register
	// Position of CHSR field.
	LCDC_OVR2CHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_OVR2CHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_OVR2CHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_OVR2CHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_OVR2CHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_OVR2CHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_OVR2CHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_OVR2CHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_OVR2CHSR_A2QSR = 0x4

	// OVR2IER: Overlay 2 Interrupt Enable Register
	// Position of DMA field.
	LCDC_OVR2IER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR2IER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR2IER_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR2IER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR2IER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR2IER_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR2IER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR2IER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR2IER_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR2IER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR2IER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR2IER_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR2IER_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR2IER_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR2IER_OVR = 0x40

	// OVR2IDR: Overlay 2 Interrupt Disable Register
	// Position of DMA field.
	LCDC_OVR2IDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR2IDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR2IDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR2IDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR2IDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR2IDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR2IDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR2IDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR2IDR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR2IDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR2IDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR2IDR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR2IDR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR2IDR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR2IDR_OVR = 0x40

	// OVR2IMR: Overlay 2 Interrupt Mask Register
	// Position of DMA field.
	LCDC_OVR2IMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR2IMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR2IMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR2IMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR2IMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR2IMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR2IMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR2IMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR2IMR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR2IMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR2IMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR2IMR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR2IMR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR2IMR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR2IMR_OVR = 0x40

	// OVR2ISR: Overlay 2 Interrupt status Register
	// Position of DMA field.
	LCDC_OVR2ISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_OVR2ISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_OVR2ISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_OVR2ISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_OVR2ISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_OVR2ISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_OVR2ISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_OVR2ISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_OVR2ISR_ADD = 0x10
	// Position of DONE field.
	LCDC_OVR2ISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_OVR2ISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_OVR2ISR_DONE = 0x20
	// Position of OVR field.
	LCDC_OVR2ISR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_OVR2ISR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_OVR2ISR_OVR = 0x40

	// OVR2HEAD: Overlay 2 DMA Head Register
	// Position of HEAD field.
	LCDC_OVR2HEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_OVR2HEAD_HEAD_Msk = 0xfffffffc

	// OVR2ADDR: Overlay 2 DMA Address Register
	// Position of ADDR field.
	LCDC_OVR2ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_OVR2ADDR_ADDR_Msk = 0xffffffff

	// OVR2CTRL: Overlay 2 DMA Control Register
	// Position of DFETCH field.
	LCDC_OVR2CTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_OVR2CTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_OVR2CTRL_DFETCH = 0x1
	// Position of LFETCH field.
	LCDC_OVR2CTRL_LFETCH_Pos = 0x1
	// Bit mask of LFETCH field.
	LCDC_OVR2CTRL_LFETCH_Msk = 0x2
	// Bit LFETCH.
	LCDC_OVR2CTRL_LFETCH = 0x2
	// Position of DMAIEN field.
	LCDC_OVR2CTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_OVR2CTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_OVR2CTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_OVR2CTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_OVR2CTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_OVR2CTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_OVR2CTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_OVR2CTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_OVR2CTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_OVR2CTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_OVR2CTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_OVR2CTRL_DONEIEN = 0x20

	// OVR2NEXT: Overlay 2 DMA Next Register
	// Position of NEXT field.
	LCDC_OVR2NEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_OVR2NEXT_NEXT_Msk = 0xffffffff

	// OVR2CFG0: Overlay 2 Configuration 0 Register
	// Position of BLEN field.
	LCDC_OVR2CFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_OVR2CFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR2CFG0_BLEN_AHB_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR2CFG0_BLEN_AHB_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR2CFG0_BLEN_AHB_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_OVR2CFG0_BLEN_AHB_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_OVR2CFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_OVR2CFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_OVR2CFG0_DLBO = 0x100
	// Position of ROTDIS field.
	LCDC_OVR2CFG0_ROTDIS_Pos = 0xc
	// Bit mask of ROTDIS field.
	LCDC_OVR2CFG0_ROTDIS_Msk = 0x1000
	// Bit ROTDIS.
	LCDC_OVR2CFG0_ROTDIS = 0x1000
	// Position of LOCKDIS field.
	LCDC_OVR2CFG0_LOCKDIS_Pos = 0xd
	// Bit mask of LOCKDIS field.
	LCDC_OVR2CFG0_LOCKDIS_Msk = 0x2000
	// Bit LOCKDIS.
	LCDC_OVR2CFG0_LOCKDIS = 0x2000

	// OVR2CFG1: Overlay 2 Configuration 1 Register
	// Position of CLUTEN field.
	LCDC_OVR2CFG1_CLUTEN_Pos = 0x0
	// Bit mask of CLUTEN field.
	LCDC_OVR2CFG1_CLUTEN_Msk = 0x1
	// Bit CLUTEN.
	LCDC_OVR2CFG1_CLUTEN = 0x1
	// Position of RGBMODE field.
	LCDC_OVR2CFG1_RGBMODE_Pos = 0x4
	// Bit mask of RGBMODE field.
	LCDC_OVR2CFG1_RGBMODE_Msk = 0xf0
	// 12 bpp RGB 444
	LCDC_OVR2CFG1_RGBMODE_12BPP_RGB_444 = 0x0
	// 16 bpp ARGB 4444
	LCDC_OVR2CFG1_RGBMODE_16BPP_ARGB_4444 = 0x1
	// 16 bpp RGBA 4444
	LCDC_OVR2CFG1_RGBMODE_16BPP_RGBA_4444 = 0x2
	// 16 bpp RGB 565
	LCDC_OVR2CFG1_RGBMODE_16BPP_RGB_565 = 0x3
	// 16 bpp TRGB 1555
	LCDC_OVR2CFG1_RGBMODE_16BPP_TRGB_1555 = 0x4
	// 18 bpp RGB 666
	LCDC_OVR2CFG1_RGBMODE_18BPP_RGB_666 = 0x5
	// 18 bpp RGB 666 PACKED
	LCDC_OVR2CFG1_RGBMODE_18BPP_RGB_666PACKED = 0x6
	// 19 bpp TRGB 1666
	LCDC_OVR2CFG1_RGBMODE_19BPP_TRGB_1666 = 0x7
	// 19 bpp TRGB 1666 PACKED
	LCDC_OVR2CFG1_RGBMODE_19BPP_TRGB_PACKED = 0x8
	// 24 bpp RGB 888
	LCDC_OVR2CFG1_RGBMODE_24BPP_RGB_888 = 0x9
	// 24 bpp RGB 888 PACKED
	LCDC_OVR2CFG1_RGBMODE_24BPP_RGB_888_PACKED = 0xa
	// 25 bpp TRGB 1888
	LCDC_OVR2CFG1_RGBMODE_25BPP_TRGB_1888 = 0xb
	// 32 bpp ARGB 8888
	LCDC_OVR2CFG1_RGBMODE_32BPP_ARGB_8888 = 0xc
	// 32 bpp RGBA 8888
	LCDC_OVR2CFG1_RGBMODE_32BPP_RGBA_8888 = 0xd
	// Position of CLUTMODE field.
	LCDC_OVR2CFG1_CLUTMODE_Pos = 0x8
	// Bit mask of CLUTMODE field.
	LCDC_OVR2CFG1_CLUTMODE_Msk = 0x300
	// color lookup table mode set to 1 bit per pixel
	LCDC_OVR2CFG1_CLUTMODE_CLUT_1BPP = 0x0
	// color lookup table mode set to 2 bits per pixel
	LCDC_OVR2CFG1_CLUTMODE_CLUT_2BPP = 0x1
	// color lookup table mode set to 4 bits per pixel
	LCDC_OVR2CFG1_CLUTMODE_CLUT_4BPP = 0x2
	// color lookup table mode set to 8 bits per pixel
	LCDC_OVR2CFG1_CLUTMODE_CLUT_8BPP = 0x3

	// OVR2CFG2: Overlay 2 Configuration 2 Register
	// Position of XPOS field.
	LCDC_OVR2CFG2_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	LCDC_OVR2CFG2_XPOS_Msk = 0x7ff
	// Position of YPOS field.
	LCDC_OVR2CFG2_YPOS_Pos = 0x10
	// Bit mask of YPOS field.
	LCDC_OVR2CFG2_YPOS_Msk = 0x7ff0000

	// OVR2CFG3: Overlay 2 Configuration 3 Register
	// Position of XSIZE field.
	LCDC_OVR2CFG3_XSIZE_Pos = 0x0
	// Bit mask of XSIZE field.
	LCDC_OVR2CFG3_XSIZE_Msk = 0x7ff
	// Position of YSIZE field.
	LCDC_OVR2CFG3_YSIZE_Pos = 0x10
	// Bit mask of YSIZE field.
	LCDC_OVR2CFG3_YSIZE_Msk = 0x7ff0000

	// OVR2CFG4: Overlay 2 Configuration 4 Register
	// Position of XSTRIDE field.
	LCDC_OVR2CFG4_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_OVR2CFG4_XSTRIDE_Msk = 0xffffffff

	// OVR2CFG5: Overlay 2 Configuration 5 Register
	// Position of PSTRIDE field.
	LCDC_OVR2CFG5_PSTRIDE_Pos = 0x0
	// Bit mask of PSTRIDE field.
	LCDC_OVR2CFG5_PSTRIDE_Msk = 0xffffffff

	// OVR2CFG6: Overlay 2 Configuration 6 Register
	// Position of BDEF field.
	LCDC_OVR2CFG6_BDEF_Pos = 0x0
	// Bit mask of BDEF field.
	LCDC_OVR2CFG6_BDEF_Msk = 0xff
	// Position of GDEF field.
	LCDC_OVR2CFG6_GDEF_Pos = 0x8
	// Bit mask of GDEF field.
	LCDC_OVR2CFG6_GDEF_Msk = 0xff00
	// Position of RDEF field.
	LCDC_OVR2CFG6_RDEF_Pos = 0x10
	// Bit mask of RDEF field.
	LCDC_OVR2CFG6_RDEF_Msk = 0xff0000

	// OVR2CFG7: Overlay 2 Configuration 7 Register
	// Position of BKEY field.
	LCDC_OVR2CFG7_BKEY_Pos = 0x0
	// Bit mask of BKEY field.
	LCDC_OVR2CFG7_BKEY_Msk = 0xff
	// Position of GKEY field.
	LCDC_OVR2CFG7_GKEY_Pos = 0x8
	// Bit mask of GKEY field.
	LCDC_OVR2CFG7_GKEY_Msk = 0xff00
	// Position of RKEY field.
	LCDC_OVR2CFG7_RKEY_Pos = 0x10
	// Bit mask of RKEY field.
	LCDC_OVR2CFG7_RKEY_Msk = 0xff0000

	// OVR2CFG8: Overlay 2 Configuration 8 Register
	// Position of BMASK field.
	LCDC_OVR2CFG8_BMASK_Pos = 0x0
	// Bit mask of BMASK field.
	LCDC_OVR2CFG8_BMASK_Msk = 0xff
	// Position of GMASK field.
	LCDC_OVR2CFG8_GMASK_Pos = 0x8
	// Bit mask of GMASK field.
	LCDC_OVR2CFG8_GMASK_Msk = 0xff00
	// Position of RMASK field.
	LCDC_OVR2CFG8_RMASK_Pos = 0x10
	// Bit mask of RMASK field.
	LCDC_OVR2CFG8_RMASK_Msk = 0xff0000

	// OVR2CFG9: Overlay 2 Configuration 9 Register
	// Position of CRKEY field.
	LCDC_OVR2CFG9_CRKEY_Pos = 0x0
	// Bit mask of CRKEY field.
	LCDC_OVR2CFG9_CRKEY_Msk = 0x1
	// Bit CRKEY.
	LCDC_OVR2CFG9_CRKEY = 0x1
	// Position of INV field.
	LCDC_OVR2CFG9_INV_Pos = 0x1
	// Bit mask of INV field.
	LCDC_OVR2CFG9_INV_Msk = 0x2
	// Bit INV.
	LCDC_OVR2CFG9_INV = 0x2
	// Position of ITER2BL field.
	LCDC_OVR2CFG9_ITER2BL_Pos = 0x2
	// Bit mask of ITER2BL field.
	LCDC_OVR2CFG9_ITER2BL_Msk = 0x4
	// Bit ITER2BL.
	LCDC_OVR2CFG9_ITER2BL = 0x4
	// Position of ITER field.
	LCDC_OVR2CFG9_ITER_Pos = 0x3
	// Bit mask of ITER field.
	LCDC_OVR2CFG9_ITER_Msk = 0x8
	// Bit ITER.
	LCDC_OVR2CFG9_ITER = 0x8
	// Position of REVALPHA field.
	LCDC_OVR2CFG9_REVALPHA_Pos = 0x4
	// Bit mask of REVALPHA field.
	LCDC_OVR2CFG9_REVALPHA_Msk = 0x10
	// Bit REVALPHA.
	LCDC_OVR2CFG9_REVALPHA = 0x10
	// Position of GAEN field.
	LCDC_OVR2CFG9_GAEN_Pos = 0x5
	// Bit mask of GAEN field.
	LCDC_OVR2CFG9_GAEN_Msk = 0x20
	// Bit GAEN.
	LCDC_OVR2CFG9_GAEN = 0x20
	// Position of LAEN field.
	LCDC_OVR2CFG9_LAEN_Pos = 0x6
	// Bit mask of LAEN field.
	LCDC_OVR2CFG9_LAEN_Msk = 0x40
	// Bit LAEN.
	LCDC_OVR2CFG9_LAEN = 0x40
	// Position of OVR field.
	LCDC_OVR2CFG9_OVR_Pos = 0x7
	// Bit mask of OVR field.
	LCDC_OVR2CFG9_OVR_Msk = 0x80
	// Bit OVR.
	LCDC_OVR2CFG9_OVR = 0x80
	// Position of DMA field.
	LCDC_OVR2CFG9_DMA_Pos = 0x8
	// Bit mask of DMA field.
	LCDC_OVR2CFG9_DMA_Msk = 0x100
	// Bit DMA.
	LCDC_OVR2CFG9_DMA = 0x100
	// Position of REP field.
	LCDC_OVR2CFG9_REP_Pos = 0x9
	// Bit mask of REP field.
	LCDC_OVR2CFG9_REP_Msk = 0x200
	// Bit REP.
	LCDC_OVR2CFG9_REP = 0x200
	// Position of DSTKEY field.
	LCDC_OVR2CFG9_DSTKEY_Pos = 0xa
	// Bit mask of DSTKEY field.
	LCDC_OVR2CFG9_DSTKEY_Msk = 0x400
	// Bit DSTKEY.
	LCDC_OVR2CFG9_DSTKEY = 0x400
	// Position of GA field.
	LCDC_OVR2CFG9_GA_Pos = 0x10
	// Bit mask of GA field.
	LCDC_OVR2CFG9_GA_Msk = 0xff0000

	// HEOCHER: High-End Overlay Channel Enable Register
	// Position of CHEN field.
	LCDC_HEOCHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_HEOCHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_HEOCHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_HEOCHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_HEOCHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_HEOCHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_HEOCHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_HEOCHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_HEOCHER_A2QEN = 0x4

	// HEOCHDR: High-End Overlay Channel Disable Register
	// Position of CHDIS field.
	LCDC_HEOCHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_HEOCHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_HEOCHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_HEOCHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_HEOCHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_HEOCHDR_CHRST = 0x100

	// HEOCHSR: High-End Overlay Channel Status Register
	// Position of CHSR field.
	LCDC_HEOCHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_HEOCHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_HEOCHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_HEOCHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_HEOCHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_HEOCHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_HEOCHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_HEOCHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_HEOCHSR_A2QSR = 0x4

	// HEOIER: High-End Overlay Interrupt Enable Register
	// Position of DMA field.
	LCDC_HEOIER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HEOIER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HEOIER_DMA = 0x4
	// Position of DSCR field.
	LCDC_HEOIER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HEOIER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HEOIER_DSCR = 0x8
	// Position of ADD field.
	LCDC_HEOIER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HEOIER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HEOIER_ADD = 0x10
	// Position of DONE field.
	LCDC_HEOIER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HEOIER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HEOIER_DONE = 0x20
	// Position of OVR field.
	LCDC_HEOIER_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HEOIER_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HEOIER_OVR = 0x40
	// Position of UDMA field.
	LCDC_HEOIER_UDMA_Pos = 0xa
	// Bit mask of UDMA field.
	LCDC_HEOIER_UDMA_Msk = 0x400
	// Bit UDMA.
	LCDC_HEOIER_UDMA = 0x400
	// Position of UDSCR field.
	LCDC_HEOIER_UDSCR_Pos = 0xb
	// Bit mask of UDSCR field.
	LCDC_HEOIER_UDSCR_Msk = 0x800
	// Bit UDSCR.
	LCDC_HEOIER_UDSCR = 0x800
	// Position of UADD field.
	LCDC_HEOIER_UADD_Pos = 0xc
	// Bit mask of UADD field.
	LCDC_HEOIER_UADD_Msk = 0x1000
	// Bit UADD.
	LCDC_HEOIER_UADD = 0x1000
	// Position of UDONE field.
	LCDC_HEOIER_UDONE_Pos = 0xd
	// Bit mask of UDONE field.
	LCDC_HEOIER_UDONE_Msk = 0x2000
	// Bit UDONE.
	LCDC_HEOIER_UDONE = 0x2000
	// Position of UOVR field.
	LCDC_HEOIER_UOVR_Pos = 0xe
	// Bit mask of UOVR field.
	LCDC_HEOIER_UOVR_Msk = 0x4000
	// Bit UOVR.
	LCDC_HEOIER_UOVR = 0x4000
	// Position of VDMA field.
	LCDC_HEOIER_VDMA_Pos = 0x12
	// Bit mask of VDMA field.
	LCDC_HEOIER_VDMA_Msk = 0x40000
	// Bit VDMA.
	LCDC_HEOIER_VDMA = 0x40000
	// Position of VDSCR field.
	LCDC_HEOIER_VDSCR_Pos = 0x13
	// Bit mask of VDSCR field.
	LCDC_HEOIER_VDSCR_Msk = 0x80000
	// Bit VDSCR.
	LCDC_HEOIER_VDSCR = 0x80000
	// Position of VADD field.
	LCDC_HEOIER_VADD_Pos = 0x14
	// Bit mask of VADD field.
	LCDC_HEOIER_VADD_Msk = 0x100000
	// Bit VADD.
	LCDC_HEOIER_VADD = 0x100000
	// Position of VDONE field.
	LCDC_HEOIER_VDONE_Pos = 0x15
	// Bit mask of VDONE field.
	LCDC_HEOIER_VDONE_Msk = 0x200000
	// Bit VDONE.
	LCDC_HEOIER_VDONE = 0x200000
	// Position of VOVR field.
	LCDC_HEOIER_VOVR_Pos = 0x16
	// Bit mask of VOVR field.
	LCDC_HEOIER_VOVR_Msk = 0x400000
	// Bit VOVR.
	LCDC_HEOIER_VOVR = 0x400000

	// HEOIDR: High-End Overlay Interrupt Disable Register
	// Position of DMA field.
	LCDC_HEOIDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HEOIDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HEOIDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HEOIDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HEOIDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HEOIDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HEOIDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HEOIDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HEOIDR_ADD = 0x10
	// Position of DONE field.
	LCDC_HEOIDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HEOIDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HEOIDR_DONE = 0x20
	// Position of OVR field.
	LCDC_HEOIDR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HEOIDR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HEOIDR_OVR = 0x40
	// Position of UDMA field.
	LCDC_HEOIDR_UDMA_Pos = 0xa
	// Bit mask of UDMA field.
	LCDC_HEOIDR_UDMA_Msk = 0x400
	// Bit UDMA.
	LCDC_HEOIDR_UDMA = 0x400
	// Position of UDSCR field.
	LCDC_HEOIDR_UDSCR_Pos = 0xb
	// Bit mask of UDSCR field.
	LCDC_HEOIDR_UDSCR_Msk = 0x800
	// Bit UDSCR.
	LCDC_HEOIDR_UDSCR = 0x800
	// Position of UADD field.
	LCDC_HEOIDR_UADD_Pos = 0xc
	// Bit mask of UADD field.
	LCDC_HEOIDR_UADD_Msk = 0x1000
	// Bit UADD.
	LCDC_HEOIDR_UADD = 0x1000
	// Position of UDONE field.
	LCDC_HEOIDR_UDONE_Pos = 0xd
	// Bit mask of UDONE field.
	LCDC_HEOIDR_UDONE_Msk = 0x2000
	// Bit UDONE.
	LCDC_HEOIDR_UDONE = 0x2000
	// Position of UOVR field.
	LCDC_HEOIDR_UOVR_Pos = 0xe
	// Bit mask of UOVR field.
	LCDC_HEOIDR_UOVR_Msk = 0x4000
	// Bit UOVR.
	LCDC_HEOIDR_UOVR = 0x4000
	// Position of VDMA field.
	LCDC_HEOIDR_VDMA_Pos = 0x12
	// Bit mask of VDMA field.
	LCDC_HEOIDR_VDMA_Msk = 0x40000
	// Bit VDMA.
	LCDC_HEOIDR_VDMA = 0x40000
	// Position of VDSCR field.
	LCDC_HEOIDR_VDSCR_Pos = 0x13
	// Bit mask of VDSCR field.
	LCDC_HEOIDR_VDSCR_Msk = 0x80000
	// Bit VDSCR.
	LCDC_HEOIDR_VDSCR = 0x80000
	// Position of VADD field.
	LCDC_HEOIDR_VADD_Pos = 0x14
	// Bit mask of VADD field.
	LCDC_HEOIDR_VADD_Msk = 0x100000
	// Bit VADD.
	LCDC_HEOIDR_VADD = 0x100000
	// Position of VDONE field.
	LCDC_HEOIDR_VDONE_Pos = 0x15
	// Bit mask of VDONE field.
	LCDC_HEOIDR_VDONE_Msk = 0x200000
	// Bit VDONE.
	LCDC_HEOIDR_VDONE = 0x200000
	// Position of VOVR field.
	LCDC_HEOIDR_VOVR_Pos = 0x16
	// Bit mask of VOVR field.
	LCDC_HEOIDR_VOVR_Msk = 0x400000
	// Bit VOVR.
	LCDC_HEOIDR_VOVR = 0x400000

	// HEOIMR: High-End Overlay Interrupt Mask Register
	// Position of DMA field.
	LCDC_HEOIMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HEOIMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HEOIMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HEOIMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HEOIMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HEOIMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HEOIMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HEOIMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HEOIMR_ADD = 0x10
	// Position of DONE field.
	LCDC_HEOIMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HEOIMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HEOIMR_DONE = 0x20
	// Position of OVR field.
	LCDC_HEOIMR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HEOIMR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HEOIMR_OVR = 0x40
	// Position of UDMA field.
	LCDC_HEOIMR_UDMA_Pos = 0xa
	// Bit mask of UDMA field.
	LCDC_HEOIMR_UDMA_Msk = 0x400
	// Bit UDMA.
	LCDC_HEOIMR_UDMA = 0x400
	// Position of UDSCR field.
	LCDC_HEOIMR_UDSCR_Pos = 0xb
	// Bit mask of UDSCR field.
	LCDC_HEOIMR_UDSCR_Msk = 0x800
	// Bit UDSCR.
	LCDC_HEOIMR_UDSCR = 0x800
	// Position of UADD field.
	LCDC_HEOIMR_UADD_Pos = 0xc
	// Bit mask of UADD field.
	LCDC_HEOIMR_UADD_Msk = 0x1000
	// Bit UADD.
	LCDC_HEOIMR_UADD = 0x1000
	// Position of UDONE field.
	LCDC_HEOIMR_UDONE_Pos = 0xd
	// Bit mask of UDONE field.
	LCDC_HEOIMR_UDONE_Msk = 0x2000
	// Bit UDONE.
	LCDC_HEOIMR_UDONE = 0x2000
	// Position of UOVR field.
	LCDC_HEOIMR_UOVR_Pos = 0xe
	// Bit mask of UOVR field.
	LCDC_HEOIMR_UOVR_Msk = 0x4000
	// Bit UOVR.
	LCDC_HEOIMR_UOVR = 0x4000
	// Position of VDMA field.
	LCDC_HEOIMR_VDMA_Pos = 0x12
	// Bit mask of VDMA field.
	LCDC_HEOIMR_VDMA_Msk = 0x40000
	// Bit VDMA.
	LCDC_HEOIMR_VDMA = 0x40000
	// Position of VDSCR field.
	LCDC_HEOIMR_VDSCR_Pos = 0x13
	// Bit mask of VDSCR field.
	LCDC_HEOIMR_VDSCR_Msk = 0x80000
	// Bit VDSCR.
	LCDC_HEOIMR_VDSCR = 0x80000
	// Position of VADD field.
	LCDC_HEOIMR_VADD_Pos = 0x14
	// Bit mask of VADD field.
	LCDC_HEOIMR_VADD_Msk = 0x100000
	// Bit VADD.
	LCDC_HEOIMR_VADD = 0x100000
	// Position of VDONE field.
	LCDC_HEOIMR_VDONE_Pos = 0x15
	// Bit mask of VDONE field.
	LCDC_HEOIMR_VDONE_Msk = 0x200000
	// Bit VDONE.
	LCDC_HEOIMR_VDONE = 0x200000
	// Position of VOVR field.
	LCDC_HEOIMR_VOVR_Pos = 0x16
	// Bit mask of VOVR field.
	LCDC_HEOIMR_VOVR_Msk = 0x400000
	// Bit VOVR.
	LCDC_HEOIMR_VOVR = 0x400000

	// HEOISR: High-End Overlay Interrupt Status Register
	// Position of DMA field.
	LCDC_HEOISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HEOISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HEOISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HEOISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HEOISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HEOISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HEOISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HEOISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HEOISR_ADD = 0x10
	// Position of DONE field.
	LCDC_HEOISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HEOISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HEOISR_DONE = 0x20
	// Position of OVR field.
	LCDC_HEOISR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HEOISR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HEOISR_OVR = 0x40
	// Position of UDMA field.
	LCDC_HEOISR_UDMA_Pos = 0xa
	// Bit mask of UDMA field.
	LCDC_HEOISR_UDMA_Msk = 0x400
	// Bit UDMA.
	LCDC_HEOISR_UDMA = 0x400
	// Position of UDSCR field.
	LCDC_HEOISR_UDSCR_Pos = 0xb
	// Bit mask of UDSCR field.
	LCDC_HEOISR_UDSCR_Msk = 0x800
	// Bit UDSCR.
	LCDC_HEOISR_UDSCR = 0x800
	// Position of UADD field.
	LCDC_HEOISR_UADD_Pos = 0xc
	// Bit mask of UADD field.
	LCDC_HEOISR_UADD_Msk = 0x1000
	// Bit UADD.
	LCDC_HEOISR_UADD = 0x1000
	// Position of UDONE field.
	LCDC_HEOISR_UDONE_Pos = 0xd
	// Bit mask of UDONE field.
	LCDC_HEOISR_UDONE_Msk = 0x2000
	// Bit UDONE.
	LCDC_HEOISR_UDONE = 0x2000
	// Position of UOVR field.
	LCDC_HEOISR_UOVR_Pos = 0xe
	// Bit mask of UOVR field.
	LCDC_HEOISR_UOVR_Msk = 0x4000
	// Bit UOVR.
	LCDC_HEOISR_UOVR = 0x4000
	// Position of VDMA field.
	LCDC_HEOISR_VDMA_Pos = 0x12
	// Bit mask of VDMA field.
	LCDC_HEOISR_VDMA_Msk = 0x40000
	// Bit VDMA.
	LCDC_HEOISR_VDMA = 0x40000
	// Position of VDSCR field.
	LCDC_HEOISR_VDSCR_Pos = 0x13
	// Bit mask of VDSCR field.
	LCDC_HEOISR_VDSCR_Msk = 0x80000
	// Bit VDSCR.
	LCDC_HEOISR_VDSCR = 0x80000
	// Position of VADD field.
	LCDC_HEOISR_VADD_Pos = 0x14
	// Bit mask of VADD field.
	LCDC_HEOISR_VADD_Msk = 0x100000
	// Bit VADD.
	LCDC_HEOISR_VADD = 0x100000
	// Position of VDONE field.
	LCDC_HEOISR_VDONE_Pos = 0x15
	// Bit mask of VDONE field.
	LCDC_HEOISR_VDONE_Msk = 0x200000
	// Bit VDONE.
	LCDC_HEOISR_VDONE = 0x200000
	// Position of VOVR field.
	LCDC_HEOISR_VOVR_Pos = 0x16
	// Bit mask of VOVR field.
	LCDC_HEOISR_VOVR_Msk = 0x400000
	// Bit VOVR.
	LCDC_HEOISR_VOVR = 0x400000

	// HEOHEAD: High-End Overlay DMA Head Register
	// Position of HEAD field.
	LCDC_HEOHEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_HEOHEAD_HEAD_Msk = 0xfffffffc

	// HEOADDR: High-End Overlay DMA Address Register
	// Position of ADDR field.
	LCDC_HEOADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_HEOADDR_ADDR_Msk = 0xffffffff

	// HEOCTRL: High-End Overlay DMA Control Register
	// Position of DFETCH field.
	LCDC_HEOCTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_HEOCTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_HEOCTRL_DFETCH = 0x1
	// Position of LFETCH field.
	LCDC_HEOCTRL_LFETCH_Pos = 0x1
	// Bit mask of LFETCH field.
	LCDC_HEOCTRL_LFETCH_Msk = 0x2
	// Bit LFETCH.
	LCDC_HEOCTRL_LFETCH = 0x2
	// Position of DMAIEN field.
	LCDC_HEOCTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_HEOCTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_HEOCTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_HEOCTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_HEOCTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_HEOCTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_HEOCTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_HEOCTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_HEOCTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_HEOCTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_HEOCTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_HEOCTRL_DONEIEN = 0x20

	// HEONEXT: High-End Overlay DMA Next Register
	// Position of NEXT field.
	LCDC_HEONEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_HEONEXT_NEXT_Msk = 0xffffffff

	// HEOUHEAD: High-End Overlay U DMA Head Register
	// Position of UHEAD field.
	LCDC_HEOUHEAD_UHEAD_Pos = 0x0
	// Bit mask of UHEAD field.
	LCDC_HEOUHEAD_UHEAD_Msk = 0xffffffff

	// HEOUADDR: High-End Overlay U DMA Address Register
	// Position of UADDR field.
	LCDC_HEOUADDR_UADDR_Pos = 0x0
	// Bit mask of UADDR field.
	LCDC_HEOUADDR_UADDR_Msk = 0xffffffff

	// HEOUCTRL: High-End Overlay U DMA control Register
	// Position of UDFETCH field.
	LCDC_HEOUCTRL_UDFETCH_Pos = 0x0
	// Bit mask of UDFETCH field.
	LCDC_HEOUCTRL_UDFETCH_Msk = 0x1
	// Bit UDFETCH.
	LCDC_HEOUCTRL_UDFETCH = 0x1
	// Position of UDMAIEN field.
	LCDC_HEOUCTRL_UDMAIEN_Pos = 0x2
	// Bit mask of UDMAIEN field.
	LCDC_HEOUCTRL_UDMAIEN_Msk = 0x4
	// Bit UDMAIEN.
	LCDC_HEOUCTRL_UDMAIEN = 0x4
	// Position of UDSCRIEN field.
	LCDC_HEOUCTRL_UDSCRIEN_Pos = 0x3
	// Bit mask of UDSCRIEN field.
	LCDC_HEOUCTRL_UDSCRIEN_Msk = 0x8
	// Bit UDSCRIEN.
	LCDC_HEOUCTRL_UDSCRIEN = 0x8
	// Position of UADDIEN field.
	LCDC_HEOUCTRL_UADDIEN_Pos = 0x4
	// Bit mask of UADDIEN field.
	LCDC_HEOUCTRL_UADDIEN_Msk = 0x10
	// Bit UADDIEN.
	LCDC_HEOUCTRL_UADDIEN = 0x10
	// Position of UDONEIEN field.
	LCDC_HEOUCTRL_UDONEIEN_Pos = 0x5
	// Bit mask of UDONEIEN field.
	LCDC_HEOUCTRL_UDONEIEN_Msk = 0x20
	// Bit UDONEIEN.
	LCDC_HEOUCTRL_UDONEIEN = 0x20

	// HEOUNEXT: High-End Overlay U DMA Next Register
	// Position of UNEXT field.
	LCDC_HEOUNEXT_UNEXT_Pos = 0x0
	// Bit mask of UNEXT field.
	LCDC_HEOUNEXT_UNEXT_Msk = 0xffffffff

	// HEOVHEAD: High-End Overlay V DMA Head Register
	// Position of VHEAD field.
	LCDC_HEOVHEAD_VHEAD_Pos = 0x0
	// Bit mask of VHEAD field.
	LCDC_HEOVHEAD_VHEAD_Msk = 0xffffffff

	// HEOVADDR: High-End Overlay V DMA Address Register
	// Position of VADDR field.
	LCDC_HEOVADDR_VADDR_Pos = 0x0
	// Bit mask of VADDR field.
	LCDC_HEOVADDR_VADDR_Msk = 0xffffffff

	// HEOVCTRL: High-End Overlay V DMA control Register
	// Position of VDFETCH field.
	LCDC_HEOVCTRL_VDFETCH_Pos = 0x0
	// Bit mask of VDFETCH field.
	LCDC_HEOVCTRL_VDFETCH_Msk = 0x1
	// Bit VDFETCH.
	LCDC_HEOVCTRL_VDFETCH = 0x1
	// Position of VDMAIEN field.
	LCDC_HEOVCTRL_VDMAIEN_Pos = 0x2
	// Bit mask of VDMAIEN field.
	LCDC_HEOVCTRL_VDMAIEN_Msk = 0x4
	// Bit VDMAIEN.
	LCDC_HEOVCTRL_VDMAIEN = 0x4
	// Position of VDSCRIEN field.
	LCDC_HEOVCTRL_VDSCRIEN_Pos = 0x3
	// Bit mask of VDSCRIEN field.
	LCDC_HEOVCTRL_VDSCRIEN_Msk = 0x8
	// Bit VDSCRIEN.
	LCDC_HEOVCTRL_VDSCRIEN = 0x8
	// Position of VADDIEN field.
	LCDC_HEOVCTRL_VADDIEN_Pos = 0x4
	// Bit mask of VADDIEN field.
	LCDC_HEOVCTRL_VADDIEN_Msk = 0x10
	// Bit VADDIEN.
	LCDC_HEOVCTRL_VADDIEN = 0x10
	// Position of VDONEIEN field.
	LCDC_HEOVCTRL_VDONEIEN_Pos = 0x5
	// Bit mask of VDONEIEN field.
	LCDC_HEOVCTRL_VDONEIEN_Msk = 0x20
	// Bit VDONEIEN.
	LCDC_HEOVCTRL_VDONEIEN = 0x20

	// HEOVNEXT: High-End Overlay VDMA Next Register
	// Position of VNEXT field.
	LCDC_HEOVNEXT_VNEXT_Pos = 0x0
	// Bit mask of VNEXT field.
	LCDC_HEOVNEXT_VNEXT_Msk = 0xffffffff

	// HEOCFG0: High-End Overlay Configuration Register 0
	// Position of SIF field.
	LCDC_HEOCFG0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	LCDC_HEOCFG0_SIF_Msk = 0x1
	// Bit SIF.
	LCDC_HEOCFG0_SIF = 0x1
	// Position of BLEN field.
	LCDC_HEOCFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_HEOCFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLEN_AHB_BLEN_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLEN_AHB_BLEN_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLEN_AHB_BLEN_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLEN_AHB_BLEN_INCR16 = 0x3
	// Position of BLENUV field.
	LCDC_HEOCFG0_BLENUV_Pos = 0x6
	// Bit mask of BLENUV field.
	LCDC_HEOCFG0_BLENUV_Msk = 0xc0
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLENUV_AHB_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLENUV_AHB_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLENUV_AHB_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HEOCFG0_BLENUV_AHB_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_HEOCFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_HEOCFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_HEOCFG0_DLBO = 0x100
	// Position of ROTDIS field.
	LCDC_HEOCFG0_ROTDIS_Pos = 0xc
	// Bit mask of ROTDIS field.
	LCDC_HEOCFG0_ROTDIS_Msk = 0x1000
	// Bit ROTDIS.
	LCDC_HEOCFG0_ROTDIS = 0x1000
	// Position of LOCKDIS field.
	LCDC_HEOCFG0_LOCKDIS_Pos = 0xd
	// Bit mask of LOCKDIS field.
	LCDC_HEOCFG0_LOCKDIS_Msk = 0x2000
	// Bit LOCKDIS.
	LCDC_HEOCFG0_LOCKDIS = 0x2000

	// HEOCFG1: High-End Overlay Configuration Register 1
	// Position of CLUTEN field.
	LCDC_HEOCFG1_CLUTEN_Pos = 0x0
	// Bit mask of CLUTEN field.
	LCDC_HEOCFG1_CLUTEN_Msk = 0x1
	// Bit CLUTEN.
	LCDC_HEOCFG1_CLUTEN = 0x1
	// Position of YUVEN field.
	LCDC_HEOCFG1_YUVEN_Pos = 0x1
	// Bit mask of YUVEN field.
	LCDC_HEOCFG1_YUVEN_Msk = 0x2
	// Bit YUVEN.
	LCDC_HEOCFG1_YUVEN = 0x2
	// Position of RGBMODE field.
	LCDC_HEOCFG1_RGBMODE_Pos = 0x4
	// Bit mask of RGBMODE field.
	LCDC_HEOCFG1_RGBMODE_Msk = 0xf0
	// 12 bpp RGB 444
	LCDC_HEOCFG1_RGBMODE_12BPP_RGB_444 = 0x0
	// 16 bpp ARGB 4444
	LCDC_HEOCFG1_RGBMODE_16BPP_ARGB_4444 = 0x1
	// 16 bpp RGBA 4444
	LCDC_HEOCFG1_RGBMODE_16BPP_RGBA_4444 = 0x2
	// 16 bpp RGB 565
	LCDC_HEOCFG1_RGBMODE_16BPP_RGB_565 = 0x3
	// 16 bpp TRGB 1555
	LCDC_HEOCFG1_RGBMODE_16BPP_TRGB_1555 = 0x4
	// 18 bpp RGB 666
	LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666 = 0x5
	// 18 bpp RGB 666 PACKED
	LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666PACKED = 0x6
	// 19 bpp TRGB 1666
	LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_1666 = 0x7
	// 19 bpp TRGB 1666 PACKED
	LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_PACKED = 0x8
	// 24 bpp RGB 888
	LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888 = 0x9
	// 24 bpp RGB 888 PACKED
	LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED = 0xa
	// 25 bpp TRGB 1888
	LCDC_HEOCFG1_RGBMODE_25BPP_TRGB_1888 = 0xb
	// 32 bpp ARGB 8888
	LCDC_HEOCFG1_RGBMODE_32BPP_ARGB_8888 = 0xc
	// 32 bpp RGBA 8888
	LCDC_HEOCFG1_RGBMODE_32BPP_RGBA_8888 = 0xd
	// Position of CLUTMODE field.
	LCDC_HEOCFG1_CLUTMODE_Pos = 0x8
	// Bit mask of CLUTMODE field.
	LCDC_HEOCFG1_CLUTMODE_Msk = 0x300
	// color lookup table mode set to 1 bit per pixel
	LCDC_HEOCFG1_CLUTMODE_CLUT_1BPP = 0x0
	// color lookup table mode set to 2 bits per pixel
	LCDC_HEOCFG1_CLUTMODE_CLUT_2BPP = 0x1
	// color lookup table mode set to 4 bits per pixel
	LCDC_HEOCFG1_CLUTMODE_CLUT_4BPP = 0x2
	// color lookup table mode set to 8 bits per pixel
	LCDC_HEOCFG1_CLUTMODE_CLUT_8BPP = 0x3
	// Position of YUVMODE field.
	LCDC_HEOCFG1_YUVMODE_Pos = 0xc
	// Bit mask of YUVMODE field.
	LCDC_HEOCFG1_YUVMODE_Msk = 0xf000
	// 32 bpp AYCbCr 444
	LCDC_HEOCFG1_YUVMODE_32BPP_AYCBCR = 0x0
	// 16 bpp Cr(n)Y(n+1)Cb(n)Y(n) 422
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE0 = 0x1
	// 16 bpp Y(n+1)Cr(n)Y(n)Cb(n) 422
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE1 = 0x2
	// 16 bpp Cb(n)Y(+1)Cr(n)Y(n) 422
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE2 = 0x3
	// 16 bpp Y(n+1)Cb(n)Y(n)Cr(n) 422
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE3 = 0x4
	// 16 bpp Semiplanar 422 YCbCr
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_SEMIPLANAR = 0x5
	// 16 bpp Planar 422 YCbCr
	LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_PLANAR = 0x6
	// 12 bpp Semiplanar 420 YCbCr
	LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_SEMIPLANAR = 0x7
	// 12 bpp Planar 420 YCbCr
	LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_PLANAR = 0x8
	// Position of YUV422ROT field.
	LCDC_HEOCFG1_YUV422ROT_Pos = 0x10
	// Bit mask of YUV422ROT field.
	LCDC_HEOCFG1_YUV422ROT_Msk = 0x10000
	// Bit YUV422ROT.
	LCDC_HEOCFG1_YUV422ROT = 0x10000
	// Position of YUV422SWP field.
	LCDC_HEOCFG1_YUV422SWP_Pos = 0x11
	// Bit mask of YUV422SWP field.
	LCDC_HEOCFG1_YUV422SWP_Msk = 0x20000
	// Bit YUV422SWP.
	LCDC_HEOCFG1_YUV422SWP = 0x20000
	// Position of DSCALEOPT field.
	LCDC_HEOCFG1_DSCALEOPT_Pos = 0x14
	// Bit mask of DSCALEOPT field.
	LCDC_HEOCFG1_DSCALEOPT_Msk = 0x100000
	// Bit DSCALEOPT.
	LCDC_HEOCFG1_DSCALEOPT = 0x100000

	// HEOCFG2: High-End Overlay Configuration Register 2
	// Position of XPOS field.
	LCDC_HEOCFG2_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	LCDC_HEOCFG2_XPOS_Msk = 0x7ff
	// Position of YPOS field.
	LCDC_HEOCFG2_YPOS_Pos = 0x10
	// Bit mask of YPOS field.
	LCDC_HEOCFG2_YPOS_Msk = 0x7ff0000

	// HEOCFG3: High-End Overlay Configuration Register 3
	// Position of XSIZE field.
	LCDC_HEOCFG3_XSIZE_Pos = 0x0
	// Bit mask of XSIZE field.
	LCDC_HEOCFG3_XSIZE_Msk = 0x7ff
	// Position of YSIZE field.
	LCDC_HEOCFG3_YSIZE_Pos = 0x10
	// Bit mask of YSIZE field.
	LCDC_HEOCFG3_YSIZE_Msk = 0x7ff0000

	// HEOCFG4: High-End Overlay Configuration Register 4
	// Position of XMEMSIZE field.
	LCDC_HEOCFG4_XMEMSIZE_Pos = 0x0
	// Bit mask of XMEMSIZE field.
	LCDC_HEOCFG4_XMEMSIZE_Msk = 0x7ff
	// Position of YMEMSIZE field.
	LCDC_HEOCFG4_YMEMSIZE_Pos = 0x10
	// Bit mask of YMEMSIZE field.
	LCDC_HEOCFG4_YMEMSIZE_Msk = 0x7ff0000

	// HEOCFG5: High-End Overlay Configuration Register 5
	// Position of XSTRIDE field.
	LCDC_HEOCFG5_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_HEOCFG5_XSTRIDE_Msk = 0xffffffff

	// HEOCFG6: High-End Overlay Configuration Register 6
	// Position of PSTRIDE field.
	LCDC_HEOCFG6_PSTRIDE_Pos = 0x0
	// Bit mask of PSTRIDE field.
	LCDC_HEOCFG6_PSTRIDE_Msk = 0xffffffff

	// HEOCFG7: High-End Overlay Configuration Register 7
	// Position of UVXSTRIDE field.
	LCDC_HEOCFG7_UVXSTRIDE_Pos = 0x0
	// Bit mask of UVXSTRIDE field.
	LCDC_HEOCFG7_UVXSTRIDE_Msk = 0xffffffff

	// HEOCFG8: High-End Overlay Configuration Register 8
	// Position of UVPSTRIDE field.
	LCDC_HEOCFG8_UVPSTRIDE_Pos = 0x0
	// Bit mask of UVPSTRIDE field.
	LCDC_HEOCFG8_UVPSTRIDE_Msk = 0xffffffff

	// HEOCFG9: High-End Overlay Configuration Register 9
	// Position of BDEF field.
	LCDC_HEOCFG9_BDEF_Pos = 0x0
	// Bit mask of BDEF field.
	LCDC_HEOCFG9_BDEF_Msk = 0xff
	// Position of GDEF field.
	LCDC_HEOCFG9_GDEF_Pos = 0x8
	// Bit mask of GDEF field.
	LCDC_HEOCFG9_GDEF_Msk = 0xff00
	// Position of RDEF field.
	LCDC_HEOCFG9_RDEF_Pos = 0x10
	// Bit mask of RDEF field.
	LCDC_HEOCFG9_RDEF_Msk = 0xff0000

	// HEOCFG10: High-End Overlay Configuration Register 10
	// Position of BKEY field.
	LCDC_HEOCFG10_BKEY_Pos = 0x0
	// Bit mask of BKEY field.
	LCDC_HEOCFG10_BKEY_Msk = 0xff
	// Position of GKEY field.
	LCDC_HEOCFG10_GKEY_Pos = 0x8
	// Bit mask of GKEY field.
	LCDC_HEOCFG10_GKEY_Msk = 0xff00
	// Position of RKEY field.
	LCDC_HEOCFG10_RKEY_Pos = 0x10
	// Bit mask of RKEY field.
	LCDC_HEOCFG10_RKEY_Msk = 0xff0000

	// HEOCFG11: High-End Overlay Configuration Register 11
	// Position of BMASK field.
	LCDC_HEOCFG11_BMASK_Pos = 0x0
	// Bit mask of BMASK field.
	LCDC_HEOCFG11_BMASK_Msk = 0xff
	// Position of GMASK field.
	LCDC_HEOCFG11_GMASK_Pos = 0x8
	// Bit mask of GMASK field.
	LCDC_HEOCFG11_GMASK_Msk = 0xff00
	// Position of RMASK field.
	LCDC_HEOCFG11_RMASK_Pos = 0x10
	// Bit mask of RMASK field.
	LCDC_HEOCFG11_RMASK_Msk = 0xff0000

	// HEOCFG12: High-End Overlay Configuration Register 12
	// Position of CRKEY field.
	LCDC_HEOCFG12_CRKEY_Pos = 0x0
	// Bit mask of CRKEY field.
	LCDC_HEOCFG12_CRKEY_Msk = 0x1
	// Bit CRKEY.
	LCDC_HEOCFG12_CRKEY = 0x1
	// Position of INV field.
	LCDC_HEOCFG12_INV_Pos = 0x1
	// Bit mask of INV field.
	LCDC_HEOCFG12_INV_Msk = 0x2
	// Bit INV.
	LCDC_HEOCFG12_INV = 0x2
	// Position of ITER2BL field.
	LCDC_HEOCFG12_ITER2BL_Pos = 0x2
	// Bit mask of ITER2BL field.
	LCDC_HEOCFG12_ITER2BL_Msk = 0x4
	// Bit ITER2BL.
	LCDC_HEOCFG12_ITER2BL = 0x4
	// Position of ITER field.
	LCDC_HEOCFG12_ITER_Pos = 0x3
	// Bit mask of ITER field.
	LCDC_HEOCFG12_ITER_Msk = 0x8
	// Bit ITER.
	LCDC_HEOCFG12_ITER = 0x8
	// Position of REVALPHA field.
	LCDC_HEOCFG12_REVALPHA_Pos = 0x4
	// Bit mask of REVALPHA field.
	LCDC_HEOCFG12_REVALPHA_Msk = 0x10
	// Bit REVALPHA.
	LCDC_HEOCFG12_REVALPHA = 0x10
	// Position of GAEN field.
	LCDC_HEOCFG12_GAEN_Pos = 0x5
	// Bit mask of GAEN field.
	LCDC_HEOCFG12_GAEN_Msk = 0x20
	// Bit GAEN.
	LCDC_HEOCFG12_GAEN = 0x20
	// Position of LAEN field.
	LCDC_HEOCFG12_LAEN_Pos = 0x6
	// Bit mask of LAEN field.
	LCDC_HEOCFG12_LAEN_Msk = 0x40
	// Bit LAEN.
	LCDC_HEOCFG12_LAEN = 0x40
	// Position of OVR field.
	LCDC_HEOCFG12_OVR_Pos = 0x7
	// Bit mask of OVR field.
	LCDC_HEOCFG12_OVR_Msk = 0x80
	// Bit OVR.
	LCDC_HEOCFG12_OVR = 0x80
	// Position of DMA field.
	LCDC_HEOCFG12_DMA_Pos = 0x8
	// Bit mask of DMA field.
	LCDC_HEOCFG12_DMA_Msk = 0x100
	// Bit DMA.
	LCDC_HEOCFG12_DMA = 0x100
	// Position of REP field.
	LCDC_HEOCFG12_REP_Pos = 0x9
	// Bit mask of REP field.
	LCDC_HEOCFG12_REP_Msk = 0x200
	// Bit REP.
	LCDC_HEOCFG12_REP = 0x200
	// Position of DSTKEY field.
	LCDC_HEOCFG12_DSTKEY_Pos = 0xa
	// Bit mask of DSTKEY field.
	LCDC_HEOCFG12_DSTKEY_Msk = 0x400
	// Bit DSTKEY.
	LCDC_HEOCFG12_DSTKEY = 0x400
	// Position of VIDPRI field.
	LCDC_HEOCFG12_VIDPRI_Pos = 0xc
	// Bit mask of VIDPRI field.
	LCDC_HEOCFG12_VIDPRI_Msk = 0x1000
	// Bit VIDPRI.
	LCDC_HEOCFG12_VIDPRI = 0x1000
	// Position of GA field.
	LCDC_HEOCFG12_GA_Pos = 0x10
	// Bit mask of GA field.
	LCDC_HEOCFG12_GA_Msk = 0xff0000

	// HEOCFG13: High-End Overlay Configuration Register 13
	// Position of XFACTOR field.
	LCDC_HEOCFG13_XFACTOR_Pos = 0x0
	// Bit mask of XFACTOR field.
	LCDC_HEOCFG13_XFACTOR_Msk = 0x3fff
	// Position of YFACTOR field.
	LCDC_HEOCFG13_YFACTOR_Pos = 0x10
	// Bit mask of YFACTOR field.
	LCDC_HEOCFG13_YFACTOR_Msk = 0x3fff0000
	// Position of SCALEN field.
	LCDC_HEOCFG13_SCALEN_Pos = 0x1f
	// Bit mask of SCALEN field.
	LCDC_HEOCFG13_SCALEN_Msk = 0x80000000
	// Bit SCALEN.
	LCDC_HEOCFG13_SCALEN = 0x80000000

	// HEOCFG14: High-End Overlay Configuration Register 14
	// Position of CSCRY field.
	LCDC_HEOCFG14_CSCRY_Pos = 0x0
	// Bit mask of CSCRY field.
	LCDC_HEOCFG14_CSCRY_Msk = 0x3ff
	// Position of CSCRU field.
	LCDC_HEOCFG14_CSCRU_Pos = 0xa
	// Bit mask of CSCRU field.
	LCDC_HEOCFG14_CSCRU_Msk = 0xffc00
	// Position of CSCRV field.
	LCDC_HEOCFG14_CSCRV_Pos = 0x14
	// Bit mask of CSCRV field.
	LCDC_HEOCFG14_CSCRV_Msk = 0x3ff00000
	// Position of CSCYOFF field.
	LCDC_HEOCFG14_CSCYOFF_Pos = 0x1e
	// Bit mask of CSCYOFF field.
	LCDC_HEOCFG14_CSCYOFF_Msk = 0x40000000
	// Bit CSCYOFF.
	LCDC_HEOCFG14_CSCYOFF = 0x40000000

	// HEOCFG15: High-End Overlay Configuration Register 15
	// Position of CSCGY field.
	LCDC_HEOCFG15_CSCGY_Pos = 0x0
	// Bit mask of CSCGY field.
	LCDC_HEOCFG15_CSCGY_Msk = 0x3ff
	// Position of CSCGU field.
	LCDC_HEOCFG15_CSCGU_Pos = 0xa
	// Bit mask of CSCGU field.
	LCDC_HEOCFG15_CSCGU_Msk = 0xffc00
	// Position of CSCGV field.
	LCDC_HEOCFG15_CSCGV_Pos = 0x14
	// Bit mask of CSCGV field.
	LCDC_HEOCFG15_CSCGV_Msk = 0x3ff00000
	// Position of CSCUOFF field.
	LCDC_HEOCFG15_CSCUOFF_Pos = 0x1e
	// Bit mask of CSCUOFF field.
	LCDC_HEOCFG15_CSCUOFF_Msk = 0x40000000
	// Bit CSCUOFF.
	LCDC_HEOCFG15_CSCUOFF = 0x40000000

	// HEOCFG16: High-End Overlay Configuration Register 16
	// Position of CSCBY field.
	LCDC_HEOCFG16_CSCBY_Pos = 0x0
	// Bit mask of CSCBY field.
	LCDC_HEOCFG16_CSCBY_Msk = 0x3ff
	// Position of CSCBU field.
	LCDC_HEOCFG16_CSCBU_Pos = 0xa
	// Bit mask of CSCBU field.
	LCDC_HEOCFG16_CSCBU_Msk = 0xffc00
	// Position of CSCBV field.
	LCDC_HEOCFG16_CSCBV_Pos = 0x14
	// Bit mask of CSCBV field.
	LCDC_HEOCFG16_CSCBV_Msk = 0x3ff00000
	// Position of CSCVOFF field.
	LCDC_HEOCFG16_CSCVOFF_Pos = 0x1e
	// Bit mask of CSCVOFF field.
	LCDC_HEOCFG16_CSCVOFF_Msk = 0x40000000
	// Bit CSCVOFF.
	LCDC_HEOCFG16_CSCVOFF = 0x40000000

	// HEOCFG17: High-End Overlay Configuration Register 17
	// Position of XPHI0COEFF0 field.
	LCDC_HEOCFG17_XPHI0COEFF0_Pos = 0x0
	// Bit mask of XPHI0COEFF0 field.
	LCDC_HEOCFG17_XPHI0COEFF0_Msk = 0xff
	// Position of XPHI0COEFF1 field.
	LCDC_HEOCFG17_XPHI0COEFF1_Pos = 0x8
	// Bit mask of XPHI0COEFF1 field.
	LCDC_HEOCFG17_XPHI0COEFF1_Msk = 0xff00
	// Position of XPHI0COEFF2 field.
	LCDC_HEOCFG17_XPHI0COEFF2_Pos = 0x10
	// Bit mask of XPHI0COEFF2 field.
	LCDC_HEOCFG17_XPHI0COEFF2_Msk = 0xff0000
	// Position of XPHI0COEFF3 field.
	LCDC_HEOCFG17_XPHI0COEFF3_Pos = 0x18
	// Bit mask of XPHI0COEFF3 field.
	LCDC_HEOCFG17_XPHI0COEFF3_Msk = 0xff000000

	// HEOCFG18: High-End Overlay Configuration Register 18
	// Position of XPHI0COEFF4 field.
	LCDC_HEOCFG18_XPHI0COEFF4_Pos = 0x0
	// Bit mask of XPHI0COEFF4 field.
	LCDC_HEOCFG18_XPHI0COEFF4_Msk = 0xff

	// HEOCFG19: High-End Overlay Configuration Register 19
	// Position of XPHI1COEFF0 field.
	LCDC_HEOCFG19_XPHI1COEFF0_Pos = 0x0
	// Bit mask of XPHI1COEFF0 field.
	LCDC_HEOCFG19_XPHI1COEFF0_Msk = 0xff
	// Position of XPHI1COEFF1 field.
	LCDC_HEOCFG19_XPHI1COEFF1_Pos = 0x8
	// Bit mask of XPHI1COEFF1 field.
	LCDC_HEOCFG19_XPHI1COEFF1_Msk = 0xff00
	// Position of XPHI1COEFF2 field.
	LCDC_HEOCFG19_XPHI1COEFF2_Pos = 0x10
	// Bit mask of XPHI1COEFF2 field.
	LCDC_HEOCFG19_XPHI1COEFF2_Msk = 0xff0000
	// Position of XPHI1COEFF3 field.
	LCDC_HEOCFG19_XPHI1COEFF3_Pos = 0x18
	// Bit mask of XPHI1COEFF3 field.
	LCDC_HEOCFG19_XPHI1COEFF3_Msk = 0xff000000

	// HEOCFG20: High-End Overlay Configuration Register 20
	// Position of XPHI1COEFF4 field.
	LCDC_HEOCFG20_XPHI1COEFF4_Pos = 0x0
	// Bit mask of XPHI1COEFF4 field.
	LCDC_HEOCFG20_XPHI1COEFF4_Msk = 0xff

	// HEOCFG21: High-End Overlay Configuration Register 21
	// Position of XPHI2COEFF0 field.
	LCDC_HEOCFG21_XPHI2COEFF0_Pos = 0x0
	// Bit mask of XPHI2COEFF0 field.
	LCDC_HEOCFG21_XPHI2COEFF0_Msk = 0xff
	// Position of XPHI2COEFF1 field.
	LCDC_HEOCFG21_XPHI2COEFF1_Pos = 0x8
	// Bit mask of XPHI2COEFF1 field.
	LCDC_HEOCFG21_XPHI2COEFF1_Msk = 0xff00
	// Position of XPHI2COEFF2 field.
	LCDC_HEOCFG21_XPHI2COEFF2_Pos = 0x10
	// Bit mask of XPHI2COEFF2 field.
	LCDC_HEOCFG21_XPHI2COEFF2_Msk = 0xff0000
	// Position of XPHI2COEFF3 field.
	LCDC_HEOCFG21_XPHI2COEFF3_Pos = 0x18
	// Bit mask of XPHI2COEFF3 field.
	LCDC_HEOCFG21_XPHI2COEFF3_Msk = 0xff000000

	// HEOCFG22: High-End Overlay Configuration Register 22
	// Position of XPHI2COEFF4 field.
	LCDC_HEOCFG22_XPHI2COEFF4_Pos = 0x0
	// Bit mask of XPHI2COEFF4 field.
	LCDC_HEOCFG22_XPHI2COEFF4_Msk = 0xff

	// HEOCFG23: High-End Overlay Configuration Register 23
	// Position of XPHI3COEFF0 field.
	LCDC_HEOCFG23_XPHI3COEFF0_Pos = 0x0
	// Bit mask of XPHI3COEFF0 field.
	LCDC_HEOCFG23_XPHI3COEFF0_Msk = 0xff
	// Position of XPHI3COEFF1 field.
	LCDC_HEOCFG23_XPHI3COEFF1_Pos = 0x8
	// Bit mask of XPHI3COEFF1 field.
	LCDC_HEOCFG23_XPHI3COEFF1_Msk = 0xff00
	// Position of XPHI3COEFF2 field.
	LCDC_HEOCFG23_XPHI3COEFF2_Pos = 0x10
	// Bit mask of XPHI3COEFF2 field.
	LCDC_HEOCFG23_XPHI3COEFF2_Msk = 0xff0000
	// Position of XPHI3COEFF3 field.
	LCDC_HEOCFG23_XPHI3COEFF3_Pos = 0x18
	// Bit mask of XPHI3COEFF3 field.
	LCDC_HEOCFG23_XPHI3COEFF3_Msk = 0xff000000

	// HEOCFG24: High-End Overlay Configuration Register 24
	// Position of XPHI3COEFF4 field.
	LCDC_HEOCFG24_XPHI3COEFF4_Pos = 0x0
	// Bit mask of XPHI3COEFF4 field.
	LCDC_HEOCFG24_XPHI3COEFF4_Msk = 0xff

	// HEOCFG25: High-End Overlay Configuration Register 25
	// Position of XPHI4COEFF0 field.
	LCDC_HEOCFG25_XPHI4COEFF0_Pos = 0x0
	// Bit mask of XPHI4COEFF0 field.
	LCDC_HEOCFG25_XPHI4COEFF0_Msk = 0xff
	// Position of XPHI4COEFF1 field.
	LCDC_HEOCFG25_XPHI4COEFF1_Pos = 0x8
	// Bit mask of XPHI4COEFF1 field.
	LCDC_HEOCFG25_XPHI4COEFF1_Msk = 0xff00
	// Position of XPHI4COEFF2 field.
	LCDC_HEOCFG25_XPHI4COEFF2_Pos = 0x10
	// Bit mask of XPHI4COEFF2 field.
	LCDC_HEOCFG25_XPHI4COEFF2_Msk = 0xff0000
	// Position of XPHI4COEFF3 field.
	LCDC_HEOCFG25_XPHI4COEFF3_Pos = 0x18
	// Bit mask of XPHI4COEFF3 field.
	LCDC_HEOCFG25_XPHI4COEFF3_Msk = 0xff000000

	// HEOCFG26: High-End Overlay Configuration Register 26
	// Position of XPHI4COEFF4 field.
	LCDC_HEOCFG26_XPHI4COEFF4_Pos = 0x0
	// Bit mask of XPHI4COEFF4 field.
	LCDC_HEOCFG26_XPHI4COEFF4_Msk = 0xff

	// HEOCFG27: High-End Overlay Configuration Register 27
	// Position of XPHI5COEFF0 field.
	LCDC_HEOCFG27_XPHI5COEFF0_Pos = 0x0
	// Bit mask of XPHI5COEFF0 field.
	LCDC_HEOCFG27_XPHI5COEFF0_Msk = 0xff
	// Position of XPHI5COEFF1 field.
	LCDC_HEOCFG27_XPHI5COEFF1_Pos = 0x8
	// Bit mask of XPHI5COEFF1 field.
	LCDC_HEOCFG27_XPHI5COEFF1_Msk = 0xff00
	// Position of XPHI5COEFF2 field.
	LCDC_HEOCFG27_XPHI5COEFF2_Pos = 0x10
	// Bit mask of XPHI5COEFF2 field.
	LCDC_HEOCFG27_XPHI5COEFF2_Msk = 0xff0000
	// Position of XPHI5COEFF3 field.
	LCDC_HEOCFG27_XPHI5COEFF3_Pos = 0x18
	// Bit mask of XPHI5COEFF3 field.
	LCDC_HEOCFG27_XPHI5COEFF3_Msk = 0xff000000

	// HEOCFG28: High-End Overlay Configuration Register 28
	// Position of XPHI5COEFF4 field.
	LCDC_HEOCFG28_XPHI5COEFF4_Pos = 0x0
	// Bit mask of XPHI5COEFF4 field.
	LCDC_HEOCFG28_XPHI5COEFF4_Msk = 0xff

	// HEOCFG29: High-End Overlay Configuration Register 29
	// Position of XPHI6COEFF0 field.
	LCDC_HEOCFG29_XPHI6COEFF0_Pos = 0x0
	// Bit mask of XPHI6COEFF0 field.
	LCDC_HEOCFG29_XPHI6COEFF0_Msk = 0xff
	// Position of XPHI6COEFF1 field.
	LCDC_HEOCFG29_XPHI6COEFF1_Pos = 0x8
	// Bit mask of XPHI6COEFF1 field.
	LCDC_HEOCFG29_XPHI6COEFF1_Msk = 0xff00
	// Position of XPHI6COEFF2 field.
	LCDC_HEOCFG29_XPHI6COEFF2_Pos = 0x10
	// Bit mask of XPHI6COEFF2 field.
	LCDC_HEOCFG29_XPHI6COEFF2_Msk = 0xff0000
	// Position of XPHI6COEFF3 field.
	LCDC_HEOCFG29_XPHI6COEFF3_Pos = 0x18
	// Bit mask of XPHI6COEFF3 field.
	LCDC_HEOCFG29_XPHI6COEFF3_Msk = 0xff000000

	// HEOCFG30: High-End Overlay Configuration Register 30
	// Position of XPHI6COEFF4 field.
	LCDC_HEOCFG30_XPHI6COEFF4_Pos = 0x0
	// Bit mask of XPHI6COEFF4 field.
	LCDC_HEOCFG30_XPHI6COEFF4_Msk = 0xff

	// HEOCFG31: High-End Overlay Configuration Register 31
	// Position of XPHI7COEFF0 field.
	LCDC_HEOCFG31_XPHI7COEFF0_Pos = 0x0
	// Bit mask of XPHI7COEFF0 field.
	LCDC_HEOCFG31_XPHI7COEFF0_Msk = 0xff
	// Position of XPHI7COEFF1 field.
	LCDC_HEOCFG31_XPHI7COEFF1_Pos = 0x8
	// Bit mask of XPHI7COEFF1 field.
	LCDC_HEOCFG31_XPHI7COEFF1_Msk = 0xff00
	// Position of XPHI7COEFF2 field.
	LCDC_HEOCFG31_XPHI7COEFF2_Pos = 0x10
	// Bit mask of XPHI7COEFF2 field.
	LCDC_HEOCFG31_XPHI7COEFF2_Msk = 0xff0000
	// Position of XPHI7COEFF3 field.
	LCDC_HEOCFG31_XPHI7COEFF3_Pos = 0x18
	// Bit mask of XPHI7COEFF3 field.
	LCDC_HEOCFG31_XPHI7COEFF3_Msk = 0xff000000

	// HEOCFG32: High-End Overlay Configuration Register 32
	// Position of XPHI7COEFF4 field.
	LCDC_HEOCFG32_XPHI7COEFF4_Pos = 0x0
	// Bit mask of XPHI7COEFF4 field.
	LCDC_HEOCFG32_XPHI7COEFF4_Msk = 0xff

	// HEOCFG33: High-End Overlay Configuration Register 33
	// Position of YPHI0COEFF0 field.
	LCDC_HEOCFG33_YPHI0COEFF0_Pos = 0x0
	// Bit mask of YPHI0COEFF0 field.
	LCDC_HEOCFG33_YPHI0COEFF0_Msk = 0xff
	// Position of YPHI0COEFF1 field.
	LCDC_HEOCFG33_YPHI0COEFF1_Pos = 0x8
	// Bit mask of YPHI0COEFF1 field.
	LCDC_HEOCFG33_YPHI0COEFF1_Msk = 0xff00
	// Position of YPHI0COEFF2 field.
	LCDC_HEOCFG33_YPHI0COEFF2_Pos = 0x10
	// Bit mask of YPHI0COEFF2 field.
	LCDC_HEOCFG33_YPHI0COEFF2_Msk = 0xff0000

	// HEOCFG34: High-End Overlay Configuration Register 34
	// Position of YPHI1COEFF0 field.
	LCDC_HEOCFG34_YPHI1COEFF0_Pos = 0x0
	// Bit mask of YPHI1COEFF0 field.
	LCDC_HEOCFG34_YPHI1COEFF0_Msk = 0xff
	// Position of YPHI1COEFF1 field.
	LCDC_HEOCFG34_YPHI1COEFF1_Pos = 0x8
	// Bit mask of YPHI1COEFF1 field.
	LCDC_HEOCFG34_YPHI1COEFF1_Msk = 0xff00
	// Position of YPHI1COEFF2 field.
	LCDC_HEOCFG34_YPHI1COEFF2_Pos = 0x10
	// Bit mask of YPHI1COEFF2 field.
	LCDC_HEOCFG34_YPHI1COEFF2_Msk = 0xff0000

	// HEOCFG35: High-End Overlay Configuration Register 35
	// Position of YPHI2COEFF0 field.
	LCDC_HEOCFG35_YPHI2COEFF0_Pos = 0x0
	// Bit mask of YPHI2COEFF0 field.
	LCDC_HEOCFG35_YPHI2COEFF0_Msk = 0xff
	// Position of YPHI2COEFF1 field.
	LCDC_HEOCFG35_YPHI2COEFF1_Pos = 0x8
	// Bit mask of YPHI2COEFF1 field.
	LCDC_HEOCFG35_YPHI2COEFF1_Msk = 0xff00
	// Position of YPHI2COEFF2 field.
	LCDC_HEOCFG35_YPHI2COEFF2_Pos = 0x10
	// Bit mask of YPHI2COEFF2 field.
	LCDC_HEOCFG35_YPHI2COEFF2_Msk = 0xff0000

	// HEOCFG36: High-End Overlay Configuration Register 36
	// Position of YPHI3COEFF0 field.
	LCDC_HEOCFG36_YPHI3COEFF0_Pos = 0x0
	// Bit mask of YPHI3COEFF0 field.
	LCDC_HEOCFG36_YPHI3COEFF0_Msk = 0xff
	// Position of YPHI3COEFF1 field.
	LCDC_HEOCFG36_YPHI3COEFF1_Pos = 0x8
	// Bit mask of YPHI3COEFF1 field.
	LCDC_HEOCFG36_YPHI3COEFF1_Msk = 0xff00
	// Position of YPHI3COEFF2 field.
	LCDC_HEOCFG36_YPHI3COEFF2_Pos = 0x10
	// Bit mask of YPHI3COEFF2 field.
	LCDC_HEOCFG36_YPHI3COEFF2_Msk = 0xff0000

	// HEOCFG37: High-End Overlay Configuration Register 37
	// Position of YPHI4COEFF0 field.
	LCDC_HEOCFG37_YPHI4COEFF0_Pos = 0x0
	// Bit mask of YPHI4COEFF0 field.
	LCDC_HEOCFG37_YPHI4COEFF0_Msk = 0xff
	// Position of YPHI4COEFF1 field.
	LCDC_HEOCFG37_YPHI4COEFF1_Pos = 0x8
	// Bit mask of YPHI4COEFF1 field.
	LCDC_HEOCFG37_YPHI4COEFF1_Msk = 0xff00
	// Position of YPHI4COEFF2 field.
	LCDC_HEOCFG37_YPHI4COEFF2_Pos = 0x10
	// Bit mask of YPHI4COEFF2 field.
	LCDC_HEOCFG37_YPHI4COEFF2_Msk = 0xff0000

	// HEOCFG38: High-End Overlay Configuration Register 38
	// Position of YPHI5COEFF0 field.
	LCDC_HEOCFG38_YPHI5COEFF0_Pos = 0x0
	// Bit mask of YPHI5COEFF0 field.
	LCDC_HEOCFG38_YPHI5COEFF0_Msk = 0xff
	// Position of YPHI5COEFF1 field.
	LCDC_HEOCFG38_YPHI5COEFF1_Pos = 0x8
	// Bit mask of YPHI5COEFF1 field.
	LCDC_HEOCFG38_YPHI5COEFF1_Msk = 0xff00
	// Position of YPHI5COEFF2 field.
	LCDC_HEOCFG38_YPHI5COEFF2_Pos = 0x10
	// Bit mask of YPHI5COEFF2 field.
	LCDC_HEOCFG38_YPHI5COEFF2_Msk = 0xff0000

	// HEOCFG39: High-End Overlay Configuration Register 39
	// Position of YPHI6COEFF0 field.
	LCDC_HEOCFG39_YPHI6COEFF0_Pos = 0x0
	// Bit mask of YPHI6COEFF0 field.
	LCDC_HEOCFG39_YPHI6COEFF0_Msk = 0xff
	// Position of YPHI6COEFF1 field.
	LCDC_HEOCFG39_YPHI6COEFF1_Pos = 0x8
	// Bit mask of YPHI6COEFF1 field.
	LCDC_HEOCFG39_YPHI6COEFF1_Msk = 0xff00
	// Position of YPHI6COEFF2 field.
	LCDC_HEOCFG39_YPHI6COEFF2_Pos = 0x10
	// Bit mask of YPHI6COEFF2 field.
	LCDC_HEOCFG39_YPHI6COEFF2_Msk = 0xff0000

	// HEOCFG40: High-End Overlay Configuration Register 40
	// Position of YPHI7COEFF0 field.
	LCDC_HEOCFG40_YPHI7COEFF0_Pos = 0x0
	// Bit mask of YPHI7COEFF0 field.
	LCDC_HEOCFG40_YPHI7COEFF0_Msk = 0xff
	// Position of YPHI7COEFF1 field.
	LCDC_HEOCFG40_YPHI7COEFF1_Pos = 0x8
	// Bit mask of YPHI7COEFF1 field.
	LCDC_HEOCFG40_YPHI7COEFF1_Msk = 0xff00
	// Position of YPHI7COEFF2 field.
	LCDC_HEOCFG40_YPHI7COEFF2_Pos = 0x10
	// Bit mask of YPHI7COEFF2 field.
	LCDC_HEOCFG40_YPHI7COEFF2_Msk = 0xff0000

	// HEOCFG41: High-End Overlay Configuration Register 41
	// Position of XPHIDEF field.
	LCDC_HEOCFG41_XPHIDEF_Pos = 0x0
	// Bit mask of XPHIDEF field.
	LCDC_HEOCFG41_XPHIDEF_Msk = 0x7
	// Position of YPHIDEF field.
	LCDC_HEOCFG41_YPHIDEF_Pos = 0x10
	// Bit mask of YPHIDEF field.
	LCDC_HEOCFG41_YPHIDEF_Msk = 0x70000

	// HCRCHER: Hardware Cursor Channel Enable Register
	// Position of CHEN field.
	LCDC_HCRCHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_HCRCHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_HCRCHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_HCRCHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_HCRCHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_HCRCHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_HCRCHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_HCRCHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_HCRCHER_A2QEN = 0x4

	// HCRCHDR: Hardware Cursor Channel disable Register
	// Position of CHDIS field.
	LCDC_HCRCHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_HCRCHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_HCRCHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_HCRCHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_HCRCHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_HCRCHDR_CHRST = 0x100

	// HCRCHSR: Hardware Cursor Channel Status Register
	// Position of CHSR field.
	LCDC_HCRCHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_HCRCHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_HCRCHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_HCRCHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_HCRCHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_HCRCHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_HCRCHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_HCRCHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_HCRCHSR_A2QSR = 0x4

	// HCRIER: Hardware Cursor Interrupt Enable Register
	// Position of DMA field.
	LCDC_HCRIER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HCRIER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HCRIER_DMA = 0x4
	// Position of DSCR field.
	LCDC_HCRIER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HCRIER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HCRIER_DSCR = 0x8
	// Position of ADD field.
	LCDC_HCRIER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HCRIER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HCRIER_ADD = 0x10
	// Position of DONE field.
	LCDC_HCRIER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HCRIER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HCRIER_DONE = 0x20
	// Position of OVR field.
	LCDC_HCRIER_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HCRIER_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HCRIER_OVR = 0x40

	// HCRIDR: Hardware Cursor Interrupt Disable Register
	// Position of DMA field.
	LCDC_HCRIDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HCRIDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HCRIDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HCRIDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HCRIDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HCRIDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HCRIDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HCRIDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HCRIDR_ADD = 0x10
	// Position of DONE field.
	LCDC_HCRIDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HCRIDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HCRIDR_DONE = 0x20
	// Position of OVR field.
	LCDC_HCRIDR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HCRIDR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HCRIDR_OVR = 0x40

	// HCRIMR: Hardware Cursor Interrupt Mask Register
	// Position of DMA field.
	LCDC_HCRIMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HCRIMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HCRIMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HCRIMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HCRIMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HCRIMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HCRIMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HCRIMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HCRIMR_ADD = 0x10
	// Position of DONE field.
	LCDC_HCRIMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HCRIMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HCRIMR_DONE = 0x20
	// Position of OVR field.
	LCDC_HCRIMR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HCRIMR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HCRIMR_OVR = 0x40

	// HCRISR: Hardware Cursor Interrupt Status Register
	// Position of DMA field.
	LCDC_HCRISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_HCRISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_HCRISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_HCRISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_HCRISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_HCRISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_HCRISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_HCRISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_HCRISR_ADD = 0x10
	// Position of DONE field.
	LCDC_HCRISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_HCRISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_HCRISR_DONE = 0x20
	// Position of OVR field.
	LCDC_HCRISR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	LCDC_HCRISR_OVR_Msk = 0x40
	// Bit OVR.
	LCDC_HCRISR_OVR = 0x40

	// HCRHEAD: Hardware Cursor DMA Head Register
	// Position of HEAD field.
	LCDC_HCRHEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_HCRHEAD_HEAD_Msk = 0xfffffffc

	// HCRADDR: Hardware cursor DMA Address Register
	// Position of ADDR field.
	LCDC_HCRADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_HCRADDR_ADDR_Msk = 0xffffffff

	// HCRCTRL: Hardware Cursor DMA Control Register
	// Position of DFETCH field.
	LCDC_HCRCTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_HCRCTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_HCRCTRL_DFETCH = 0x1
	// Position of LFETCH field.
	LCDC_HCRCTRL_LFETCH_Pos = 0x1
	// Bit mask of LFETCH field.
	LCDC_HCRCTRL_LFETCH_Msk = 0x2
	// Bit LFETCH.
	LCDC_HCRCTRL_LFETCH = 0x2
	// Position of DMAIEN field.
	LCDC_HCRCTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_HCRCTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_HCRCTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_HCRCTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_HCRCTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_HCRCTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_HCRCTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_HCRCTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_HCRCTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_HCRCTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_HCRCTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_HCRCTRL_DONEIEN = 0x20

	// HCRNEXT: Hardware Cursor DMA NExt Register
	// Position of NEXT field.
	LCDC_HCRNEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_HCRNEXT_NEXT_Msk = 0xffffffff

	// HCRCFG0: Hardware Cursor Configuration 0 Register
	// Position of SIF field.
	LCDC_HCRCFG0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	LCDC_HCRCFG0_SIF_Msk = 0x1
	// Bit SIF.
	LCDC_HCRCFG0_SIF = 0x1
	// Position of BLEN field.
	LCDC_HCRCFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_HCRCFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HCRCFG0_BLEN_AHB_BLEN_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HCRCFG0_BLEN_AHB_BLEN_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HCRCFG0_BLEN_AHB_BLEN_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_HCRCFG0_BLEN_AHB_BLEN_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_HCRCFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_HCRCFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_HCRCFG0_DLBO = 0x100

	// HCRCFG1: Hardware Cursor Configuration 1 Register
	// Position of CLUTEN field.
	LCDC_HCRCFG1_CLUTEN_Pos = 0x0
	// Bit mask of CLUTEN field.
	LCDC_HCRCFG1_CLUTEN_Msk = 0x1
	// Bit CLUTEN.
	LCDC_HCRCFG1_CLUTEN = 0x1
	// Position of RGBMODE field.
	LCDC_HCRCFG1_RGBMODE_Pos = 0x4
	// Bit mask of RGBMODE field.
	LCDC_HCRCFG1_RGBMODE_Msk = 0xf0
	// 12 bpp RGB 444
	LCDC_HCRCFG1_RGBMODE_12BPP_RGB_444 = 0x0
	// 16 bpp ARGB 4444
	LCDC_HCRCFG1_RGBMODE_16BPP_ARGB_4444 = 0x1
	// 16 bpp RGBA 4444
	LCDC_HCRCFG1_RGBMODE_16BPP_RGBA_4444 = 0x2
	// 16 bpp RGB 565
	LCDC_HCRCFG1_RGBMODE_16BPP_RGB_565 = 0x3
	// 16 bpp TRGB 1555
	LCDC_HCRCFG1_RGBMODE_16BPP_TRGB_1555 = 0x4
	// 18 bpp RGB 666
	LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666 = 0x5
	// 18 bpp RGB 666 PACKED
	LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666PACKED = 0x6
	// 19 bpp TRGB 1666
	LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_1666 = 0x7
	// 19 bpp TRGB 1666 PACKED
	LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_PACKED = 0x8
	// 24 bpp RGB 888
	LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888 = 0x9
	// 24 bpp RGB 888 PACKED
	LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888_PACKED = 0xa
	// 25 bpp TRGB 1888
	LCDC_HCRCFG1_RGBMODE_25BPP_TRGB_1888 = 0xb
	// 32 bpp ARGB 8888
	LCDC_HCRCFG1_RGBMODE_32BPP_ARGB_8888 = 0xc
	// 32 bpp RGBA 8888
	LCDC_HCRCFG1_RGBMODE_32BPP_RGBA_8888 = 0xd
	// Position of CLUTMODE field.
	LCDC_HCRCFG1_CLUTMODE_Pos = 0x8
	// Bit mask of CLUTMODE field.
	LCDC_HCRCFG1_CLUTMODE_Msk = 0x300
	// color lookup table mode set to 1 bit per pixel
	LCDC_HCRCFG1_CLUTMODE_CLUT_1BPP = 0x0
	// color lookup table mode set to 2 bits per pixel
	LCDC_HCRCFG1_CLUTMODE_CLUT_2BPP = 0x1
	// color lookup table mode set to 4 bits per pixel
	LCDC_HCRCFG1_CLUTMODE_CLUT_4BPP = 0x2
	// color lookup table mode set to 8 bits per pixel
	LCDC_HCRCFG1_CLUTMODE_CLUT_8BPP = 0x3

	// HCRCFG2: Hardware Cursor Configuration 2 Register
	// Position of XPOS field.
	LCDC_HCRCFG2_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	LCDC_HCRCFG2_XPOS_Msk = 0x7ff
	// Position of YPOS field.
	LCDC_HCRCFG2_YPOS_Pos = 0x10
	// Bit mask of YPOS field.
	LCDC_HCRCFG2_YPOS_Msk = 0x7ff0000

	// HCRCFG3: Hardware Cursor Configuration 3 Register
	// Position of XSIZE field.
	LCDC_HCRCFG3_XSIZE_Pos = 0x0
	// Bit mask of XSIZE field.
	LCDC_HCRCFG3_XSIZE_Msk = 0x7ff
	// Position of YSIZE field.
	LCDC_HCRCFG3_YSIZE_Pos = 0x10
	// Bit mask of YSIZE field.
	LCDC_HCRCFG3_YSIZE_Msk = 0x7ff0000

	// HCRCFG4: Hardware Cursor Configuration 4 Register
	// Position of XSTRIDE field.
	LCDC_HCRCFG4_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_HCRCFG4_XSTRIDE_Msk = 0xffffffff

	// HCRCFG6: Hardware Cursor Configuration 6 Register
	// Position of BDEF field.
	LCDC_HCRCFG6_BDEF_Pos = 0x0
	// Bit mask of BDEF field.
	LCDC_HCRCFG6_BDEF_Msk = 0xff
	// Position of GDEF field.
	LCDC_HCRCFG6_GDEF_Pos = 0x8
	// Bit mask of GDEF field.
	LCDC_HCRCFG6_GDEF_Msk = 0xff00
	// Position of RDEF field.
	LCDC_HCRCFG6_RDEF_Pos = 0x10
	// Bit mask of RDEF field.
	LCDC_HCRCFG6_RDEF_Msk = 0xff0000

	// HCRCFG7: Hardware Cursor Configuration 7 Register
	// Position of BKEY field.
	LCDC_HCRCFG7_BKEY_Pos = 0x0
	// Bit mask of BKEY field.
	LCDC_HCRCFG7_BKEY_Msk = 0xff
	// Position of GKEY field.
	LCDC_HCRCFG7_GKEY_Pos = 0x8
	// Bit mask of GKEY field.
	LCDC_HCRCFG7_GKEY_Msk = 0xff00
	// Position of RKEY field.
	LCDC_HCRCFG7_RKEY_Pos = 0x10
	// Bit mask of RKEY field.
	LCDC_HCRCFG7_RKEY_Msk = 0xff0000

	// HCRCFG8: Hardware Cursor Configuration 8 Register
	// Position of BMASK field.
	LCDC_HCRCFG8_BMASK_Pos = 0x0
	// Bit mask of BMASK field.
	LCDC_HCRCFG8_BMASK_Msk = 0xff
	// Position of GMASK field.
	LCDC_HCRCFG8_GMASK_Pos = 0x8
	// Bit mask of GMASK field.
	LCDC_HCRCFG8_GMASK_Msk = 0xff00
	// Position of RMASK field.
	LCDC_HCRCFG8_RMASK_Pos = 0x10
	// Bit mask of RMASK field.
	LCDC_HCRCFG8_RMASK_Msk = 0xff0000

	// HCRCFG9: Hardware Cursor Configuration 9 Register
	// Position of CRKEY field.
	LCDC_HCRCFG9_CRKEY_Pos = 0x0
	// Bit mask of CRKEY field.
	LCDC_HCRCFG9_CRKEY_Msk = 0x1
	// Bit CRKEY.
	LCDC_HCRCFG9_CRKEY = 0x1
	// Position of INV field.
	LCDC_HCRCFG9_INV_Pos = 0x1
	// Bit mask of INV field.
	LCDC_HCRCFG9_INV_Msk = 0x2
	// Bit INV.
	LCDC_HCRCFG9_INV = 0x2
	// Position of ITER2BL field.
	LCDC_HCRCFG9_ITER2BL_Pos = 0x2
	// Bit mask of ITER2BL field.
	LCDC_HCRCFG9_ITER2BL_Msk = 0x4
	// Bit ITER2BL.
	LCDC_HCRCFG9_ITER2BL = 0x4
	// Position of ITER field.
	LCDC_HCRCFG9_ITER_Pos = 0x3
	// Bit mask of ITER field.
	LCDC_HCRCFG9_ITER_Msk = 0x8
	// Bit ITER.
	LCDC_HCRCFG9_ITER = 0x8
	// Position of REVALPHA field.
	LCDC_HCRCFG9_REVALPHA_Pos = 0x4
	// Bit mask of REVALPHA field.
	LCDC_HCRCFG9_REVALPHA_Msk = 0x10
	// Bit REVALPHA.
	LCDC_HCRCFG9_REVALPHA = 0x10
	// Position of GAEN field.
	LCDC_HCRCFG9_GAEN_Pos = 0x5
	// Bit mask of GAEN field.
	LCDC_HCRCFG9_GAEN_Msk = 0x20
	// Bit GAEN.
	LCDC_HCRCFG9_GAEN = 0x20
	// Position of LAEN field.
	LCDC_HCRCFG9_LAEN_Pos = 0x6
	// Bit mask of LAEN field.
	LCDC_HCRCFG9_LAEN_Msk = 0x40
	// Bit LAEN.
	LCDC_HCRCFG9_LAEN = 0x40
	// Position of OVR field.
	LCDC_HCRCFG9_OVR_Pos = 0x7
	// Bit mask of OVR field.
	LCDC_HCRCFG9_OVR_Msk = 0x80
	// Bit OVR.
	LCDC_HCRCFG9_OVR = 0x80
	// Position of DMA field.
	LCDC_HCRCFG9_DMA_Pos = 0x8
	// Bit mask of DMA field.
	LCDC_HCRCFG9_DMA_Msk = 0x100
	// Bit DMA.
	LCDC_HCRCFG9_DMA = 0x100
	// Position of REP field.
	LCDC_HCRCFG9_REP_Pos = 0x9
	// Bit mask of REP field.
	LCDC_HCRCFG9_REP_Msk = 0x200
	// Bit REP.
	LCDC_HCRCFG9_REP = 0x200
	// Position of DSTKEY field.
	LCDC_HCRCFG9_DSTKEY_Pos = 0xa
	// Bit mask of DSTKEY field.
	LCDC_HCRCFG9_DSTKEY_Msk = 0x400
	// Bit DSTKEY.
	LCDC_HCRCFG9_DSTKEY = 0x400
	// Position of GA field.
	LCDC_HCRCFG9_GA_Pos = 0x10
	// Bit mask of GA field.
	LCDC_HCRCFG9_GA_Msk = 0xff0000

	// PPCHER: Post Processing Channel Enable Register
	// Position of CHEN field.
	LCDC_PPCHER_CHEN_Pos = 0x0
	// Bit mask of CHEN field.
	LCDC_PPCHER_CHEN_Msk = 0x1
	// Bit CHEN.
	LCDC_PPCHER_CHEN = 0x1
	// Position of UPDATEEN field.
	LCDC_PPCHER_UPDATEEN_Pos = 0x1
	// Bit mask of UPDATEEN field.
	LCDC_PPCHER_UPDATEEN_Msk = 0x2
	// Bit UPDATEEN.
	LCDC_PPCHER_UPDATEEN = 0x2
	// Position of A2QEN field.
	LCDC_PPCHER_A2QEN_Pos = 0x2
	// Bit mask of A2QEN field.
	LCDC_PPCHER_A2QEN_Msk = 0x4
	// Bit A2QEN.
	LCDC_PPCHER_A2QEN = 0x4

	// PPCHDR: Post Processing Channel Disable Register
	// Position of CHDIS field.
	LCDC_PPCHDR_CHDIS_Pos = 0x0
	// Bit mask of CHDIS field.
	LCDC_PPCHDR_CHDIS_Msk = 0x1
	// Bit CHDIS.
	LCDC_PPCHDR_CHDIS = 0x1
	// Position of CHRST field.
	LCDC_PPCHDR_CHRST_Pos = 0x8
	// Bit mask of CHRST field.
	LCDC_PPCHDR_CHRST_Msk = 0x100
	// Bit CHRST.
	LCDC_PPCHDR_CHRST = 0x100

	// PPCHSR: Post Processing Channel Status Register
	// Position of CHSR field.
	LCDC_PPCHSR_CHSR_Pos = 0x0
	// Bit mask of CHSR field.
	LCDC_PPCHSR_CHSR_Msk = 0x1
	// Bit CHSR.
	LCDC_PPCHSR_CHSR = 0x1
	// Position of UPDATESR field.
	LCDC_PPCHSR_UPDATESR_Pos = 0x1
	// Bit mask of UPDATESR field.
	LCDC_PPCHSR_UPDATESR_Msk = 0x2
	// Bit UPDATESR.
	LCDC_PPCHSR_UPDATESR = 0x2
	// Position of A2QSR field.
	LCDC_PPCHSR_A2QSR_Pos = 0x2
	// Bit mask of A2QSR field.
	LCDC_PPCHSR_A2QSR_Msk = 0x4
	// Bit A2QSR.
	LCDC_PPCHSR_A2QSR = 0x4

	// PPIER: Post Processing Interrupt Enable Register
	// Position of DMA field.
	LCDC_PPIER_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_PPIER_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_PPIER_DMA = 0x4
	// Position of DSCR field.
	LCDC_PPIER_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_PPIER_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_PPIER_DSCR = 0x8
	// Position of ADD field.
	LCDC_PPIER_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_PPIER_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_PPIER_ADD = 0x10
	// Position of DONE field.
	LCDC_PPIER_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_PPIER_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_PPIER_DONE = 0x20

	// PPIDR: Post Processing Interrupt Disable Register
	// Position of DMA field.
	LCDC_PPIDR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_PPIDR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_PPIDR_DMA = 0x4
	// Position of DSCR field.
	LCDC_PPIDR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_PPIDR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_PPIDR_DSCR = 0x8
	// Position of ADD field.
	LCDC_PPIDR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_PPIDR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_PPIDR_ADD = 0x10
	// Position of DONE field.
	LCDC_PPIDR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_PPIDR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_PPIDR_DONE = 0x20

	// PPIMR: Post Processing Interrupt Mask Register
	// Position of DMA field.
	LCDC_PPIMR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_PPIMR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_PPIMR_DMA = 0x4
	// Position of DSCR field.
	LCDC_PPIMR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_PPIMR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_PPIMR_DSCR = 0x8
	// Position of ADD field.
	LCDC_PPIMR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_PPIMR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_PPIMR_ADD = 0x10
	// Position of DONE field.
	LCDC_PPIMR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_PPIMR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_PPIMR_DONE = 0x20

	// PPISR: Post Processing Interrupt Status Register
	// Position of DMA field.
	LCDC_PPISR_DMA_Pos = 0x2
	// Bit mask of DMA field.
	LCDC_PPISR_DMA_Msk = 0x4
	// Bit DMA.
	LCDC_PPISR_DMA = 0x4
	// Position of DSCR field.
	LCDC_PPISR_DSCR_Pos = 0x3
	// Bit mask of DSCR field.
	LCDC_PPISR_DSCR_Msk = 0x8
	// Bit DSCR.
	LCDC_PPISR_DSCR = 0x8
	// Position of ADD field.
	LCDC_PPISR_ADD_Pos = 0x4
	// Bit mask of ADD field.
	LCDC_PPISR_ADD_Msk = 0x10
	// Bit ADD.
	LCDC_PPISR_ADD = 0x10
	// Position of DONE field.
	LCDC_PPISR_DONE_Pos = 0x5
	// Bit mask of DONE field.
	LCDC_PPISR_DONE_Msk = 0x20
	// Bit DONE.
	LCDC_PPISR_DONE = 0x20

	// PPHEAD: Post Processing Head Register
	// Position of HEAD field.
	LCDC_PPHEAD_HEAD_Pos = 0x2
	// Bit mask of HEAD field.
	LCDC_PPHEAD_HEAD_Msk = 0xfffffffc

	// PPADDR: Post Processing Address Register
	// Position of ADDR field.
	LCDC_PPADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDC_PPADDR_ADDR_Msk = 0xffffffff

	// PPCTRL: Post Processing Control Register
	// Position of DFETCH field.
	LCDC_PPCTRL_DFETCH_Pos = 0x0
	// Bit mask of DFETCH field.
	LCDC_PPCTRL_DFETCH_Msk = 0x1
	// Bit DFETCH.
	LCDC_PPCTRL_DFETCH = 0x1
	// Position of DMAIEN field.
	LCDC_PPCTRL_DMAIEN_Pos = 0x2
	// Bit mask of DMAIEN field.
	LCDC_PPCTRL_DMAIEN_Msk = 0x4
	// Bit DMAIEN.
	LCDC_PPCTRL_DMAIEN = 0x4
	// Position of DSCRIEN field.
	LCDC_PPCTRL_DSCRIEN_Pos = 0x3
	// Bit mask of DSCRIEN field.
	LCDC_PPCTRL_DSCRIEN_Msk = 0x8
	// Bit DSCRIEN.
	LCDC_PPCTRL_DSCRIEN = 0x8
	// Position of ADDIEN field.
	LCDC_PPCTRL_ADDIEN_Pos = 0x4
	// Bit mask of ADDIEN field.
	LCDC_PPCTRL_ADDIEN_Msk = 0x10
	// Bit ADDIEN.
	LCDC_PPCTRL_ADDIEN = 0x10
	// Position of DONEIEN field.
	LCDC_PPCTRL_DONEIEN_Pos = 0x5
	// Bit mask of DONEIEN field.
	LCDC_PPCTRL_DONEIEN_Msk = 0x20
	// Bit DONEIEN.
	LCDC_PPCTRL_DONEIEN = 0x20

	// PPNEXT: Post Processing Next Register
	// Position of NEXT field.
	LCDC_PPNEXT_NEXT_Pos = 0x0
	// Bit mask of NEXT field.
	LCDC_PPNEXT_NEXT_Msk = 0xffffffff

	// PPCFG0: Post Processing Configuration Register 0
	// Position of SIF field.
	LCDC_PPCFG0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	LCDC_PPCFG0_SIF_Msk = 0x1
	// Bit SIF.
	LCDC_PPCFG0_SIF = 0x1
	// Position of BLEN field.
	LCDC_PPCFG0_BLEN_Pos = 0x4
	// Bit mask of BLEN field.
	LCDC_PPCFG0_BLEN_Msk = 0x30
	// AHB Access is started as soon as there is enough space in the FIFO to store one data. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_PPCFG0_BLEN_AHB_BLEN_SINGLE = 0x0
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 4 data. An AHB INCR4 Burst is used. SINGLE, INCR and INCR4 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_PPCFG0_BLEN_AHB_BLEN_INCR4 = 0x1
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 8 data. An AHB INCR8 Burst is used. SINGLE, INCR, INCR4 and INCR8 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_PPCFG0_BLEN_AHB_BLEN_INCR8 = 0x2
	// AHB Access is started as soon as there is enough space in the FIFO to store a total amount of 16 data. An AHB INCR16 Burst is used. SINGLE, INCR, INCR4, INCR8 and INCR16 bursts are used. INCR is used for a burst of 2 and 3 beats.
	LCDC_PPCFG0_BLEN_AHB_BLEN_INCR16 = 0x3
	// Position of DLBO field.
	LCDC_PPCFG0_DLBO_Pos = 0x8
	// Bit mask of DLBO field.
	LCDC_PPCFG0_DLBO_Msk = 0x100
	// Bit DLBO.
	LCDC_PPCFG0_DLBO = 0x100

	// PPCFG1: Post Processing Configuration Register 1
	// Position of PPMODE field.
	LCDC_PPCFG1_PPMODE_Pos = 0x0
	// Bit mask of PPMODE field.
	LCDC_PPCFG1_PPMODE_Msk = 0x7
	// RGB 16 bpp
	LCDC_PPCFG1_PPMODE_PPMODE_RGB_16BPP = 0x0
	// RGB 24 bpp PACKED
	LCDC_PPCFG1_PPMODE_PPMODE_RGB_24BPP_PACKED = 0x1
	// RGB 24 bpp UNPACKED
	LCDC_PPCFG1_PPMODE_PPMODE_RGB_24BPP_UNPACKED = 0x2
	// YCbCr 422 16 bpp (Mode 0)
	LCDC_PPCFG1_PPMODE_PPMODE_YCBCR_422_MODE0 = 0x3
	// YCbCr 422 16 bpp (Mode 1)
	LCDC_PPCFG1_PPMODE_PPMODE_YCBCR_422_MODE1 = 0x4
	// YCbCr 422 16 bpp (Mode 2)
	LCDC_PPCFG1_PPMODE_PPMODE_YCBCR_422_MODE2 = 0x5
	// YCbCr 422 16 bpp (Mode 3)
	LCDC_PPCFG1_PPMODE_PPMODE_YCBCR_422_MODE3 = 0x6
	// Position of ITUBT601 field.
	LCDC_PPCFG1_ITUBT601_Pos = 0x4
	// Bit mask of ITUBT601 field.
	LCDC_PPCFG1_ITUBT601_Msk = 0x10
	// Bit ITUBT601.
	LCDC_PPCFG1_ITUBT601 = 0x10

	// PPCFG2: Post Processing Configuration Register 2
	// Position of XSTRIDE field.
	LCDC_PPCFG2_XSTRIDE_Pos = 0x0
	// Bit mask of XSTRIDE field.
	LCDC_PPCFG2_XSTRIDE_Msk = 0xffffffff

	// PPCFG3: Post Processing Configuration Register 3
	// Position of CSCYR field.
	LCDC_PPCFG3_CSCYR_Pos = 0x0
	// Bit mask of CSCYR field.
	LCDC_PPCFG3_CSCYR_Msk = 0x3ff
	// Position of CSCYG field.
	LCDC_PPCFG3_CSCYG_Pos = 0xa
	// Bit mask of CSCYG field.
	LCDC_PPCFG3_CSCYG_Msk = 0xffc00
	// Position of CSCYB field.
	LCDC_PPCFG3_CSCYB_Pos = 0x14
	// Bit mask of CSCYB field.
	LCDC_PPCFG3_CSCYB_Msk = 0x3ff00000
	// Position of CSCYOFF field.
	LCDC_PPCFG3_CSCYOFF_Pos = 0x1e
	// Bit mask of CSCYOFF field.
	LCDC_PPCFG3_CSCYOFF_Msk = 0x40000000
	// Bit CSCYOFF.
	LCDC_PPCFG3_CSCYOFF = 0x40000000

	// PPCFG4: Post Processing Configuration Register 4
	// Position of CSCUR field.
	LCDC_PPCFG4_CSCUR_Pos = 0x0
	// Bit mask of CSCUR field.
	LCDC_PPCFG4_CSCUR_Msk = 0x3ff
	// Position of CSCUG field.
	LCDC_PPCFG4_CSCUG_Pos = 0xa
	// Bit mask of CSCUG field.
	LCDC_PPCFG4_CSCUG_Msk = 0xffc00
	// Position of CSCUB field.
	LCDC_PPCFG4_CSCUB_Pos = 0x14
	// Bit mask of CSCUB field.
	LCDC_PPCFG4_CSCUB_Msk = 0x3ff00000
	// Position of CSCUOFF field.
	LCDC_PPCFG4_CSCUOFF_Pos = 0x1e
	// Bit mask of CSCUOFF field.
	LCDC_PPCFG4_CSCUOFF_Msk = 0x40000000
	// Bit CSCUOFF.
	LCDC_PPCFG4_CSCUOFF = 0x40000000

	// PPCFG5: Post Processing Configuration Register 5
	// Position of CSCVR field.
	LCDC_PPCFG5_CSCVR_Pos = 0x0
	// Bit mask of CSCVR field.
	LCDC_PPCFG5_CSCVR_Msk = 0x3ff
	// Position of CSCVG field.
	LCDC_PPCFG5_CSCVG_Pos = 0xa
	// Bit mask of CSCVG field.
	LCDC_PPCFG5_CSCVG_Msk = 0xffc00
	// Position of CSCVB field.
	LCDC_PPCFG5_CSCVB_Pos = 0x14
	// Bit mask of CSCVB field.
	LCDC_PPCFG5_CSCVB_Msk = 0x3ff00000
	// Position of CSCVOFF field.
	LCDC_PPCFG5_CSCVOFF_Pos = 0x1e
	// Bit mask of CSCVOFF field.
	LCDC_PPCFG5_CSCVOFF_Msk = 0x40000000
	// Bit CSCVOFF.
	LCDC_PPCFG5_CSCVOFF = 0x40000000

	// BASECLUT: Base CLUT Register
	// Position of BCLUT field.
	LCDC_BASECLUT_BCLUT_Pos = 0x0
	// Bit mask of BCLUT field.
	LCDC_BASECLUT_BCLUT_Msk = 0xff
	// Position of GCLUT field.
	LCDC_BASECLUT_GCLUT_Pos = 0x8
	// Bit mask of GCLUT field.
	LCDC_BASECLUT_GCLUT_Msk = 0xff00
	// Position of RCLUT field.
	LCDC_BASECLUT_RCLUT_Pos = 0x10
	// Bit mask of RCLUT field.
	LCDC_BASECLUT_RCLUT_Msk = 0xff0000

	// OVR1CLUT: Overlay 1 CLUT Register
	// Position of BCLUT field.
	LCDC_OVR1CLUT_BCLUT_Pos = 0x0
	// Bit mask of BCLUT field.
	LCDC_OVR1CLUT_BCLUT_Msk = 0xff
	// Position of GCLUT field.
	LCDC_OVR1CLUT_GCLUT_Pos = 0x8
	// Bit mask of GCLUT field.
	LCDC_OVR1CLUT_GCLUT_Msk = 0xff00
	// Position of RCLUT field.
	LCDC_OVR1CLUT_RCLUT_Pos = 0x10
	// Bit mask of RCLUT field.
	LCDC_OVR1CLUT_RCLUT_Msk = 0xff0000
	// Position of ACLUT field.
	LCDC_OVR1CLUT_ACLUT_Pos = 0x18
	// Bit mask of ACLUT field.
	LCDC_OVR1CLUT_ACLUT_Msk = 0xff000000

	// OVR2CLUT: Overlay 2 CLUT Register
	// Position of BCLUT field.
	LCDC_OVR2CLUT_BCLUT_Pos = 0x0
	// Bit mask of BCLUT field.
	LCDC_OVR2CLUT_BCLUT_Msk = 0xff
	// Position of GCLUT field.
	LCDC_OVR2CLUT_GCLUT_Pos = 0x8
	// Bit mask of GCLUT field.
	LCDC_OVR2CLUT_GCLUT_Msk = 0xff00
	// Position of RCLUT field.
	LCDC_OVR2CLUT_RCLUT_Pos = 0x10
	// Bit mask of RCLUT field.
	LCDC_OVR2CLUT_RCLUT_Msk = 0xff0000
	// Position of ACLUT field.
	LCDC_OVR2CLUT_ACLUT_Pos = 0x18
	// Bit mask of ACLUT field.
	LCDC_OVR2CLUT_ACLUT_Msk = 0xff000000

	// HEOCLUT: High End Overlay CLUT Register
	// Position of BCLUT field.
	LCDC_HEOCLUT_BCLUT_Pos = 0x0
	// Bit mask of BCLUT field.
	LCDC_HEOCLUT_BCLUT_Msk = 0xff
	// Position of GCLUT field.
	LCDC_HEOCLUT_GCLUT_Pos = 0x8
	// Bit mask of GCLUT field.
	LCDC_HEOCLUT_GCLUT_Msk = 0xff00
	// Position of RCLUT field.
	LCDC_HEOCLUT_RCLUT_Pos = 0x10
	// Bit mask of RCLUT field.
	LCDC_HEOCLUT_RCLUT_Msk = 0xff0000
	// Position of ACLUT field.
	LCDC_HEOCLUT_ACLUT_Pos = 0x18
	// Bit mask of ACLUT field.
	LCDC_HEOCLUT_ACLUT_Msk = 0xff000000

	// HCRCLUT: Hardware Cursor CLUT Register
	// Position of BCLUT field.
	LCDC_HCRCLUT_BCLUT_Pos = 0x0
	// Bit mask of BCLUT field.
	LCDC_HCRCLUT_BCLUT_Msk = 0xff
	// Position of GCLUT field.
	LCDC_HCRCLUT_GCLUT_Pos = 0x8
	// Bit mask of GCLUT field.
	LCDC_HCRCLUT_GCLUT_Msk = 0xff00
	// Position of RCLUT field.
	LCDC_HCRCLUT_RCLUT_Pos = 0x10
	// Bit mask of RCLUT field.
	LCDC_HCRCLUT_RCLUT_Msk = 0xff0000
	// Position of ACLUT field.
	LCDC_HCRCLUT_ACLUT_Pos = 0x18
	// Bit mask of ACLUT field.
	LCDC_HCRCLUT_ACLUT_Msk = 0xff000000
)

// Constants for ISI: Image Sensor Interface
const (
	// CFG1: ISI Configuration 1 Register
	// Position of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Pos = 0x2
	// Bit mask of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Msk = 0x4
	// Bit HSYNC_POL.
	ISI_CFG1_HSYNC_POL = 0x4
	// Position of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Pos = 0x3
	// Bit mask of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Msk = 0x8
	// Bit VSYNC_POL.
	ISI_CFG1_VSYNC_POL = 0x8
	// Position of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Pos = 0x4
	// Bit mask of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Msk = 0x10
	// Bit PIXCLK_POL.
	ISI_CFG1_PIXCLK_POL = 0x10
	// Position of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Pos = 0x6
	// Bit mask of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Msk = 0x40
	// Bit EMB_SYNC.
	ISI_CFG1_EMB_SYNC = 0x40
	// Position of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Pos = 0x7
	// Bit mask of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Msk = 0x80
	// Bit CRC_SYNC.
	ISI_CFG1_CRC_SYNC = 0x80
	// Position of FRATE field.
	ISI_CFG1_FRATE_Pos = 0x8
	// Bit mask of FRATE field.
	ISI_CFG1_FRATE_Msk = 0x700
	// Position of DISCR field.
	ISI_CFG1_DISCR_Pos = 0xb
	// Bit mask of DISCR field.
	ISI_CFG1_DISCR_Msk = 0x800
	// Bit DISCR.
	ISI_CFG1_DISCR = 0x800
	// Position of FULL field.
	ISI_CFG1_FULL_Pos = 0xc
	// Bit mask of FULL field.
	ISI_CFG1_FULL_Msk = 0x1000
	// Bit FULL.
	ISI_CFG1_FULL = 0x1000
	// Position of THMASK field.
	ISI_CFG1_THMASK_Pos = 0xd
	// Bit mask of THMASK field.
	ISI_CFG1_THMASK_Msk = 0x6000
	// Only 4 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_4 = 0x0
	// Only 4 and 8 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_8 = 0x1
	// 4, 8 and 16 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_16 = 0x2
	// Position of SLD field.
	ISI_CFG1_SLD_Pos = 0x10
	// Bit mask of SLD field.
	ISI_CFG1_SLD_Msk = 0xff0000
	// Position of SFD field.
	ISI_CFG1_SFD_Pos = 0x18
	// Bit mask of SFD field.
	ISI_CFG1_SFD_Msk = 0xff000000

	// CFG2: ISI Configuration 2 Register
	// Position of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Pos = 0x0
	// Bit mask of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Msk = 0x7ff
	// Position of GS_MODE field.
	ISI_CFG2_GS_MODE_Pos = 0xb
	// Bit mask of GS_MODE field.
	ISI_CFG2_GS_MODE_Msk = 0x800
	// Bit GS_MODE.
	ISI_CFG2_GS_MODE = 0x800
	// Position of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Pos = 0xc
	// Bit mask of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Msk = 0x1000
	// Bit RGB_MODE.
	ISI_CFG2_RGB_MODE = 0x1000
	// Position of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Pos = 0xd
	// Bit mask of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Msk = 0x2000
	// Bit GRAYSCALE.
	ISI_CFG2_GRAYSCALE = 0x2000
	// Position of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Pos = 0xe
	// Bit mask of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Msk = 0x4000
	// Bit RGB_SWAP.
	ISI_CFG2_RGB_SWAP = 0x4000
	// Position of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Pos = 0xf
	// Bit mask of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Msk = 0x8000
	// Bit COL_SPACE.
	ISI_CFG2_COL_SPACE = 0x8000
	// Position of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Pos = 0x10
	// Bit mask of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Msk = 0x7ff0000
	// Position of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Pos = 0x1c
	// Bit mask of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Msk = 0x30000000
	// Position of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Pos = 0x1e
	// Bit mask of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Msk = 0xc0000000

	// PSIZE: ISI Preview Size Register
	// Position of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Pos = 0x0
	// Bit mask of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Msk = 0x3ff
	// Position of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Pos = 0x10
	// Bit mask of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Msk = 0x3ff0000

	// PDECF: ISI Preview Decimation Factor Register
	// Position of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Pos = 0x0
	// Bit mask of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Msk = 0xff

	// Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
	// Position of C0 field.
	ISI_Y2R_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_Y2R_SET0_C0_Msk = 0xff
	// Position of C1 field.
	ISI_Y2R_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_Y2R_SET0_C1_Msk = 0xff00
	// Position of C2 field.
	ISI_Y2R_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_Y2R_SET0_C2_Msk = 0xff0000
	// Position of C3 field.
	ISI_Y2R_SET0_C3_Pos = 0x18
	// Bit mask of C3 field.
	ISI_Y2R_SET0_C3_Msk = 0xff000000

	// Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
	// Position of C4 field.
	ISI_Y2R_SET1_C4_Pos = 0x0
	// Bit mask of C4 field.
	ISI_Y2R_SET1_C4_Msk = 0x1ff
	// Position of Yoff field.
	ISI_Y2R_SET1_Yoff_Pos = 0xc
	// Bit mask of Yoff field.
	ISI_Y2R_SET1_Yoff_Msk = 0x1000
	// Bit Yoff.
	ISI_Y2R_SET1_Yoff = 0x1000
	// Position of Croff field.
	ISI_Y2R_SET1_Croff_Pos = 0xd
	// Bit mask of Croff field.
	ISI_Y2R_SET1_Croff_Msk = 0x2000
	// Bit Croff.
	ISI_Y2R_SET1_Croff = 0x2000
	// Position of Cboff field.
	ISI_Y2R_SET1_Cboff_Pos = 0xe
	// Bit mask of Cboff field.
	ISI_Y2R_SET1_Cboff_Msk = 0x4000
	// Bit Cboff.
	ISI_Y2R_SET1_Cboff = 0x4000

	// R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
	// Position of C0 field.
	ISI_R2Y_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_R2Y_SET0_C0_Msk = 0x7f
	// Position of C1 field.
	ISI_R2Y_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_R2Y_SET0_C1_Msk = 0x7f00
	// Position of C2 field.
	ISI_R2Y_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_R2Y_SET0_C2_Msk = 0x7f0000
	// Position of Roff field.
	ISI_R2Y_SET0_Roff_Pos = 0x18
	// Bit mask of Roff field.
	ISI_R2Y_SET0_Roff_Msk = 0x1000000
	// Bit Roff.
	ISI_R2Y_SET0_Roff = 0x1000000

	// R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
	// Position of C3 field.
	ISI_R2Y_SET1_C3_Pos = 0x0
	// Bit mask of C3 field.
	ISI_R2Y_SET1_C3_Msk = 0x7f
	// Position of C4 field.
	ISI_R2Y_SET1_C4_Pos = 0x8
	// Bit mask of C4 field.
	ISI_R2Y_SET1_C4_Msk = 0x7f00
	// Position of C5 field.
	ISI_R2Y_SET1_C5_Pos = 0x10
	// Bit mask of C5 field.
	ISI_R2Y_SET1_C5_Msk = 0x7f0000
	// Position of Goff field.
	ISI_R2Y_SET1_Goff_Pos = 0x18
	// Bit mask of Goff field.
	ISI_R2Y_SET1_Goff_Msk = 0x1000000
	// Bit Goff.
	ISI_R2Y_SET1_Goff = 0x1000000

	// R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
	// Position of C6 field.
	ISI_R2Y_SET2_C6_Pos = 0x0
	// Bit mask of C6 field.
	ISI_R2Y_SET2_C6_Msk = 0x7f
	// Position of C7 field.
	ISI_R2Y_SET2_C7_Pos = 0x8
	// Bit mask of C7 field.
	ISI_R2Y_SET2_C7_Msk = 0x7f00
	// Position of C8 field.
	ISI_R2Y_SET2_C8_Pos = 0x10
	// Bit mask of C8 field.
	ISI_R2Y_SET2_C8_Msk = 0x7f0000
	// Position of Boff field.
	ISI_R2Y_SET2_Boff_Pos = 0x18
	// Bit mask of Boff field.
	ISI_R2Y_SET2_Boff_Msk = 0x1000000
	// Bit Boff.
	ISI_R2Y_SET2_Boff = 0x1000000

	// CR: ISI Control Register
	// Position of ISI_EN field.
	ISI_CR_ISI_EN_Pos = 0x0
	// Bit mask of ISI_EN field.
	ISI_CR_ISI_EN_Msk = 0x1
	// Bit ISI_EN.
	ISI_CR_ISI_EN = 0x1
	// Position of ISI_DIS field.
	ISI_CR_ISI_DIS_Pos = 0x1
	// Bit mask of ISI_DIS field.
	ISI_CR_ISI_DIS_Msk = 0x2
	// Bit ISI_DIS.
	ISI_CR_ISI_DIS = 0x2
	// Position of ISI_SRST field.
	ISI_CR_ISI_SRST_Pos = 0x2
	// Bit mask of ISI_SRST field.
	ISI_CR_ISI_SRST_Msk = 0x4
	// Bit ISI_SRST.
	ISI_CR_ISI_SRST = 0x4
	// Position of ISI_CDC field.
	ISI_CR_ISI_CDC_Pos = 0x8
	// Bit mask of ISI_CDC field.
	ISI_CR_ISI_CDC_Msk = 0x100
	// Bit ISI_CDC.
	ISI_CR_ISI_CDC = 0x100

	// SR: ISI Status Register
	// Position of ENABLE field.
	ISI_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ISI_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ISI_SR_ENABLE = 0x1
	// Position of DIS_DONE field.
	ISI_SR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_SR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_SR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_SR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_SR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_SR_SRST = 0x4
	// Position of CDC_PND field.
	ISI_SR_CDC_PND_Pos = 0x8
	// Bit mask of CDC_PND field.
	ISI_SR_CDC_PND_Msk = 0x100
	// Bit CDC_PND.
	ISI_SR_CDC_PND = 0x100
	// Position of VSYNC field.
	ISI_SR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_SR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_SR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_SR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_SR_CXFR_DONE = 0x20000
	// Position of SIP field.
	ISI_SR_SIP_Pos = 0x13
	// Bit mask of SIP field.
	ISI_SR_SIP_Msk = 0x80000
	// Bit SIP.
	ISI_SR_SIP = 0x80000
	// Position of P_OVR field.
	ISI_SR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_SR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_SR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_SR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_SR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_SR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_SR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_SR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_SR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_SR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_SR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_SR_FR_OVR = 0x8000000

	// IER: ISI Interrupt Enable Register
	// Position of DIS_DONE field.
	ISI_IER_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IER_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IER_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IER_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IER_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IER_SRST = 0x4
	// Position of VSYNC field.
	ISI_IER_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IER_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IER_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IER_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IER_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IER_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IER_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IER_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IER_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IER_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IER_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IER_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IER_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IER_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IER_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IER_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IER_FR_OVR = 0x8000000

	// IDR: ISI Interrupt Disable Register
	// Position of DIS_DONE field.
	ISI_IDR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IDR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IDR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IDR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IDR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IDR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IDR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IDR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IDR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IDR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IDR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IDR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IDR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IDR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IDR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IDR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IDR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IDR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IDR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IDR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IDR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IDR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IDR_FR_OVR = 0x8000000

	// IMR: ISI Interrupt Mask Register
	// Position of DIS_DONE field.
	ISI_IMR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IMR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IMR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IMR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IMR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IMR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IMR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IMR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IMR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IMR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IMR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IMR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IMR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IMR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IMR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IMR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IMR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IMR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IMR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IMR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IMR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IMR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IMR_FR_OVR = 0x8000000

	// DMA_CHER: DMA Channel Enable Register
	// Position of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Pos = 0x0
	// Bit mask of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Msk = 0x1
	// Bit P_CH_EN.
	ISI_DMA_CHER_P_CH_EN = 0x1
	// Position of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Pos = 0x1
	// Bit mask of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Msk = 0x2
	// Bit C_CH_EN.
	ISI_DMA_CHER_C_CH_EN = 0x2

	// DMA_CHDR: DMA Channel Disable Register
	// Position of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Pos = 0x0
	// Bit mask of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Msk = 0x1
	// Bit P_CH_DIS.
	ISI_DMA_CHDR_P_CH_DIS = 0x1
	// Position of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Pos = 0x1
	// Bit mask of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Msk = 0x2
	// Bit C_CH_DIS.
	ISI_DMA_CHDR_C_CH_DIS = 0x2

	// DMA_CHSR: DMA Channel Status Register
	// Position of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Pos = 0x0
	// Bit mask of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Msk = 0x1
	// Bit P_CH_S.
	ISI_DMA_CHSR_P_CH_S = 0x1
	// Position of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Pos = 0x1
	// Bit mask of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Msk = 0x2
	// Bit C_CH_S.
	ISI_DMA_CHSR_C_CH_S = 0x2

	// DMA_P_ADDR: DMA Preview Base Address Register
	// Position of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Pos = 0x2
	// Bit mask of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Msk = 0xfffffffc

	// DMA_P_CTRL: DMA Preview Control Register
	// Position of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Pos = 0x0
	// Bit mask of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Msk = 0x1
	// Bit P_FETCH.
	ISI_DMA_P_CTRL_P_FETCH = 0x1
	// Position of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Pos = 0x1
	// Bit mask of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Msk = 0x2
	// Bit P_WB.
	ISI_DMA_P_CTRL_P_WB = 0x2
	// Position of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Pos = 0x2
	// Bit mask of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Msk = 0x4
	// Bit P_IEN.
	ISI_DMA_P_CTRL_P_IEN = 0x4
	// Position of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Pos = 0x3
	// Bit mask of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Msk = 0x8
	// Bit P_DONE.
	ISI_DMA_P_CTRL_P_DONE = 0x8

	// DMA_P_DSCR: DMA Preview Descriptor Address Register
	// Position of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Pos = 0x2
	// Bit mask of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Msk = 0xfffffffc

	// DMA_C_ADDR: DMA Codec Base Address Register
	// Position of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Pos = 0x2
	// Bit mask of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Msk = 0xfffffffc

	// DMA_C_CTRL: DMA Codec Control Register
	// Position of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Pos = 0x0
	// Bit mask of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Msk = 0x1
	// Bit C_FETCH.
	ISI_DMA_C_CTRL_C_FETCH = 0x1
	// Position of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Pos = 0x1
	// Bit mask of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Msk = 0x2
	// Bit C_WB.
	ISI_DMA_C_CTRL_C_WB = 0x2
	// Position of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Pos = 0x2
	// Bit mask of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Msk = 0x4
	// Bit C_IEN.
	ISI_DMA_C_CTRL_C_IEN = 0x4
	// Position of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Pos = 0x3
	// Bit mask of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Msk = 0x8
	// Bit C_DONE.
	ISI_DMA_C_CTRL_C_DONE = 0x8

	// DMA_C_DSCR: DMA Codec Descriptor Address Register
	// Position of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Pos = 0x2
	// Bit mask of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Msk = 0xfffffffc

	// WPCR: Write Protection Control Register
	// Position of WP_EN field.
	ISI_WPCR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	ISI_WPCR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	ISI_WPCR_WP_EN = 0x1
	// Position of WP_KEY field.
	ISI_WPCR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	ISI_WPCR_WP_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WP_VS field.
	ISI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	ISI_WPSR_WP_VS_Msk = 0xf
	// Position of WP_VSRC field.
	ISI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	ISI_WPSR_WP_VSRC_Msk = 0xffff00
)

// Constants for SFR: Special Function Registers
const (
	// OHCIICR: OHCI Interrupt Configuration Register
	// Position of RES0 field.
	SFR_OHCIICR_RES0_Pos = 0x0
	// Bit mask of RES0 field.
	SFR_OHCIICR_RES0_Msk = 0x1
	// Bit RES0.
	SFR_OHCIICR_RES0 = 0x1
	// Position of RES1 field.
	SFR_OHCIICR_RES1_Pos = 0x1
	// Bit mask of RES1 field.
	SFR_OHCIICR_RES1_Msk = 0x2
	// Bit RES1.
	SFR_OHCIICR_RES1 = 0x2
	// Position of RES2 field.
	SFR_OHCIICR_RES2_Pos = 0x2
	// Bit mask of RES2 field.
	SFR_OHCIICR_RES2_Msk = 0x4
	// Bit RES2.
	SFR_OHCIICR_RES2 = 0x4
	// Position of ARIE field.
	SFR_OHCIICR_ARIE_Pos = 0x4
	// Bit mask of ARIE field.
	SFR_OHCIICR_ARIE_Msk = 0x10
	// Bit ARIE.
	SFR_OHCIICR_ARIE = 0x10
	// Position of APPSTART field.
	SFR_OHCIICR_APPSTART_Pos = 0x5
	// Bit mask of APPSTART field.
	SFR_OHCIICR_APPSTART_Msk = 0x20
	// Bit APPSTART.
	SFR_OHCIICR_APPSTART = 0x20
	// Position of UDPPUDIS field.
	SFR_OHCIICR_UDPPUDIS_Pos = 0x17
	// Bit mask of UDPPUDIS field.
	SFR_OHCIICR_UDPPUDIS_Msk = 0x800000
	// Bit UDPPUDIS.
	SFR_OHCIICR_UDPPUDIS = 0x800000

	// OHCIISR: OHCI Interrupt Status Register
	// Position of RIS0 field.
	SFR_OHCIISR_RIS0_Pos = 0x0
	// Bit mask of RIS0 field.
	SFR_OHCIISR_RIS0_Msk = 0x1
	// Bit RIS0.
	SFR_OHCIISR_RIS0 = 0x1
	// Position of RIS1 field.
	SFR_OHCIISR_RIS1_Pos = 0x1
	// Bit mask of RIS1 field.
	SFR_OHCIISR_RIS1_Msk = 0x2
	// Bit RIS1.
	SFR_OHCIISR_RIS1 = 0x2
	// Position of RIS2 field.
	SFR_OHCIISR_RIS2_Pos = 0x2
	// Bit mask of RIS2 field.
	SFR_OHCIISR_RIS2_Msk = 0x4
	// Bit RIS2.
	SFR_OHCIISR_RIS2 = 0x4

	// AHB: AHB Configuration Register
	// Position of PFETCH10 field.
	SFR_AHB_PFETCH10_Pos = 0xa
	// Bit mask of PFETCH10 field.
	SFR_AHB_PFETCH10_Msk = 0x400
	// Bit PFETCH10.
	SFR_AHB_PFETCH10 = 0x400
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH10_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH10_INCR8 = 0x1
	// Position of PFETCH11 field.
	SFR_AHB_PFETCH11_Pos = 0xb
	// Bit mask of PFETCH11 field.
	SFR_AHB_PFETCH11_Msk = 0x800
	// Bit PFETCH11.
	SFR_AHB_PFETCH11 = 0x800
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH11_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH11_INCR8 = 0x1
	// Position of PFETCH12 field.
	SFR_AHB_PFETCH12_Pos = 0xc
	// Bit mask of PFETCH12 field.
	SFR_AHB_PFETCH12_Msk = 0x1000
	// Bit PFETCH12.
	SFR_AHB_PFETCH12 = 0x1000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH12_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH12_INCR8 = 0x1
	// Position of PFETCH13 field.
	SFR_AHB_PFETCH13_Pos = 0xd
	// Bit mask of PFETCH13 field.
	SFR_AHB_PFETCH13_Msk = 0x2000
	// Bit PFETCH13.
	SFR_AHB_PFETCH13 = 0x2000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH13_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH13_INCR8 = 0x1
	// Position of PFETCH14 field.
	SFR_AHB_PFETCH14_Pos = 0xe
	// Bit mask of PFETCH14 field.
	SFR_AHB_PFETCH14_Msk = 0x4000
	// Bit PFETCH14.
	SFR_AHB_PFETCH14 = 0x4000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH14_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH14_INCR8 = 0x1
	// Position of DLBOPT10 field.
	SFR_AHB_DLBOPT10_Pos = 0x1a
	// Bit mask of DLBOPT10 field.
	SFR_AHB_DLBOPT10_Msk = 0x4000000
	// Bit DLBOPT10.
	SFR_AHB_DLBOPT10 = 0x4000000
	// Position of DLBOPT11 field.
	SFR_AHB_DLBOPT11_Pos = 0x1b
	// Bit mask of DLBOPT11 field.
	SFR_AHB_DLBOPT11_Msk = 0x8000000
	// Bit DLBOPT11.
	SFR_AHB_DLBOPT11 = 0x8000000
	// Position of DLBOPT12 field.
	SFR_AHB_DLBOPT12_Pos = 0x1c
	// Bit mask of DLBOPT12 field.
	SFR_AHB_DLBOPT12_Msk = 0x10000000
	// Bit DLBOPT12.
	SFR_AHB_DLBOPT12 = 0x10000000
	// Position of DLBOPT13 field.
	SFR_AHB_DLBOPT13_Pos = 0x1d
	// Bit mask of DLBOPT13 field.
	SFR_AHB_DLBOPT13_Msk = 0x20000000
	// Bit DLBOPT13.
	SFR_AHB_DLBOPT13 = 0x20000000
	// Position of DLBOPT14 field.
	SFR_AHB_DLBOPT14_Pos = 0x1e
	// Bit mask of DLBOPT14 field.
	SFR_AHB_DLBOPT14_Msk = 0x40000000
	// Bit DLBOPT14.
	SFR_AHB_DLBOPT14 = 0x40000000

	// BRIDGE: Bridge Configuration Register
	// Position of APBTURBO field.
	SFR_BRIDGE_APBTURBO_Pos = 0x0
	// Bit mask of APBTURBO field.
	SFR_BRIDGE_APBTURBO_Msk = 0x1
	// Bit APBTURBO.
	SFR_BRIDGE_APBTURBO = 0x1
	// Position of AXI2AHBSEL field.
	SFR_BRIDGE_AXI2AHBSEL_Pos = 0x8
	// Bit mask of AXI2AHBSEL field.
	SFR_BRIDGE_AXI2AHBSEL_Msk = 0x100
	// Bit AXI2AHBSEL.
	SFR_BRIDGE_AXI2AHBSEL = 0x100
	// use single port bridge.
	SFR_BRIDGE_AXI2AHBSEL_SINGLE = 0x0
	// use dual port bridge.
	SFR_BRIDGE_AXI2AHBSEL_DUAL = 0x1

	// SECURE: Security Configuration Register
	// Position of ROM field.
	SFR_SECURE_ROM_Pos = 0x0
	// Bit mask of ROM field.
	SFR_SECURE_ROM_Msk = 0x1
	// Bit ROM.
	SFR_SECURE_ROM = 0x1
	// Position of FUSE field.
	SFR_SECURE_FUSE_Pos = 0x8
	// Bit mask of FUSE field.
	SFR_SECURE_FUSE_Msk = 0x100
	// Bit FUSE.
	SFR_SECURE_FUSE = 0x100

	// UTMICKTRIM: UTMI Clock Trimming Register
	// Position of FREQ field.
	SFR_UTMICKTRIM_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	SFR_UTMICKTRIM_FREQ_Msk = 0x3
	// 12 MHz reference clock
	SFR_UTMICKTRIM_FREQ_12 = 0x0
	// 16 MHz reference clock
	SFR_UTMICKTRIM_FREQ_16 = 0x1
	// 24 MHz reference clock
	SFR_UTMICKTRIM_FREQ_24 = 0x2
	// 48 MHz reference clock
	SFR_UTMICKTRIM_FREQ_48 = 0x3
	// Position of VBG field.
	SFR_UTMICKTRIM_VBG_Pos = 0x10
	// Bit mask of VBG field.
	SFR_UTMICKTRIM_VBG_Msk = 0xf0000

	// UTMIHSTRIM: UTMI High Speed Trimming Register
	// Position of SQUELCH field.
	SFR_UTMIHSTRIM_SQUELCH_Pos = 0x0
	// Bit mask of SQUELCH field.
	SFR_UTMIHSTRIM_SQUELCH_Msk = 0x7
	// Position of DISC field.
	SFR_UTMIHSTRIM_DISC_Pos = 0x4
	// Bit mask of DISC field.
	SFR_UTMIHSTRIM_DISC_Msk = 0x70
	// Position of SLOPE0 field.
	SFR_UTMIHSTRIM_SLOPE0_Pos = 0x8
	// Bit mask of SLOPE0 field.
	SFR_UTMIHSTRIM_SLOPE0_Msk = 0x700
	// Position of SLOPE1 field.
	SFR_UTMIHSTRIM_SLOPE1_Pos = 0xc
	// Bit mask of SLOPE1 field.
	SFR_UTMIHSTRIM_SLOPE1_Msk = 0x7000
	// Position of SLOPE2 field.
	SFR_UTMIHSTRIM_SLOPE2_Pos = 0x10
	// Bit mask of SLOPE2 field.
	SFR_UTMIHSTRIM_SLOPE2_Msk = 0x70000

	// UTMIFSTRIM: UTMI Full Speed Trimming Register
	// Position of RISE field.
	SFR_UTMIFSTRIM_RISE_Pos = 0x0
	// Bit mask of RISE field.
	SFR_UTMIFSTRIM_RISE_Msk = 0x7
	// Position of FALL field.
	SFR_UTMIFSTRIM_FALL_Pos = 0x4
	// Bit mask of FALL field.
	SFR_UTMIFSTRIM_FALL_Msk = 0x70
	// Position of XCVR field.
	SFR_UTMIFSTRIM_XCVR_Pos = 0x8
	// Bit mask of XCVR field.
	SFR_UTMIFSTRIM_XCVR_Msk = 0x300
	// Position of ZN field.
	SFR_UTMIFSTRIM_ZN_Pos = 0x10
	// Bit mask of ZN field.
	SFR_UTMIFSTRIM_ZN_Msk = 0x70000
	// Position of ZP field.
	SFR_UTMIFSTRIM_ZP_Pos = 0x14
	// Bit mask of ZP field.
	SFR_UTMIFSTRIM_ZP_Msk = 0x700000

	// UTMISWAP: UTMI DP/DM Pin Swapping Register
	// Position of PORT0 field.
	SFR_UTMISWAP_PORT0_Pos = 0x0
	// Bit mask of PORT0 field.
	SFR_UTMISWAP_PORT0_Msk = 0x1
	// Bit PORT0.
	SFR_UTMISWAP_PORT0 = 0x1
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT0_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT0_SWAPPED = 0x1
	// Position of PORT1 field.
	SFR_UTMISWAP_PORT1_Pos = 0x1
	// Bit mask of PORT1 field.
	SFR_UTMISWAP_PORT1_Msk = 0x2
	// Bit PORT1.
	SFR_UTMISWAP_PORT1 = 0x2
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT1_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT1_SWAPPED = 0x1
	// Position of PORT2 field.
	SFR_UTMISWAP_PORT2_Pos = 0x2
	// Bit mask of PORT2 field.
	SFR_UTMISWAP_PORT2_Msk = 0x4
	// Bit PORT2.
	SFR_UTMISWAP_PORT2 = 0x4
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT2_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT2_SWAPPED = 0x1

	// EBICFG: EBI Configuration Register
	// Position of DRIVE0 field.
	SFR_EBICFG_DRIVE0_Pos = 0x0
	// Bit mask of DRIVE0 field.
	SFR_EBICFG_DRIVE0_Msk = 0x3
	// Low drive level
	SFR_EBICFG_DRIVE0_LOW = 0x0
	// Medium drive level
	SFR_EBICFG_DRIVE0_MEDIUM = 0x2
	// High drive level
	SFR_EBICFG_DRIVE0_HIGH = 0x3
	// Position of PULL0 field.
	SFR_EBICFG_PULL0_Pos = 0x2
	// Bit mask of PULL0 field.
	SFR_EBICFG_PULL0_Msk = 0xc
	// Pull-up
	SFR_EBICFG_PULL0_UP = 0x0
	// No Pull
	SFR_EBICFG_PULL0_NONE = 0x1
	// Pull-down
	SFR_EBICFG_PULL0_DOWN = 0x3
	// Position of SCH0 field.
	SFR_EBICFG_SCH0_Pos = 0x4
	// Bit mask of SCH0 field.
	SFR_EBICFG_SCH0_Msk = 0x10
	// Bit SCH0.
	SFR_EBICFG_SCH0 = 0x10
	// Position of DRIVE1 field.
	SFR_EBICFG_DRIVE1_Pos = 0x8
	// Bit mask of DRIVE1 field.
	SFR_EBICFG_DRIVE1_Msk = 0x300
	// Low drive level
	SFR_EBICFG_DRIVE1_LOW = 0x0
	// Medium drive level
	SFR_EBICFG_DRIVE1_MEDIUM = 0x2
	// High drive level
	SFR_EBICFG_DRIVE1_HIGH = 0x3
	// Position of PULL1 field.
	SFR_EBICFG_PULL1_Pos = 0xa
	// Bit mask of PULL1 field.
	SFR_EBICFG_PULL1_Msk = 0xc00
	// Pull-up
	SFR_EBICFG_PULL1_UP = 0x0
	// No Pull
	SFR_EBICFG_PULL1_NONE = 0x1
	// Pull-down
	SFR_EBICFG_PULL1_DOWN = 0x3
	// Position of SCH1 field.
	SFR_EBICFG_SCH1_Pos = 0xc
	// Bit mask of SCH1 field.
	SFR_EBICFG_SCH1_Msk = 0x1000
	// Bit SCH1.
	SFR_EBICFG_SCH1 = 0x1000
	// Position of BMS field.
	SFR_EBICFG_BMS_Pos = 0x10
	// Bit mask of BMS field.
	SFR_EBICFG_BMS_Msk = 0x10000
	// Bit BMS.
	SFR_EBICFG_BMS = 0x10000
	// Boot on ROM.
	SFR_EBICFG_BMS_ROM = 0x0
	// Boot on EBI.
	SFR_EBICFG_BMS_EBI = 0x1
)

// Constants for ADC: Analog-to-Digital Converter
const (
	// CR: Control Register
	// Position of SWRST field.
	ADC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	ADC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	ADC_CR_SWRST = 0x1
	// Position of START field.
	ADC_CR_START_Pos = 0x1
	// Bit mask of START field.
	ADC_CR_START_Msk = 0x2
	// Bit START.
	ADC_CR_START = 0x2
	// Position of TSCALIB field.
	ADC_CR_TSCALIB_Pos = 0x2
	// Bit mask of TSCALIB field.
	ADC_CR_TSCALIB_Msk = 0x4
	// Bit TSCALIB.
	ADC_CR_TSCALIB = 0x4
	// Position of AUTOCAL field.
	ADC_CR_AUTOCAL_Pos = 0x3
	// Bit mask of AUTOCAL field.
	ADC_CR_AUTOCAL_Msk = 0x8
	// Bit AUTOCAL.
	ADC_CR_AUTOCAL = 0x8

	// MR: Mode Register
	// Position of TRGSEL field.
	ADC_MR_TRGSEL_Pos = 0x1
	// Bit mask of TRGSEL field.
	ADC_MR_TRGSEL_Msk = 0xe
	// ADTRG
	ADC_MR_TRGSEL_ADC_TRIG0 = 0x0
	// TIOA0
	ADC_MR_TRGSEL_ADC_TRIG1 = 0x1
	// TIOA1
	ADC_MR_TRGSEL_ADC_TRIG2 = 0x2
	// TIOA2
	ADC_MR_TRGSEL_ADC_TRIG3 = 0x3
	// PWM event line 0
	ADC_MR_TRGSEL_ADC_TRIG4 = 0x4
	// PWM_even line 1
	ADC_MR_TRGSEL_ADC_TRIG5 = 0x5
	// Position of SLEEP field.
	ADC_MR_SLEEP_Pos = 0x5
	// Bit mask of SLEEP field.
	ADC_MR_SLEEP_Msk = 0x20
	// Bit SLEEP.
	ADC_MR_SLEEP = 0x20
	// Normal Mode: The ADC Core and reference voltage circuitry are kept ON between conversions
	ADC_MR_SLEEP_NORMAL = 0x0
	// Sleep Mode: The wake-up time can be modified by programming FWUP bit
	ADC_MR_SLEEP_SLEEP = 0x1
	// Position of FWUP field.
	ADC_MR_FWUP_Pos = 0x6
	// Bit mask of FWUP field.
	ADC_MR_FWUP_Msk = 0x40
	// Bit FWUP.
	ADC_MR_FWUP = 0x40
	// If SLEEP is 1 then both ADC Core and reference voltage circuitry are OFF between conversions
	ADC_MR_FWUP_OFF = 0x0
	// If SLEEP is 1 then Fast Wake-up Sleep Mode: The Voltage reference is ON between conversions and ADC Core is OFF
	ADC_MR_FWUP_ON = 0x1
	// Position of PRESCAL field.
	ADC_MR_PRESCAL_Pos = 0x8
	// Bit mask of PRESCAL field.
	ADC_MR_PRESCAL_Msk = 0xff00
	// Position of STARTUP field.
	ADC_MR_STARTUP_Pos = 0x10
	// Bit mask of STARTUP field.
	ADC_MR_STARTUP_Msk = 0xf0000
	// 0 periods of ADCClock
	ADC_MR_STARTUP_SUT0 = 0x0
	// 8 periods of ADCClock
	ADC_MR_STARTUP_SUT8 = 0x1
	// 16 periods of ADCClock
	ADC_MR_STARTUP_SUT16 = 0x2
	// 24 periods of ADCClock
	ADC_MR_STARTUP_SUT24 = 0x3
	// 64 periods of ADCClock
	ADC_MR_STARTUP_SUT64 = 0x4
	// 80 periods of ADCClock
	ADC_MR_STARTUP_SUT80 = 0x5
	// 96 periods of ADCClock
	ADC_MR_STARTUP_SUT96 = 0x6
	// 112 periods of ADCClock
	ADC_MR_STARTUP_SUT112 = 0x7
	// 512 periods of ADCClock
	ADC_MR_STARTUP_SUT512 = 0x8
	// 576 periods of ADCClock
	ADC_MR_STARTUP_SUT576 = 0x9
	// 640 periods of ADCClock
	ADC_MR_STARTUP_SUT640 = 0xa
	// 704 periods of ADCClock
	ADC_MR_STARTUP_SUT704 = 0xb
	// 768 periods of ADCClock
	ADC_MR_STARTUP_SUT768 = 0xc
	// 832 periods of ADCClock
	ADC_MR_STARTUP_SUT832 = 0xd
	// 896 periods of ADCClock
	ADC_MR_STARTUP_SUT896 = 0xe
	// 960 periods of ADCClock
	ADC_MR_STARTUP_SUT960 = 0xf
	// Position of SETTLING field.
	ADC_MR_SETTLING_Pos = 0x14
	// Bit mask of SETTLING field.
	ADC_MR_SETTLING_Msk = 0x300000
	// 3 periods of ADCClock
	ADC_MR_SETTLING_AST3 = 0x0
	// 5 periods of ADCClock
	ADC_MR_SETTLING_AST5 = 0x1
	// 9 periods of ADCClock
	ADC_MR_SETTLING_AST9 = 0x2
	// 17 periods of ADCClock
	ADC_MR_SETTLING_AST17 = 0x3
	// Position of ANACH field.
	ADC_MR_ANACH_Pos = 0x17
	// Bit mask of ANACH field.
	ADC_MR_ANACH_Msk = 0x800000
	// Bit ANACH.
	ADC_MR_ANACH = 0x800000
	// No analog change on channel switching: DIFF0, GAIN0 and OFF0 are used for all channels
	ADC_MR_ANACH_NONE = 0x0
	// Allows different analog settings for each channel. See ADC_CGR and ADC_COR Registers
	ADC_MR_ANACH_ALLOWED = 0x1
	// Position of TRACKTIM field.
	ADC_MR_TRACKTIM_Pos = 0x18
	// Bit mask of TRACKTIM field.
	ADC_MR_TRACKTIM_Msk = 0xf000000
	// Position of USEQ field.
	ADC_MR_USEQ_Pos = 0x1f
	// Bit mask of USEQ field.
	ADC_MR_USEQ_Msk = 0x80000000
	// Bit USEQ.
	ADC_MR_USEQ = 0x80000000
	// Normal Mode: The controller converts channels in a simple numeric order depending only on the channel index.
	ADC_MR_USEQ_NUM_ORDER = 0x0
	// User Sequence Mode: The sequence respects what is defined in ADC_SEQR1 and ADC_SEQR2 registers and can be used to convert several times the same channel.
	ADC_MR_USEQ_REG_ORDER = 0x1

	// SEQR1: Channel Sequence Register 1
	// Position of USCH1 field.
	ADC_SEQR1_USCH1_Pos = 0x0
	// Bit mask of USCH1 field.
	ADC_SEQR1_USCH1_Msk = 0xf
	// Position of USCH2 field.
	ADC_SEQR1_USCH2_Pos = 0x4
	// Bit mask of USCH2 field.
	ADC_SEQR1_USCH2_Msk = 0xf0
	// Position of USCH3 field.
	ADC_SEQR1_USCH3_Pos = 0x8
	// Bit mask of USCH3 field.
	ADC_SEQR1_USCH3_Msk = 0xf00
	// Position of USCH4 field.
	ADC_SEQR1_USCH4_Pos = 0xc
	// Bit mask of USCH4 field.
	ADC_SEQR1_USCH4_Msk = 0xf000
	// Position of USCH5 field.
	ADC_SEQR1_USCH5_Pos = 0x10
	// Bit mask of USCH5 field.
	ADC_SEQR1_USCH5_Msk = 0xf0000
	// Position of USCH6 field.
	ADC_SEQR1_USCH6_Pos = 0x14
	// Bit mask of USCH6 field.
	ADC_SEQR1_USCH6_Msk = 0xf00000
	// Position of USCH7 field.
	ADC_SEQR1_USCH7_Pos = 0x18
	// Bit mask of USCH7 field.
	ADC_SEQR1_USCH7_Msk = 0xf000000
	// Position of USCH8 field.
	ADC_SEQR1_USCH8_Pos = 0x1c
	// Bit mask of USCH8 field.
	ADC_SEQR1_USCH8_Msk = 0xf0000000

	// SEQR2: Channel Sequence Register 2
	// Position of USCH9 field.
	ADC_SEQR2_USCH9_Pos = 0x0
	// Bit mask of USCH9 field.
	ADC_SEQR2_USCH9_Msk = 0xf
	// Position of USCH10 field.
	ADC_SEQR2_USCH10_Pos = 0x4
	// Bit mask of USCH10 field.
	ADC_SEQR2_USCH10_Msk = 0xf0
	// Position of USCH11 field.
	ADC_SEQR2_USCH11_Pos = 0x8
	// Bit mask of USCH11 field.
	ADC_SEQR2_USCH11_Msk = 0xf00

	// CHER: Channel Enable Register
	// Position of CH0 field.
	ADC_CHER_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHER_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHER_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHER_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHER_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHER_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHER_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHER_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHER_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHER_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHER_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHER_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHER_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHER_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHER_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHER_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHER_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHER_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHER_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHER_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHER_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHER_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHER_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHER_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHER_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHER_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHER_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHER_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHER_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHER_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHER_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHER_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHER_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHER_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHER_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHER_CH11 = 0x800

	// CHDR: Channel Disable Register
	// Position of CH0 field.
	ADC_CHDR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHDR_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHDR_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHDR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHDR_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHDR_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHDR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHDR_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHDR_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHDR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHDR_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHDR_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHDR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHDR_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHDR_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHDR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHDR_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHDR_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHDR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHDR_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHDR_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHDR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHDR_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHDR_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHDR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHDR_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHDR_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHDR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHDR_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHDR_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHDR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHDR_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHDR_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHDR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHDR_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHDR_CH11 = 0x800

	// CHSR: Channel Status Register
	// Position of CH0 field.
	ADC_CHSR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHSR_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHSR_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHSR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHSR_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHSR_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHSR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHSR_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHSR_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHSR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHSR_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHSR_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHSR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHSR_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHSR_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHSR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHSR_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHSR_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHSR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHSR_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHSR_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHSR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHSR_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHSR_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHSR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHSR_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHSR_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHSR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHSR_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHSR_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHSR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHSR_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHSR_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHSR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHSR_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHSR_CH11 = 0x800

	// LCDR: Last Converted Data Register
	// Position of LDATA field.
	ADC_LCDR_LDATA_Pos = 0x0
	// Bit mask of LDATA field.
	ADC_LCDR_LDATA_Msk = 0xfff
	// Position of CHNB field.
	ADC_LCDR_CHNB_Pos = 0xc
	// Bit mask of CHNB field.
	ADC_LCDR_CHNB_Msk = 0xf000

	// IER: Interrupt Enable Register
	// Position of EOC0 field.
	ADC_IER_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IER_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IER_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IER_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IER_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IER_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IER_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IER_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IER_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IER_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IER_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IER_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IER_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IER_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IER_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IER_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IER_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IER_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IER_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IER_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IER_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IER_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IER_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IER_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IER_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IER_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IER_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IER_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IER_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IER_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IER_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IER_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IER_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IER_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IER_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IER_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IER_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IER_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IER_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IER_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IER_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IER_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IER_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IER_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IER_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IER_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IER_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IER_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IER_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IER_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IER_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IER_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IER_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IER_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IER_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IER_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IER_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IER_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IER_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IER_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IER_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IER_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IER_NOPEN = 0x40000000

	// IDR: Interrupt Disable Register
	// Position of EOC0 field.
	ADC_IDR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IDR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IDR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IDR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IDR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IDR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IDR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IDR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IDR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IDR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IDR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IDR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IDR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IDR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IDR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IDR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IDR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IDR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IDR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IDR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IDR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IDR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IDR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IDR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IDR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IDR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IDR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IDR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IDR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IDR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IDR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IDR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IDR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IDR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IDR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IDR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IDR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IDR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IDR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IDR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IDR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IDR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IDR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IDR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IDR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IDR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IDR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IDR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IDR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IDR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IDR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IDR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IDR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IDR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IDR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IDR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IDR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IDR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IDR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IDR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IDR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IDR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IDR_NOPEN = 0x40000000

	// IMR: Interrupt Mask Register
	// Position of EOC0 field.
	ADC_IMR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IMR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IMR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IMR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IMR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IMR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IMR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IMR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IMR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IMR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IMR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IMR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IMR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IMR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IMR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IMR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IMR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IMR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IMR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IMR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IMR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IMR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IMR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IMR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IMR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IMR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IMR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IMR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IMR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IMR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IMR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IMR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IMR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IMR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IMR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IMR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IMR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IMR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IMR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IMR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IMR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IMR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IMR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IMR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IMR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IMR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IMR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IMR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IMR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IMR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IMR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IMR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IMR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IMR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IMR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IMR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IMR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IMR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IMR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IMR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IMR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IMR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IMR_NOPEN = 0x40000000

	// ISR: Interrupt Status Register
	// Position of EOC0 field.
	ADC_ISR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_ISR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_ISR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_ISR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_ISR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_ISR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_ISR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_ISR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_ISR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_ISR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_ISR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_ISR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_ISR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_ISR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_ISR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_ISR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_ISR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_ISR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_ISR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_ISR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_ISR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_ISR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_ISR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_ISR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_ISR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_ISR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_ISR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_ISR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_ISR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_ISR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_ISR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_ISR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_ISR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_ISR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_ISR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_ISR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_ISR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_ISR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_ISR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_ISR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_ISR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_ISR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_ISR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_ISR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_ISR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_ISR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_ISR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_ISR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_ISR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_ISR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_ISR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_ISR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_ISR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_ISR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_ISR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_ISR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_ISR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_ISR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_ISR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_ISR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_ISR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_ISR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_ISR_NOPEN = 0x40000000
	// Position of PENS field.
	ADC_ISR_PENS_Pos = 0x1f
	// Bit mask of PENS field.
	ADC_ISR_PENS_Msk = 0x80000000
	// Bit PENS.
	ADC_ISR_PENS = 0x80000000

	// OVER: Overrun Status Register
	// Position of OVRE0 field.
	ADC_OVER_OVRE0_Pos = 0x0
	// Bit mask of OVRE0 field.
	ADC_OVER_OVRE0_Msk = 0x1
	// Bit OVRE0.
	ADC_OVER_OVRE0 = 0x1
	// Position of OVRE1 field.
	ADC_OVER_OVRE1_Pos = 0x1
	// Bit mask of OVRE1 field.
	ADC_OVER_OVRE1_Msk = 0x2
	// Bit OVRE1.
	ADC_OVER_OVRE1 = 0x2
	// Position of OVRE2 field.
	ADC_OVER_OVRE2_Pos = 0x2
	// Bit mask of OVRE2 field.
	ADC_OVER_OVRE2_Msk = 0x4
	// Bit OVRE2.
	ADC_OVER_OVRE2 = 0x4
	// Position of OVRE3 field.
	ADC_OVER_OVRE3_Pos = 0x3
	// Bit mask of OVRE3 field.
	ADC_OVER_OVRE3_Msk = 0x8
	// Bit OVRE3.
	ADC_OVER_OVRE3 = 0x8
	// Position of OVRE4 field.
	ADC_OVER_OVRE4_Pos = 0x4
	// Bit mask of OVRE4 field.
	ADC_OVER_OVRE4_Msk = 0x10
	// Bit OVRE4.
	ADC_OVER_OVRE4 = 0x10
	// Position of OVRE5 field.
	ADC_OVER_OVRE5_Pos = 0x5
	// Bit mask of OVRE5 field.
	ADC_OVER_OVRE5_Msk = 0x20
	// Bit OVRE5.
	ADC_OVER_OVRE5 = 0x20
	// Position of OVRE6 field.
	ADC_OVER_OVRE6_Pos = 0x6
	// Bit mask of OVRE6 field.
	ADC_OVER_OVRE6_Msk = 0x40
	// Bit OVRE6.
	ADC_OVER_OVRE6 = 0x40
	// Position of OVRE7 field.
	ADC_OVER_OVRE7_Pos = 0x7
	// Bit mask of OVRE7 field.
	ADC_OVER_OVRE7_Msk = 0x80
	// Bit OVRE7.
	ADC_OVER_OVRE7 = 0x80
	// Position of OVRE8 field.
	ADC_OVER_OVRE8_Pos = 0x8
	// Bit mask of OVRE8 field.
	ADC_OVER_OVRE8_Msk = 0x100
	// Bit OVRE8.
	ADC_OVER_OVRE8 = 0x100
	// Position of OVRE9 field.
	ADC_OVER_OVRE9_Pos = 0x9
	// Bit mask of OVRE9 field.
	ADC_OVER_OVRE9_Msk = 0x200
	// Bit OVRE9.
	ADC_OVER_OVRE9 = 0x200
	// Position of OVRE10 field.
	ADC_OVER_OVRE10_Pos = 0xa
	// Bit mask of OVRE10 field.
	ADC_OVER_OVRE10_Msk = 0x400
	// Bit OVRE10.
	ADC_OVER_OVRE10 = 0x400
	// Position of OVRE11 field.
	ADC_OVER_OVRE11_Pos = 0xb
	// Bit mask of OVRE11 field.
	ADC_OVER_OVRE11_Msk = 0x800
	// Bit OVRE11.
	ADC_OVER_OVRE11 = 0x800

	// EMR: Extended Mode Register
	// Position of CMPMODE field.
	ADC_EMR_CMPMODE_Pos = 0x0
	// Bit mask of CMPMODE field.
	ADC_EMR_CMPMODE_Msk = 0x3
	// Generates an event when the converted data is lower than the low threshold of the window.
	ADC_EMR_CMPMODE_LOW = 0x0
	// Generates an event when the converted data is higher than the high threshold of the window.
	ADC_EMR_CMPMODE_HIGH = 0x1
	// Generates an event when the converted data is in the comparison window.
	ADC_EMR_CMPMODE_IN = 0x2
	// Generates an event when the converted data is out of the comparison window.
	ADC_EMR_CMPMODE_OUT = 0x3
	// Position of CMPSEL field.
	ADC_EMR_CMPSEL_Pos = 0x4
	// Bit mask of CMPSEL field.
	ADC_EMR_CMPSEL_Msk = 0xf0
	// Position of CMPALL field.
	ADC_EMR_CMPALL_Pos = 0x9
	// Bit mask of CMPALL field.
	ADC_EMR_CMPALL_Msk = 0x200
	// Bit CMPALL.
	ADC_EMR_CMPALL = 0x200
	// Position of CMPFILTER field.
	ADC_EMR_CMPFILTER_Pos = 0xc
	// Bit mask of CMPFILTER field.
	ADC_EMR_CMPFILTER_Msk = 0x3000
	// Position of TAG field.
	ADC_EMR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	ADC_EMR_TAG_Msk = 0x1000000
	// Bit TAG.
	ADC_EMR_TAG = 0x1000000

	// CWR: Compare Window Register
	// Position of LOWTHRES field.
	ADC_CWR_LOWTHRES_Pos = 0x0
	// Bit mask of LOWTHRES field.
	ADC_CWR_LOWTHRES_Msk = 0xfff
	// Position of HIGHTHRES field.
	ADC_CWR_HIGHTHRES_Pos = 0x10
	// Bit mask of HIGHTHRES field.
	ADC_CWR_HIGHTHRES_Msk = 0xfff0000

	// CGR: Channel Gain Register
	// Position of GAIN0 field.
	ADC_CGR_GAIN0_Pos = 0x0
	// Bit mask of GAIN0 field.
	ADC_CGR_GAIN0_Msk = 0x3
	// Position of GAIN1 field.
	ADC_CGR_GAIN1_Pos = 0x2
	// Bit mask of GAIN1 field.
	ADC_CGR_GAIN1_Msk = 0xc
	// Position of GAIN2 field.
	ADC_CGR_GAIN2_Pos = 0x4
	// Bit mask of GAIN2 field.
	ADC_CGR_GAIN2_Msk = 0x30
	// Position of GAIN3 field.
	ADC_CGR_GAIN3_Pos = 0x6
	// Bit mask of GAIN3 field.
	ADC_CGR_GAIN3_Msk = 0xc0
	// Position of GAIN4 field.
	ADC_CGR_GAIN4_Pos = 0x8
	// Bit mask of GAIN4 field.
	ADC_CGR_GAIN4_Msk = 0x300
	// Position of GAIN5 field.
	ADC_CGR_GAIN5_Pos = 0xa
	// Bit mask of GAIN5 field.
	ADC_CGR_GAIN5_Msk = 0xc00
	// Position of GAIN6 field.
	ADC_CGR_GAIN6_Pos = 0xc
	// Bit mask of GAIN6 field.
	ADC_CGR_GAIN6_Msk = 0x3000
	// Position of GAIN7 field.
	ADC_CGR_GAIN7_Pos = 0xe
	// Bit mask of GAIN7 field.
	ADC_CGR_GAIN7_Msk = 0xc000
	// Position of GAIN8 field.
	ADC_CGR_GAIN8_Pos = 0x10
	// Bit mask of GAIN8 field.
	ADC_CGR_GAIN8_Msk = 0x30000
	// Position of GAIN9 field.
	ADC_CGR_GAIN9_Pos = 0x12
	// Bit mask of GAIN9 field.
	ADC_CGR_GAIN9_Msk = 0xc0000
	// Position of GAIN10 field.
	ADC_CGR_GAIN10_Pos = 0x14
	// Bit mask of GAIN10 field.
	ADC_CGR_GAIN10_Msk = 0x300000
	// Position of GAIN11 field.
	ADC_CGR_GAIN11_Pos = 0x16
	// Bit mask of GAIN11 field.
	ADC_CGR_GAIN11_Msk = 0xc00000

	// COR: Channel Offset Register
	// Position of OFF0 field.
	ADC_COR_OFF0_Pos = 0x0
	// Bit mask of OFF0 field.
	ADC_COR_OFF0_Msk = 0x1
	// Bit OFF0.
	ADC_COR_OFF0 = 0x1
	// Position of OFF1 field.
	ADC_COR_OFF1_Pos = 0x1
	// Bit mask of OFF1 field.
	ADC_COR_OFF1_Msk = 0x2
	// Bit OFF1.
	ADC_COR_OFF1 = 0x2
	// Position of OFF2 field.
	ADC_COR_OFF2_Pos = 0x2
	// Bit mask of OFF2 field.
	ADC_COR_OFF2_Msk = 0x4
	// Bit OFF2.
	ADC_COR_OFF2 = 0x4
	// Position of OFF3 field.
	ADC_COR_OFF3_Pos = 0x3
	// Bit mask of OFF3 field.
	ADC_COR_OFF3_Msk = 0x8
	// Bit OFF3.
	ADC_COR_OFF3 = 0x8
	// Position of OFF4 field.
	ADC_COR_OFF4_Pos = 0x4
	// Bit mask of OFF4 field.
	ADC_COR_OFF4_Msk = 0x10
	// Bit OFF4.
	ADC_COR_OFF4 = 0x10
	// Position of OFF5 field.
	ADC_COR_OFF5_Pos = 0x5
	// Bit mask of OFF5 field.
	ADC_COR_OFF5_Msk = 0x20
	// Bit OFF5.
	ADC_COR_OFF5 = 0x20
	// Position of OFF6 field.
	ADC_COR_OFF6_Pos = 0x6
	// Bit mask of OFF6 field.
	ADC_COR_OFF6_Msk = 0x40
	// Bit OFF6.
	ADC_COR_OFF6 = 0x40
	// Position of OFF7 field.
	ADC_COR_OFF7_Pos = 0x7
	// Bit mask of OFF7 field.
	ADC_COR_OFF7_Msk = 0x80
	// Bit OFF7.
	ADC_COR_OFF7 = 0x80
	// Position of OFF8 field.
	ADC_COR_OFF8_Pos = 0x8
	// Bit mask of OFF8 field.
	ADC_COR_OFF8_Msk = 0x100
	// Bit OFF8.
	ADC_COR_OFF8 = 0x100
	// Position of OFF9 field.
	ADC_COR_OFF9_Pos = 0x9
	// Bit mask of OFF9 field.
	ADC_COR_OFF9_Msk = 0x200
	// Bit OFF9.
	ADC_COR_OFF9 = 0x200
	// Position of OFF10 field.
	ADC_COR_OFF10_Pos = 0xa
	// Bit mask of OFF10 field.
	ADC_COR_OFF10_Msk = 0x400
	// Bit OFF10.
	ADC_COR_OFF10 = 0x400
	// Position of OFF11 field.
	ADC_COR_OFF11_Pos = 0xb
	// Bit mask of OFF11 field.
	ADC_COR_OFF11_Msk = 0x800
	// Bit OFF11.
	ADC_COR_OFF11 = 0x800
	// Position of DIFF0 field.
	ADC_COR_DIFF0_Pos = 0x10
	// Bit mask of DIFF0 field.
	ADC_COR_DIFF0_Msk = 0x10000
	// Bit DIFF0.
	ADC_COR_DIFF0 = 0x10000
	// Position of DIFF1 field.
	ADC_COR_DIFF1_Pos = 0x11
	// Bit mask of DIFF1 field.
	ADC_COR_DIFF1_Msk = 0x20000
	// Bit DIFF1.
	ADC_COR_DIFF1 = 0x20000
	// Position of DIFF2 field.
	ADC_COR_DIFF2_Pos = 0x12
	// Bit mask of DIFF2 field.
	ADC_COR_DIFF2_Msk = 0x40000
	// Bit DIFF2.
	ADC_COR_DIFF2 = 0x40000
	// Position of DIFF3 field.
	ADC_COR_DIFF3_Pos = 0x13
	// Bit mask of DIFF3 field.
	ADC_COR_DIFF3_Msk = 0x80000
	// Bit DIFF3.
	ADC_COR_DIFF3 = 0x80000
	// Position of DIFF4 field.
	ADC_COR_DIFF4_Pos = 0x14
	// Bit mask of DIFF4 field.
	ADC_COR_DIFF4_Msk = 0x100000
	// Bit DIFF4.
	ADC_COR_DIFF4 = 0x100000
	// Position of DIFF5 field.
	ADC_COR_DIFF5_Pos = 0x15
	// Bit mask of DIFF5 field.
	ADC_COR_DIFF5_Msk = 0x200000
	// Bit DIFF5.
	ADC_COR_DIFF5 = 0x200000
	// Position of DIFF6 field.
	ADC_COR_DIFF6_Pos = 0x16
	// Bit mask of DIFF6 field.
	ADC_COR_DIFF6_Msk = 0x400000
	// Bit DIFF6.
	ADC_COR_DIFF6 = 0x400000
	// Position of DIFF7 field.
	ADC_COR_DIFF7_Pos = 0x17
	// Bit mask of DIFF7 field.
	ADC_COR_DIFF7_Msk = 0x800000
	// Bit DIFF7.
	ADC_COR_DIFF7 = 0x800000
	// Position of DIFF8 field.
	ADC_COR_DIFF8_Pos = 0x18
	// Bit mask of DIFF8 field.
	ADC_COR_DIFF8_Msk = 0x1000000
	// Bit DIFF8.
	ADC_COR_DIFF8 = 0x1000000
	// Position of DIFF9 field.
	ADC_COR_DIFF9_Pos = 0x19
	// Bit mask of DIFF9 field.
	ADC_COR_DIFF9_Msk = 0x2000000
	// Bit DIFF9.
	ADC_COR_DIFF9 = 0x2000000
	// Position of DIFF10 field.
	ADC_COR_DIFF10_Pos = 0x1a
	// Bit mask of DIFF10 field.
	ADC_COR_DIFF10_Msk = 0x4000000
	// Bit DIFF10.
	ADC_COR_DIFF10 = 0x4000000
	// Position of DIFF11 field.
	ADC_COR_DIFF11_Pos = 0x1b
	// Bit mask of DIFF11 field.
	ADC_COR_DIFF11_Msk = 0x8000000
	// Bit DIFF11.
	ADC_COR_DIFF11 = 0x8000000

	// CDR: Channel Data Register
	// Position of DATA field.
	ADC_CDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_CDR_DATA_Msk = 0xfff

	// ACR: Analog Control Register
	// Position of PENDETSENS field.
	ADC_ACR_PENDETSENS_Pos = 0x0
	// Bit mask of PENDETSENS field.
	ADC_ACR_PENDETSENS_Msk = 0x3

	// TSMR: Touchscreen Mode Register
	// Position of TSMODE field.
	ADC_TSMR_TSMODE_Pos = 0x0
	// Bit mask of TSMODE field.
	ADC_TSMR_TSMODE_Msk = 0x3
	// No Touchscreen
	ADC_TSMR_TSMODE_NONE = 0x0
	// 4-wire Touchscreen without pressure measurement
	ADC_TSMR_TSMODE_4_WIRE_NO_PM = 0x1
	// 4-wire Touchscreen with pressure measurement
	ADC_TSMR_TSMODE_4_WIRE = 0x2
	// 5-wire Touchscreen
	ADC_TSMR_TSMODE_5_WIRE = 0x3
	// Position of TSAV field.
	ADC_TSMR_TSAV_Pos = 0x4
	// Bit mask of TSAV field.
	ADC_TSMR_TSAV_Msk = 0x30
	// No Filtering. Only one ADC conversion per measure
	ADC_TSMR_TSAV_NO_FILTER = 0x0
	// Averages 2 ADC conversions
	ADC_TSMR_TSAV_AVG2CONV = 0x1
	// Averages 4 ADC conversions
	ADC_TSMR_TSAV_AVG4CONV = 0x2
	// Averages 8 ADC conversions
	ADC_TSMR_TSAV_AVG8CONV = 0x3
	// Position of TSFREQ field.
	ADC_TSMR_TSFREQ_Pos = 0x8
	// Bit mask of TSFREQ field.
	ADC_TSMR_TSFREQ_Msk = 0xf00
	// Position of TSSCTIM field.
	ADC_TSMR_TSSCTIM_Pos = 0x10
	// Bit mask of TSSCTIM field.
	ADC_TSMR_TSSCTIM_Msk = 0xf0000
	// Position of NOTSDMA field.
	ADC_TSMR_NOTSDMA_Pos = 0x16
	// Bit mask of NOTSDMA field.
	ADC_TSMR_NOTSDMA_Msk = 0x400000
	// Bit NOTSDMA.
	ADC_TSMR_NOTSDMA = 0x400000
	// Position of PENDET field.
	ADC_TSMR_PENDET_Pos = 0x18
	// Bit mask of PENDET field.
	ADC_TSMR_PENDET_Msk = 0x1000000
	// Bit PENDET.
	ADC_TSMR_PENDET = 0x1000000
	// Position of PENDBC field.
	ADC_TSMR_PENDBC_Pos = 0x1c
	// Bit mask of PENDBC field.
	ADC_TSMR_PENDBC_Msk = 0xf0000000

	// XPOSR: Touchscreen X Position Register
	// Position of XPOS field.
	ADC_XPOSR_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	ADC_XPOSR_XPOS_Msk = 0xfff
	// Position of XSCALE field.
	ADC_XPOSR_XSCALE_Pos = 0x10
	// Bit mask of XSCALE field.
	ADC_XPOSR_XSCALE_Msk = 0xfff0000

	// YPOSR: Touchscreen Y Position Register
	// Position of YPOS field.
	ADC_YPOSR_YPOS_Pos = 0x0
	// Bit mask of YPOS field.
	ADC_YPOSR_YPOS_Msk = 0xfff
	// Position of YSCALE field.
	ADC_YPOSR_YSCALE_Pos = 0x10
	// Bit mask of YSCALE field.
	ADC_YPOSR_YSCALE_Msk = 0xfff0000

	// PRESSR: Touchscreen Pressure Register
	// Position of Z1 field.
	ADC_PRESSR_Z1_Pos = 0x0
	// Bit mask of Z1 field.
	ADC_PRESSR_Z1_Msk = 0xfff
	// Position of Z2 field.
	ADC_PRESSR_Z2_Pos = 0x10
	// Bit mask of Z2 field.
	ADC_PRESSR_Z2_Msk = 0xfff0000

	// TRGR: Trigger Register
	// Position of TRGMOD field.
	ADC_TRGR_TRGMOD_Pos = 0x0
	// Bit mask of TRGMOD field.
	ADC_TRGR_TRGMOD_Msk = 0x7
	// No trigger, only software trigger can start conversions
	ADC_TRGR_TRGMOD_NO_TRIGGER = 0x0
	// External Trigger Rising Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_RISE = 0x1
	// External Trigger Falling Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_FALL = 0x2
	// External Trigger Any Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_ANY = 0x3
	// Pen Detect Trigger (shall be selected only if PENDET is set and TSAMOD = Touchscreen only mode)
	ADC_TRGR_TRGMOD_PEN_TRIG = 0x4
	// Periodic Trigger (TRGPER shall be initiated appropriately)
	ADC_TRGR_TRGMOD_PERIOD_TRIG = 0x5
	// Continuous Mode
	ADC_TRGR_TRGMOD_CONTINUOUS = 0x6
	// Position of TRGPER field.
	ADC_TRGR_TRGPER_Pos = 0x10
	// Bit mask of TRGPER field.
	ADC_TRGR_TRGPER_Msk = 0xffff0000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	ADC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	ADC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	ADC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	ADC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	ADC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	ADC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	ADC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	ADC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	ADC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	ADC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for EMAC: Ethernet MAC 10/100
const (
	// NCR: Network Control Register
	// Position of LB field.
	EMAC_NCR_LB_Pos = 0x0
	// Bit mask of LB field.
	EMAC_NCR_LB_Msk = 0x1
	// Bit LB.
	EMAC_NCR_LB = 0x1
	// Position of LLB field.
	EMAC_NCR_LLB_Pos = 0x1
	// Bit mask of LLB field.
	EMAC_NCR_LLB_Msk = 0x2
	// Bit LLB.
	EMAC_NCR_LLB = 0x2
	// Position of RE field.
	EMAC_NCR_RE_Pos = 0x2
	// Bit mask of RE field.
	EMAC_NCR_RE_Msk = 0x4
	// Bit RE.
	EMAC_NCR_RE = 0x4
	// Position of TE field.
	EMAC_NCR_TE_Pos = 0x3
	// Bit mask of TE field.
	EMAC_NCR_TE_Msk = 0x8
	// Bit TE.
	EMAC_NCR_TE = 0x8
	// Position of MPE field.
	EMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	EMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	EMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	EMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	EMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	EMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	EMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	EMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	EMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	EMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	EMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	EMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	EMAC_NCR_BP = 0x100
	// Position of TSTART field.
	EMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	EMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	EMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	EMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	EMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	EMAC_NCR_THALT = 0x400

	// NCFGR: Network Configuration Register
	// Position of SPD field.
	EMAC_NCFGR_SPD_Pos = 0x0
	// Bit mask of SPD field.
	EMAC_NCFGR_SPD_Msk = 0x1
	// Bit SPD.
	EMAC_NCFGR_SPD = 0x1
	// Position of FD field.
	EMAC_NCFGR_FD_Pos = 0x1
	// Bit mask of FD field.
	EMAC_NCFGR_FD_Msk = 0x2
	// Bit FD.
	EMAC_NCFGR_FD = 0x2
	// Position of JFRAME field.
	EMAC_NCFGR_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	EMAC_NCFGR_JFRAME_Msk = 0x8
	// Bit JFRAME.
	EMAC_NCFGR_JFRAME = 0x8
	// Position of CAF field.
	EMAC_NCFGR_CAF_Pos = 0x4
	// Bit mask of CAF field.
	EMAC_NCFGR_CAF_Msk = 0x10
	// Bit CAF.
	EMAC_NCFGR_CAF = 0x10
	// Position of NBC field.
	EMAC_NCFGR_NBC_Pos = 0x5
	// Bit mask of NBC field.
	EMAC_NCFGR_NBC_Msk = 0x20
	// Bit NBC.
	EMAC_NCFGR_NBC = 0x20
	// Position of MTI field.
	EMAC_NCFGR_MTI_Pos = 0x6
	// Bit mask of MTI field.
	EMAC_NCFGR_MTI_Msk = 0x40
	// Bit MTI.
	EMAC_NCFGR_MTI = 0x40
	// Position of UNI field.
	EMAC_NCFGR_UNI_Pos = 0x7
	// Bit mask of UNI field.
	EMAC_NCFGR_UNI_Msk = 0x80
	// Bit UNI.
	EMAC_NCFGR_UNI = 0x80
	// Position of BIG field.
	EMAC_NCFGR_BIG_Pos = 0x8
	// Bit mask of BIG field.
	EMAC_NCFGR_BIG_Msk = 0x100
	// Bit BIG.
	EMAC_NCFGR_BIG = 0x100
	// Position of CLK field.
	EMAC_NCFGR_CLK_Pos = 0xa
	// Bit mask of CLK field.
	EMAC_NCFGR_CLK_Msk = 0xc00
	// MCK divided by 8 (MCK up to 20 MHz).
	EMAC_NCFGR_CLK_MCK_8 = 0x0
	// MCK divided by 16 (MCK up to 40 MHz).
	EMAC_NCFGR_CLK_MCK_16 = 0x1
	// MCK divided by 32 (MCK up to 80 MHz).
	EMAC_NCFGR_CLK_MCK_32 = 0x2
	// MCK divided by 64 (MCK up to 160 MHz).
	EMAC_NCFGR_CLK_MCK_64 = 0x3
	// Position of RTY field.
	EMAC_NCFGR_RTY_Pos = 0xc
	// Bit mask of RTY field.
	EMAC_NCFGR_RTY_Msk = 0x1000
	// Bit RTY.
	EMAC_NCFGR_RTY = 0x1000
	// Position of PAE field.
	EMAC_NCFGR_PAE_Pos = 0xd
	// Bit mask of PAE field.
	EMAC_NCFGR_PAE_Msk = 0x2000
	// Bit PAE.
	EMAC_NCFGR_PAE = 0x2000
	// Position of RBOF field.
	EMAC_NCFGR_RBOF_Pos = 0xe
	// Bit mask of RBOF field.
	EMAC_NCFGR_RBOF_Msk = 0xc000
	// No offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_0 = 0x0
	// One-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_1 = 0x1
	// Two-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_2 = 0x2
	// Three-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_3 = 0x3
	// Position of RLCE field.
	EMAC_NCFGR_RLCE_Pos = 0x10
	// Bit mask of RLCE field.
	EMAC_NCFGR_RLCE_Msk = 0x10000
	// Bit RLCE.
	EMAC_NCFGR_RLCE = 0x10000
	// Position of DRFCS field.
	EMAC_NCFGR_DRFCS_Pos = 0x11
	// Bit mask of DRFCS field.
	EMAC_NCFGR_DRFCS_Msk = 0x20000
	// Bit DRFCS.
	EMAC_NCFGR_DRFCS = 0x20000
	// Position of EFRHD field.
	EMAC_NCFGR_EFRHD_Pos = 0x12
	// Bit mask of EFRHD field.
	EMAC_NCFGR_EFRHD_Msk = 0x40000
	// Bit EFRHD.
	EMAC_NCFGR_EFRHD = 0x40000
	// Position of IRXFCS field.
	EMAC_NCFGR_IRXFCS_Pos = 0x13
	// Bit mask of IRXFCS field.
	EMAC_NCFGR_IRXFCS_Msk = 0x80000
	// Bit IRXFCS.
	EMAC_NCFGR_IRXFCS = 0x80000

	// NSR: Network Status Register
	// Position of MDIO field.
	EMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	EMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	EMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	EMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	EMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	EMAC_NSR_IDLE = 0x4

	// TSR: Transmit Status Register
	// Position of UBR field.
	EMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	EMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	EMAC_TSR_UBR = 0x1
	// Position of COL field.
	EMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	EMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	EMAC_TSR_COL = 0x2
	// Position of RLES field.
	EMAC_TSR_RLES_Pos = 0x2
	// Bit mask of RLES field.
	EMAC_TSR_RLES_Msk = 0x4
	// Bit RLES.
	EMAC_TSR_RLES = 0x4
	// Position of TGO field.
	EMAC_TSR_TGO_Pos = 0x3
	// Bit mask of TGO field.
	EMAC_TSR_TGO_Msk = 0x8
	// Bit TGO.
	EMAC_TSR_TGO = 0x8
	// Position of BEX field.
	EMAC_TSR_BEX_Pos = 0x4
	// Bit mask of BEX field.
	EMAC_TSR_BEX_Msk = 0x10
	// Bit BEX.
	EMAC_TSR_BEX = 0x10
	// Position of COMP field.
	EMAC_TSR_COMP_Pos = 0x5
	// Bit mask of COMP field.
	EMAC_TSR_COMP_Msk = 0x20
	// Bit COMP.
	EMAC_TSR_COMP = 0x20
	// Position of UND field.
	EMAC_TSR_UND_Pos = 0x6
	// Bit mask of UND field.
	EMAC_TSR_UND_Msk = 0x40
	// Bit UND.
	EMAC_TSR_UND = 0x40

	// RBQP: Receive Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_RBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_RBQP_ADDR_Msk = 0xfffffffc

	// TBQP: Transmit Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_TBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_TBQP_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	EMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	EMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	EMAC_RSR_BNA = 0x1
	// Position of REC field.
	EMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	EMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	EMAC_RSR_REC = 0x2
	// Position of OVR field.
	EMAC_RSR_OVR_Pos = 0x2
	// Bit mask of OVR field.
	EMAC_RSR_OVR_Msk = 0x4
	// Bit OVR.
	EMAC_RSR_OVR = 0x4

	// ISR: Interrupt Status Register
	// Position of MFD field.
	EMAC_ISR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_ISR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_ISR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_ISR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_ISR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_ISR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_ISR_TUND = 0x10
	// Position of RLEX field.
	EMAC_ISR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	EMAC_ISR_RLEX_Msk = 0x20
	// Bit RLEX.
	EMAC_ISR_RLEX = 0x20
	// Position of TXERR field.
	EMAC_ISR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_ISR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_ISR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_ISR_HRESP = 0x800
	// Position of PFRE field.
	EMAC_ISR_PFRE_Pos = 0xc
	// Bit mask of PFRE field.
	EMAC_ISR_PFRE_Msk = 0x1000
	// Bit PFRE.
	EMAC_ISR_PFRE = 0x1000
	// Position of PTZ field.
	EMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_ISR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_ISR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_ISR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_ISR_WOL = 0x4000

	// IER: Interrupt Enable Register
	// Position of MFD field.
	EMAC_IER_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IER_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IER_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IER_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IER_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IER_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IER_TUND = 0x10
	// Position of RLE field.
	EMAC_IER_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IER_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IER_RLE = 0x20
	// Position of TXERR field.
	EMAC_IER_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IER_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IER_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IER_HRESP = 0x800
	// Position of PFR field.
	EMAC_IER_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IER_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IER_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IER_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IER_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IER_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IER_WOL = 0x4000

	// IDR: Interrupt Disable Register
	// Position of MFD field.
	EMAC_IDR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IDR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IDR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IDR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IDR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IDR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IDR_TUND = 0x10
	// Position of RLE field.
	EMAC_IDR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IDR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IDR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IDR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IDR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IDR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IDR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IDR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IDR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IDR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IDR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IDR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IDR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IDR_WOL = 0x4000

	// IMR: Interrupt Mask Register
	// Position of MFD field.
	EMAC_IMR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IMR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IMR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IMR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IMR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IMR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IMR_TUND = 0x10
	// Position of RLE field.
	EMAC_IMR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IMR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IMR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IMR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IMR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IMR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IMR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IMR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IMR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IMR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IMR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IMR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IMR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IMR_WOL = 0x4000

	// MAN: Phy Maintenance Register
	// Position of DATA field.
	EMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	EMAC_MAN_DATA_Msk = 0xffff
	// Position of CODE field.
	EMAC_MAN_CODE_Pos = 0x10
	// Bit mask of CODE field.
	EMAC_MAN_CODE_Msk = 0x30000
	// Position of REGA field.
	EMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	EMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	EMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	EMAC_MAN_PHYA_Msk = 0xf800000
	// Position of RW field.
	EMAC_MAN_RW_Pos = 0x1c
	// Bit mask of RW field.
	EMAC_MAN_RW_Msk = 0x30000000
	// Position of SOF field.
	EMAC_MAN_SOF_Pos = 0x1e
	// Bit mask of SOF field.
	EMAC_MAN_SOF_Msk = 0xc0000000

	// PTR: Pause Time Register
	// Position of PTIME field.
	EMAC_PTR_PTIME_Pos = 0x0
	// Bit mask of PTIME field.
	EMAC_PTR_PTIME_Msk = 0xffff

	// PFR: Pause Frames Received Register
	// Position of FROK field.
	EMAC_PFR_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_PFR_FROK_Msk = 0xffff

	// FTO: Frames Transmitted Ok Register
	// Position of FTOK field.
	EMAC_FTO_FTOK_Pos = 0x0
	// Bit mask of FTOK field.
	EMAC_FTO_FTOK_Msk = 0xffffff

	// SCF: Single Collision Frames Register
	// Position of SCF field.
	EMAC_SCF_SCF_Pos = 0x0
	// Bit mask of SCF field.
	EMAC_SCF_SCF_Msk = 0xffff

	// MCF: Multiple Collision Frames Register
	// Position of MCF field.
	EMAC_MCF_MCF_Pos = 0x0
	// Bit mask of MCF field.
	EMAC_MCF_MCF_Msk = 0xffff

	// FRO: Frames Received Ok Register
	// Position of FROK field.
	EMAC_FRO_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_FRO_FROK_Msk = 0xffffff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCSE field.
	EMAC_FCSE_FCSE_Pos = 0x0
	// Bit mask of FCSE field.
	EMAC_FCSE_FCSE_Msk = 0xff

	// ALE: Alignment Errors Register
	// Position of ALE field.
	EMAC_ALE_ALE_Pos = 0x0
	// Bit mask of ALE field.
	EMAC_ALE_ALE_Msk = 0xff

	// DTF: Deferred Transmission Frames Register
	// Position of DTF field.
	EMAC_DTF_DTF_Pos = 0x0
	// Bit mask of DTF field.
	EMAC_DTF_DTF_Msk = 0xffff

	// LCOL: Late Collisions Register
	// Position of LCOL field.
	EMAC_LCOL_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	EMAC_LCOL_LCOL_Msk = 0xff

	// ECOL: Excessive Collisions Register
	// Position of EXCOL field.
	EMAC_ECOL_EXCOL_Pos = 0x0
	// Bit mask of EXCOL field.
	EMAC_ECOL_EXCOL_Msk = 0xff

	// TUND: Transmit Underrun Errors Register
	// Position of TUND field.
	EMAC_TUND_TUND_Pos = 0x0
	// Bit mask of TUND field.
	EMAC_TUND_TUND_Msk = 0xff

	// CSE: Carrier Sense Errors Register
	// Position of CSE field.
	EMAC_CSE_CSE_Pos = 0x0
	// Bit mask of CSE field.
	EMAC_CSE_CSE_Msk = 0xff

	// RRE: Receive Resource Errors Register
	// Position of RRE field.
	EMAC_RRE_RRE_Pos = 0x0
	// Bit mask of RRE field.
	EMAC_RRE_RRE_Msk = 0xffff

	// ROV: Receive Overrun Errors Register
	// Position of ROVR field.
	EMAC_ROV_ROVR_Pos = 0x0
	// Bit mask of ROVR field.
	EMAC_ROV_ROVR_Msk = 0xff

	// RSE: Receive Symbol Errors Register
	// Position of RSE field.
	EMAC_RSE_RSE_Pos = 0x0
	// Bit mask of RSE field.
	EMAC_RSE_RSE_Msk = 0xff

	// ELE: Excessive Length Errors Register
	// Position of EXL field.
	EMAC_ELE_EXL_Pos = 0x0
	// Bit mask of EXL field.
	EMAC_ELE_EXL_Msk = 0xff

	// RJA: Receive Jabbers Register
	// Position of RJB field.
	EMAC_RJA_RJB_Pos = 0x0
	// Bit mask of RJB field.
	EMAC_RJA_RJB_Msk = 0xff

	// USF: Undersize Frames Register
	// Position of USF field.
	EMAC_USF_USF_Pos = 0x0
	// Bit mask of USF field.
	EMAC_USF_USF_Msk = 0xff

	// STE: SQE Test Errors Register
	// Position of SQER field.
	EMAC_STE_SQER_Pos = 0x0
	// Bit mask of SQER field.
	EMAC_STE_SQER_Msk = 0xff

	// RLE: Received Length Field Mismatch Register
	// Position of RLFM field.
	EMAC_RLE_RLFM_Pos = 0x0
	// Bit mask of RLFM field.
	EMAC_RLE_RLFM_Msk = 0xff

	// HRB: Hash Register Bottom [31:0] Register
	// Position of ADDR field.
	EMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top [63:32] Register
	// Position of ADDR field.
	EMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRT_ADDR_Msk = 0xffffffff

	// SA1B: Specific Address 1 Bottom Register
	// Position of ADDR field.
	EMAC_SA1B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1B_ADDR_Msk = 0xffffffff

	// SA1T: Specific Address 1 Top Register
	// Position of ADDR field.
	EMAC_SA1T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1T_ADDR_Msk = 0xffff

	// SA2B: Specific Address 2 Bottom Register
	// Position of ADDR field.
	EMAC_SA2B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2B_ADDR_Msk = 0xffffffff

	// SA2T: Specific Address 2 Top Register
	// Position of ADDR field.
	EMAC_SA2T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2T_ADDR_Msk = 0xffff

	// SA3B: Specific Address 3 Bottom Register
	// Position of ADDR field.
	EMAC_SA3B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3B_ADDR_Msk = 0xffffffff

	// SA3T: Specific Address 3 Top Register
	// Position of ADDR field.
	EMAC_SA3T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3T_ADDR_Msk = 0xffff

	// SA4B: Specific Address 4 Bottom Register
	// Position of ADDR field.
	EMAC_SA4B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4B_ADDR_Msk = 0xffffffff

	// SA4T: Specific Address 4 Top Register
	// Position of ADDR field.
	EMAC_SA4T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4T_ADDR_Msk = 0xffff

	// TID: Type ID Checking Register
	// Position of TID field.
	EMAC_TID_TID_Pos = 0x0
	// Bit mask of TID field.
	EMAC_TID_TID_Msk = 0xffff

	// USRIO: User Input/Output Register
	// Position of RMII field.
	EMAC_USRIO_RMII_Pos = 0x0
	// Bit mask of RMII field.
	EMAC_USRIO_RMII_Msk = 0x1
	// Bit RMII.
	EMAC_USRIO_RMII = 0x1
	// Position of CLKEN field.
	EMAC_USRIO_CLKEN_Pos = 0x1
	// Bit mask of CLKEN field.
	EMAC_USRIO_CLKEN_Msk = 0x2
	// Bit CLKEN.
	EMAC_USRIO_CLKEN = 0x2

	// WOL: Wake on LAN Register
	// Position of IP field.
	EMAC_WOL_IP_Pos = 0x0
	// Bit mask of IP field.
	EMAC_WOL_IP_Msk = 0xffff
	// Position of MAG field.
	EMAC_WOL_MAG_Pos = 0x10
	// Bit mask of MAG field.
	EMAC_WOL_MAG_Msk = 0x10000
	// Bit MAG.
	EMAC_WOL_MAG = 0x10000
	// Position of ARP field.
	EMAC_WOL_ARP_Pos = 0x11
	// Bit mask of ARP field.
	EMAC_WOL_ARP_Msk = 0x20000
	// Bit ARP.
	EMAC_WOL_ARP = 0x20000
	// Position of SA1 field.
	EMAC_WOL_SA1_Pos = 0x12
	// Bit mask of SA1 field.
	EMAC_WOL_SA1_Msk = 0x40000
	// Bit SA1.
	EMAC_WOL_SA1 = 0x40000
	// Position of MTI field.
	EMAC_WOL_MTI_Pos = 0x13
	// Bit mask of MTI field.
	EMAC_WOL_MTI_Msk = 0x80000
	// Bit MTI.
	EMAC_WOL_MTI = 0x80000
)

// Constants for UDPHS: USB High Speed Device Port
const (
	// CTRL: UDPHS Control Register
	// Position of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Pos = 0x0
	// Bit mask of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Msk = 0x7f
	// Position of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Pos = 0x7
	// Bit mask of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Msk = 0x80
	// Bit FADDR_EN.
	UDPHS_CTRL_FADDR_EN = 0x80
	// Position of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Pos = 0x8
	// Bit mask of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Msk = 0x100
	// Bit EN_UDPHS.
	UDPHS_CTRL_EN_UDPHS = 0x100
	// Position of DETACH field.
	UDPHS_CTRL_DETACH_Pos = 0x9
	// Bit mask of DETACH field.
	UDPHS_CTRL_DETACH_Msk = 0x200
	// Bit DETACH.
	UDPHS_CTRL_DETACH = 0x200
	// Position of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Pos = 0xa
	// Bit mask of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Msk = 0x400
	// Bit REWAKEUP.
	UDPHS_CTRL_REWAKEUP = 0x400
	// Position of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Pos = 0xb
	// Bit mask of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Msk = 0x800
	// Bit PULLD_DIS.
	UDPHS_CTRL_PULLD_DIS = 0x800

	// FNUM: UDPHS Frame Number Register
	// Position of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Pos = 0x0
	// Bit mask of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Msk = 0x7
	// Position of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Pos = 0x3
	// Bit mask of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Msk = 0x3ff8
	// Position of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Pos = 0x1f
	// Bit mask of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Msk = 0x80000000
	// Bit FNUM_ERR.
	UDPHS_FNUM_FNUM_ERR = 0x80000000

	// IEN: UDPHS Interrupt Enable Register
	// Position of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_IEN_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_IEN_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_IEN_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_IEN_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_IEN_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_IEN_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_IEN_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_IEN_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_IEN_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_IEN_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_IEN_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_IEN_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_IEN_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_IEN_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_IEN_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_IEN_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_IEN_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_IEN_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_IEN_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_IEN_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_IEN_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_IEN_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_IEN_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_IEN_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_IEN_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_IEN_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_IEN_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_IEN_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_IEN_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_IEN_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_IEN_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_IEN_EPT_6 = 0x4000
	// Position of EPT_7 field.
	UDPHS_IEN_EPT_7_Pos = 0xf
	// Bit mask of EPT_7 field.
	UDPHS_IEN_EPT_7_Msk = 0x8000
	// Bit EPT_7.
	UDPHS_IEN_EPT_7 = 0x8000
	// Position of EPT_8 field.
	UDPHS_IEN_EPT_8_Pos = 0x10
	// Bit mask of EPT_8 field.
	UDPHS_IEN_EPT_8_Msk = 0x10000
	// Bit EPT_8.
	UDPHS_IEN_EPT_8 = 0x10000
	// Position of EPT_9 field.
	UDPHS_IEN_EPT_9_Pos = 0x11
	// Bit mask of EPT_9 field.
	UDPHS_IEN_EPT_9_Msk = 0x20000
	// Bit EPT_9.
	UDPHS_IEN_EPT_9 = 0x20000
	// Position of EPT_10 field.
	UDPHS_IEN_EPT_10_Pos = 0x12
	// Bit mask of EPT_10 field.
	UDPHS_IEN_EPT_10_Msk = 0x40000
	// Bit EPT_10.
	UDPHS_IEN_EPT_10 = 0x40000
	// Position of EPT_11 field.
	UDPHS_IEN_EPT_11_Pos = 0x13
	// Bit mask of EPT_11 field.
	UDPHS_IEN_EPT_11_Msk = 0x80000
	// Bit EPT_11.
	UDPHS_IEN_EPT_11 = 0x80000
	// Position of EPT_12 field.
	UDPHS_IEN_EPT_12_Pos = 0x14
	// Bit mask of EPT_12 field.
	UDPHS_IEN_EPT_12_Msk = 0x100000
	// Bit EPT_12.
	UDPHS_IEN_EPT_12 = 0x100000
	// Position of EPT_13 field.
	UDPHS_IEN_EPT_13_Pos = 0x15
	// Bit mask of EPT_13 field.
	UDPHS_IEN_EPT_13_Msk = 0x200000
	// Bit EPT_13.
	UDPHS_IEN_EPT_13 = 0x200000
	// Position of EPT_14 field.
	UDPHS_IEN_EPT_14_Pos = 0x16
	// Bit mask of EPT_14 field.
	UDPHS_IEN_EPT_14_Msk = 0x400000
	// Bit EPT_14.
	UDPHS_IEN_EPT_14 = 0x400000
	// Position of EPT_15 field.
	UDPHS_IEN_EPT_15_Pos = 0x17
	// Bit mask of EPT_15 field.
	UDPHS_IEN_EPT_15_Msk = 0x800000
	// Bit EPT_15.
	UDPHS_IEN_EPT_15 = 0x800000
	// Position of DMA_1 field.
	UDPHS_IEN_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_IEN_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_IEN_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_IEN_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_IEN_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_IEN_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_IEN_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_IEN_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_IEN_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_IEN_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_IEN_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_IEN_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_IEN_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_IEN_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_IEN_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_IEN_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_IEN_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_IEN_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	UDPHS_IEN_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	UDPHS_IEN_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	UDPHS_IEN_DMA_7 = 0x80000000

	// INTSTA: UDPHS Interrupt Status Register
	// Position of SPEED field.
	UDPHS_INTSTA_SPEED_Pos = 0x0
	// Bit mask of SPEED field.
	UDPHS_INTSTA_SPEED_Msk = 0x1
	// Bit SPEED.
	UDPHS_INTSTA_SPEED = 0x1
	// Position of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_INTSTA_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_INTSTA_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_INTSTA_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_INTSTA_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_INTSTA_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_INTSTA_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_INTSTA_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_INTSTA_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_INTSTA_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_INTSTA_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_INTSTA_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_INTSTA_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_INTSTA_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_INTSTA_EPT_6 = 0x4000
	// Position of EPT_7 field.
	UDPHS_INTSTA_EPT_7_Pos = 0xf
	// Bit mask of EPT_7 field.
	UDPHS_INTSTA_EPT_7_Msk = 0x8000
	// Bit EPT_7.
	UDPHS_INTSTA_EPT_7 = 0x8000
	// Position of EPT_8 field.
	UDPHS_INTSTA_EPT_8_Pos = 0x10
	// Bit mask of EPT_8 field.
	UDPHS_INTSTA_EPT_8_Msk = 0x10000
	// Bit EPT_8.
	UDPHS_INTSTA_EPT_8 = 0x10000
	// Position of EPT_9 field.
	UDPHS_INTSTA_EPT_9_Pos = 0x11
	// Bit mask of EPT_9 field.
	UDPHS_INTSTA_EPT_9_Msk = 0x20000
	// Bit EPT_9.
	UDPHS_INTSTA_EPT_9 = 0x20000
	// Position of EPT_10 field.
	UDPHS_INTSTA_EPT_10_Pos = 0x12
	// Bit mask of EPT_10 field.
	UDPHS_INTSTA_EPT_10_Msk = 0x40000
	// Bit EPT_10.
	UDPHS_INTSTA_EPT_10 = 0x40000
	// Position of EPT_11 field.
	UDPHS_INTSTA_EPT_11_Pos = 0x13
	// Bit mask of EPT_11 field.
	UDPHS_INTSTA_EPT_11_Msk = 0x80000
	// Bit EPT_11.
	UDPHS_INTSTA_EPT_11 = 0x80000
	// Position of EPT_12 field.
	UDPHS_INTSTA_EPT_12_Pos = 0x14
	// Bit mask of EPT_12 field.
	UDPHS_INTSTA_EPT_12_Msk = 0x100000
	// Bit EPT_12.
	UDPHS_INTSTA_EPT_12 = 0x100000
	// Position of EPT_13 field.
	UDPHS_INTSTA_EPT_13_Pos = 0x15
	// Bit mask of EPT_13 field.
	UDPHS_INTSTA_EPT_13_Msk = 0x200000
	// Bit EPT_13.
	UDPHS_INTSTA_EPT_13 = 0x200000
	// Position of EPT_14 field.
	UDPHS_INTSTA_EPT_14_Pos = 0x16
	// Bit mask of EPT_14 field.
	UDPHS_INTSTA_EPT_14_Msk = 0x400000
	// Bit EPT_14.
	UDPHS_INTSTA_EPT_14 = 0x400000
	// Position of EPT_15 field.
	UDPHS_INTSTA_EPT_15_Pos = 0x17
	// Bit mask of EPT_15 field.
	UDPHS_INTSTA_EPT_15_Msk = 0x800000
	// Bit EPT_15.
	UDPHS_INTSTA_EPT_15 = 0x800000
	// Position of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_INTSTA_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_INTSTA_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_INTSTA_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_INTSTA_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_INTSTA_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_INTSTA_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	UDPHS_INTSTA_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	UDPHS_INTSTA_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	UDPHS_INTSTA_DMA_7 = 0x80000000

	// CLRINT: UDPHS Clear Interrupt Register
	// Position of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_CLRINT_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_CLRINT_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_CLRINT_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_CLRINT_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_CLRINT_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_CLRINT_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_CLRINT_UPSTR_RES = 0x80

	// EPTRST: UDPHS Endpoints Reset Register
	// Position of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Pos = 0x0
	// Bit mask of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Msk = 0x1
	// Bit EPT_0.
	UDPHS_EPTRST_EPT_0 = 0x1
	// Position of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Pos = 0x1
	// Bit mask of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Msk = 0x2
	// Bit EPT_1.
	UDPHS_EPTRST_EPT_1 = 0x2
	// Position of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Pos = 0x2
	// Bit mask of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Msk = 0x4
	// Bit EPT_2.
	UDPHS_EPTRST_EPT_2 = 0x4
	// Position of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Pos = 0x3
	// Bit mask of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Msk = 0x8
	// Bit EPT_3.
	UDPHS_EPTRST_EPT_3 = 0x8
	// Position of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Pos = 0x4
	// Bit mask of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Msk = 0x10
	// Bit EPT_4.
	UDPHS_EPTRST_EPT_4 = 0x10
	// Position of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Pos = 0x5
	// Bit mask of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Msk = 0x20
	// Bit EPT_5.
	UDPHS_EPTRST_EPT_5 = 0x20
	// Position of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Pos = 0x6
	// Bit mask of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Msk = 0x40
	// Bit EPT_6.
	UDPHS_EPTRST_EPT_6 = 0x40
	// Position of EPT_7 field.
	UDPHS_EPTRST_EPT_7_Pos = 0x7
	// Bit mask of EPT_7 field.
	UDPHS_EPTRST_EPT_7_Msk = 0x80
	// Bit EPT_7.
	UDPHS_EPTRST_EPT_7 = 0x80
	// Position of EPT_8 field.
	UDPHS_EPTRST_EPT_8_Pos = 0x8
	// Bit mask of EPT_8 field.
	UDPHS_EPTRST_EPT_8_Msk = 0x100
	// Bit EPT_8.
	UDPHS_EPTRST_EPT_8 = 0x100
	// Position of EPT_9 field.
	UDPHS_EPTRST_EPT_9_Pos = 0x9
	// Bit mask of EPT_9 field.
	UDPHS_EPTRST_EPT_9_Msk = 0x200
	// Bit EPT_9.
	UDPHS_EPTRST_EPT_9 = 0x200
	// Position of EPT_10 field.
	UDPHS_EPTRST_EPT_10_Pos = 0xa
	// Bit mask of EPT_10 field.
	UDPHS_EPTRST_EPT_10_Msk = 0x400
	// Bit EPT_10.
	UDPHS_EPTRST_EPT_10 = 0x400
	// Position of EPT_11 field.
	UDPHS_EPTRST_EPT_11_Pos = 0xb
	// Bit mask of EPT_11 field.
	UDPHS_EPTRST_EPT_11_Msk = 0x800
	// Bit EPT_11.
	UDPHS_EPTRST_EPT_11 = 0x800
	// Position of EPT_12 field.
	UDPHS_EPTRST_EPT_12_Pos = 0xc
	// Bit mask of EPT_12 field.
	UDPHS_EPTRST_EPT_12_Msk = 0x1000
	// Bit EPT_12.
	UDPHS_EPTRST_EPT_12 = 0x1000
	// Position of EPT_13 field.
	UDPHS_EPTRST_EPT_13_Pos = 0xd
	// Bit mask of EPT_13 field.
	UDPHS_EPTRST_EPT_13_Msk = 0x2000
	// Bit EPT_13.
	UDPHS_EPTRST_EPT_13 = 0x2000
	// Position of EPT_14 field.
	UDPHS_EPTRST_EPT_14_Pos = 0xe
	// Bit mask of EPT_14 field.
	UDPHS_EPTRST_EPT_14_Msk = 0x4000
	// Bit EPT_14.
	UDPHS_EPTRST_EPT_14 = 0x4000
	// Position of EPT_15 field.
	UDPHS_EPTRST_EPT_15_Pos = 0xf
	// Bit mask of EPT_15 field.
	UDPHS_EPTRST_EPT_15_Msk = 0x8000
	// Bit EPT_15.
	UDPHS_EPTRST_EPT_15 = 0x8000

	// TST: UDPHS Test Register
	// Position of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Pos = 0x0
	// Bit mask of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Msk = 0x3
	// Normal Mode: The macro is in Full Speed mode, ready to make a High Speed identification, if the host supports it and then to automatically switch to High Speed mode
	UDPHS_TST_SPEED_CFG_NORMAL = 0x0
	// Force High Speed: Set this value to force the hardware to work in High Speed mode. Only for debug or test purpose.
	UDPHS_TST_SPEED_CFG_HIGH_SPEED = 0x2
	// Force Full Speed: Set this value to force the hardware to work only in Full Speed mode. In this configuration, the macro will not respond to a High Speed reset handshake.
	UDPHS_TST_SPEED_CFG_FULL_SPEED = 0x3
	// Position of TST_J field.
	UDPHS_TST_TST_J_Pos = 0x2
	// Bit mask of TST_J field.
	UDPHS_TST_TST_J_Msk = 0x4
	// Bit TST_J.
	UDPHS_TST_TST_J = 0x4
	// Position of TST_K field.
	UDPHS_TST_TST_K_Pos = 0x3
	// Bit mask of TST_K field.
	UDPHS_TST_TST_K_Msk = 0x8
	// Bit TST_K.
	UDPHS_TST_TST_K = 0x8
	// Position of TST_PKT field.
	UDPHS_TST_TST_PKT_Pos = 0x4
	// Bit mask of TST_PKT field.
	UDPHS_TST_TST_PKT_Msk = 0x10
	// Bit TST_PKT.
	UDPHS_TST_TST_PKT = 0x10
	// Position of OPMODE2 field.
	UDPHS_TST_OPMODE2_Pos = 0x5
	// Bit mask of OPMODE2 field.
	UDPHS_TST_OPMODE2_Msk = 0x20
	// Bit OPMODE2.
	UDPHS_TST_OPMODE2 = 0x20

	// EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG0_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG0_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG0_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG0_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG0_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG0_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG0_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG0_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG0_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG0_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG0_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG0_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG0_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG0_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG0_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG0_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG0_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG0_EPT_MAPD = 0x80000000

	// EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_SHRT_PCKT = 0x80000000

	// EPTCTLENB0_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_SHRT_PCKT = 0x80000000

	// EPTCTL0_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA0_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA0_TXRDY = 0x800

	// EPTSETSTA0_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA0_NAK_OUT = 0x8000

	// EPTCLRSTA0_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA0_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_SHRT_PCKT = 0x80000000

	// EPTSTA0_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG1_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG1_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG1_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG1_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG1_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG1_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG1_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG1_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG1_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG1_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG1_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG1_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG1_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG1_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG1_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG1_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG1_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG1_EPT_MAPD = 0x80000000

	// EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_SHRT_PCKT = 0x80000000

	// EPTCTLENB1_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_SHRT_PCKT = 0x80000000

	// EPTCTL1_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA1_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA1_TXRDY = 0x800

	// EPTSETSTA1_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA1_NAK_OUT = 0x8000

	// EPTCLRSTA1_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA1_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_SHRT_PCKT = 0x80000000

	// EPTSTA1_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG2_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG2_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG2_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG2_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG2_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG2_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG2_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG2_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG2_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG2_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG2_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG2_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG2_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG2_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG2_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG2_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG2_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG2_EPT_MAPD = 0x80000000

	// EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_SHRT_PCKT = 0x80000000

	// EPTCTLENB2_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_SHRT_PCKT = 0x80000000

	// EPTCTL2_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA2_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA2_TXRDY = 0x800

	// EPTSETSTA2_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA2_NAK_OUT = 0x8000

	// EPTCLRSTA2_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA2_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_SHRT_PCKT = 0x80000000

	// EPTSTA2_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG3_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG3_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG3_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG3_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG3_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG3_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG3_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG3_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG3_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG3_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG3_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG3_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG3_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG3_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG3_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG3_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG3_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG3_EPT_MAPD = 0x80000000

	// EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_SHRT_PCKT = 0x80000000

	// EPTCTLENB3_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_SHRT_PCKT = 0x80000000

	// EPTCTL3_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA3_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA3_TXRDY = 0x800

	// EPTSETSTA3_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA3_NAK_OUT = 0x8000

	// EPTCLRSTA3_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA3_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_SHRT_PCKT = 0x80000000

	// EPTSTA3_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG4_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG4_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG4_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG4_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG4_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG4_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG4_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG4_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG4_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG4_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG4_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG4_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG4_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG4_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG4_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG4_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG4_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG4_EPT_MAPD = 0x80000000

	// EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_SHRT_PCKT = 0x80000000

	// EPTCTLENB4_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_SHRT_PCKT = 0x80000000

	// EPTCTL4_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA4_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA4_TXRDY = 0x800

	// EPTSETSTA4_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA4_NAK_OUT = 0x8000

	// EPTCLRSTA4_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA4_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_SHRT_PCKT = 0x80000000

	// EPTSTA4_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG5_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG5_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG5_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG5_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG5_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG5_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG5_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG5_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG5_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG5_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG5_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG5_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG5_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG5_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG5_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG5_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG5_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG5_EPT_MAPD = 0x80000000

	// EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_SHRT_PCKT = 0x80000000

	// EPTCTLENB5_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_SHRT_PCKT = 0x80000000

	// EPTCTL5_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA5_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA5_TXRDY = 0x800

	// EPTSETSTA5_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA5_NAK_OUT = 0x8000

	// EPTCLRSTA5_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA5_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_SHRT_PCKT = 0x80000000

	// EPTSTA5_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG6_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG6_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG6_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG6_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG6_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG6_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG6_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG6_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG6_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG6_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG6_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG6_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG6_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG6_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG6_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG6_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG6_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG6_EPT_MAPD = 0x80000000

	// EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_SHRT_PCKT = 0x80000000

	// EPTCTLENB6_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_SHRT_PCKT = 0x80000000

	// EPTCTL6_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA6_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA6_TXRDY = 0x800

	// EPTSETSTA6_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA6_NAK_OUT = 0x8000

	// EPTCLRSTA6_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA6_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_SHRT_PCKT = 0x80000000

	// EPTSTA6_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG7: UDPHS Endpoint Configuration Register (endpoint = 7)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG7_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG7_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG7_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG7_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG7_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG7_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG7_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG7_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG7_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG7_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG7_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG7_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG7_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG7_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG7_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG7_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG7_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG7_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG7_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG7_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG7_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG7_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG7_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG7_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG7_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG7_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG7_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG7_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG7_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG7_EPT_MAPD = 0x80000000

	// EPTCTLENB7: UDPHS Endpoint Control Enable Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB7_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB7_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB7_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB7_SHRT_PCKT = 0x80000000

	// EPTCTLENB7_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS7: UDPHS Endpoint Control Disable Register (endpoint = 7)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS7_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS7_SHRT_PCKT = 0x80000000

	// EPTCTLDIS7_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 7)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL7: UDPHS Endpoint Control Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL7_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL7_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL7_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL7_SHRT_PCKT = 0x80000000

	// EPTCTL7_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA7: UDPHS Endpoint Set Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA7_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA7_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA7_TXRDY = 0x800

	// EPTSETSTA7_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 7)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA7: UDPHS Endpoint Clear Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA7_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA7_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA7_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA7_NAK_OUT = 0x8000

	// EPTCLRSTA7_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 7)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA7: UDPHS Endpoint Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA7_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA7_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA7_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA7_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA7_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA7_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA7_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA7_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA7_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA7_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA7_SHRT_PCKT = 0x80000000

	// EPTSTA7_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 7)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA7_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA7_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA7_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA7_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG8: UDPHS Endpoint Configuration Register (endpoint = 8)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG8_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG8_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG8_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG8_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG8_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG8_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG8_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG8_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG8_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG8_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG8_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG8_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG8_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG8_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG8_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG8_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG8_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG8_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG8_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG8_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG8_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG8_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG8_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG8_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG8_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG8_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG8_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG8_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG8_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG8_EPT_MAPD = 0x80000000

	// EPTCTLENB8: UDPHS Endpoint Control Enable Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB8_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB8_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB8_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB8_SHRT_PCKT = 0x80000000

	// EPTCTLENB8_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS8: UDPHS Endpoint Control Disable Register (endpoint = 8)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS8_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS8_SHRT_PCKT = 0x80000000

	// EPTCTLDIS8_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 8)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL8: UDPHS Endpoint Control Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL8_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL8_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL8_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL8_SHRT_PCKT = 0x80000000

	// EPTCTL8_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA8: UDPHS Endpoint Set Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA8_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA8_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA8_TXRDY = 0x800

	// EPTSETSTA8_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 8)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA8: UDPHS Endpoint Clear Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA8_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA8_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA8_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA8_NAK_OUT = 0x8000

	// EPTCLRSTA8_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 8)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA8: UDPHS Endpoint Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA8_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA8_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA8_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA8_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA8_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA8_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA8_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA8_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA8_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA8_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA8_SHRT_PCKT = 0x80000000

	// EPTSTA8_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 8)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA8_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA8_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA8_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA8_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG9: UDPHS Endpoint Configuration Register (endpoint = 9)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG9_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG9_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG9_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG9_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG9_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG9_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG9_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG9_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG9_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG9_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG9_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG9_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG9_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG9_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG9_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG9_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG9_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG9_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG9_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG9_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG9_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG9_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG9_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG9_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG9_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG9_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG9_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG9_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG9_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG9_EPT_MAPD = 0x80000000

	// EPTCTLENB9: UDPHS Endpoint Control Enable Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB9_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB9_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB9_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB9_SHRT_PCKT = 0x80000000

	// EPTCTLENB9_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS9: UDPHS Endpoint Control Disable Register (endpoint = 9)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS9_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS9_SHRT_PCKT = 0x80000000

	// EPTCTLDIS9_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 9)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL9: UDPHS Endpoint Control Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL9_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL9_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL9_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL9_SHRT_PCKT = 0x80000000

	// EPTCTL9_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA9: UDPHS Endpoint Set Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA9_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA9_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA9_TXRDY = 0x800

	// EPTSETSTA9_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 9)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA9: UDPHS Endpoint Clear Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA9_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA9_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA9_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA9_NAK_OUT = 0x8000

	// EPTCLRSTA9_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 9)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA9: UDPHS Endpoint Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA9_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA9_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA9_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA9_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA9_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA9_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA9_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA9_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA9_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA9_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA9_SHRT_PCKT = 0x80000000

	// EPTSTA9_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 9)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA9_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA9_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA9_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA9_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG10: UDPHS Endpoint Configuration Register (endpoint = 10)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG10_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG10_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG10_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG10_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG10_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG10_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG10_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG10_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG10_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG10_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG10_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG10_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG10_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG10_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG10_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG10_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG10_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG10_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG10_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG10_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG10_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG10_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG10_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG10_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG10_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG10_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG10_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG10_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG10_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG10_EPT_MAPD = 0x80000000

	// EPTCTLENB10: UDPHS Endpoint Control Enable Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB10_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB10_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB10_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB10_SHRT_PCKT = 0x80000000

	// EPTCTLENB10_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS10: UDPHS Endpoint Control Disable Register (endpoint = 10)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS10_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS10_SHRT_PCKT = 0x80000000

	// EPTCTLDIS10_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 10)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL10: UDPHS Endpoint Control Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL10_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL10_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL10_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL10_SHRT_PCKT = 0x80000000

	// EPTCTL10_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA10: UDPHS Endpoint Set Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA10_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA10_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA10_TXRDY = 0x800

	// EPTSETSTA10_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 10)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA10: UDPHS Endpoint Clear Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA10_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA10_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA10_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA10_NAK_OUT = 0x8000

	// EPTCLRSTA10_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 10)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA10: UDPHS Endpoint Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA10_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA10_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA10_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA10_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA10_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA10_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA10_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA10_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA10_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA10_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA10_SHRT_PCKT = 0x80000000

	// EPTSTA10_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 10)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA10_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA10_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA10_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA10_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG11: UDPHS Endpoint Configuration Register (endpoint = 11)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG11_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG11_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG11_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG11_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG11_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG11_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG11_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG11_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG11_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG11_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG11_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG11_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG11_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG11_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG11_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG11_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG11_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG11_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG11_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG11_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG11_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG11_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG11_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG11_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG11_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG11_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG11_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG11_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG11_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG11_EPT_MAPD = 0x80000000

	// EPTCTLENB11: UDPHS Endpoint Control Enable Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB11_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB11_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB11_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB11_SHRT_PCKT = 0x80000000

	// EPTCTLENB11_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS11: UDPHS Endpoint Control Disable Register (endpoint = 11)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS11_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS11_SHRT_PCKT = 0x80000000

	// EPTCTLDIS11_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 11)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL11: UDPHS Endpoint Control Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL11_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL11_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL11_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL11_SHRT_PCKT = 0x80000000

	// EPTCTL11_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA11: UDPHS Endpoint Set Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA11_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA11_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA11_TXRDY = 0x800

	// EPTSETSTA11_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 11)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA11: UDPHS Endpoint Clear Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA11_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA11_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA11_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA11_NAK_OUT = 0x8000

	// EPTCLRSTA11_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 11)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA11: UDPHS Endpoint Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA11_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA11_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA11_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA11_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA11_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA11_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA11_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA11_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA11_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA11_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA11_SHRT_PCKT = 0x80000000

	// EPTSTA11_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 11)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA11_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA11_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA11_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA11_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG12: UDPHS Endpoint Configuration Register (endpoint = 12)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG12_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG12_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG12_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG12_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG12_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG12_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG12_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG12_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG12_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG12_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG12_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG12_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG12_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG12_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG12_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG12_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG12_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG12_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG12_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG12_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG12_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG12_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG12_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG12_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG12_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG12_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG12_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG12_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG12_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG12_EPT_MAPD = 0x80000000

	// EPTCTLENB12: UDPHS Endpoint Control Enable Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB12_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB12_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB12_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB12_SHRT_PCKT = 0x80000000

	// EPTCTLENB12_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS12: UDPHS Endpoint Control Disable Register (endpoint = 12)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS12_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS12_SHRT_PCKT = 0x80000000

	// EPTCTLDIS12_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 12)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL12: UDPHS Endpoint Control Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL12_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL12_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL12_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL12_SHRT_PCKT = 0x80000000

	// EPTCTL12_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA12: UDPHS Endpoint Set Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA12_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA12_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA12_TXRDY = 0x800

	// EPTSETSTA12_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 12)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA12: UDPHS Endpoint Clear Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA12_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA12_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA12_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA12_NAK_OUT = 0x8000

	// EPTCLRSTA12_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 12)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA12: UDPHS Endpoint Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA12_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA12_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA12_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA12_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA12_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA12_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA12_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA12_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA12_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA12_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA12_SHRT_PCKT = 0x80000000

	// EPTSTA12_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 12)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA12_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA12_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA12_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA12_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG13: UDPHS Endpoint Configuration Register (endpoint = 13)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG13_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG13_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG13_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG13_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG13_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG13_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG13_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG13_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG13_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG13_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG13_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG13_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG13_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG13_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG13_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG13_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG13_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG13_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG13_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG13_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG13_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG13_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG13_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG13_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG13_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG13_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG13_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG13_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG13_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG13_EPT_MAPD = 0x80000000

	// EPTCTLENB13: UDPHS Endpoint Control Enable Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB13_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB13_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB13_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB13_SHRT_PCKT = 0x80000000

	// EPTCTLENB13_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS13: UDPHS Endpoint Control Disable Register (endpoint = 13)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS13_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS13_SHRT_PCKT = 0x80000000

	// EPTCTLDIS13_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 13)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL13: UDPHS Endpoint Control Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL13_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL13_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL13_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL13_SHRT_PCKT = 0x80000000

	// EPTCTL13_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA13: UDPHS Endpoint Set Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA13_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA13_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA13_TXRDY = 0x800

	// EPTSETSTA13_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 13)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA13: UDPHS Endpoint Clear Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA13_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA13_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA13_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA13_NAK_OUT = 0x8000

	// EPTCLRSTA13_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 13)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA13: UDPHS Endpoint Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA13_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA13_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA13_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA13_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA13_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA13_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA13_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA13_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA13_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA13_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA13_SHRT_PCKT = 0x80000000

	// EPTSTA13_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 13)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA13_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA13_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA13_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA13_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG14: UDPHS Endpoint Configuration Register (endpoint = 14)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG14_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG14_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG14_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG14_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG14_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG14_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG14_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG14_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG14_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG14_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG14_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG14_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG14_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG14_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG14_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG14_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG14_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG14_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG14_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG14_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG14_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG14_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG14_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG14_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG14_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG14_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG14_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG14_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG14_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG14_EPT_MAPD = 0x80000000

	// EPTCTLENB14: UDPHS Endpoint Control Enable Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB14_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB14_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB14_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB14_SHRT_PCKT = 0x80000000

	// EPTCTLENB14_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS14: UDPHS Endpoint Control Disable Register (endpoint = 14)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS14_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS14_SHRT_PCKT = 0x80000000

	// EPTCTLDIS14_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 14)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL14: UDPHS Endpoint Control Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL14_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL14_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL14_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL14_SHRT_PCKT = 0x80000000

	// EPTCTL14_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA14: UDPHS Endpoint Set Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA14_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA14_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA14_TXRDY = 0x800

	// EPTSETSTA14_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 14)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA14: UDPHS Endpoint Clear Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA14_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA14_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA14_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA14_NAK_OUT = 0x8000

	// EPTCLRSTA14_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 14)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA14: UDPHS Endpoint Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA14_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA14_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA14_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA14_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA14_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA14_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA14_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA14_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA14_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA14_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA14_SHRT_PCKT = 0x80000000

	// EPTSTA14_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 14)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA14_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA14_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA14_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA14_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG15: UDPHS Endpoint Configuration Register (endpoint = 15)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG15_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG15_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG15_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG15_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG15_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG15_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG15_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG15_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG15_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG15_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG15_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG15_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG15_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG15_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG15_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG15_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG15_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG15_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG15_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG15_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG15_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG15_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG15_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG15_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG15_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG15_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG15_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG15_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG15_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG15_EPT_MAPD = 0x80000000

	// EPTCTLENB15: UDPHS Endpoint Control Enable Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB15_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB15_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB15_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB15_SHRT_PCKT = 0x80000000

	// EPTCTLENB15_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS15: UDPHS Endpoint Control Disable Register (endpoint = 15)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS15_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS15_SHRT_PCKT = 0x80000000

	// EPTCTLDIS15_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 15)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL15: UDPHS Endpoint Control Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL15_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL15_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL15_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL15_SHRT_PCKT = 0x80000000

	// EPTCTL15_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA15: UDPHS Endpoint Set Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA15_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA15_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA15_TXRDY = 0x800

	// EPTSETSTA15_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 15)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA15: UDPHS Endpoint Clear Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA15_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA15_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA15_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA15_NAK_OUT = 0x8000

	// EPTCLRSTA15_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 15)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA15: UDPHS Endpoint Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA15_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA15_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA15_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA15_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA15_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA15_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA15_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA15_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA15_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA15_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA15_SHRT_PCKT = 0x80000000

	// EPTSTA15_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 15)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA15_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA15_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA15_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA15_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT = 0x80000000

	// DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL0_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL0_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL0_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL0_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL0_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL0_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL0_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL0_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS0_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS0_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS0_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS0_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS0_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL1_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL1_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL1_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL1_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL1_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL1_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL1_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL1_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS1_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS1_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS1_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS1_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS1_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL2_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL2_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL2_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL2_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL2_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL2_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL2_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL2_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS2_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS2_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS2_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS2_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS2_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL3_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL3_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL3_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL3_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL3_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL3_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL3_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL3_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS3_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS3_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS3_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS3_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS3_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL4_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL4_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL4_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL4_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL4_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL4_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL4_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL4_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS4_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS4_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS4_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS4_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS4_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL5_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL5_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL5_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL5_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL5_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL5_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL5_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL5_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS5_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS5_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS5_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS5_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS5_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC6: UDPHS DMA Next Descriptor Address Register (channel = 6)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC6_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC6_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS6: UDPHS DMA Channel Address Register (channel = 6)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS6_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS6_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL6: UDPHS DMA Channel Control Register (channel = 6)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL6_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL6_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL6_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL6_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL6_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL6_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL6_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL6_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL6_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL6_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL6_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL6_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL6_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL6_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL6_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL6_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL6_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL6_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL6_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL6_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL6_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL6_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL6_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL6_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL6_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL6_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS6: UDPHS DMA Channel Status Register (channel = 6)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS6_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS6_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS6_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS6_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS6_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS6_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS6_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS6_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS6_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS6_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS6_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS6_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS6_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS6_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS6_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS6_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS6_BUFF_COUNT_Msk = 0xffff0000
)

// Constants for TRNG: True Random Number Generator
const (
	// CR: Control Register
	// Position of ENABLE field.
	TRNG_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TRNG_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	TRNG_CR_ENABLE = 0x1
	// Position of KEY field.
	TRNG_CR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TRNG_CR_KEY_Msk = 0xffffff00

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	TRNG_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IER_DATRDY = 0x1

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	TRNG_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IDR_DATRDY = 0x1

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	TRNG_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IMR_DATRDY = 0x1

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	TRNG_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_ISR_DATRDY = 0x1

	// ODATA: Output Data Register
	// Position of ODATA field.
	TRNG_ODATA_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	TRNG_ODATA_ODATA_Msk = 0xffffffff
)

// Constants for FUSE: Fuse Controller
const (
	// CR: Fuse Control Register
	// Position of WRQ field.
	FUSE_CR_WRQ_Pos = 0x0
	// Bit mask of WRQ field.
	FUSE_CR_WRQ_Msk = 0x1
	// Bit WRQ.
	FUSE_CR_WRQ = 0x1
	// Position of RRQ field.
	FUSE_CR_RRQ_Pos = 0x1
	// Bit mask of RRQ field.
	FUSE_CR_RRQ_Msk = 0x2
	// Bit RRQ.
	FUSE_CR_RRQ = 0x2
	// Position of KEY field.
	FUSE_CR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FUSE_CR_KEY_Msk = 0xff00
	// valid key.
	FUSE_CR_KEY_VALID = 0xfb

	// MR: Fuse Mode Register
	// Position of MSK field.
	FUSE_MR_MSK_Pos = 0x0
	// Bit mask of MSK field.
	FUSE_MR_MSK_Msk = 0x1
	// Bit MSK.
	FUSE_MR_MSK = 0x1

	// IR: Fuse Index Register
	// Position of WS field.
	FUSE_IR_WS_Pos = 0x0
	// Bit mask of WS field.
	FUSE_IR_WS_Msk = 0x1
	// Bit WS.
	FUSE_IR_WS = 0x1
	// Position of RS field.
	FUSE_IR_RS_Pos = 0x1
	// Bit mask of RS field.
	FUSE_IR_RS_Msk = 0x2
	// Bit RS.
	FUSE_IR_RS = 0x2
	// Position of WSEL field.
	FUSE_IR_WSEL_Pos = 0x8
	// Bit mask of WSEL field.
	FUSE_IR_WSEL_Msk = 0xf00

	// DR: Fuse Data Register
	// Position of DATA field.
	FUSE_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FUSE_DR_DATA_Msk = 0xffffffff

	// SR: Fuse Status Register
	// Position of FUSE field.
	FUSE_SR_FUSE_Pos = 0x0
	// Bit mask of FUSE field.
	FUSE_SR_FUSE_Msk = 0xffffffff
)

// Constants for DMAC0: DMA Controller 0
const (
	// GCFG: DMAC Global Configuration Register
	// Position of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Pos = 0x4
	// Bit mask of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Msk = 0x10
	// Bit ARB_CFG.
	DMAC_GCFG_ARB_CFG = 0x10
	// Fixed priority arbiter.
	DMAC_GCFG_ARB_CFG_FIXED = 0x0
	// Modified round robin arbiter.
	DMAC_GCFG_ARB_CFG_ROUND_ROBIN = 0x1
	// Position of DICEN field.
	DMAC_GCFG_DICEN_Pos = 0x8
	// Bit mask of DICEN field.
	DMAC_GCFG_DICEN_Msk = 0x100
	// Bit DICEN.
	DMAC_GCFG_DICEN = 0x100

	// EN: DMAC Enable Register
	// Position of ENABLE field.
	DMAC_EN_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DMAC_EN_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DMAC_EN_ENABLE = 0x1

	// SREQ: DMAC Software Single Request Register
	// Position of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Pos = 0x0
	// Bit mask of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Msk = 0x1
	// Bit SSREQ0.
	DMAC_SREQ_SSREQ0 = 0x1
	// Position of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Pos = 0x1
	// Bit mask of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Msk = 0x2
	// Bit DSREQ0.
	DMAC_SREQ_DSREQ0 = 0x2
	// Position of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Pos = 0x2
	// Bit mask of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Msk = 0x4
	// Bit SSREQ1.
	DMAC_SREQ_SSREQ1 = 0x4
	// Position of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Pos = 0x3
	// Bit mask of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Msk = 0x8
	// Bit DSREQ1.
	DMAC_SREQ_DSREQ1 = 0x8
	// Position of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Pos = 0x4
	// Bit mask of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Msk = 0x10
	// Bit SSREQ2.
	DMAC_SREQ_SSREQ2 = 0x10
	// Position of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Pos = 0x5
	// Bit mask of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Msk = 0x20
	// Bit DSREQ2.
	DMAC_SREQ_DSREQ2 = 0x20
	// Position of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Pos = 0x6
	// Bit mask of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Msk = 0x40
	// Bit SSREQ3.
	DMAC_SREQ_SSREQ3 = 0x40
	// Position of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Pos = 0x7
	// Bit mask of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Msk = 0x80
	// Bit DSREQ3.
	DMAC_SREQ_DSREQ3 = 0x80
	// Position of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Pos = 0x8
	// Bit mask of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Msk = 0x100
	// Bit SSREQ4.
	DMAC_SREQ_SSREQ4 = 0x100
	// Position of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Pos = 0x9
	// Bit mask of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Msk = 0x200
	// Bit DSREQ4.
	DMAC_SREQ_DSREQ4 = 0x200
	// Position of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Pos = 0xa
	// Bit mask of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Msk = 0x400
	// Bit SSREQ5.
	DMAC_SREQ_SSREQ5 = 0x400
	// Position of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Pos = 0xb
	// Bit mask of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Msk = 0x800
	// Bit DSREQ5.
	DMAC_SREQ_DSREQ5 = 0x800
	// Position of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Pos = 0xc
	// Bit mask of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Msk = 0x1000
	// Bit SSREQ6.
	DMAC_SREQ_SSREQ6 = 0x1000
	// Position of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Pos = 0xd
	// Bit mask of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Msk = 0x2000
	// Bit DSREQ6.
	DMAC_SREQ_DSREQ6 = 0x2000
	// Position of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Pos = 0xe
	// Bit mask of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Msk = 0x4000
	// Bit SSREQ7.
	DMAC_SREQ_SSREQ7 = 0x4000
	// Position of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Pos = 0xf
	// Bit mask of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Msk = 0x8000
	// Bit DSREQ7.
	DMAC_SREQ_DSREQ7 = 0x8000

	// CREQ: DMAC Software Chunk Transfer Request Register
	// Position of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Pos = 0x0
	// Bit mask of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Msk = 0x1
	// Bit SCREQ0.
	DMAC_CREQ_SCREQ0 = 0x1
	// Position of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Pos = 0x1
	// Bit mask of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Msk = 0x2
	// Bit DCREQ0.
	DMAC_CREQ_DCREQ0 = 0x2
	// Position of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Pos = 0x2
	// Bit mask of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Msk = 0x4
	// Bit SCREQ1.
	DMAC_CREQ_SCREQ1 = 0x4
	// Position of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Pos = 0x3
	// Bit mask of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Msk = 0x8
	// Bit DCREQ1.
	DMAC_CREQ_DCREQ1 = 0x8
	// Position of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Pos = 0x4
	// Bit mask of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Msk = 0x10
	// Bit SCREQ2.
	DMAC_CREQ_SCREQ2 = 0x10
	// Position of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Pos = 0x5
	// Bit mask of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Msk = 0x20
	// Bit DCREQ2.
	DMAC_CREQ_DCREQ2 = 0x20
	// Position of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Pos = 0x6
	// Bit mask of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Msk = 0x40
	// Bit SCREQ3.
	DMAC_CREQ_SCREQ3 = 0x40
	// Position of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Pos = 0x7
	// Bit mask of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Msk = 0x80
	// Bit DCREQ3.
	DMAC_CREQ_DCREQ3 = 0x80
	// Position of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Pos = 0x8
	// Bit mask of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Msk = 0x100
	// Bit SCREQ4.
	DMAC_CREQ_SCREQ4 = 0x100
	// Position of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Pos = 0x9
	// Bit mask of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Msk = 0x200
	// Bit DCREQ4.
	DMAC_CREQ_DCREQ4 = 0x200
	// Position of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Pos = 0xa
	// Bit mask of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Msk = 0x400
	// Bit SCREQ5.
	DMAC_CREQ_SCREQ5 = 0x400
	// Position of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Pos = 0xb
	// Bit mask of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Msk = 0x800
	// Bit DCREQ5.
	DMAC_CREQ_DCREQ5 = 0x800
	// Position of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Pos = 0xc
	// Bit mask of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Msk = 0x1000
	// Bit SCREQ6.
	DMAC_CREQ_SCREQ6 = 0x1000
	// Position of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Pos = 0xd
	// Bit mask of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Msk = 0x2000
	// Bit DCREQ6.
	DMAC_CREQ_DCREQ6 = 0x2000
	// Position of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Pos = 0xe
	// Bit mask of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Msk = 0x4000
	// Bit SCREQ7.
	DMAC_CREQ_SCREQ7 = 0x4000
	// Position of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Pos = 0xf
	// Bit mask of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Msk = 0x8000
	// Bit DCREQ7.
	DMAC_CREQ_DCREQ7 = 0x8000

	// LAST: DMAC Software Last Transfer Flag Register
	// Position of SLAST0 field.
	DMAC_LAST_SLAST0_Pos = 0x0
	// Bit mask of SLAST0 field.
	DMAC_LAST_SLAST0_Msk = 0x1
	// Bit SLAST0.
	DMAC_LAST_SLAST0 = 0x1
	// Position of DLAST0 field.
	DMAC_LAST_DLAST0_Pos = 0x1
	// Bit mask of DLAST0 field.
	DMAC_LAST_DLAST0_Msk = 0x2
	// Bit DLAST0.
	DMAC_LAST_DLAST0 = 0x2
	// Position of SLAST1 field.
	DMAC_LAST_SLAST1_Pos = 0x2
	// Bit mask of SLAST1 field.
	DMAC_LAST_SLAST1_Msk = 0x4
	// Bit SLAST1.
	DMAC_LAST_SLAST1 = 0x4
	// Position of DLAST1 field.
	DMAC_LAST_DLAST1_Pos = 0x3
	// Bit mask of DLAST1 field.
	DMAC_LAST_DLAST1_Msk = 0x8
	// Bit DLAST1.
	DMAC_LAST_DLAST1 = 0x8
	// Position of SLAST2 field.
	DMAC_LAST_SLAST2_Pos = 0x4
	// Bit mask of SLAST2 field.
	DMAC_LAST_SLAST2_Msk = 0x10
	// Bit SLAST2.
	DMAC_LAST_SLAST2 = 0x10
	// Position of DLAST2 field.
	DMAC_LAST_DLAST2_Pos = 0x5
	// Bit mask of DLAST2 field.
	DMAC_LAST_DLAST2_Msk = 0x20
	// Bit DLAST2.
	DMAC_LAST_DLAST2 = 0x20
	// Position of SLAST3 field.
	DMAC_LAST_SLAST3_Pos = 0x6
	// Bit mask of SLAST3 field.
	DMAC_LAST_SLAST3_Msk = 0x40
	// Bit SLAST3.
	DMAC_LAST_SLAST3 = 0x40
	// Position of DLAST3 field.
	DMAC_LAST_DLAST3_Pos = 0x7
	// Bit mask of DLAST3 field.
	DMAC_LAST_DLAST3_Msk = 0x80
	// Bit DLAST3.
	DMAC_LAST_DLAST3 = 0x80
	// Position of SLAST4 field.
	DMAC_LAST_SLAST4_Pos = 0x8
	// Bit mask of SLAST4 field.
	DMAC_LAST_SLAST4_Msk = 0x100
	// Bit SLAST4.
	DMAC_LAST_SLAST4 = 0x100
	// Position of DLAST4 field.
	DMAC_LAST_DLAST4_Pos = 0x9
	// Bit mask of DLAST4 field.
	DMAC_LAST_DLAST4_Msk = 0x200
	// Bit DLAST4.
	DMAC_LAST_DLAST4 = 0x200
	// Position of SLAST5 field.
	DMAC_LAST_SLAST5_Pos = 0xa
	// Bit mask of SLAST5 field.
	DMAC_LAST_SLAST5_Msk = 0x400
	// Bit SLAST5.
	DMAC_LAST_SLAST5 = 0x400
	// Position of DLAST5 field.
	DMAC_LAST_DLAST5_Pos = 0xb
	// Bit mask of DLAST5 field.
	DMAC_LAST_DLAST5_Msk = 0x800
	// Bit DLAST5.
	DMAC_LAST_DLAST5 = 0x800
	// Position of SLAST6 field.
	DMAC_LAST_SLAST6_Pos = 0xc
	// Bit mask of SLAST6 field.
	DMAC_LAST_SLAST6_Msk = 0x1000
	// Bit SLAST6.
	DMAC_LAST_SLAST6 = 0x1000
	// Position of DLAST6 field.
	DMAC_LAST_DLAST6_Pos = 0xd
	// Bit mask of DLAST6 field.
	DMAC_LAST_DLAST6_Msk = 0x2000
	// Bit DLAST6.
	DMAC_LAST_DLAST6 = 0x2000
	// Position of SLAST7 field.
	DMAC_LAST_SLAST7_Pos = 0xe
	// Bit mask of SLAST7 field.
	DMAC_LAST_SLAST7_Msk = 0x4000
	// Bit SLAST7.
	DMAC_LAST_SLAST7 = 0x4000
	// Position of DLAST7 field.
	DMAC_LAST_DLAST7_Pos = 0xf
	// Bit mask of DLAST7 field.
	DMAC_LAST_DLAST7_Msk = 0x8000
	// Bit DLAST7.
	DMAC_LAST_DLAST7 = 0x8000

	// EBCIER: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Enable register.
	// Position of BTC0 field.
	DMAC_EBCIER_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIER_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIER_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIER_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIER_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIER_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIER_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIER_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIER_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIER_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIER_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIER_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIER_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIER_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIER_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIER_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIER_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIER_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIER_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIER_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIER_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIER_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIER_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIER_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIER_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIER_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIER_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIER_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIER_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIER_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIER_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIER_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIER_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIER_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIER_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIER_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIER_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIER_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIER_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIER_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIER_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIER_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIER_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIER_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIER_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIER_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIER_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIER_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIER_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIER_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIER_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIER_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIER_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIER_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIER_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIER_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIER_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIER_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIER_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIER_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIER_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIER_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIER_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIER_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIER_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIER_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIER_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIER_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIER_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIER_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIER_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIER_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIER_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIER_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIER_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIER_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIER_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIER_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIER_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIER_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIER_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIER_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIER_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIER_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIER_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIER_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIER_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIER_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIER_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIER_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIER_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIER_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIER_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIER_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIER_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIER_DICERR7 = 0x80000000

	// EBCIDR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Disable register.
	// Position of BTC0 field.
	DMAC_EBCIDR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIDR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIDR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIDR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIDR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIDR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIDR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIDR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIDR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIDR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIDR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIDR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIDR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIDR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIDR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIDR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIDR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIDR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIDR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIDR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIDR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIDR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIDR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIDR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIDR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIDR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIDR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIDR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIDR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIDR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIDR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIDR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIDR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIDR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIDR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIDR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIDR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIDR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIDR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIDR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIDR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIDR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIDR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIDR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIDR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIDR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIDR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIDR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIDR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIDR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIDR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIDR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIDR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIDR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIDR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIDR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIDR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIDR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIDR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIDR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIDR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIDR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIDR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIDR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIDR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIDR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIDR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIDR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIDR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIDR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIDR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIDR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIDR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIDR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIDR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIDR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIDR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIDR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIDR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIDR_DICERR7 = 0x80000000

	// EBCIMR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Mask Register.
	// Position of BTC0 field.
	DMAC_EBCIMR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIMR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIMR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIMR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIMR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIMR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIMR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIMR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIMR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIMR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIMR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIMR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIMR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIMR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIMR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIMR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIMR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIMR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIMR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIMR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIMR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIMR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIMR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIMR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIMR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIMR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIMR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIMR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIMR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIMR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIMR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIMR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIMR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIMR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIMR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIMR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIMR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIMR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIMR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIMR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIMR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIMR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIMR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIMR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIMR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIMR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIMR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIMR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIMR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIMR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIMR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIMR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIMR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIMR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIMR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIMR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIMR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIMR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIMR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIMR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIMR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIMR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIMR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIMR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIMR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIMR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIMR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIMR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIMR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIMR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIMR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIMR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIMR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIMR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIMR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIMR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIMR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIMR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIMR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIMR_DICERR7 = 0x80000000

	// EBCISR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Status Register.
	// Position of BTC0 field.
	DMAC_EBCISR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCISR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCISR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCISR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCISR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCISR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCISR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCISR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCISR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCISR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCISR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCISR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCISR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCISR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCISR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCISR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCISR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCISR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCISR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCISR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCISR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCISR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCISR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCISR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCISR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCISR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCISR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCISR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCISR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCISR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCISR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCISR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCISR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCISR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCISR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCISR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCISR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCISR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCISR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCISR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCISR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCISR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCISR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCISR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCISR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCISR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCISR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCISR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCISR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCISR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCISR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCISR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCISR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCISR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCISR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCISR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCISR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCISR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCISR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCISR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCISR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCISR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCISR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCISR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCISR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCISR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCISR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCISR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCISR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCISR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCISR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCISR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCISR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCISR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCISR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCISR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCISR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCISR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCISR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCISR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCISR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCISR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCISR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCISR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCISR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCISR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCISR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCISR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCISR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCISR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCISR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCISR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCISR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCISR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCISR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCISR_DICERR7 = 0x80000000

	// CHER: DMAC Channel Handler Enable Register
	// Position of ENA0 field.
	DMAC_CHER_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHER_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHER_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHER_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHER_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHER_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHER_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHER_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHER_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHER_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHER_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHER_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHER_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHER_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHER_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHER_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHER_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHER_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHER_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHER_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHER_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHER_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHER_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHER_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHER_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHER_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHER_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHER_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHER_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHER_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHER_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHER_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHER_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHER_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHER_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHER_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHER_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHER_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHER_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHER_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHER_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHER_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHER_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHER_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHER_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHER_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHER_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHER_SUSP7 = 0x8000
	// Position of KEEP0 field.
	DMAC_CHER_KEEP0_Pos = 0x18
	// Bit mask of KEEP0 field.
	DMAC_CHER_KEEP0_Msk = 0x1000000
	// Bit KEEP0.
	DMAC_CHER_KEEP0 = 0x1000000
	// Position of KEEP1 field.
	DMAC_CHER_KEEP1_Pos = 0x19
	// Bit mask of KEEP1 field.
	DMAC_CHER_KEEP1_Msk = 0x2000000
	// Bit KEEP1.
	DMAC_CHER_KEEP1 = 0x2000000
	// Position of KEEP2 field.
	DMAC_CHER_KEEP2_Pos = 0x1a
	// Bit mask of KEEP2 field.
	DMAC_CHER_KEEP2_Msk = 0x4000000
	// Bit KEEP2.
	DMAC_CHER_KEEP2 = 0x4000000
	// Position of KEEP3 field.
	DMAC_CHER_KEEP3_Pos = 0x1b
	// Bit mask of KEEP3 field.
	DMAC_CHER_KEEP3_Msk = 0x8000000
	// Bit KEEP3.
	DMAC_CHER_KEEP3 = 0x8000000
	// Position of KEEP4 field.
	DMAC_CHER_KEEP4_Pos = 0x1c
	// Bit mask of KEEP4 field.
	DMAC_CHER_KEEP4_Msk = 0x10000000
	// Bit KEEP4.
	DMAC_CHER_KEEP4 = 0x10000000
	// Position of KEEP5 field.
	DMAC_CHER_KEEP5_Pos = 0x1d
	// Bit mask of KEEP5 field.
	DMAC_CHER_KEEP5_Msk = 0x20000000
	// Bit KEEP5.
	DMAC_CHER_KEEP5 = 0x20000000
	// Position of KEEP6 field.
	DMAC_CHER_KEEP6_Pos = 0x1e
	// Bit mask of KEEP6 field.
	DMAC_CHER_KEEP6_Msk = 0x40000000
	// Bit KEEP6.
	DMAC_CHER_KEEP6 = 0x40000000
	// Position of KEEP7 field.
	DMAC_CHER_KEEP7_Pos = 0x1f
	// Bit mask of KEEP7 field.
	DMAC_CHER_KEEP7_Msk = 0x80000000
	// Bit KEEP7.
	DMAC_CHER_KEEP7 = 0x80000000

	// CHDR: DMAC Channel Handler Disable Register
	// Position of DIS0 field.
	DMAC_CHDR_DIS0_Pos = 0x0
	// Bit mask of DIS0 field.
	DMAC_CHDR_DIS0_Msk = 0x1
	// Bit DIS0.
	DMAC_CHDR_DIS0 = 0x1
	// Position of DIS1 field.
	DMAC_CHDR_DIS1_Pos = 0x1
	// Bit mask of DIS1 field.
	DMAC_CHDR_DIS1_Msk = 0x2
	// Bit DIS1.
	DMAC_CHDR_DIS1 = 0x2
	// Position of DIS2 field.
	DMAC_CHDR_DIS2_Pos = 0x2
	// Bit mask of DIS2 field.
	DMAC_CHDR_DIS2_Msk = 0x4
	// Bit DIS2.
	DMAC_CHDR_DIS2 = 0x4
	// Position of DIS3 field.
	DMAC_CHDR_DIS3_Pos = 0x3
	// Bit mask of DIS3 field.
	DMAC_CHDR_DIS3_Msk = 0x8
	// Bit DIS3.
	DMAC_CHDR_DIS3 = 0x8
	// Position of DIS4 field.
	DMAC_CHDR_DIS4_Pos = 0x4
	// Bit mask of DIS4 field.
	DMAC_CHDR_DIS4_Msk = 0x10
	// Bit DIS4.
	DMAC_CHDR_DIS4 = 0x10
	// Position of DIS5 field.
	DMAC_CHDR_DIS5_Pos = 0x5
	// Bit mask of DIS5 field.
	DMAC_CHDR_DIS5_Msk = 0x20
	// Bit DIS5.
	DMAC_CHDR_DIS5 = 0x20
	// Position of DIS6 field.
	DMAC_CHDR_DIS6_Pos = 0x6
	// Bit mask of DIS6 field.
	DMAC_CHDR_DIS6_Msk = 0x40
	// Bit DIS6.
	DMAC_CHDR_DIS6 = 0x40
	// Position of DIS7 field.
	DMAC_CHDR_DIS7_Pos = 0x7
	// Bit mask of DIS7 field.
	DMAC_CHDR_DIS7_Msk = 0x80
	// Bit DIS7.
	DMAC_CHDR_DIS7 = 0x80
	// Position of RES0 field.
	DMAC_CHDR_RES0_Pos = 0x8
	// Bit mask of RES0 field.
	DMAC_CHDR_RES0_Msk = 0x100
	// Bit RES0.
	DMAC_CHDR_RES0 = 0x100
	// Position of RES1 field.
	DMAC_CHDR_RES1_Pos = 0x9
	// Bit mask of RES1 field.
	DMAC_CHDR_RES1_Msk = 0x200
	// Bit RES1.
	DMAC_CHDR_RES1 = 0x200
	// Position of RES2 field.
	DMAC_CHDR_RES2_Pos = 0xa
	// Bit mask of RES2 field.
	DMAC_CHDR_RES2_Msk = 0x400
	// Bit RES2.
	DMAC_CHDR_RES2 = 0x400
	// Position of RES3 field.
	DMAC_CHDR_RES3_Pos = 0xb
	// Bit mask of RES3 field.
	DMAC_CHDR_RES3_Msk = 0x800
	// Bit RES3.
	DMAC_CHDR_RES3 = 0x800
	// Position of RES4 field.
	DMAC_CHDR_RES4_Pos = 0xc
	// Bit mask of RES4 field.
	DMAC_CHDR_RES4_Msk = 0x1000
	// Bit RES4.
	DMAC_CHDR_RES4 = 0x1000
	// Position of RES5 field.
	DMAC_CHDR_RES5_Pos = 0xd
	// Bit mask of RES5 field.
	DMAC_CHDR_RES5_Msk = 0x2000
	// Bit RES5.
	DMAC_CHDR_RES5 = 0x2000
	// Position of RES6 field.
	DMAC_CHDR_RES6_Pos = 0xe
	// Bit mask of RES6 field.
	DMAC_CHDR_RES6_Msk = 0x4000
	// Bit RES6.
	DMAC_CHDR_RES6 = 0x4000
	// Position of RES7 field.
	DMAC_CHDR_RES7_Pos = 0xf
	// Bit mask of RES7 field.
	DMAC_CHDR_RES7_Msk = 0x8000
	// Bit RES7.
	DMAC_CHDR_RES7 = 0x8000

	// CHSR: DMAC Channel Handler Status Register
	// Position of ENA0 field.
	DMAC_CHSR_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHSR_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHSR_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHSR_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHSR_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHSR_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHSR_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHSR_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHSR_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHSR_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHSR_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHSR_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHSR_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHSR_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHSR_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHSR_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHSR_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHSR_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHSR_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHSR_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHSR_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHSR_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHSR_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHSR_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHSR_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHSR_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHSR_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHSR_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHSR_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHSR_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHSR_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHSR_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHSR_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHSR_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHSR_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHSR_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHSR_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHSR_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHSR_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHSR_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHSR_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHSR_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHSR_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHSR_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHSR_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHSR_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHSR_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHSR_SUSP7 = 0x8000
	// Position of EMPT0 field.
	DMAC_CHSR_EMPT0_Pos = 0x10
	// Bit mask of EMPT0 field.
	DMAC_CHSR_EMPT0_Msk = 0x10000
	// Bit EMPT0.
	DMAC_CHSR_EMPT0 = 0x10000
	// Position of EMPT1 field.
	DMAC_CHSR_EMPT1_Pos = 0x11
	// Bit mask of EMPT1 field.
	DMAC_CHSR_EMPT1_Msk = 0x20000
	// Bit EMPT1.
	DMAC_CHSR_EMPT1 = 0x20000
	// Position of EMPT2 field.
	DMAC_CHSR_EMPT2_Pos = 0x12
	// Bit mask of EMPT2 field.
	DMAC_CHSR_EMPT2_Msk = 0x40000
	// Bit EMPT2.
	DMAC_CHSR_EMPT2 = 0x40000
	// Position of EMPT3 field.
	DMAC_CHSR_EMPT3_Pos = 0x13
	// Bit mask of EMPT3 field.
	DMAC_CHSR_EMPT3_Msk = 0x80000
	// Bit EMPT3.
	DMAC_CHSR_EMPT3 = 0x80000
	// Position of EMPT4 field.
	DMAC_CHSR_EMPT4_Pos = 0x14
	// Bit mask of EMPT4 field.
	DMAC_CHSR_EMPT4_Msk = 0x100000
	// Bit EMPT4.
	DMAC_CHSR_EMPT4 = 0x100000
	// Position of EMPT5 field.
	DMAC_CHSR_EMPT5_Pos = 0x15
	// Bit mask of EMPT5 field.
	DMAC_CHSR_EMPT5_Msk = 0x200000
	// Bit EMPT5.
	DMAC_CHSR_EMPT5 = 0x200000
	// Position of EMPT6 field.
	DMAC_CHSR_EMPT6_Pos = 0x16
	// Bit mask of EMPT6 field.
	DMAC_CHSR_EMPT6_Msk = 0x400000
	// Bit EMPT6.
	DMAC_CHSR_EMPT6 = 0x400000
	// Position of EMPT7 field.
	DMAC_CHSR_EMPT7_Pos = 0x17
	// Bit mask of EMPT7 field.
	DMAC_CHSR_EMPT7_Msk = 0x800000
	// Bit EMPT7.
	DMAC_CHSR_EMPT7 = 0x800000
	// Position of STAL0 field.
	DMAC_CHSR_STAL0_Pos = 0x18
	// Bit mask of STAL0 field.
	DMAC_CHSR_STAL0_Msk = 0x1000000
	// Bit STAL0.
	DMAC_CHSR_STAL0 = 0x1000000
	// Position of STAL1 field.
	DMAC_CHSR_STAL1_Pos = 0x19
	// Bit mask of STAL1 field.
	DMAC_CHSR_STAL1_Msk = 0x2000000
	// Bit STAL1.
	DMAC_CHSR_STAL1 = 0x2000000
	// Position of STAL2 field.
	DMAC_CHSR_STAL2_Pos = 0x1a
	// Bit mask of STAL2 field.
	DMAC_CHSR_STAL2_Msk = 0x4000000
	// Bit STAL2.
	DMAC_CHSR_STAL2 = 0x4000000
	// Position of STAL3 field.
	DMAC_CHSR_STAL3_Pos = 0x1b
	// Bit mask of STAL3 field.
	DMAC_CHSR_STAL3_Msk = 0x8000000
	// Bit STAL3.
	DMAC_CHSR_STAL3 = 0x8000000
	// Position of STAL4 field.
	DMAC_CHSR_STAL4_Pos = 0x1c
	// Bit mask of STAL4 field.
	DMAC_CHSR_STAL4_Msk = 0x10000000
	// Bit STAL4.
	DMAC_CHSR_STAL4 = 0x10000000
	// Position of STAL5 field.
	DMAC_CHSR_STAL5_Pos = 0x1d
	// Bit mask of STAL5 field.
	DMAC_CHSR_STAL5_Msk = 0x20000000
	// Bit STAL5.
	DMAC_CHSR_STAL5 = 0x20000000
	// Position of STAL6 field.
	DMAC_CHSR_STAL6_Pos = 0x1e
	// Bit mask of STAL6 field.
	DMAC_CHSR_STAL6_Msk = 0x40000000
	// Bit STAL6.
	DMAC_CHSR_STAL6 = 0x40000000
	// Position of STAL7 field.
	DMAC_CHSR_STAL7_Pos = 0x1f
	// Bit mask of STAL7 field.
	DMAC_CHSR_STAL7_Msk = 0x80000000
	// Bit STAL7.
	DMAC_CHSR_STAL7 = 0x80000000

	// SADDR0: DMAC Channel Source Address Register (ch_num = 0)
	// Position of SADDR field.
	DMAC_SADDR0_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR0_SADDR_Msk = 0xffffffff

	// DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
	// Position of DADDR field.
	DMAC_DADDR0_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR0_DADDR_Msk = 0xffffffff

	// DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
	// Position of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR0_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR0_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR0_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR0_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR0_DSCR_Msk = 0xfffffffc

	// CTRLA0: DMAC Channel Control A Register (ch_num = 0)
	// Position of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA0_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA0_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA0_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA0_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA0_DONE = 0x80000000

	// CTRLB0: DMAC Channel Control B Register (ch_num = 0)
	// Position of SIF field.
	DMAC_CTRLB0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB0_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB0_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB0_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB0_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB0_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB0_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB0_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB0_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB0_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB0_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB0_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB0_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB0_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB0_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB0_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB0_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB0_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB0_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB0_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB0_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB0_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB0_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB0_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB0_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB0_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB0_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB0_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB0_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB0_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB0_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB0_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB0_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB0_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB0_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB0_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB0_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB0_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB0_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB0_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB0_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB0_AUTO_ENABLE = 0x1

	// CFG0: DMAC Channel Configuration Register (ch_num = 0)
	// Position of SRC_PER field.
	DMAC_CFG0_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG0_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG0_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG0_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG0_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG0_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG0_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG0_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG0_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG0_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG0_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG0_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG0_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG0_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG0_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG0_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG0_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG0_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG0_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG0_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG0_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG0_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG0_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG0_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG0_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG0_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG0_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG0_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG0_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG0_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG0_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG0_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG0_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG0_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG0_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG0_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG0_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG0_FIFOCFG_ASAP_CFG = 0x2

	// SPIP0: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 0)
	// Position of SPIP_HOLE field.
	DMAC_SPIP0_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP0_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP0_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP0_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP0: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 0)
	// Position of DPIP_HOLE field.
	DMAC_DPIP0_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP0_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP0_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP0_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR1: DMAC Channel Source Address Register (ch_num = 1)
	// Position of SADDR field.
	DMAC_SADDR1_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR1_SADDR_Msk = 0xffffffff

	// DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
	// Position of DADDR field.
	DMAC_DADDR1_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR1_DADDR_Msk = 0xffffffff

	// DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
	// Position of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR1_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR1_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR1_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR1_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR1_DSCR_Msk = 0xfffffffc

	// CTRLA1: DMAC Channel Control A Register (ch_num = 1)
	// Position of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA1_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA1_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA1_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA1_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA1_DONE = 0x80000000

	// CTRLB1: DMAC Channel Control B Register (ch_num = 1)
	// Position of SIF field.
	DMAC_CTRLB1_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB1_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB1_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB1_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB1_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB1_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB1_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB1_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB1_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB1_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB1_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB1_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB1_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB1_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB1_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB1_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB1_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB1_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB1_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB1_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB1_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB1_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB1_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB1_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB1_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB1_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB1_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB1_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB1_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB1_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB1_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB1_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB1_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB1_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB1_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB1_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB1_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB1_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB1_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB1_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB1_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB1_AUTO_ENABLE = 0x1

	// CFG1: DMAC Channel Configuration Register (ch_num = 1)
	// Position of SRC_PER field.
	DMAC_CFG1_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG1_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG1_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG1_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG1_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG1_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG1_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG1_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG1_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG1_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG1_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG1_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG1_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG1_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG1_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG1_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG1_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG1_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG1_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG1_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG1_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG1_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG1_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG1_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG1_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG1_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG1_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG1_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG1_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG1_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG1_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG1_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG1_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG1_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG1_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG1_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG1_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG1_FIFOCFG_ASAP_CFG = 0x2

	// SPIP1: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 1)
	// Position of SPIP_HOLE field.
	DMAC_SPIP1_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP1_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP1_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP1_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP1: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 1)
	// Position of DPIP_HOLE field.
	DMAC_DPIP1_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP1_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP1_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP1_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR2: DMAC Channel Source Address Register (ch_num = 2)
	// Position of SADDR field.
	DMAC_SADDR2_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR2_SADDR_Msk = 0xffffffff

	// DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
	// Position of DADDR field.
	DMAC_DADDR2_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR2_DADDR_Msk = 0xffffffff

	// DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
	// Position of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR2_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR2_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR2_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR2_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR2_DSCR_Msk = 0xfffffffc

	// CTRLA2: DMAC Channel Control A Register (ch_num = 2)
	// Position of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA2_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA2_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA2_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA2_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA2_DONE = 0x80000000

	// CTRLB2: DMAC Channel Control B Register (ch_num = 2)
	// Position of SIF field.
	DMAC_CTRLB2_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB2_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB2_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB2_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB2_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB2_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB2_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB2_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB2_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB2_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB2_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB2_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB2_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB2_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB2_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB2_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB2_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB2_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB2_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB2_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB2_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB2_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB2_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB2_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB2_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB2_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB2_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB2_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB2_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB2_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB2_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB2_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB2_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB2_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB2_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB2_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB2_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB2_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB2_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB2_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB2_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB2_AUTO_ENABLE = 0x1

	// CFG2: DMAC Channel Configuration Register (ch_num = 2)
	// Position of SRC_PER field.
	DMAC_CFG2_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG2_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG2_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG2_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG2_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG2_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG2_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG2_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG2_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG2_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG2_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG2_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG2_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG2_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG2_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG2_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG2_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG2_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG2_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG2_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG2_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG2_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG2_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG2_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG2_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG2_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG2_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG2_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG2_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG2_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG2_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG2_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG2_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG2_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG2_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG2_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG2_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG2_FIFOCFG_ASAP_CFG = 0x2

	// SPIP2: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 2)
	// Position of SPIP_HOLE field.
	DMAC_SPIP2_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP2_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP2_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP2_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP2: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 2)
	// Position of DPIP_HOLE field.
	DMAC_DPIP2_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP2_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP2_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP2_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR3: DMAC Channel Source Address Register (ch_num = 3)
	// Position of SADDR field.
	DMAC_SADDR3_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR3_SADDR_Msk = 0xffffffff

	// DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
	// Position of DADDR field.
	DMAC_DADDR3_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR3_DADDR_Msk = 0xffffffff

	// DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
	// Position of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR3_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR3_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR3_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR3_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR3_DSCR_Msk = 0xfffffffc

	// CTRLA3: DMAC Channel Control A Register (ch_num = 3)
	// Position of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA3_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA3_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA3_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA3_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA3_DONE = 0x80000000

	// CTRLB3: DMAC Channel Control B Register (ch_num = 3)
	// Position of SIF field.
	DMAC_CTRLB3_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB3_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB3_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB3_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB3_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB3_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB3_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB3_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB3_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB3_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB3_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB3_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB3_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB3_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB3_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB3_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB3_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB3_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB3_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB3_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB3_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB3_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB3_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB3_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB3_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB3_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB3_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB3_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB3_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB3_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB3_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB3_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB3_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB3_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB3_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB3_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB3_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB3_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB3_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB3_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB3_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB3_AUTO_ENABLE = 0x1

	// CFG3: DMAC Channel Configuration Register (ch_num = 3)
	// Position of SRC_PER field.
	DMAC_CFG3_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG3_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG3_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG3_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG3_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG3_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG3_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG3_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG3_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG3_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG3_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG3_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG3_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG3_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG3_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG3_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG3_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG3_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG3_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG3_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG3_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG3_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG3_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG3_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG3_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG3_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG3_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG3_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG3_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG3_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG3_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG3_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG3_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG3_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG3_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG3_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG3_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG3_FIFOCFG_ASAP_CFG = 0x2

	// SPIP3: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 3)
	// Position of SPIP_HOLE field.
	DMAC_SPIP3_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP3_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP3_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP3_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP3: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 3)
	// Position of DPIP_HOLE field.
	DMAC_DPIP3_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP3_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP3_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP3_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR4: DMAC Channel Source Address Register (ch_num = 4)
	// Position of SADDR field.
	DMAC_SADDR4_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR4_SADDR_Msk = 0xffffffff

	// DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
	// Position of DADDR field.
	DMAC_DADDR4_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR4_DADDR_Msk = 0xffffffff

	// DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
	// Position of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR4_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR4_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR4_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR4_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR4_DSCR_Msk = 0xfffffffc

	// CTRLA4: DMAC Channel Control A Register (ch_num = 4)
	// Position of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA4_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA4_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA4_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA4_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA4_DONE = 0x80000000

	// CTRLB4: DMAC Channel Control B Register (ch_num = 4)
	// Position of SIF field.
	DMAC_CTRLB4_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB4_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB4_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB4_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB4_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB4_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB4_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB4_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB4_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB4_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB4_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB4_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB4_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB4_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB4_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB4_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB4_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB4_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB4_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB4_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB4_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB4_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB4_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB4_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB4_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB4_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB4_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB4_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB4_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB4_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB4_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB4_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB4_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB4_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB4_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB4_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB4_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB4_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB4_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB4_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB4_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB4_AUTO_ENABLE = 0x1

	// CFG4: DMAC Channel Configuration Register (ch_num = 4)
	// Position of SRC_PER field.
	DMAC_CFG4_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG4_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG4_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG4_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG4_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG4_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG4_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG4_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG4_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG4_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG4_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG4_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG4_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG4_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG4_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG4_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG4_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG4_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG4_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG4_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG4_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG4_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG4_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG4_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG4_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG4_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG4_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG4_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG4_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG4_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG4_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG4_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG4_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG4_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG4_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG4_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG4_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG4_FIFOCFG_ASAP_CFG = 0x2

	// SPIP4: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 4)
	// Position of SPIP_HOLE field.
	DMAC_SPIP4_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP4_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP4_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP4_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP4: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 4)
	// Position of DPIP_HOLE field.
	DMAC_DPIP4_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP4_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP4_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP4_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR5: DMAC Channel Source Address Register (ch_num = 5)
	// Position of SADDR field.
	DMAC_SADDR5_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR5_SADDR_Msk = 0xffffffff

	// DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
	// Position of DADDR field.
	DMAC_DADDR5_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR5_DADDR_Msk = 0xffffffff

	// DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
	// Position of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR5_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR5_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR5_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR5_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR5_DSCR_Msk = 0xfffffffc

	// CTRLA5: DMAC Channel Control A Register (ch_num = 5)
	// Position of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA5_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA5_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA5_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA5_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA5_DONE = 0x80000000

	// CTRLB5: DMAC Channel Control B Register (ch_num = 5)
	// Position of SIF field.
	DMAC_CTRLB5_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB5_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB5_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB5_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB5_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB5_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB5_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB5_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB5_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB5_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB5_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB5_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB5_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB5_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB5_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB5_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB5_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB5_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB5_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB5_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB5_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB5_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB5_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB5_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB5_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB5_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB5_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB5_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB5_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB5_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB5_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB5_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB5_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB5_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB5_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB5_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB5_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB5_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB5_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB5_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB5_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB5_AUTO_ENABLE = 0x1

	// CFG5: DMAC Channel Configuration Register (ch_num = 5)
	// Position of SRC_PER field.
	DMAC_CFG5_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG5_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG5_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG5_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG5_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG5_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG5_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG5_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG5_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG5_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG5_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG5_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG5_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG5_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG5_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG5_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG5_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG5_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG5_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG5_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG5_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG5_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG5_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG5_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG5_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG5_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG5_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG5_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG5_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG5_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG5_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG5_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG5_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG5_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG5_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG5_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG5_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG5_FIFOCFG_ASAP_CFG = 0x2

	// SPIP5: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 5)
	// Position of SPIP_HOLE field.
	DMAC_SPIP5_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP5_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP5_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP5_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP5: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 5)
	// Position of DPIP_HOLE field.
	DMAC_DPIP5_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP5_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP5_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP5_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR6: DMAC Channel Source Address Register (ch_num = 6)
	// Position of SADDR field.
	DMAC_SADDR6_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR6_SADDR_Msk = 0xffffffff

	// DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
	// Position of DADDR field.
	DMAC_DADDR6_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR6_DADDR_Msk = 0xffffffff

	// DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
	// Position of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR6_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR6_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR6_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR6_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR6_DSCR_Msk = 0xfffffffc

	// CTRLA6: DMAC Channel Control A Register (ch_num = 6)
	// Position of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA6_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA6_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA6_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA6_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA6_DONE = 0x80000000

	// CTRLB6: DMAC Channel Control B Register (ch_num = 6)
	// Position of SIF field.
	DMAC_CTRLB6_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB6_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB6_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB6_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB6_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB6_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB6_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB6_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB6_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB6_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB6_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB6_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB6_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB6_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB6_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB6_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB6_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB6_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB6_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB6_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB6_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB6_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB6_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB6_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB6_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB6_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB6_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB6_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB6_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB6_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB6_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB6_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB6_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB6_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB6_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB6_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB6_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB6_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB6_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB6_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB6_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB6_AUTO_ENABLE = 0x1

	// CFG6: DMAC Channel Configuration Register (ch_num = 6)
	// Position of SRC_PER field.
	DMAC_CFG6_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG6_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG6_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG6_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG6_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG6_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG6_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG6_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG6_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG6_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG6_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG6_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG6_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG6_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG6_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG6_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG6_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG6_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG6_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG6_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG6_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG6_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG6_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG6_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG6_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG6_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG6_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG6_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG6_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG6_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG6_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG6_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG6_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG6_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG6_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG6_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG6_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG6_FIFOCFG_ASAP_CFG = 0x2

	// SPIP6: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 6)
	// Position of SPIP_HOLE field.
	DMAC_SPIP6_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP6_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP6_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP6_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP6: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 6)
	// Position of DPIP_HOLE field.
	DMAC_DPIP6_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP6_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP6_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP6_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR7: DMAC Channel Source Address Register (ch_num = 7)
	// Position of SADDR field.
	DMAC_SADDR7_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR7_SADDR_Msk = 0xffffffff

	// DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
	// Position of DADDR field.
	DMAC_DADDR7_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR7_DADDR_Msk = 0xffffffff

	// DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
	// Position of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR7_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR7_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR7_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR7_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR7_DSCR_Msk = 0xfffffffc

	// CTRLA7: DMAC Channel Control A Register (ch_num = 7)
	// Position of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA7_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA7_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA7_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA7_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA7_DONE = 0x80000000

	// CTRLB7: DMAC Channel Control B Register (ch_num = 7)
	// Position of SIF field.
	DMAC_CTRLB7_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB7_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB7_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB7_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB7_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB7_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB7_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB7_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB7_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB7_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB7_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB7_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB7_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB7_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB7_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB7_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB7_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB7_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB7_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB7_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB7_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB7_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB7_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB7_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB7_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB7_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB7_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB7_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB7_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB7_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB7_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB7_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB7_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB7_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB7_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB7_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB7_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB7_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB7_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB7_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB7_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB7_AUTO_ENABLE = 0x1

	// CFG7: DMAC Channel Configuration Register (ch_num = 7)
	// Position of SRC_PER field.
	DMAC_CFG7_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG7_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG7_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG7_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG7_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG7_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG7_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG7_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG7_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG7_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG7_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG7_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG7_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG7_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG7_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG7_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG7_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG7_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG7_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG7_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG7_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG7_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG7_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG7_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG7_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG7_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG7_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG7_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG7_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG7_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG7_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG7_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG7_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG7_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG7_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG7_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG7_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG7_FIFOCFG_ASAP_CFG = 0x2

	// SPIP7: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 7)
	// Position of SPIP_HOLE field.
	DMAC_SPIP7_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP7_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP7_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP7_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP7: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 7)
	// Position of DPIP_HOLE field.
	DMAC_DPIP7_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP7_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP7_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP7_DPIP_BOUNDARY_Msk = 0x3ff0000

	// WPMR: DMAC Write Protect Mode Register
	// Position of WPEN field.
	DMAC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	DMAC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	DMAC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	DMAC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	DMAC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: DMAC Write Protect Status Register
	// Position of WPVS field.
	DMAC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	DMAC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	DMAC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	DMAC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	DMAC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MPDDRC: AHB Multi-port DDR-SDRAM Controller
const (
	// MR: MPDDRC Mode Register
	// Position of MODE field.
	EBI_MR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	EBI_MR_MODE_Msk = 0x7
	// Normal Mode. Any access to the MPDDRC will be decoded normally. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_NORMAL_CMD = 0x0
	// The MPDDRC issues a NOP command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_NOP_CMD = 0x1
	// The MPDDRC issues an "All Banks Precharge" command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the SDRAM.
	EBI_MR_MODE_PRCGALL_CMD = 0x2
	// The MPDDRC issues a "Load Mode Register" command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_LMR_CMD = 0x3
	// The MPDDRC issues an "Auto-Refresh" Command when the DDR-SDRAM device is accessed regardless of the cycle. Previously, an "All Banks Precharge" command must be issued. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_RFSH_CMD = 0x4
	// The MPDDRC issues an "Extended Load Mode Register" command when the SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM. The write in the DDR-SDRAM must be done in the appropriate bank.
	EBI_MR_MODE_EXT_LMR_CMD = 0x5
	// Deep power mode: Access to deep power-down mode
	EBI_MR_MODE_DEEP_CMD = 0x6
	// The MPDDRC issues an "LPDDR2 Mode Register" command when the Low-power DDR2-SDRAM device is accessed regardless of the cycle. To activate this mode, the "Mode Register" command must be followed by a write to the Low-power DDR2-SDRAM.
	EBI_MR_MODE_LPDDR2_CMD = 0x7
	// Position of MRS field.
	EBI_MR_MRS_Pos = 0x8
	// Bit mask of MRS field.
	EBI_MR_MRS_Msk = 0xff00

	// RTR: MPDDRC Refresh Timer Register
	// Position of COUNT field.
	EBI_RTR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	EBI_RTR_COUNT_Msk = 0xfff
	// Position of ADJ_REF field.
	EBI_RTR_ADJ_REF_Pos = 0x10
	// Bit mask of ADJ_REF field.
	EBI_RTR_ADJ_REF_Msk = 0x10000
	// Bit ADJ_REF.
	EBI_RTR_ADJ_REF = 0x10000
	// Position of REF_PB field.
	EBI_RTR_REF_PB_Pos = 0x11
	// Bit mask of REF_PB field.
	EBI_RTR_REF_PB_Msk = 0x20000
	// Bit REF_PB.
	EBI_RTR_REF_PB = 0x20000
	// Position of MR4_VALUE field.
	EBI_RTR_MR4_VALUE_Pos = 0x14
	// Bit mask of MR4_VALUE field.
	EBI_RTR_MR4_VALUE_Msk = 0x700000

	// CR: MPDDRC Configuration Register
	// Position of NC field.
	EBI_CR_NC_Pos = 0x0
	// Bit mask of NC field.
	EBI_CR_NC_Msk = 0x3
	// 9 DDR column bits
	EBI_CR_NC_COL_9 = 0x0
	// 10 DDR column bits
	EBI_CR_NC_COL_10 = 0x1
	// 11 DDR column bits
	EBI_CR_NC_COL_11 = 0x2
	// 12 DDR column bits
	EBI_CR_NC_COL_12 = 0x3
	// Position of NR field.
	EBI_CR_NR_Pos = 0x2
	// Bit mask of NR field.
	EBI_CR_NR_Msk = 0xc
	// 11 row bits
	EBI_CR_NR_ROW_11 = 0x0
	// 12 row bits
	EBI_CR_NR_ROW_12 = 0x1
	// 13 row bits
	EBI_CR_NR_ROW_13 = 0x2
	// 14 row bits
	EBI_CR_NR_ROW_14 = 0x3
	// Position of CAS field.
	EBI_CR_CAS_Pos = 0x4
	// Bit mask of CAS field.
	EBI_CR_CAS_Msk = 0x70
	// LPDDR1 CAS Latency 2
	EBI_CR_CAS_DDR_CAS2 = 0x2
	// DDR2/LPDDR2/LPDDR1 CAS Latency 3
	EBI_CR_CAS_DDR_CAS3 = 0x3
	// DDR2/LPDDR2 CAS Latency 4
	EBI_CR_CAS_DDR_CAS4 = 0x4
	// DDR2/LPDDR2 CAS Latency 5
	EBI_CR_CAS_DDR_CAS5 = 0x5
	// DDR2 CAS Latency 6
	EBI_CR_CAS_DDR_CAS6 = 0x6
	// Position of DLL field.
	EBI_CR_DLL_Pos = 0x7
	// Bit mask of DLL field.
	EBI_CR_DLL_Msk = 0x80
	// Bit DLL.
	EBI_CR_DLL = 0x80
	// Disable DLL reset.
	EBI_CR_DLL_RESET_DISABLED = 0x0
	// Enable DLL reset.
	EBI_CR_DLL_RESET_ENABLED = 0x1
	// Position of DIC_DS field.
	EBI_CR_DIC_DS_Pos = 0x8
	// Bit mask of DIC_DS field.
	EBI_CR_DIC_DS_Msk = 0x100
	// Bit DIC_DS.
	EBI_CR_DIC_DS = 0x100
	// Position of DIS_DLL field.
	EBI_CR_DIS_DLL_Pos = 0x9
	// Bit mask of DIS_DLL field.
	EBI_CR_DIS_DLL_Msk = 0x200
	// Bit DIS_DLL.
	EBI_CR_DIS_DLL = 0x200
	// Position of ZQ field.
	EBI_CR_ZQ_Pos = 0xa
	// Bit mask of ZQ field.
	EBI_CR_ZQ_Msk = 0xc00
	// Calibration command after initialization
	EBI_CR_ZQ_INIT = 0x0
	// Long calibration
	EBI_CR_ZQ_LONG = 0x1
	// Short calibration
	EBI_CR_ZQ_SHORT = 0x2
	// ZQ Reset
	EBI_CR_ZQ_RESET = 0x3
	// Position of OCD field.
	EBI_CR_OCD_Pos = 0xc
	// Bit mask of OCD field.
	EBI_CR_OCD_Msk = 0x7000
	// Position of DQMS field.
	EBI_CR_DQMS_Pos = 0x10
	// Bit mask of DQMS field.
	EBI_CR_DQMS_Msk = 0x10000
	// Bit DQMS.
	EBI_CR_DQMS = 0x10000
	// DQM is not shared with another controller.
	EBI_CR_DQMS_NOT_SHARED = 0x0
	// DQM is shared with another controller.
	EBI_CR_DQMS_SHARED = 0x1
	// Position of ENRDM field.
	EBI_CR_ENRDM_Pos = 0x11
	// Bit mask of ENRDM field.
	EBI_CR_ENRDM_Msk = 0x20000
	// Bit ENRDM.
	EBI_CR_ENRDM = 0x20000
	// DQS/DDR_DATA phase error correction is disabled.
	EBI_CR_ENRDM_OFF = 0x0
	// DQS/DDR_DATA phase error correction is enabled.
	EBI_CR_ENRDM_ON = 0x1
	// Position of NB field.
	EBI_CR_NB_Pos = 0x14
	// Bit mask of NB field.
	EBI_CR_NB_Msk = 0x100000
	// Bit NB.
	EBI_CR_NB = 0x100000
	// 4 banks
	EBI_CR_NB_4 = 0x0
	// 8 banks
	EBI_CR_NB_8 = 0x1
	// Position of NDQS field.
	EBI_CR_NDQS_Pos = 0x15
	// Bit mask of NDQS field.
	EBI_CR_NDQS_Msk = 0x200000
	// Bit NDQS.
	EBI_CR_NDQS = 0x200000
	// Not DQS is enabled.
	EBI_CR_NDQS_ENABLED = 0x0
	// Not DQS is disabled.
	EBI_CR_NDQS_DISABLED = 0x1
	// Position of DECOD field.
	EBI_CR_DECOD_Pos = 0x16
	// Bit mask of DECOD field.
	EBI_CR_DECOD_Msk = 0x400000
	// Bit DECOD.
	EBI_CR_DECOD = 0x400000
	// Position of UNAL field.
	EBI_CR_UNAL_Pos = 0x17
	// Bit mask of UNAL field.
	EBI_CR_UNAL_Msk = 0x800000
	// Bit UNAL.
	EBI_CR_UNAL = 0x800000
	// Unaligned access is not supported.
	EBI_CR_UNAL_UNSUPPORTED = 0x0
	// Unaligned access is supported.
	EBI_CR_UNAL_SUPPORTED = 0x1

	// TPR0: MPDDRC Timing Parameter 0 Register
	// Position of TRAS field.
	EBI_TPR0_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	EBI_TPR0_TRAS_Msk = 0xf
	// Position of TRCD field.
	EBI_TPR0_TRCD_Pos = 0x4
	// Bit mask of TRCD field.
	EBI_TPR0_TRCD_Msk = 0xf0
	// Position of TWR field.
	EBI_TPR0_TWR_Pos = 0x8
	// Bit mask of TWR field.
	EBI_TPR0_TWR_Msk = 0xf00
	// Position of TRC field.
	EBI_TPR0_TRC_Pos = 0xc
	// Bit mask of TRC field.
	EBI_TPR0_TRC_Msk = 0xf000
	// Position of TRP field.
	EBI_TPR0_TRP_Pos = 0x10
	// Bit mask of TRP field.
	EBI_TPR0_TRP_Msk = 0xf0000
	// Position of TRRD field.
	EBI_TPR0_TRRD_Pos = 0x14
	// Bit mask of TRRD field.
	EBI_TPR0_TRRD_Msk = 0xf00000
	// Position of TWTR field.
	EBI_TPR0_TWTR_Pos = 0x18
	// Bit mask of TWTR field.
	EBI_TPR0_TWTR_Msk = 0x7000000
	// Position of RDC_WRRD field.
	EBI_TPR0_RDC_WRRD_Pos = 0x1b
	// Bit mask of RDC_WRRD field.
	EBI_TPR0_RDC_WRRD_Msk = 0x8000000
	// Bit RDC_WRRD.
	EBI_TPR0_RDC_WRRD = 0x8000000
	// Position of TMRD field.
	EBI_TPR0_TMRD_Pos = 0x1c
	// Bit mask of TMRD field.
	EBI_TPR0_TMRD_Msk = 0xf0000000

	// TPR1: MPDDRC Timing Parameter 1 Register
	// Position of TRFC field.
	EBI_TPR1_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	EBI_TPR1_TRFC_Msk = 0x7f
	// Position of TXSNR field.
	EBI_TPR1_TXSNR_Pos = 0x8
	// Bit mask of TXSNR field.
	EBI_TPR1_TXSNR_Msk = 0xff00
	// Position of TXSRD field.
	EBI_TPR1_TXSRD_Pos = 0x10
	// Bit mask of TXSRD field.
	EBI_TPR1_TXSRD_Msk = 0xff0000
	// Position of TXP field.
	EBI_TPR1_TXP_Pos = 0x18
	// Bit mask of TXP field.
	EBI_TPR1_TXP_Msk = 0xf000000

	// TPR2: MPDDRC Timing Parameter 2 Register
	// Position of TXARD field.
	EBI_TPR2_TXARD_Pos = 0x0
	// Bit mask of TXARD field.
	EBI_TPR2_TXARD_Msk = 0xf
	// Position of TXARDS field.
	EBI_TPR2_TXARDS_Pos = 0x4
	// Bit mask of TXARDS field.
	EBI_TPR2_TXARDS_Msk = 0xf0
	// Position of TRPA field.
	EBI_TPR2_TRPA_Pos = 0x8
	// Bit mask of TRPA field.
	EBI_TPR2_TRPA_Msk = 0xf00
	// Position of TRTP field.
	EBI_TPR2_TRTP_Pos = 0xc
	// Bit mask of TRTP field.
	EBI_TPR2_TRTP_Msk = 0x7000
	// Position of TFAW field.
	EBI_TPR2_TFAW_Pos = 0x10
	// Bit mask of TFAW field.
	EBI_TPR2_TFAW_Msk = 0xf0000

	// LPR: MPDDRC Low-power Register
	// Position of LPCB field.
	EBI_LPR_LPCB_Pos = 0x0
	// Bit mask of LPCB field.
	EBI_LPR_LPCB_Msk = 0x3
	// Low-power Feature is inhibited. No power-down, self refresh and deep-power modes are issued to the DDR-SDRAM device.
	EBI_LPR_LPCB_DISABLED = 0x0
	// The MPDDRC issues a Self Refresh command to the DDR-SDRAM device, the clock(s) is/are de-activated and the CKE signal is set low. The DDR-SDRAM device leaves the self refresh mode when accessed and reenters it after the access.
	EBI_LPR_LPCB_SELFREFRESH = 0x1
	// The MPDDRC issues a Power-down Command to the DDR-SDRAM device after each access, the CKE signal is set low. The DDR-SDRAM device leaves the power-down mode when accessed and reenters it after the access.
	EBI_LPR_LPCB_POWERDOWN = 0x2
	// The MPDDRC issues a Deep Power-down command to the Low-power DDR-SDRAM device.
	EBI_LPR_LPCB_DEEP_PWD = 0x3
	// Position of CLK_FR field.
	EBI_LPR_CLK_FR_Pos = 0x2
	// Bit mask of CLK_FR field.
	EBI_LPR_CLK_FR_Msk = 0x4
	// Bit CLK_FR.
	EBI_LPR_CLK_FR = 0x4
	// Clock(s) is/are not frozen.
	EBI_LPR_CLK_FR_DISABLED = 0x0
	// Clock(s) is/are frozen.
	EBI_LPR_CLK_FR_ENABLED = 0x1
	// Position of LPDDR2_PWOFF field.
	EBI_LPR_LPDDR2_PWOFF_Pos = 0x3
	// Bit mask of LPDDR2_PWOFF field.
	EBI_LPR_LPDDR2_PWOFF_Msk = 0x8
	// Bit LPDDR2_PWOFF.
	EBI_LPR_LPDDR2_PWOFF = 0x8
	// No power off sequence applied to LPDDR2.
	EBI_LPR_LPDDR2_PWOFF_DISABLED = 0x0
	// A power off sequence is applied to the LPDDR2 device. CKE is forced low.
	EBI_LPR_LPDDR2_PWOFF_ENABLED = 0x1
	// Position of PASR field.
	EBI_LPR_PASR_Pos = 0x4
	// Bit mask of PASR field.
	EBI_LPR_PASR_Msk = 0x70
	// Position of DS field.
	EBI_LPR_DS_Pos = 0x8
	// Bit mask of DS field.
	EBI_LPR_DS_Msk = 0x700
	// Position of TIMEOUT field.
	EBI_LPR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	EBI_LPR_TIMEOUT_Msk = 0x3000
	// The SDRAM controller activates the SDRAM low-power mode immediately after the end of the last transfer.
	EBI_LPR_TIMEOUT_0 = 0x0
	// The SDRAM controller activates the SDRAM low-power mode 64 clock cycles after the end of the last transfer.
	EBI_LPR_TIMEOUT_64 = 0x1
	// The SDRAM controller activates the SDRAM low-power mode 128 clock cycles after the end of the last transfer.
	EBI_LPR_TIMEOUT_128 = 0x2
	// Position of APDE field.
	EBI_LPR_APDE_Pos = 0x10
	// Bit mask of APDE field.
	EBI_LPR_APDE_Msk = 0x10000
	// Bit APDE.
	EBI_LPR_APDE = 0x10000
	// Fast Exit.
	EBI_LPR_APDE_FAST = 0x0
	// Low Exit.
	EBI_LPR_APDE_SLOW = 0x1
	// Position of UPD_MR field.
	EBI_LPR_UPD_MR_Pos = 0x14
	// Bit mask of UPD_MR field.
	EBI_LPR_UPD_MR_Msk = 0x300000
	// Update is disabled.
	EBI_LPR_UPD_MR_DISABLED = 0x0

	// MD: MPDDRC Memory Device Register
	// Position of MD field.
	EBI_MD_MD_Pos = 0x0
	// Bit mask of MD field.
	EBI_MD_MD_Msk = 0x7
	// Low-power DDR1-SDRAM
	EBI_MD_MD_LPDDR_SDRAM = 0x3
	// DDR2-SDRAM
	EBI_MD_MD_DDR2_SDRAM = 0x6
	// Low-Power DDR2-SDRAM
	EBI_MD_MD_LPDDR2_SDRAM = 0x7
	// Position of DBW field.
	EBI_MD_DBW_Pos = 0x4
	// Bit mask of DBW field.
	EBI_MD_DBW_Msk = 0x10
	// Bit DBW.
	EBI_MD_DBW = 0x10
	// Data bus width is 32 bits.
	EBI_MD_DBW_DBW_32_BITS = 0x0
	// Data bus width is 16 bits.(1)
	EBI_MD_DBW_DBW_16_BITS = 0x1

	// HS: MPDDRC High Speed Register
	// Position of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Pos = 0x2
	// Bit mask of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Msk = 0x4
	// Bit DIS_ANTICIP_READ.
	EBI_HS_DIS_ANTICIP_READ = 0x4

	// LPDDR2_LPR: MPDDRC LPDDR2 Low-power Register
	// Position of BK_MASK_PASR field.
	EBI_LPDDR2_LPR_BK_MASK_PASR_Pos = 0x0
	// Bit mask of BK_MASK_PASR field.
	EBI_LPDDR2_LPR_BK_MASK_PASR_Msk = 0xff
	// Position of SEG_MASK field.
	EBI_LPDDR2_LPR_SEG_MASK_Pos = 0x8
	// Bit mask of SEG_MASK field.
	EBI_LPDDR2_LPR_SEG_MASK_Msk = 0xffff00
	// Position of DS field.
	EBI_LPDDR2_LPR_DS_Pos = 0x18
	// Bit mask of DS field.
	EBI_LPDDR2_LPR_DS_Msk = 0xf000000

	// LPDDR2_CAL_MR4: MPDDRC LPDDR2 Calibration and MR4 Register
	// Position of COUNT_CAL field.
	EBI_LPDDR2_CAL_MR4_COUNT_CAL_Pos = 0x0
	// Bit mask of COUNT_CAL field.
	EBI_LPDDR2_CAL_MR4_COUNT_CAL_Msk = 0xffff
	// Position of MR4_READ field.
	EBI_LPDDR2_CAL_MR4_MR4_READ_Pos = 0x10
	// Bit mask of MR4_READ field.
	EBI_LPDDR2_CAL_MR4_MR4_READ_Msk = 0xffff0000

	// LPDDR2_TIM_CAL: MPDDRC LPDDR2 Timing Calibration Register
	// Position of ZQCS field.
	EBI_LPDDR2_TIM_CAL_ZQCS_Pos = 0x0
	// Bit mask of ZQCS field.
	EBI_LPDDR2_TIM_CAL_ZQCS_Msk = 0xff

	// IO_CALIBR: MPDDRC IO Calibration
	// Position of RDIV field.
	EBI_IO_CALIBR_RDIV_Pos = 0x0
	// Bit mask of RDIV field.
	EBI_IO_CALIBR_RDIV_Msk = 0x7
	// LPDDR2 RZQ = 34,3 Ohm, DDR2/LPDDR1: Not applicable
	EBI_IO_CALIBR_RDIV_RZQ_34 = 0x1
	// LPDDR2:RZQ = 40 Ohm, DDR2/LPDDR1: RZQ = 33,3 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_40_RZQ_33_3 = 0x2
	// LPDDR2:RZQ =48 Ohm, DDR2/LPDDR1: RZQ =40 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_48_RZQ_40 = 0x3
	// LPDDR2:RZQ =60 Ohm, DDR2/LPDDR1: RZQ =50 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_60_RZQ_50 = 0x4
	// LPDDR2: RZQ = 80 Ohm, DDR2/LPDDR1: RZQ = 66,7 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_80_RZQ_66_7 = 0x6
	// LPDDR2:RZQ = 120 Ohm, DDR2/LPDDR1: RZQ = 100 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_120_RZQ_100 = 0x7
	// Position of TZQIO field.
	EBI_IO_CALIBR_TZQIO_Pos = 0x8
	// Bit mask of TZQIO field.
	EBI_IO_CALIBR_TZQIO_Msk = 0x700
	// Position of CALCODEP field.
	EBI_IO_CALIBR_CALCODEP_Pos = 0x10
	// Bit mask of CALCODEP field.
	EBI_IO_CALIBR_CALCODEP_Msk = 0xf0000
	// Position of CALCODEN field.
	EBI_IO_CALIBR_CALCODEN_Pos = 0x14
	// Bit mask of CALCODEN field.
	EBI_IO_CALIBR_CALCODEN_Msk = 0xf00000

	// SAW: MPDDRC Smart Adaptation Wrapper 0 Register
	// Position of FLUSH_MAX field.
	EBI_SAW_FLUSH_MAX_Pos = 0x0
	// Bit mask of FLUSH_MAX field.
	EBI_SAW_FLUSH_MAX_Msk = 0xff
	// Position of INCR_THRESH field.
	EBI_SAW_INCR_THRESH_Pos = 0x8
	// Bit mask of INCR_THRESH field.
	EBI_SAW_INCR_THRESH_Msk = 0x3f00
	// 1 word/dword max
	EBI_SAW_INCR_THRESH_1 = 0x1
	// 2 word/dword max
	EBI_SAW_INCR_THRESH_2 = 0x2
	// 4 word/dword max
	EBI_SAW_INCR_THRESH_4 = 0x4
	// 8 word/dword max
	EBI_SAW_INCR_THRESH_8 = 0x8
	// 16 word/dword max
	EBI_SAW_INCR_THRESH_16 = 0x10
	// 32 word/dword max
	EBI_SAW_INCR_THRESH_32 = 0x20
	// Position of PFCH_THRESH field.
	EBI_SAW_PFCH_THRESH_Pos = 0x10
	// Bit mask of PFCH_THRESH field.
	EBI_SAW_PFCH_THRESH_Msk = 0x3f0000
	// 2 word/dword max
	EBI_SAW_PFCH_THRESH_2 = 0x2
	// 4 word/dword max
	EBI_SAW_PFCH_THRESH_4 = 0x4
	// 8 word/dword max
	EBI_SAW_PFCH_THRESH_8 = 0x8

	// DLL_MO: MPDDRC DLL Master Offset Register
	// Position of MOFF field.
	EBI_DLL_MO_MOFF_Pos = 0x0
	// Bit mask of MOFF field.
	EBI_DLL_MO_MOFF_Msk = 0xf
	// Position of CLK90OFF field.
	EBI_DLL_MO_CLK90OFF_Pos = 0x8
	// Bit mask of CLK90OFF field.
	EBI_DLL_MO_CLK90OFF_Msk = 0x1f00
	// Position of SELOFF field.
	EBI_DLL_MO_SELOFF_Pos = 0x10
	// Bit mask of SELOFF field.
	EBI_DLL_MO_SELOFF_Msk = 0x10000
	// Bit SELOFF.
	EBI_DLL_MO_SELOFF = 0x10000

	// DLL_SOF: MPDDRC DLL Slave Offset Register
	// Position of S0OFF field.
	EBI_DLL_SOF_S0OFF_Pos = 0x0
	// Bit mask of S0OFF field.
	EBI_DLL_SOF_S0OFF_Msk = 0x1f
	// Position of S1OFF field.
	EBI_DLL_SOF_S1OFF_Pos = 0x8
	// Bit mask of S1OFF field.
	EBI_DLL_SOF_S1OFF_Msk = 0x1f00
	// Position of S2OFF field.
	EBI_DLL_SOF_S2OFF_Pos = 0x10
	// Bit mask of S2OFF field.
	EBI_DLL_SOF_S2OFF_Msk = 0x1f0000
	// Position of S3OFF field.
	EBI_DLL_SOF_S3OFF_Pos = 0x18
	// Bit mask of S3OFF field.
	EBI_DLL_SOF_S3OFF_Msk = 0x1f000000

	// DLL_MS: MPDDRC DLL Status Master Register
	// Position of MDINC field.
	EBI_DLL_MS_MDINC_Pos = 0x0
	// Bit mask of MDINC field.
	EBI_DLL_MS_MDINC_Msk = 0x1
	// Bit MDINC.
	EBI_DLL_MS_MDINC = 0x1
	// Position of MDDEC field.
	EBI_DLL_MS_MDDEC_Pos = 0x1
	// Bit mask of MDDEC field.
	EBI_DLL_MS_MDDEC_Msk = 0x2
	// Bit MDDEC.
	EBI_DLL_MS_MDDEC = 0x2
	// Position of MDOVF field.
	EBI_DLL_MS_MDOVF_Pos = 0x2
	// Bit mask of MDOVF field.
	EBI_DLL_MS_MDOVF_Msk = 0x4
	// Bit MDOVF.
	EBI_DLL_MS_MDOVF = 0x4
	// Position of MDVAL field.
	EBI_DLL_MS_MDVAL_Pos = 0x8
	// Bit mask of MDVAL field.
	EBI_DLL_MS_MDVAL_Msk = 0xff00

	// DLL_SS: MPDDRC DLL Status Slave 0 Register
	// Position of SDCOVF field.
	EBI_DLL_SS_SDCOVF_Pos = 0x0
	// Bit mask of SDCOVF field.
	EBI_DLL_SS_SDCOVF_Msk = 0x1
	// Bit SDCOVF.
	EBI_DLL_SS_SDCOVF = 0x1
	// Position of SDCUDF field.
	EBI_DLL_SS_SDCUDF_Pos = 0x1
	// Bit mask of SDCUDF field.
	EBI_DLL_SS_SDCUDF_Msk = 0x2
	// Bit SDCUDF.
	EBI_DLL_SS_SDCUDF = 0x2
	// Position of SDERF field.
	EBI_DLL_SS_SDERF_Pos = 0x2
	// Bit mask of SDERF field.
	EBI_DLL_SS_SDERF_Msk = 0x4
	// Bit SDERF.
	EBI_DLL_SS_SDERF = 0x4
	// Position of SDVAL field.
	EBI_DLL_SS_SDVAL_Pos = 0x8
	// Bit mask of SDVAL field.
	EBI_DLL_SS_SDVAL_Msk = 0xff00
	// Position of SDCVAL field.
	EBI_DLL_SS_SDCVAL_Pos = 0x10
	// Bit mask of SDCVAL field.
	EBI_DLL_SS_SDCVAL_Msk = 0xff0000

	// WPCR: MPDDRC Write Protect Control Register
	// Position of WPEN field.
	EBI_WPCR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	EBI_WPCR_WPEN_Msk = 0x1
	// Bit WPEN.
	EBI_WPCR_WPEN = 0x1
	// Position of WPKEY field.
	EBI_WPCR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	EBI_WPCR_WPKEY_Msk = 0xffffff00

	// WPSR: MPDDRC Write Protect Status Register
	// Position of WPVS field.
	EBI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	EBI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	EBI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	EBI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	EBI_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MATRIX: AHB Bus Matrix
const (
	// MCFG: Master Configuration Register
	// Position of ULBT field.
	MATRIX_MCFG_ULBT_Pos = 0x0
	// Bit mask of ULBT field.
	MATRIX_MCFG_ULBT_Msk = 0x7

	// SCFG: Slave Configuration Register
	// Position of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Pos = 0x0
	// Bit mask of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Msk = 0x1ff
	// Position of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Pos = 0x10
	// Bit mask of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Msk = 0x30000
	// Position of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Pos = 0x12
	// Bit mask of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Msk = 0x3c0000

	// PRAS0: Priority Register A for Slave 0
	// Position of M0PR field.
	MATRIX_PRAS0_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS0_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS0_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS0_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS0_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS0_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS0_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS0_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS0_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS0_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS0_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS0_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS0_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS0_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS0_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS0_M7PR_Msk = 0x30000000

	// PRBS0: Priority Register B for Slave 0
	// Position of M8PR field.
	MATRIX_PRBS0_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS0_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS0_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS0_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS0_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS0_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS0_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS0_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS0_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS0_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS0_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS0_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS0_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS0_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS0_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS0_M15PR_Msk = 0x30000000

	// PRAS1: Priority Register A for Slave 1
	// Position of M0PR field.
	MATRIX_PRAS1_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS1_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS1_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS1_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS1_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS1_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS1_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS1_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS1_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS1_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS1_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS1_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS1_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS1_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS1_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS1_M7PR_Msk = 0x30000000

	// PRBS1: Priority Register B for Slave 1
	// Position of M8PR field.
	MATRIX_PRBS1_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS1_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS1_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS1_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS1_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS1_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS1_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS1_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS1_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS1_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS1_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS1_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS1_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS1_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS1_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS1_M15PR_Msk = 0x30000000

	// PRAS2: Priority Register A for Slave 2
	// Position of M0PR field.
	MATRIX_PRAS2_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS2_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS2_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS2_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS2_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS2_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS2_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS2_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS2_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS2_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS2_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS2_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS2_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS2_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS2_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS2_M7PR_Msk = 0x30000000

	// PRBS2: Priority Register B for Slave 2
	// Position of M8PR field.
	MATRIX_PRBS2_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS2_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS2_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS2_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS2_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS2_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS2_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS2_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS2_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS2_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS2_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS2_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS2_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS2_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS2_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS2_M15PR_Msk = 0x30000000

	// PRAS3: Priority Register A for Slave 3
	// Position of M0PR field.
	MATRIX_PRAS3_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS3_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS3_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS3_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS3_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS3_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS3_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS3_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS3_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS3_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS3_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS3_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS3_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS3_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS3_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS3_M7PR_Msk = 0x30000000

	// PRBS3: Priority Register B for Slave 3
	// Position of M8PR field.
	MATRIX_PRBS3_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS3_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS3_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS3_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS3_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS3_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS3_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS3_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS3_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS3_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS3_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS3_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS3_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS3_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS3_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS3_M15PR_Msk = 0x30000000

	// PRAS4: Priority Register A for Slave 4
	// Position of M0PR field.
	MATRIX_PRAS4_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS4_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS4_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS4_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS4_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS4_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS4_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS4_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS4_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS4_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS4_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS4_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS4_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS4_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS4_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS4_M7PR_Msk = 0x30000000

	// PRBS4: Priority Register B for Slave 4
	// Position of M8PR field.
	MATRIX_PRBS4_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS4_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS4_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS4_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS4_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS4_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS4_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS4_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS4_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS4_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS4_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS4_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS4_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS4_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS4_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS4_M15PR_Msk = 0x30000000

	// PRAS5: Priority Register A for Slave 5
	// Position of M0PR field.
	MATRIX_PRAS5_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS5_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS5_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS5_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS5_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS5_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS5_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS5_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS5_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS5_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS5_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS5_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS5_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS5_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS5_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS5_M7PR_Msk = 0x30000000

	// PRBS5: Priority Register B for Slave 5
	// Position of M8PR field.
	MATRIX_PRBS5_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS5_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS5_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS5_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS5_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS5_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS5_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS5_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS5_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS5_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS5_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS5_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS5_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS5_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS5_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS5_M15PR_Msk = 0x30000000

	// PRAS6: Priority Register A for Slave 6
	// Position of M0PR field.
	MATRIX_PRAS6_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS6_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS6_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS6_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS6_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS6_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS6_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS6_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS6_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS6_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS6_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS6_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS6_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS6_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS6_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS6_M7PR_Msk = 0x30000000

	// PRBS6: Priority Register B for Slave 6
	// Position of M8PR field.
	MATRIX_PRBS6_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS6_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS6_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS6_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS6_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS6_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS6_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS6_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS6_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS6_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS6_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS6_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS6_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS6_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS6_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS6_M15PR_Msk = 0x30000000

	// PRAS7: Priority Register A for Slave 7
	// Position of M0PR field.
	MATRIX_PRAS7_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS7_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS7_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS7_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS7_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS7_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS7_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS7_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS7_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS7_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS7_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS7_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS7_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS7_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS7_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS7_M7PR_Msk = 0x30000000

	// PRBS7: Priority Register B for Slave 7
	// Position of M8PR field.
	MATRIX_PRBS7_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS7_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS7_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS7_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS7_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS7_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS7_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS7_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS7_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS7_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS7_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS7_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS7_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS7_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS7_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS7_M15PR_Msk = 0x30000000

	// PRAS8: Priority Register A for Slave 8
	// Position of M0PR field.
	MATRIX_PRAS8_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS8_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS8_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS8_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS8_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS8_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS8_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS8_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS8_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS8_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS8_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS8_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS8_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS8_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS8_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS8_M7PR_Msk = 0x30000000

	// PRBS8: Priority Register B for Slave 8
	// Position of M8PR field.
	MATRIX_PRBS8_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS8_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS8_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS8_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS8_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS8_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS8_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS8_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS8_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS8_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS8_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS8_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS8_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS8_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS8_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS8_M15PR_Msk = 0x30000000

	// PRAS9: Priority Register A for Slave 9
	// Position of M0PR field.
	MATRIX_PRAS9_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS9_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS9_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS9_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS9_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS9_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS9_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS9_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS9_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS9_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS9_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS9_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS9_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS9_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS9_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS9_M7PR_Msk = 0x30000000

	// PRBS9: Priority Register B for Slave 9
	// Position of M8PR field.
	MATRIX_PRBS9_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS9_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS9_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS9_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS9_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS9_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS9_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS9_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS9_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS9_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS9_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS9_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS9_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS9_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS9_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS9_M15PR_Msk = 0x30000000

	// PRAS10: Priority Register A for Slave 10
	// Position of M0PR field.
	MATRIX_PRAS10_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS10_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS10_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS10_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS10_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS10_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS10_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS10_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS10_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS10_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS10_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS10_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS10_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS10_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS10_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS10_M7PR_Msk = 0x30000000

	// PRBS10: Priority Register B for Slave 10
	// Position of M8PR field.
	MATRIX_PRBS10_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS10_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS10_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS10_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS10_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS10_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS10_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS10_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS10_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS10_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS10_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS10_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS10_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS10_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS10_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS10_M15PR_Msk = 0x30000000

	// PRAS11: Priority Register A for Slave 11
	// Position of M0PR field.
	MATRIX_PRAS11_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS11_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS11_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS11_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS11_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS11_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS11_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS11_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS11_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS11_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS11_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS11_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS11_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS11_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS11_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS11_M7PR_Msk = 0x30000000

	// PRBS11: Priority Register B for Slave 11
	// Position of M8PR field.
	MATRIX_PRBS11_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS11_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS11_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS11_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS11_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS11_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS11_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS11_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS11_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS11_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS11_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS11_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS11_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS11_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS11_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS11_M15PR_Msk = 0x30000000

	// PRAS12: Priority Register A for Slave 12
	// Position of M0PR field.
	MATRIX_PRAS12_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS12_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS12_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS12_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS12_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS12_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS12_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS12_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS12_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS12_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS12_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS12_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS12_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS12_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS12_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS12_M7PR_Msk = 0x30000000

	// PRBS12: Priority Register B for Slave 12
	// Position of M8PR field.
	MATRIX_PRBS12_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS12_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS12_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS12_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS12_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS12_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS12_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS12_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS12_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS12_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS12_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS12_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS12_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS12_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS12_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS12_M15PR_Msk = 0x30000000

	// PRAS13: Priority Register A for Slave 13
	// Position of M0PR field.
	MATRIX_PRAS13_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS13_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS13_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS13_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS13_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS13_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS13_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS13_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS13_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS13_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS13_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS13_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS13_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS13_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS13_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS13_M7PR_Msk = 0x30000000

	// PRBS13: Priority Register B for Slave 13
	// Position of M8PR field.
	MATRIX_PRBS13_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS13_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS13_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS13_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS13_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS13_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS13_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS13_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS13_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS13_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS13_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS13_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS13_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS13_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS13_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS13_M15PR_Msk = 0x30000000

	// PRAS14: Priority Register A for Slave 14
	// Position of M0PR field.
	MATRIX_PRAS14_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS14_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS14_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS14_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS14_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS14_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS14_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS14_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS14_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS14_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS14_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS14_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS14_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS14_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS14_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS14_M7PR_Msk = 0x30000000

	// PRBS14: Priority Register B for Slave 14
	// Position of M8PR field.
	MATRIX_PRBS14_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS14_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS14_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS14_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS14_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS14_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS14_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS14_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS14_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS14_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS14_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS14_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS14_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS14_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS14_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS14_M15PR_Msk = 0x30000000

	// PRAS15: Priority Register A for Slave 15
	// Position of M0PR field.
	MATRIX_PRAS15_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS15_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS15_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS15_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS15_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS15_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS15_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS15_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS15_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS15_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS15_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS15_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS15_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS15_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS15_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS15_M7PR_Msk = 0x30000000

	// PRBS15: Priority Register B for Slave 15
	// Position of M8PR field.
	MATRIX_PRBS15_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS15_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS15_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS15_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS15_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS15_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS15_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS15_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS15_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS15_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS15_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS15_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS15_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS15_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS15_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS15_M15PR_Msk = 0x30000000

	// MRCR: Master Remap Control Register
	// Position of RCB0 field.
	MATRIX_MRCR_RCB0_Pos = 0x0
	// Bit mask of RCB0 field.
	MATRIX_MRCR_RCB0_Msk = 0x1
	// Bit RCB0.
	MATRIX_MRCR_RCB0 = 0x1
	// Position of RCB1 field.
	MATRIX_MRCR_RCB1_Pos = 0x1
	// Bit mask of RCB1 field.
	MATRIX_MRCR_RCB1_Msk = 0x2
	// Bit RCB1.
	MATRIX_MRCR_RCB1 = 0x2
	// Position of RCB2 field.
	MATRIX_MRCR_RCB2_Pos = 0x2
	// Bit mask of RCB2 field.
	MATRIX_MRCR_RCB2_Msk = 0x4
	// Bit RCB2.
	MATRIX_MRCR_RCB2 = 0x4
	// Position of RCB3 field.
	MATRIX_MRCR_RCB3_Pos = 0x3
	// Bit mask of RCB3 field.
	MATRIX_MRCR_RCB3_Msk = 0x8
	// Bit RCB3.
	MATRIX_MRCR_RCB3 = 0x8
	// Position of RCB4 field.
	MATRIX_MRCR_RCB4_Pos = 0x4
	// Bit mask of RCB4 field.
	MATRIX_MRCR_RCB4_Msk = 0x10
	// Bit RCB4.
	MATRIX_MRCR_RCB4 = 0x10
	// Position of RCB5 field.
	MATRIX_MRCR_RCB5_Pos = 0x5
	// Bit mask of RCB5 field.
	MATRIX_MRCR_RCB5_Msk = 0x20
	// Bit RCB5.
	MATRIX_MRCR_RCB5 = 0x20
	// Position of RCB6 field.
	MATRIX_MRCR_RCB6_Pos = 0x6
	// Bit mask of RCB6 field.
	MATRIX_MRCR_RCB6_Msk = 0x40
	// Bit RCB6.
	MATRIX_MRCR_RCB6 = 0x40
	// Position of RCB7 field.
	MATRIX_MRCR_RCB7_Pos = 0x7
	// Bit mask of RCB7 field.
	MATRIX_MRCR_RCB7_Msk = 0x80
	// Bit RCB7.
	MATRIX_MRCR_RCB7 = 0x80
	// Position of RCB8 field.
	MATRIX_MRCR_RCB8_Pos = 0x8
	// Bit mask of RCB8 field.
	MATRIX_MRCR_RCB8_Msk = 0x100
	// Bit RCB8.
	MATRIX_MRCR_RCB8 = 0x100
	// Position of RCB9 field.
	MATRIX_MRCR_RCB9_Pos = 0x9
	// Bit mask of RCB9 field.
	MATRIX_MRCR_RCB9_Msk = 0x200
	// Bit RCB9.
	MATRIX_MRCR_RCB9 = 0x200
	// Position of RCB10 field.
	MATRIX_MRCR_RCB10_Pos = 0xa
	// Bit mask of RCB10 field.
	MATRIX_MRCR_RCB10_Msk = 0x400
	// Bit RCB10.
	MATRIX_MRCR_RCB10 = 0x400
	// Position of RCB11 field.
	MATRIX_MRCR_RCB11_Pos = 0xb
	// Bit mask of RCB11 field.
	MATRIX_MRCR_RCB11_Msk = 0x800
	// Bit RCB11.
	MATRIX_MRCR_RCB11 = 0x800
	// Position of RCB12 field.
	MATRIX_MRCR_RCB12_Pos = 0xc
	// Bit mask of RCB12 field.
	MATRIX_MRCR_RCB12_Msk = 0x1000
	// Bit RCB12.
	MATRIX_MRCR_RCB12 = 0x1000
	// Position of RCB13 field.
	MATRIX_MRCR_RCB13_Pos = 0xd
	// Bit mask of RCB13 field.
	MATRIX_MRCR_RCB13_Msk = 0x2000
	// Bit RCB13.
	MATRIX_MRCR_RCB13 = 0x2000
	// Position of RCB14 field.
	MATRIX_MRCR_RCB14_Pos = 0xe
	// Bit mask of RCB14 field.
	MATRIX_MRCR_RCB14_Msk = 0x4000
	// Bit RCB14.
	MATRIX_MRCR_RCB14 = 0x4000
	// Position of RCB15 field.
	MATRIX_MRCR_RCB15_Pos = 0xf
	// Bit mask of RCB15 field.
	MATRIX_MRCR_RCB15_Msk = 0x8000
	// Bit RCB15.
	MATRIX_MRCR_RCB15 = 0x8000

	// SFR: Special Function Register
	// Position of SFR field.
	MATRIX_SFR_SFR_Pos = 0x0
	// Bit mask of SFR field.
	MATRIX_SFR_SFR_Msk = 0xffffffff

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	MATRIX_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	MATRIX_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	MATRIX_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	MATRIX_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	MATRIX_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	MATRIX_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	MATRIX_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	MATRIX_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for DBGU: Debug Unit
const (
	// CR: Control Register
	// Position of RSTRX field.
	DBGU_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	DBGU_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	DBGU_CR_RSTRX = 0x4
	// Position of RSTTX field.
	DBGU_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	DBGU_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	DBGU_CR_RSTTX = 0x8
	// Position of RXEN field.
	DBGU_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	DBGU_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	DBGU_CR_RXEN = 0x10
	// Position of RXDIS field.
	DBGU_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	DBGU_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	DBGU_CR_RXDIS = 0x20
	// Position of TXEN field.
	DBGU_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	DBGU_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	DBGU_CR_TXEN = 0x40
	// Position of TXDIS field.
	DBGU_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	DBGU_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	DBGU_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	DBGU_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	DBGU_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	DBGU_CR_RSTSTA = 0x100

	// MR: Mode Register
	// Position of PAR field.
	DBGU_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	DBGU_MR_PAR_Msk = 0xe00
	// Even Parity
	DBGU_MR_PAR_EVEN = 0x0
	// Odd Parity
	DBGU_MR_PAR_ODD = 0x1
	// Space: Parity forced to 0
	DBGU_MR_PAR_SPACE = 0x2
	// Mark: Parity forced to 1
	DBGU_MR_PAR_MARK = 0x3
	// No Parity
	DBGU_MR_PAR_NONE = 0x4
	// Position of CHMODE field.
	DBGU_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	DBGU_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	DBGU_MR_CHMODE_NORM = 0x0
	// Automatic Echo
	DBGU_MR_CHMODE_AUTO = 0x1
	// Local Loopback
	DBGU_MR_CHMODE_LOCLOOP = 0x2
	// Remote Loopback
	DBGU_MR_CHMODE_REMLOOP = 0x3

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	DBGU_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IER_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IER_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IER_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IER_FRAME = 0x40
	// Position of PARE field.
	DBGU_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IER_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IER_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IER_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IER_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IER_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IER_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IER_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IER_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IER_COMMRX = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	DBGU_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IDR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IDR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IDR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IDR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IDR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IDR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IDR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IDR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IDR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IDR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IDR_COMMRX = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	DBGU_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IMR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IMR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IMR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IMR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IMR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IMR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IMR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IMR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IMR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IMR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IMR_COMMRX = 0x80000000

	// SR: Status Register
	// Position of RXRDY field.
	DBGU_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_SR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_SR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_SR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_SR_FRAME = 0x40
	// Position of PARE field.
	DBGU_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_SR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_SR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_SR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_SR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_SR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_SR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_SR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_SR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_SR_COMMRX = 0x80000000

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	DBGU_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	DBGU_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	DBGU_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	DBGU_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	DBGU_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	DBGU_BRGR_CD_Msk = 0xffff
	// DBGU Disabled
	DBGU_BRGR_CD_DISABLED = 0x0
	// MCK
	DBGU_BRGR_CD_MCK = 0x1

	// CIDR: Chip ID Register
	// Position of VERSION field.
	DBGU_CIDR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	DBGU_CIDR_VERSION_Msk = 0x1f
	// Position of EPROC field.
	DBGU_CIDR_EPROC_Pos = 0x5
	// Bit mask of EPROC field.
	DBGU_CIDR_EPROC_Msk = 0xe0
	// ARM946ES
	DBGU_CIDR_EPROC_ARM946ES = 0x1
	// ARM7TDMI
	DBGU_CIDR_EPROC_ARM7TDMI = 0x2
	// Cortex-M3
	DBGU_CIDR_EPROC_CM3 = 0x3
	// ARM920T
	DBGU_CIDR_EPROC_ARM920T = 0x4
	// ARM926EJS
	DBGU_CIDR_EPROC_ARM926EJS = 0x5
	// Cortex-A5
	DBGU_CIDR_EPROC_CA5 = 0x6
	// Position of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Pos = 0x8
	// Bit mask of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Msk = 0xf00
	// None
	DBGU_CIDR_NVPSIZ_NONE = 0x0
	// 8K bytes
	DBGU_CIDR_NVPSIZ_8K = 0x1
	// 16K bytes
	DBGU_CIDR_NVPSIZ_16K = 0x2
	// 32K bytes
	DBGU_CIDR_NVPSIZ_32K = 0x3
	// 64K bytes
	DBGU_CIDR_NVPSIZ_64K = 0x5
	// 128K bytes
	DBGU_CIDR_NVPSIZ_128K = 0x7
	// 256K bytes
	DBGU_CIDR_NVPSIZ_256K = 0x9
	// 512K bytes
	DBGU_CIDR_NVPSIZ_512K = 0xa
	// 1024K bytes
	DBGU_CIDR_NVPSIZ_1024K = 0xc
	// 2048K bytes
	DBGU_CIDR_NVPSIZ_2048K = 0xe
	// Position of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Pos = 0xc
	// Bit mask of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Msk = 0xf000
	// None
	DBGU_CIDR_NVPSIZ2_NONE = 0x0
	// 8K bytes
	DBGU_CIDR_NVPSIZ2_8K = 0x1
	// 16K bytes
	DBGU_CIDR_NVPSIZ2_16K = 0x2
	// 32K bytes
	DBGU_CIDR_NVPSIZ2_32K = 0x3
	// 64K bytes
	DBGU_CIDR_NVPSIZ2_64K = 0x5
	// 128K bytes
	DBGU_CIDR_NVPSIZ2_128K = 0x7
	// 256K bytes
	DBGU_CIDR_NVPSIZ2_256K = 0x9
	// 512K bytes
	DBGU_CIDR_NVPSIZ2_512K = 0xa
	// 1024K bytes
	DBGU_CIDR_NVPSIZ2_1024K = 0xc
	// 2048K bytes
	DBGU_CIDR_NVPSIZ2_2048K = 0xe
	// Position of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Pos = 0x10
	// Bit mask of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Msk = 0xf0000
	// 1K bytes
	DBGU_CIDR_SRAMSIZ_1K = 0x1
	// 2K bytes
	DBGU_CIDR_SRAMSIZ_2K = 0x2
	// 6K bytes
	DBGU_CIDR_SRAMSIZ_6K = 0x3
	// 112K bytes
	DBGU_CIDR_SRAMSIZ_112K = 0x4
	// 4K bytes
	DBGU_CIDR_SRAMSIZ_4K = 0x5
	// 80K bytes
	DBGU_CIDR_SRAMSIZ_80K = 0x6
	// 160K bytes
	DBGU_CIDR_SRAMSIZ_160K = 0x7
	// 8K bytes
	DBGU_CIDR_SRAMSIZ_8K = 0x8
	// 16K bytes
	DBGU_CIDR_SRAMSIZ_16K = 0x9
	// 32K bytes
	DBGU_CIDR_SRAMSIZ_32K = 0xa
	// 64K bytes
	DBGU_CIDR_SRAMSIZ_64K = 0xb
	// 128K bytes
	DBGU_CIDR_SRAMSIZ_128K = 0xc
	// 256K bytes
	DBGU_CIDR_SRAMSIZ_256K = 0xd
	// 96K bytes
	DBGU_CIDR_SRAMSIZ_96K = 0xe
	// 512K bytes
	DBGU_CIDR_SRAMSIZ_512K = 0xf
	// Position of ARCH field.
	DBGU_CIDR_ARCH_Pos = 0x14
	// Bit mask of ARCH field.
	DBGU_CIDR_ARCH_Msk = 0xff00000
	// AT91SAM9xx Series
	DBGU_CIDR_ARCH_AT91SAM9xx = 0x19
	// AT91SAM9XExx Series
	DBGU_CIDR_ARCH_AT91SAM9XExx = 0x29
	// AT91x34 Series
	DBGU_CIDR_ARCH_AT91x34 = 0x34
	// CAP7 Series
	DBGU_CIDR_ARCH_CAP7 = 0x37
	// CAP9 Series
	DBGU_CIDR_ARCH_CAP9 = 0x39
	// CAP11 Series
	DBGU_CIDR_ARCH_CAP11 = 0x3b
	// AT91x40 Series
	DBGU_CIDR_ARCH_AT91x40 = 0x40
	// AT91x42 Series
	DBGU_CIDR_ARCH_AT91x42 = 0x42
	// AT91x55 Series
	DBGU_CIDR_ARCH_AT91x55 = 0x55
	// AT91SAM7Axx Series
	DBGU_CIDR_ARCH_AT91SAM7Axx = 0x60
	// AT91SAM7AQxx Series
	DBGU_CIDR_ARCH_AT91SAM7AQxx = 0x61
	// AT91x63 Series
	DBGU_CIDR_ARCH_AT91x63 = 0x63
	// AT91SAM7Sxx Series
	DBGU_CIDR_ARCH_AT91SAM7Sxx = 0x70
	// AT91SAM7XCxx Series
	DBGU_CIDR_ARCH_AT91SAM7XCxx = 0x71
	// AT91SAM7SExx Series
	DBGU_CIDR_ARCH_AT91SAM7SExx = 0x72
	// AT91SAM7Lxx Series
	DBGU_CIDR_ARCH_AT91SAM7Lxx = 0x73
	// AT91SAM7Xxx Series
	DBGU_CIDR_ARCH_AT91SAM7Xxx = 0x75
	// AT91SAM7SLxx Series
	DBGU_CIDR_ARCH_AT91SAM7SLxx = 0x76
	// ATSAM3UxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3UxC = 0x80
	// ATSAM3UxE Series (144-pin version)
	DBGU_CIDR_ARCH_ATSAM3UxE = 0x81
	// ATSAM3AxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3AxC = 0x83
	// ATSAM3XxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxC = 0x84
	// ATSAM3XxE Series (144-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxE = 0x85
	// ATSAM3XxG Series (208/217-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxG = 0x86
	// ATSAM3SxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxA = 0x88
	// ATSAM3SxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxB = 0x89
	// ATSAM3SxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxC = 0x8a
	// AT91x92 Series
	DBGU_CIDR_ARCH_AT91x92 = 0x92
	// ATSAM3NxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxA = 0x93
	// ATSAM3NxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxB = 0x94
	// ATSAM3NxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxC = 0x95
	// ATSAM3SDxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxA = 0x98
	// ATSAM3SDxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxB = 0x99
	// ATSAM3SDxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxC = 0x9a
	// AT75Cxx Series
	DBGU_CIDR_ARCH_AT75Cxx = 0xf0
	// Position of NVPTYP field.
	DBGU_CIDR_NVPTYP_Pos = 0x1c
	// Bit mask of NVPTYP field.
	DBGU_CIDR_NVPTYP_Msk = 0x70000000
	// ROM
	DBGU_CIDR_NVPTYP_ROM = 0x0
	// ROMless or on-chip Flash
	DBGU_CIDR_NVPTYP_ROMLESS = 0x1
	// Embedded Flash Memory
	DBGU_CIDR_NVPTYP_FLASH = 0x2
	// ROM and Embedded Flash MemoryNVPSIZ is ROM size NVPSIZ2 is Flash size
	DBGU_CIDR_NVPTYP_ROM_FLASH = 0x3
	// SRAM emulating ROM
	DBGU_CIDR_NVPTYP_SRAM = 0x4
	// Position of EXT field.
	DBGU_CIDR_EXT_Pos = 0x1f
	// Bit mask of EXT field.
	DBGU_CIDR_EXT_Msk = 0x80000000
	// Bit EXT.
	DBGU_CIDR_EXT = 0x80000000

	// EXID: Chip ID Extension Register
	// Position of EXID field.
	DBGU_EXID_EXID_Pos = 0x0
	// Bit mask of EXID field.
	DBGU_EXID_EXID_Msk = 0xffffffff

	// FNR: Force NTRST Register
	// Position of FNTRST field.
	DBGU_FNR_FNTRST_Pos = 0x0
	// Bit mask of FNTRST field.
	DBGU_FNR_FNTRST_Msk = 0x1
	// Bit FNTRST.
	DBGU_FNR_FNTRST = 0x1
)

// Constants for AIC: Advanced Interrupt Controller
const (
	// SSR: Source Select Register
	// Position of INTSEL field.
	AIC_SSR_INTSEL_Pos = 0x0
	// Bit mask of INTSEL field.
	AIC_SSR_INTSEL_Msk = 0x7f

	// SMR: Source Mode Register
	// Position of PRIOR field.
	AIC_SMR_PRIOR_Pos = 0x0
	// Bit mask of PRIOR field.
	AIC_SMR_PRIOR_Msk = 0x7
	// Position of SRCTYPE field.
	AIC_SMR_SRCTYPE_Pos = 0x5
	// Bit mask of SRCTYPE field.
	AIC_SMR_SRCTYPE_Msk = 0x60
	// High level Sensitive for internal sourceLow level Sensitive for external source
	AIC_SMR_SRCTYPE_INT_LEVEL_SENSITIVE = 0x0
	// Positive edge triggered for internal sourceNegative edge triggered for external source
	AIC_SMR_SRCTYPE_INT_EDGE_TRIGGERED = 0x1
	// High level Sensitive for internal sourceHigh level Sensitive for external source
	AIC_SMR_SRCTYPE_EXT_HIGH_LEVEL = 0x2
	// Positive edge triggered for internal sourcePositive edge triggered for external source
	AIC_SMR_SRCTYPE_EXT_POSITIVE_EDGE = 0x3

	// SVR: Source Vector Register
	// Position of VECTOR field.
	AIC_SVR_VECTOR_Pos = 0x0
	// Bit mask of VECTOR field.
	AIC_SVR_VECTOR_Msk = 0xffffffff

	// IVR: Interrupt Vector Register
	// Position of IRQV field.
	AIC_IVR_IRQV_Pos = 0x0
	// Bit mask of IRQV field.
	AIC_IVR_IRQV_Msk = 0xffffffff

	// FVR: FIQ Interrupt Vector Register
	// Position of FIQV field.
	AIC_FVR_FIQV_Pos = 0x0
	// Bit mask of FIQV field.
	AIC_FVR_FIQV_Msk = 0xffffffff

	// ISR: Interrupt Status Register
	// Position of IRQID field.
	AIC_ISR_IRQID_Pos = 0x0
	// Bit mask of IRQID field.
	AIC_ISR_IRQID_Msk = 0x7f

	// IPR0: Interrupt Pending Register 0
	// Position of FIQ field.
	AIC_IPR0_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IPR0_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IPR0_FIQ = 0x1
	// Position of SYS field.
	AIC_IPR0_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IPR0_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IPR0_SYS = 0x2
	// Position of PID2 field.
	AIC_IPR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IPR0_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IPR0_PID2 = 0x4
	// Position of PID3 field.
	AIC_IPR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IPR0_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IPR0_PID3 = 0x8
	// Position of PID4 field.
	AIC_IPR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IPR0_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IPR0_PID4 = 0x10
	// Position of PID5 field.
	AIC_IPR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IPR0_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IPR0_PID5 = 0x20
	// Position of PID6 field.
	AIC_IPR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IPR0_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IPR0_PID6 = 0x40
	// Position of PID7 field.
	AIC_IPR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IPR0_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IPR0_PID7 = 0x80
	// Position of PID8 field.
	AIC_IPR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IPR0_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IPR0_PID8 = 0x100
	// Position of PID9 field.
	AIC_IPR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IPR0_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IPR0_PID9 = 0x200
	// Position of PID10 field.
	AIC_IPR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IPR0_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IPR0_PID10 = 0x400
	// Position of PID11 field.
	AIC_IPR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IPR0_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IPR0_PID11 = 0x800
	// Position of PID12 field.
	AIC_IPR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IPR0_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IPR0_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IPR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IPR0_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IPR0_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IPR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IPR0_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IPR0_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IPR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IPR0_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IPR0_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IPR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IPR0_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IPR0_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IPR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IPR0_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IPR0_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IPR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IPR0_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IPR0_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IPR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IPR0_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IPR0_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IPR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IPR0_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IPR0_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IPR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IPR0_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IPR0_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IPR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IPR0_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IPR0_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IPR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IPR0_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IPR0_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IPR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IPR0_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IPR0_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IPR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IPR0_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IPR0_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IPR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IPR0_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IPR0_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IPR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IPR0_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IPR0_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IPR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IPR0_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IPR0_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IPR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IPR0_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IPR0_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IPR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IPR0_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IPR0_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IPR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IPR0_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IPR0_PID31 = 0x80000000

	// IPR1: Interrupt Pending Register 1
	// Position of PID32 field.
	AIC_IPR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	AIC_IPR1_PID32_Msk = 0x1
	// Bit PID32.
	AIC_IPR1_PID32 = 0x1
	// Position of PID33 field.
	AIC_IPR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	AIC_IPR1_PID33_Msk = 0x2
	// Bit PID33.
	AIC_IPR1_PID33 = 0x2
	// Position of PID34 field.
	AIC_IPR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	AIC_IPR1_PID34_Msk = 0x4
	// Bit PID34.
	AIC_IPR1_PID34 = 0x4
	// Position of PID35 field.
	AIC_IPR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	AIC_IPR1_PID35_Msk = 0x8
	// Bit PID35.
	AIC_IPR1_PID35 = 0x8
	// Position of PID36 field.
	AIC_IPR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	AIC_IPR1_PID36_Msk = 0x10
	// Bit PID36.
	AIC_IPR1_PID36 = 0x10
	// Position of PID37 field.
	AIC_IPR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	AIC_IPR1_PID37_Msk = 0x20
	// Bit PID37.
	AIC_IPR1_PID37 = 0x20
	// Position of PID38 field.
	AIC_IPR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	AIC_IPR1_PID38_Msk = 0x40
	// Bit PID38.
	AIC_IPR1_PID38 = 0x40
	// Position of PID39 field.
	AIC_IPR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	AIC_IPR1_PID39_Msk = 0x80
	// Bit PID39.
	AIC_IPR1_PID39 = 0x80
	// Position of PID40 field.
	AIC_IPR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	AIC_IPR1_PID40_Msk = 0x100
	// Bit PID40.
	AIC_IPR1_PID40 = 0x100
	// Position of PID41 field.
	AIC_IPR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	AIC_IPR1_PID41_Msk = 0x200
	// Bit PID41.
	AIC_IPR1_PID41 = 0x200
	// Position of PID42 field.
	AIC_IPR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	AIC_IPR1_PID42_Msk = 0x400
	// Bit PID42.
	AIC_IPR1_PID42 = 0x400
	// Position of PID43 field.
	AIC_IPR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	AIC_IPR1_PID43_Msk = 0x800
	// Bit PID43.
	AIC_IPR1_PID43 = 0x800
	// Position of PID44 field.
	AIC_IPR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	AIC_IPR1_PID44_Msk = 0x1000
	// Bit PID44.
	AIC_IPR1_PID44 = 0x1000
	// Position of PID45 field.
	AIC_IPR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	AIC_IPR1_PID45_Msk = 0x2000
	// Bit PID45.
	AIC_IPR1_PID45 = 0x2000
	// Position of PID46 field.
	AIC_IPR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	AIC_IPR1_PID46_Msk = 0x4000
	// Bit PID46.
	AIC_IPR1_PID46 = 0x4000
	// Position of PID47 field.
	AIC_IPR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	AIC_IPR1_PID47_Msk = 0x8000
	// Bit PID47.
	AIC_IPR1_PID47 = 0x8000
	// Position of PID48 field.
	AIC_IPR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	AIC_IPR1_PID48_Msk = 0x10000
	// Bit PID48.
	AIC_IPR1_PID48 = 0x10000
	// Position of PID49 field.
	AIC_IPR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	AIC_IPR1_PID49_Msk = 0x20000
	// Bit PID49.
	AIC_IPR1_PID49 = 0x20000
	// Position of PID50 field.
	AIC_IPR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	AIC_IPR1_PID50_Msk = 0x40000
	// Bit PID50.
	AIC_IPR1_PID50 = 0x40000
	// Position of PID51 field.
	AIC_IPR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	AIC_IPR1_PID51_Msk = 0x80000
	// Bit PID51.
	AIC_IPR1_PID51 = 0x80000
	// Position of PID52 field.
	AIC_IPR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	AIC_IPR1_PID52_Msk = 0x100000
	// Bit PID52.
	AIC_IPR1_PID52 = 0x100000
	// Position of PID53 field.
	AIC_IPR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	AIC_IPR1_PID53_Msk = 0x200000
	// Bit PID53.
	AIC_IPR1_PID53 = 0x200000
	// Position of PID54 field.
	AIC_IPR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	AIC_IPR1_PID54_Msk = 0x400000
	// Bit PID54.
	AIC_IPR1_PID54 = 0x400000
	// Position of PID55 field.
	AIC_IPR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	AIC_IPR1_PID55_Msk = 0x800000
	// Bit PID55.
	AIC_IPR1_PID55 = 0x800000
	// Position of PID56 field.
	AIC_IPR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	AIC_IPR1_PID56_Msk = 0x1000000
	// Bit PID56.
	AIC_IPR1_PID56 = 0x1000000
	// Position of PID57 field.
	AIC_IPR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	AIC_IPR1_PID57_Msk = 0x2000000
	// Bit PID57.
	AIC_IPR1_PID57 = 0x2000000
	// Position of PID58 field.
	AIC_IPR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	AIC_IPR1_PID58_Msk = 0x4000000
	// Bit PID58.
	AIC_IPR1_PID58 = 0x4000000
	// Position of PID59 field.
	AIC_IPR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	AIC_IPR1_PID59_Msk = 0x8000000
	// Bit PID59.
	AIC_IPR1_PID59 = 0x8000000
	// Position of PID60 field.
	AIC_IPR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	AIC_IPR1_PID60_Msk = 0x10000000
	// Bit PID60.
	AIC_IPR1_PID60 = 0x10000000
	// Position of PID61 field.
	AIC_IPR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	AIC_IPR1_PID61_Msk = 0x20000000
	// Bit PID61.
	AIC_IPR1_PID61 = 0x20000000
	// Position of PID62 field.
	AIC_IPR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	AIC_IPR1_PID62_Msk = 0x40000000
	// Bit PID62.
	AIC_IPR1_PID62 = 0x40000000
	// Position of PID63 field.
	AIC_IPR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	AIC_IPR1_PID63_Msk = 0x80000000
	// Bit PID63.
	AIC_IPR1_PID63 = 0x80000000

	// IPR2: Interrupt Pending Register 2
	// Position of PID64 field.
	AIC_IPR2_PID64_Pos = 0x0
	// Bit mask of PID64 field.
	AIC_IPR2_PID64_Msk = 0x1
	// Bit PID64.
	AIC_IPR2_PID64 = 0x1
	// Position of PID65 field.
	AIC_IPR2_PID65_Pos = 0x1
	// Bit mask of PID65 field.
	AIC_IPR2_PID65_Msk = 0x2
	// Bit PID65.
	AIC_IPR2_PID65 = 0x2
	// Position of PID66 field.
	AIC_IPR2_PID66_Pos = 0x2
	// Bit mask of PID66 field.
	AIC_IPR2_PID66_Msk = 0x4
	// Bit PID66.
	AIC_IPR2_PID66 = 0x4
	// Position of PID67 field.
	AIC_IPR2_PID67_Pos = 0x3
	// Bit mask of PID67 field.
	AIC_IPR2_PID67_Msk = 0x8
	// Bit PID67.
	AIC_IPR2_PID67 = 0x8
	// Position of PID68 field.
	AIC_IPR2_PID68_Pos = 0x4
	// Bit mask of PID68 field.
	AIC_IPR2_PID68_Msk = 0x10
	// Bit PID68.
	AIC_IPR2_PID68 = 0x10
	// Position of PID69 field.
	AIC_IPR2_PID69_Pos = 0x5
	// Bit mask of PID69 field.
	AIC_IPR2_PID69_Msk = 0x20
	// Bit PID69.
	AIC_IPR2_PID69 = 0x20
	// Position of PID70 field.
	AIC_IPR2_PID70_Pos = 0x6
	// Bit mask of PID70 field.
	AIC_IPR2_PID70_Msk = 0x40
	// Bit PID70.
	AIC_IPR2_PID70 = 0x40
	// Position of PID71 field.
	AIC_IPR2_PID71_Pos = 0x7
	// Bit mask of PID71 field.
	AIC_IPR2_PID71_Msk = 0x80
	// Bit PID71.
	AIC_IPR2_PID71 = 0x80
	// Position of PID72 field.
	AIC_IPR2_PID72_Pos = 0x8
	// Bit mask of PID72 field.
	AIC_IPR2_PID72_Msk = 0x100
	// Bit PID72.
	AIC_IPR2_PID72 = 0x100
	// Position of PID73 field.
	AIC_IPR2_PID73_Pos = 0x9
	// Bit mask of PID73 field.
	AIC_IPR2_PID73_Msk = 0x200
	// Bit PID73.
	AIC_IPR2_PID73 = 0x200
	// Position of PID74 field.
	AIC_IPR2_PID74_Pos = 0xa
	// Bit mask of PID74 field.
	AIC_IPR2_PID74_Msk = 0x400
	// Bit PID74.
	AIC_IPR2_PID74 = 0x400
	// Position of PID75 field.
	AIC_IPR2_PID75_Pos = 0xb
	// Bit mask of PID75 field.
	AIC_IPR2_PID75_Msk = 0x800
	// Bit PID75.
	AIC_IPR2_PID75 = 0x800
	// Position of PID76 field.
	AIC_IPR2_PID76_Pos = 0xc
	// Bit mask of PID76 field.
	AIC_IPR2_PID76_Msk = 0x1000
	// Bit PID76.
	AIC_IPR2_PID76 = 0x1000
	// Position of PID77 field.
	AIC_IPR2_PID77_Pos = 0xd
	// Bit mask of PID77 field.
	AIC_IPR2_PID77_Msk = 0x2000
	// Bit PID77.
	AIC_IPR2_PID77 = 0x2000
	// Position of PID78 field.
	AIC_IPR2_PID78_Pos = 0xe
	// Bit mask of PID78 field.
	AIC_IPR2_PID78_Msk = 0x4000
	// Bit PID78.
	AIC_IPR2_PID78 = 0x4000
	// Position of PID79 field.
	AIC_IPR2_PID79_Pos = 0xf
	// Bit mask of PID79 field.
	AIC_IPR2_PID79_Msk = 0x8000
	// Bit PID79.
	AIC_IPR2_PID79 = 0x8000
	// Position of PID80 field.
	AIC_IPR2_PID80_Pos = 0x10
	// Bit mask of PID80 field.
	AIC_IPR2_PID80_Msk = 0x10000
	// Bit PID80.
	AIC_IPR2_PID80 = 0x10000
	// Position of PID81 field.
	AIC_IPR2_PID81_Pos = 0x11
	// Bit mask of PID81 field.
	AIC_IPR2_PID81_Msk = 0x20000
	// Bit PID81.
	AIC_IPR2_PID81 = 0x20000
	// Position of PID82 field.
	AIC_IPR2_PID82_Pos = 0x12
	// Bit mask of PID82 field.
	AIC_IPR2_PID82_Msk = 0x40000
	// Bit PID82.
	AIC_IPR2_PID82 = 0x40000
	// Position of PID83 field.
	AIC_IPR2_PID83_Pos = 0x13
	// Bit mask of PID83 field.
	AIC_IPR2_PID83_Msk = 0x80000
	// Bit PID83.
	AIC_IPR2_PID83 = 0x80000
	// Position of PID84 field.
	AIC_IPR2_PID84_Pos = 0x14
	// Bit mask of PID84 field.
	AIC_IPR2_PID84_Msk = 0x100000
	// Bit PID84.
	AIC_IPR2_PID84 = 0x100000
	// Position of PID85 field.
	AIC_IPR2_PID85_Pos = 0x15
	// Bit mask of PID85 field.
	AIC_IPR2_PID85_Msk = 0x200000
	// Bit PID85.
	AIC_IPR2_PID85 = 0x200000
	// Position of PID86 field.
	AIC_IPR2_PID86_Pos = 0x16
	// Bit mask of PID86 field.
	AIC_IPR2_PID86_Msk = 0x400000
	// Bit PID86.
	AIC_IPR2_PID86 = 0x400000
	// Position of PID87 field.
	AIC_IPR2_PID87_Pos = 0x17
	// Bit mask of PID87 field.
	AIC_IPR2_PID87_Msk = 0x800000
	// Bit PID87.
	AIC_IPR2_PID87 = 0x800000
	// Position of PID88 field.
	AIC_IPR2_PID88_Pos = 0x18
	// Bit mask of PID88 field.
	AIC_IPR2_PID88_Msk = 0x1000000
	// Bit PID88.
	AIC_IPR2_PID88 = 0x1000000
	// Position of PID89 field.
	AIC_IPR2_PID89_Pos = 0x19
	// Bit mask of PID89 field.
	AIC_IPR2_PID89_Msk = 0x2000000
	// Bit PID89.
	AIC_IPR2_PID89 = 0x2000000
	// Position of PID90 field.
	AIC_IPR2_PID90_Pos = 0x1a
	// Bit mask of PID90 field.
	AIC_IPR2_PID90_Msk = 0x4000000
	// Bit PID90.
	AIC_IPR2_PID90 = 0x4000000
	// Position of PID91 field.
	AIC_IPR2_PID91_Pos = 0x1b
	// Bit mask of PID91 field.
	AIC_IPR2_PID91_Msk = 0x8000000
	// Bit PID91.
	AIC_IPR2_PID91 = 0x8000000
	// Position of PID92 field.
	AIC_IPR2_PID92_Pos = 0x1c
	// Bit mask of PID92 field.
	AIC_IPR2_PID92_Msk = 0x10000000
	// Bit PID92.
	AIC_IPR2_PID92 = 0x10000000
	// Position of PID93 field.
	AIC_IPR2_PID93_Pos = 0x1d
	// Bit mask of PID93 field.
	AIC_IPR2_PID93_Msk = 0x20000000
	// Bit PID93.
	AIC_IPR2_PID93 = 0x20000000
	// Position of PID94 field.
	AIC_IPR2_PID94_Pos = 0x1e
	// Bit mask of PID94 field.
	AIC_IPR2_PID94_Msk = 0x40000000
	// Bit PID94.
	AIC_IPR2_PID94 = 0x40000000
	// Position of PID95 field.
	AIC_IPR2_PID95_Pos = 0x1f
	// Bit mask of PID95 field.
	AIC_IPR2_PID95_Msk = 0x80000000
	// Bit PID95.
	AIC_IPR2_PID95 = 0x80000000

	// IPR3: Interrupt Pending Register 3
	// Position of PID96 field.
	AIC_IPR3_PID96_Pos = 0x0
	// Bit mask of PID96 field.
	AIC_IPR3_PID96_Msk = 0x1
	// Bit PID96.
	AIC_IPR3_PID96 = 0x1
	// Position of PID97 field.
	AIC_IPR3_PID97_Pos = 0x1
	// Bit mask of PID97 field.
	AIC_IPR3_PID97_Msk = 0x2
	// Bit PID97.
	AIC_IPR3_PID97 = 0x2
	// Position of PID98 field.
	AIC_IPR3_PID98_Pos = 0x2
	// Bit mask of PID98 field.
	AIC_IPR3_PID98_Msk = 0x4
	// Bit PID98.
	AIC_IPR3_PID98 = 0x4
	// Position of PID99 field.
	AIC_IPR3_PID99_Pos = 0x3
	// Bit mask of PID99 field.
	AIC_IPR3_PID99_Msk = 0x8
	// Bit PID99.
	AIC_IPR3_PID99 = 0x8
	// Position of PID100 field.
	AIC_IPR3_PID100_Pos = 0x4
	// Bit mask of PID100 field.
	AIC_IPR3_PID100_Msk = 0x10
	// Bit PID100.
	AIC_IPR3_PID100 = 0x10
	// Position of PID101 field.
	AIC_IPR3_PID101_Pos = 0x5
	// Bit mask of PID101 field.
	AIC_IPR3_PID101_Msk = 0x20
	// Bit PID101.
	AIC_IPR3_PID101 = 0x20
	// Position of PID102 field.
	AIC_IPR3_PID102_Pos = 0x6
	// Bit mask of PID102 field.
	AIC_IPR3_PID102_Msk = 0x40
	// Bit PID102.
	AIC_IPR3_PID102 = 0x40
	// Position of PID103 field.
	AIC_IPR3_PID103_Pos = 0x7
	// Bit mask of PID103 field.
	AIC_IPR3_PID103_Msk = 0x80
	// Bit PID103.
	AIC_IPR3_PID103 = 0x80
	// Position of PID104 field.
	AIC_IPR3_PID104_Pos = 0x8
	// Bit mask of PID104 field.
	AIC_IPR3_PID104_Msk = 0x100
	// Bit PID104.
	AIC_IPR3_PID104 = 0x100
	// Position of PID105 field.
	AIC_IPR3_PID105_Pos = 0x9
	// Bit mask of PID105 field.
	AIC_IPR3_PID105_Msk = 0x200
	// Bit PID105.
	AIC_IPR3_PID105 = 0x200
	// Position of PID106 field.
	AIC_IPR3_PID106_Pos = 0xa
	// Bit mask of PID106 field.
	AIC_IPR3_PID106_Msk = 0x400
	// Bit PID106.
	AIC_IPR3_PID106 = 0x400
	// Position of PID107 field.
	AIC_IPR3_PID107_Pos = 0xb
	// Bit mask of PID107 field.
	AIC_IPR3_PID107_Msk = 0x800
	// Bit PID107.
	AIC_IPR3_PID107 = 0x800
	// Position of PID108 field.
	AIC_IPR3_PID108_Pos = 0xc
	// Bit mask of PID108 field.
	AIC_IPR3_PID108_Msk = 0x1000
	// Bit PID108.
	AIC_IPR3_PID108 = 0x1000
	// Position of PID109 field.
	AIC_IPR3_PID109_Pos = 0xd
	// Bit mask of PID109 field.
	AIC_IPR3_PID109_Msk = 0x2000
	// Bit PID109.
	AIC_IPR3_PID109 = 0x2000
	// Position of PID110 field.
	AIC_IPR3_PID110_Pos = 0xe
	// Bit mask of PID110 field.
	AIC_IPR3_PID110_Msk = 0x4000
	// Bit PID110.
	AIC_IPR3_PID110 = 0x4000
	// Position of PID111 field.
	AIC_IPR3_PID111_Pos = 0xf
	// Bit mask of PID111 field.
	AIC_IPR3_PID111_Msk = 0x8000
	// Bit PID111.
	AIC_IPR3_PID111 = 0x8000
	// Position of PID112 field.
	AIC_IPR3_PID112_Pos = 0x10
	// Bit mask of PID112 field.
	AIC_IPR3_PID112_Msk = 0x10000
	// Bit PID112.
	AIC_IPR3_PID112 = 0x10000
	// Position of PID113 field.
	AIC_IPR3_PID113_Pos = 0x11
	// Bit mask of PID113 field.
	AIC_IPR3_PID113_Msk = 0x20000
	// Bit PID113.
	AIC_IPR3_PID113 = 0x20000
	// Position of PID114 field.
	AIC_IPR3_PID114_Pos = 0x12
	// Bit mask of PID114 field.
	AIC_IPR3_PID114_Msk = 0x40000
	// Bit PID114.
	AIC_IPR3_PID114 = 0x40000
	// Position of PID115 field.
	AIC_IPR3_PID115_Pos = 0x13
	// Bit mask of PID115 field.
	AIC_IPR3_PID115_Msk = 0x80000
	// Bit PID115.
	AIC_IPR3_PID115 = 0x80000
	// Position of PID116 field.
	AIC_IPR3_PID116_Pos = 0x14
	// Bit mask of PID116 field.
	AIC_IPR3_PID116_Msk = 0x100000
	// Bit PID116.
	AIC_IPR3_PID116 = 0x100000
	// Position of PID117 field.
	AIC_IPR3_PID117_Pos = 0x15
	// Bit mask of PID117 field.
	AIC_IPR3_PID117_Msk = 0x200000
	// Bit PID117.
	AIC_IPR3_PID117 = 0x200000
	// Position of PID118 field.
	AIC_IPR3_PID118_Pos = 0x16
	// Bit mask of PID118 field.
	AIC_IPR3_PID118_Msk = 0x400000
	// Bit PID118.
	AIC_IPR3_PID118 = 0x400000
	// Position of PID119 field.
	AIC_IPR3_PID119_Pos = 0x17
	// Bit mask of PID119 field.
	AIC_IPR3_PID119_Msk = 0x800000
	// Bit PID119.
	AIC_IPR3_PID119 = 0x800000
	// Position of PID120 field.
	AIC_IPR3_PID120_Pos = 0x18
	// Bit mask of PID120 field.
	AIC_IPR3_PID120_Msk = 0x1000000
	// Bit PID120.
	AIC_IPR3_PID120 = 0x1000000
	// Position of PID121 field.
	AIC_IPR3_PID121_Pos = 0x19
	// Bit mask of PID121 field.
	AIC_IPR3_PID121_Msk = 0x2000000
	// Bit PID121.
	AIC_IPR3_PID121 = 0x2000000
	// Position of PID122 field.
	AIC_IPR3_PID122_Pos = 0x1a
	// Bit mask of PID122 field.
	AIC_IPR3_PID122_Msk = 0x4000000
	// Bit PID122.
	AIC_IPR3_PID122 = 0x4000000
	// Position of PID123 field.
	AIC_IPR3_PID123_Pos = 0x1b
	// Bit mask of PID123 field.
	AIC_IPR3_PID123_Msk = 0x8000000
	// Bit PID123.
	AIC_IPR3_PID123 = 0x8000000
	// Position of PID124 field.
	AIC_IPR3_PID124_Pos = 0x1c
	// Bit mask of PID124 field.
	AIC_IPR3_PID124_Msk = 0x10000000
	// Bit PID124.
	AIC_IPR3_PID124 = 0x10000000
	// Position of PID125 field.
	AIC_IPR3_PID125_Pos = 0x1d
	// Bit mask of PID125 field.
	AIC_IPR3_PID125_Msk = 0x20000000
	// Bit PID125.
	AIC_IPR3_PID125 = 0x20000000
	// Position of PID126 field.
	AIC_IPR3_PID126_Pos = 0x1e
	// Bit mask of PID126 field.
	AIC_IPR3_PID126_Msk = 0x40000000
	// Bit PID126.
	AIC_IPR3_PID126 = 0x40000000
	// Position of PID127 field.
	AIC_IPR3_PID127_Pos = 0x1f
	// Bit mask of PID127 field.
	AIC_IPR3_PID127_Msk = 0x80000000
	// Bit PID127.
	AIC_IPR3_PID127 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of INTM field.
	AIC_IMR_INTM_Pos = 0x0
	// Bit mask of INTM field.
	AIC_IMR_INTM_Msk = 0x1
	// Bit INTM.
	AIC_IMR_INTM = 0x1

	// CISR: Core Interrupt Status Register
	// Position of NFIQ field.
	AIC_CISR_NFIQ_Pos = 0x0
	// Bit mask of NFIQ field.
	AIC_CISR_NFIQ_Msk = 0x1
	// Bit NFIQ.
	AIC_CISR_NFIQ = 0x1
	// Position of NIRQ field.
	AIC_CISR_NIRQ_Pos = 0x1
	// Bit mask of NIRQ field.
	AIC_CISR_NIRQ_Msk = 0x2
	// Bit NIRQ.
	AIC_CISR_NIRQ = 0x2

	// EOICR: End of Interrupt Command Register
	// Position of ENDIT field.
	AIC_EOICR_ENDIT_Pos = 0x0
	// Bit mask of ENDIT field.
	AIC_EOICR_ENDIT_Msk = 0x1
	// Bit ENDIT.
	AIC_EOICR_ENDIT = 0x1

	// SPU: Spurious Interrupt Vector Register
	// Position of SIVR field.
	AIC_SPU_SIVR_Pos = 0x0
	// Bit mask of SIVR field.
	AIC_SPU_SIVR_Msk = 0xffffffff

	// IECR: Interrupt Enable Command Register
	// Position of INTEN field.
	AIC_IECR_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	AIC_IECR_INTEN_Msk = 0x1
	// Bit INTEN.
	AIC_IECR_INTEN = 0x1

	// IDCR: Interrupt Disable Command Register
	// Position of INTD field.
	AIC_IDCR_INTD_Pos = 0x0
	// Bit mask of INTD field.
	AIC_IDCR_INTD_Msk = 0x1
	// Bit INTD.
	AIC_IDCR_INTD = 0x1

	// ICCR: Interrupt Clear Command Register
	// Position of INTCLR field.
	AIC_ICCR_INTCLR_Pos = 0x0
	// Bit mask of INTCLR field.
	AIC_ICCR_INTCLR_Msk = 0x1
	// Bit INTCLR.
	AIC_ICCR_INTCLR = 0x1

	// ISCR: Interrupt Set Command Register
	// Position of INTSET field.
	AIC_ISCR_INTSET_Pos = 0x0
	// Bit mask of INTSET field.
	AIC_ISCR_INTSET_Msk = 0x1
	// Bit INTSET.
	AIC_ISCR_INTSET = 0x1

	// FFER: Fast Forcing Enable Register
	// Position of FFEN field.
	AIC_FFER_FFEN_Pos = 0x0
	// Bit mask of FFEN field.
	AIC_FFER_FFEN_Msk = 0x1
	// Bit FFEN.
	AIC_FFER_FFEN = 0x1

	// FFDR: Fast Forcing Disable Register
	// Position of FFDIS field.
	AIC_FFDR_FFDIS_Pos = 0x0
	// Bit mask of FFDIS field.
	AIC_FFDR_FFDIS_Msk = 0x1
	// Bit FFDIS.
	AIC_FFDR_FFDIS = 0x1

	// FFSR: Fast Forcing Status Register
	// Position of FFS field.
	AIC_FFSR_FFS_Pos = 0x0
	// Bit mask of FFS field.
	AIC_FFSR_FFS_Msk = 0x1
	// Bit FFS.
	AIC_FFSR_FFS = 0x1

	// DCR: Debug Control Register
	// Position of PROT field.
	AIC_DCR_PROT_Pos = 0x0
	// Bit mask of PROT field.
	AIC_DCR_PROT_Msk = 0x1
	// Bit PROT.
	AIC_DCR_PROT = 0x1
	// Position of GMSK field.
	AIC_DCR_GMSK_Pos = 0x1
	// Bit mask of GMSK field.
	AIC_DCR_GMSK_Msk = 0x2
	// Bit GMSK.
	AIC_DCR_GMSK = 0x2

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	AIC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	AIC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	AIC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	AIC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	AIC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	AIC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	AIC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	AIC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	AIC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	AIC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for PIOA: Parallel Input/Output Controller A
const (
	// PER: PIO Enable Register
	// Position of P0 field.
	PIO_PER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PER_P0_Msk = 0x1
	// Bit P0.
	PIO_PER_P0 = 0x1
	// Position of P1 field.
	PIO_PER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PER_P1_Msk = 0x2
	// Bit P1.
	PIO_PER_P1 = 0x2
	// Position of P2 field.
	PIO_PER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PER_P2_Msk = 0x4
	// Bit P2.
	PIO_PER_P2 = 0x4
	// Position of P3 field.
	PIO_PER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PER_P3_Msk = 0x8
	// Bit P3.
	PIO_PER_P3 = 0x8
	// Position of P4 field.
	PIO_PER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PER_P4_Msk = 0x10
	// Bit P4.
	PIO_PER_P4 = 0x10
	// Position of P5 field.
	PIO_PER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PER_P5_Msk = 0x20
	// Bit P5.
	PIO_PER_P5 = 0x20
	// Position of P6 field.
	PIO_PER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PER_P6_Msk = 0x40
	// Bit P6.
	PIO_PER_P6 = 0x40
	// Position of P7 field.
	PIO_PER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PER_P7_Msk = 0x80
	// Bit P7.
	PIO_PER_P7 = 0x80
	// Position of P8 field.
	PIO_PER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PER_P8_Msk = 0x100
	// Bit P8.
	PIO_PER_P8 = 0x100
	// Position of P9 field.
	PIO_PER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PER_P9_Msk = 0x200
	// Bit P9.
	PIO_PER_P9 = 0x200
	// Position of P10 field.
	PIO_PER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PER_P10_Msk = 0x400
	// Bit P10.
	PIO_PER_P10 = 0x400
	// Position of P11 field.
	PIO_PER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PER_P11_Msk = 0x800
	// Bit P11.
	PIO_PER_P11 = 0x800
	// Position of P12 field.
	PIO_PER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PER_P12 = 0x1000
	// Position of P13 field.
	PIO_PER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PER_P13 = 0x2000
	// Position of P14 field.
	PIO_PER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PER_P14 = 0x4000
	// Position of P15 field.
	PIO_PER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PER_P15 = 0x8000
	// Position of P16 field.
	PIO_PER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PER_P16 = 0x10000
	// Position of P17 field.
	PIO_PER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PER_P17 = 0x20000
	// Position of P18 field.
	PIO_PER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PER_P18 = 0x40000
	// Position of P19 field.
	PIO_PER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PER_P19 = 0x80000
	// Position of P20 field.
	PIO_PER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PER_P20 = 0x100000
	// Position of P21 field.
	PIO_PER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PER_P21 = 0x200000
	// Position of P22 field.
	PIO_PER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PER_P22 = 0x400000
	// Position of P23 field.
	PIO_PER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PER_P23 = 0x800000
	// Position of P24 field.
	PIO_PER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PER_P31 = 0x80000000

	// PDR: PIO Disable Register
	// Position of P0 field.
	PIO_PDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDR_P0 = 0x1
	// Position of P1 field.
	PIO_PDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDR_P1 = 0x2
	// Position of P2 field.
	PIO_PDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDR_P2 = 0x4
	// Position of P3 field.
	PIO_PDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDR_P3 = 0x8
	// Position of P4 field.
	PIO_PDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDR_P4 = 0x10
	// Position of P5 field.
	PIO_PDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDR_P5 = 0x20
	// Position of P6 field.
	PIO_PDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDR_P6 = 0x40
	// Position of P7 field.
	PIO_PDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDR_P7 = 0x80
	// Position of P8 field.
	PIO_PDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDR_P8 = 0x100
	// Position of P9 field.
	PIO_PDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDR_P9 = 0x200
	// Position of P10 field.
	PIO_PDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDR_P10 = 0x400
	// Position of P11 field.
	PIO_PDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDR_P11 = 0x800
	// Position of P12 field.
	PIO_PDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDR_P31 = 0x80000000

	// PSR: PIO Status Register
	// Position of P0 field.
	PIO_PSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PSR_P0 = 0x1
	// Position of P1 field.
	PIO_PSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PSR_P1 = 0x2
	// Position of P2 field.
	PIO_PSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PSR_P2 = 0x4
	// Position of P3 field.
	PIO_PSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PSR_P3 = 0x8
	// Position of P4 field.
	PIO_PSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PSR_P4 = 0x10
	// Position of P5 field.
	PIO_PSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PSR_P5 = 0x20
	// Position of P6 field.
	PIO_PSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PSR_P6 = 0x40
	// Position of P7 field.
	PIO_PSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PSR_P7 = 0x80
	// Position of P8 field.
	PIO_PSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PSR_P8 = 0x100
	// Position of P9 field.
	PIO_PSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PSR_P9 = 0x200
	// Position of P10 field.
	PIO_PSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PSR_P10 = 0x400
	// Position of P11 field.
	PIO_PSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PSR_P11 = 0x800
	// Position of P12 field.
	PIO_PSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PSR_P31 = 0x80000000

	// OER: Output Enable Register
	// Position of P0 field.
	PIO_OER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OER_P0_Msk = 0x1
	// Bit P0.
	PIO_OER_P0 = 0x1
	// Position of P1 field.
	PIO_OER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OER_P1_Msk = 0x2
	// Bit P1.
	PIO_OER_P1 = 0x2
	// Position of P2 field.
	PIO_OER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OER_P2_Msk = 0x4
	// Bit P2.
	PIO_OER_P2 = 0x4
	// Position of P3 field.
	PIO_OER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OER_P3_Msk = 0x8
	// Bit P3.
	PIO_OER_P3 = 0x8
	// Position of P4 field.
	PIO_OER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OER_P4_Msk = 0x10
	// Bit P4.
	PIO_OER_P4 = 0x10
	// Position of P5 field.
	PIO_OER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OER_P5_Msk = 0x20
	// Bit P5.
	PIO_OER_P5 = 0x20
	// Position of P6 field.
	PIO_OER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OER_P6_Msk = 0x40
	// Bit P6.
	PIO_OER_P6 = 0x40
	// Position of P7 field.
	PIO_OER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OER_P7_Msk = 0x80
	// Bit P7.
	PIO_OER_P7 = 0x80
	// Position of P8 field.
	PIO_OER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OER_P8_Msk = 0x100
	// Bit P8.
	PIO_OER_P8 = 0x100
	// Position of P9 field.
	PIO_OER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OER_P9_Msk = 0x200
	// Bit P9.
	PIO_OER_P9 = 0x200
	// Position of P10 field.
	PIO_OER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OER_P10_Msk = 0x400
	// Bit P10.
	PIO_OER_P10 = 0x400
	// Position of P11 field.
	PIO_OER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OER_P11_Msk = 0x800
	// Bit P11.
	PIO_OER_P11 = 0x800
	// Position of P12 field.
	PIO_OER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OER_P12 = 0x1000
	// Position of P13 field.
	PIO_OER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OER_P13 = 0x2000
	// Position of P14 field.
	PIO_OER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OER_P14 = 0x4000
	// Position of P15 field.
	PIO_OER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OER_P15 = 0x8000
	// Position of P16 field.
	PIO_OER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OER_P16 = 0x10000
	// Position of P17 field.
	PIO_OER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OER_P17 = 0x20000
	// Position of P18 field.
	PIO_OER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OER_P18 = 0x40000
	// Position of P19 field.
	PIO_OER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OER_P19 = 0x80000
	// Position of P20 field.
	PIO_OER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OER_P20 = 0x100000
	// Position of P21 field.
	PIO_OER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OER_P21 = 0x200000
	// Position of P22 field.
	PIO_OER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OER_P22 = 0x400000
	// Position of P23 field.
	PIO_OER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OER_P23 = 0x800000
	// Position of P24 field.
	PIO_OER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OER_P31 = 0x80000000

	// ODR: Output Disable Register
	// Position of P0 field.
	PIO_ODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODR_P0 = 0x1
	// Position of P1 field.
	PIO_ODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODR_P1 = 0x2
	// Position of P2 field.
	PIO_ODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODR_P2 = 0x4
	// Position of P3 field.
	PIO_ODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODR_P3 = 0x8
	// Position of P4 field.
	PIO_ODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODR_P4 = 0x10
	// Position of P5 field.
	PIO_ODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODR_P5 = 0x20
	// Position of P6 field.
	PIO_ODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODR_P6 = 0x40
	// Position of P7 field.
	PIO_ODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODR_P7 = 0x80
	// Position of P8 field.
	PIO_ODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODR_P8 = 0x100
	// Position of P9 field.
	PIO_ODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODR_P9 = 0x200
	// Position of P10 field.
	PIO_ODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODR_P10 = 0x400
	// Position of P11 field.
	PIO_ODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODR_P11 = 0x800
	// Position of P12 field.
	PIO_ODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODR_P31 = 0x80000000

	// OSR: Output Status Register
	// Position of P0 field.
	PIO_OSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OSR_P0 = 0x1
	// Position of P1 field.
	PIO_OSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OSR_P1 = 0x2
	// Position of P2 field.
	PIO_OSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OSR_P2 = 0x4
	// Position of P3 field.
	PIO_OSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OSR_P3 = 0x8
	// Position of P4 field.
	PIO_OSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OSR_P4 = 0x10
	// Position of P5 field.
	PIO_OSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OSR_P5 = 0x20
	// Position of P6 field.
	PIO_OSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OSR_P6 = 0x40
	// Position of P7 field.
	PIO_OSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OSR_P7 = 0x80
	// Position of P8 field.
	PIO_OSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OSR_P8 = 0x100
	// Position of P9 field.
	PIO_OSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OSR_P9 = 0x200
	// Position of P10 field.
	PIO_OSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OSR_P10 = 0x400
	// Position of P11 field.
	PIO_OSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OSR_P11 = 0x800
	// Position of P12 field.
	PIO_OSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OSR_P31 = 0x80000000

	// IFER: Glitch Input Filter Enable Register
	// Position of P0 field.
	PIO_IFER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFER_P0 = 0x1
	// Position of P1 field.
	PIO_IFER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFER_P1 = 0x2
	// Position of P2 field.
	PIO_IFER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFER_P2 = 0x4
	// Position of P3 field.
	PIO_IFER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFER_P3 = 0x8
	// Position of P4 field.
	PIO_IFER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFER_P4 = 0x10
	// Position of P5 field.
	PIO_IFER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFER_P5 = 0x20
	// Position of P6 field.
	PIO_IFER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFER_P6 = 0x40
	// Position of P7 field.
	PIO_IFER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFER_P7 = 0x80
	// Position of P8 field.
	PIO_IFER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFER_P8 = 0x100
	// Position of P9 field.
	PIO_IFER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFER_P9 = 0x200
	// Position of P10 field.
	PIO_IFER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFER_P10 = 0x400
	// Position of P11 field.
	PIO_IFER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFER_P11 = 0x800
	// Position of P12 field.
	PIO_IFER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFER_P31 = 0x80000000

	// IFDR: Glitch Input Filter Disable Register
	// Position of P0 field.
	PIO_IFDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFDR_P31 = 0x80000000

	// IFSR: Glitch Input Filter Status Register
	// Position of P0 field.
	PIO_IFSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSR_P31 = 0x80000000

	// SODR: Set Output Data Register
	// Position of P0 field.
	PIO_SODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_SODR_P0_Msk = 0x1
	// Bit P0.
	PIO_SODR_P0 = 0x1
	// Position of P1 field.
	PIO_SODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_SODR_P1_Msk = 0x2
	// Bit P1.
	PIO_SODR_P1 = 0x2
	// Position of P2 field.
	PIO_SODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_SODR_P2_Msk = 0x4
	// Bit P2.
	PIO_SODR_P2 = 0x4
	// Position of P3 field.
	PIO_SODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_SODR_P3_Msk = 0x8
	// Bit P3.
	PIO_SODR_P3 = 0x8
	// Position of P4 field.
	PIO_SODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_SODR_P4_Msk = 0x10
	// Bit P4.
	PIO_SODR_P4 = 0x10
	// Position of P5 field.
	PIO_SODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_SODR_P5_Msk = 0x20
	// Bit P5.
	PIO_SODR_P5 = 0x20
	// Position of P6 field.
	PIO_SODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_SODR_P6_Msk = 0x40
	// Bit P6.
	PIO_SODR_P6 = 0x40
	// Position of P7 field.
	PIO_SODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_SODR_P7_Msk = 0x80
	// Bit P7.
	PIO_SODR_P7 = 0x80
	// Position of P8 field.
	PIO_SODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_SODR_P8_Msk = 0x100
	// Bit P8.
	PIO_SODR_P8 = 0x100
	// Position of P9 field.
	PIO_SODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_SODR_P9_Msk = 0x200
	// Bit P9.
	PIO_SODR_P9 = 0x200
	// Position of P10 field.
	PIO_SODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_SODR_P10_Msk = 0x400
	// Bit P10.
	PIO_SODR_P10 = 0x400
	// Position of P11 field.
	PIO_SODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_SODR_P11_Msk = 0x800
	// Bit P11.
	PIO_SODR_P11 = 0x800
	// Position of P12 field.
	PIO_SODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_SODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_SODR_P12 = 0x1000
	// Position of P13 field.
	PIO_SODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_SODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_SODR_P13 = 0x2000
	// Position of P14 field.
	PIO_SODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_SODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_SODR_P14 = 0x4000
	// Position of P15 field.
	PIO_SODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_SODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_SODR_P15 = 0x8000
	// Position of P16 field.
	PIO_SODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_SODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_SODR_P16 = 0x10000
	// Position of P17 field.
	PIO_SODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_SODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_SODR_P17 = 0x20000
	// Position of P18 field.
	PIO_SODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_SODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_SODR_P18 = 0x40000
	// Position of P19 field.
	PIO_SODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_SODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_SODR_P19 = 0x80000
	// Position of P20 field.
	PIO_SODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_SODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_SODR_P20 = 0x100000
	// Position of P21 field.
	PIO_SODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_SODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_SODR_P21 = 0x200000
	// Position of P22 field.
	PIO_SODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_SODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_SODR_P22 = 0x400000
	// Position of P23 field.
	PIO_SODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_SODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_SODR_P23 = 0x800000
	// Position of P24 field.
	PIO_SODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_SODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_SODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_SODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_SODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_SODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_SODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_SODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_SODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_SODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_SODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_SODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_SODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_SODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_SODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_SODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_SODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_SODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_SODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_SODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_SODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_SODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_SODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_SODR_P31 = 0x80000000

	// CODR: Clear Output Data Register
	// Position of P0 field.
	PIO_CODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_CODR_P0_Msk = 0x1
	// Bit P0.
	PIO_CODR_P0 = 0x1
	// Position of P1 field.
	PIO_CODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_CODR_P1_Msk = 0x2
	// Bit P1.
	PIO_CODR_P1 = 0x2
	// Position of P2 field.
	PIO_CODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_CODR_P2_Msk = 0x4
	// Bit P2.
	PIO_CODR_P2 = 0x4
	// Position of P3 field.
	PIO_CODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_CODR_P3_Msk = 0x8
	// Bit P3.
	PIO_CODR_P3 = 0x8
	// Position of P4 field.
	PIO_CODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_CODR_P4_Msk = 0x10
	// Bit P4.
	PIO_CODR_P4 = 0x10
	// Position of P5 field.
	PIO_CODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_CODR_P5_Msk = 0x20
	// Bit P5.
	PIO_CODR_P5 = 0x20
	// Position of P6 field.
	PIO_CODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_CODR_P6_Msk = 0x40
	// Bit P6.
	PIO_CODR_P6 = 0x40
	// Position of P7 field.
	PIO_CODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_CODR_P7_Msk = 0x80
	// Bit P7.
	PIO_CODR_P7 = 0x80
	// Position of P8 field.
	PIO_CODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_CODR_P8_Msk = 0x100
	// Bit P8.
	PIO_CODR_P8 = 0x100
	// Position of P9 field.
	PIO_CODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_CODR_P9_Msk = 0x200
	// Bit P9.
	PIO_CODR_P9 = 0x200
	// Position of P10 field.
	PIO_CODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_CODR_P10_Msk = 0x400
	// Bit P10.
	PIO_CODR_P10 = 0x400
	// Position of P11 field.
	PIO_CODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_CODR_P11_Msk = 0x800
	// Bit P11.
	PIO_CODR_P11 = 0x800
	// Position of P12 field.
	PIO_CODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_CODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_CODR_P12 = 0x1000
	// Position of P13 field.
	PIO_CODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_CODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_CODR_P13 = 0x2000
	// Position of P14 field.
	PIO_CODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_CODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_CODR_P14 = 0x4000
	// Position of P15 field.
	PIO_CODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_CODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_CODR_P15 = 0x8000
	// Position of P16 field.
	PIO_CODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_CODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_CODR_P16 = 0x10000
	// Position of P17 field.
	PIO_CODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_CODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_CODR_P17 = 0x20000
	// Position of P18 field.
	PIO_CODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_CODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_CODR_P18 = 0x40000
	// Position of P19 field.
	PIO_CODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_CODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_CODR_P19 = 0x80000
	// Position of P20 field.
	PIO_CODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_CODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_CODR_P20 = 0x100000
	// Position of P21 field.
	PIO_CODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_CODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_CODR_P21 = 0x200000
	// Position of P22 field.
	PIO_CODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_CODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_CODR_P22 = 0x400000
	// Position of P23 field.
	PIO_CODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_CODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_CODR_P23 = 0x800000
	// Position of P24 field.
	PIO_CODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_CODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_CODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_CODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_CODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_CODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_CODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_CODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_CODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_CODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_CODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_CODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_CODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_CODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_CODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_CODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_CODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_CODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_CODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_CODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_CODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_CODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_CODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_CODR_P31 = 0x80000000

	// ODSR: Output Data Status Register
	// Position of P0 field.
	PIO_ODSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODSR_P0 = 0x1
	// Position of P1 field.
	PIO_ODSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODSR_P1 = 0x2
	// Position of P2 field.
	PIO_ODSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODSR_P2 = 0x4
	// Position of P3 field.
	PIO_ODSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODSR_P3 = 0x8
	// Position of P4 field.
	PIO_ODSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODSR_P4 = 0x10
	// Position of P5 field.
	PIO_ODSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODSR_P5 = 0x20
	// Position of P6 field.
	PIO_ODSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODSR_P6 = 0x40
	// Position of P7 field.
	PIO_ODSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODSR_P7 = 0x80
	// Position of P8 field.
	PIO_ODSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODSR_P8 = 0x100
	// Position of P9 field.
	PIO_ODSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODSR_P9 = 0x200
	// Position of P10 field.
	PIO_ODSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODSR_P10 = 0x400
	// Position of P11 field.
	PIO_ODSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODSR_P11 = 0x800
	// Position of P12 field.
	PIO_ODSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODSR_P31 = 0x80000000

	// PDSR: Pin Data Status Register
	// Position of P0 field.
	PIO_PDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDSR_P31 = 0x80000000

	// IER: Interrupt Enable Register
	// Position of P0 field.
	PIO_IER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IER_P0_Msk = 0x1
	// Bit P0.
	PIO_IER_P0 = 0x1
	// Position of P1 field.
	PIO_IER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IER_P1_Msk = 0x2
	// Bit P1.
	PIO_IER_P1 = 0x2
	// Position of P2 field.
	PIO_IER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IER_P2_Msk = 0x4
	// Bit P2.
	PIO_IER_P2 = 0x4
	// Position of P3 field.
	PIO_IER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IER_P3_Msk = 0x8
	// Bit P3.
	PIO_IER_P3 = 0x8
	// Position of P4 field.
	PIO_IER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IER_P4_Msk = 0x10
	// Bit P4.
	PIO_IER_P4 = 0x10
	// Position of P5 field.
	PIO_IER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IER_P5_Msk = 0x20
	// Bit P5.
	PIO_IER_P5 = 0x20
	// Position of P6 field.
	PIO_IER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IER_P6_Msk = 0x40
	// Bit P6.
	PIO_IER_P6 = 0x40
	// Position of P7 field.
	PIO_IER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IER_P7_Msk = 0x80
	// Bit P7.
	PIO_IER_P7 = 0x80
	// Position of P8 field.
	PIO_IER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IER_P8_Msk = 0x100
	// Bit P8.
	PIO_IER_P8 = 0x100
	// Position of P9 field.
	PIO_IER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IER_P9_Msk = 0x200
	// Bit P9.
	PIO_IER_P9 = 0x200
	// Position of P10 field.
	PIO_IER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IER_P10_Msk = 0x400
	// Bit P10.
	PIO_IER_P10 = 0x400
	// Position of P11 field.
	PIO_IER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IER_P11_Msk = 0x800
	// Bit P11.
	PIO_IER_P11 = 0x800
	// Position of P12 field.
	PIO_IER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IER_P12 = 0x1000
	// Position of P13 field.
	PIO_IER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IER_P13 = 0x2000
	// Position of P14 field.
	PIO_IER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IER_P14 = 0x4000
	// Position of P15 field.
	PIO_IER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IER_P15 = 0x8000
	// Position of P16 field.
	PIO_IER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IER_P16 = 0x10000
	// Position of P17 field.
	PIO_IER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IER_P17 = 0x20000
	// Position of P18 field.
	PIO_IER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IER_P18 = 0x40000
	// Position of P19 field.
	PIO_IER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IER_P19 = 0x80000
	// Position of P20 field.
	PIO_IER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IER_P20 = 0x100000
	// Position of P21 field.
	PIO_IER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IER_P21 = 0x200000
	// Position of P22 field.
	PIO_IER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IER_P22 = 0x400000
	// Position of P23 field.
	PIO_IER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IER_P23 = 0x800000
	// Position of P24 field.
	PIO_IER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IER_P31 = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of P0 field.
	PIO_IDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IDR_P0 = 0x1
	// Position of P1 field.
	PIO_IDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IDR_P1 = 0x2
	// Position of P2 field.
	PIO_IDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IDR_P2 = 0x4
	// Position of P3 field.
	PIO_IDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IDR_P3 = 0x8
	// Position of P4 field.
	PIO_IDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IDR_P4 = 0x10
	// Position of P5 field.
	PIO_IDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IDR_P5 = 0x20
	// Position of P6 field.
	PIO_IDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IDR_P6 = 0x40
	// Position of P7 field.
	PIO_IDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IDR_P7 = 0x80
	// Position of P8 field.
	PIO_IDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IDR_P8 = 0x100
	// Position of P9 field.
	PIO_IDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IDR_P9 = 0x200
	// Position of P10 field.
	PIO_IDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IDR_P10 = 0x400
	// Position of P11 field.
	PIO_IDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IDR_P11 = 0x800
	// Position of P12 field.
	PIO_IDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IDR_P31 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of P0 field.
	PIO_IMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IMR_P0_Msk = 0x1
	// Bit P0.
	PIO_IMR_P0 = 0x1
	// Position of P1 field.
	PIO_IMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IMR_P1_Msk = 0x2
	// Bit P1.
	PIO_IMR_P1 = 0x2
	// Position of P2 field.
	PIO_IMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IMR_P2_Msk = 0x4
	// Bit P2.
	PIO_IMR_P2 = 0x4
	// Position of P3 field.
	PIO_IMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IMR_P3_Msk = 0x8
	// Bit P3.
	PIO_IMR_P3 = 0x8
	// Position of P4 field.
	PIO_IMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IMR_P4_Msk = 0x10
	// Bit P4.
	PIO_IMR_P4 = 0x10
	// Position of P5 field.
	PIO_IMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IMR_P5_Msk = 0x20
	// Bit P5.
	PIO_IMR_P5 = 0x20
	// Position of P6 field.
	PIO_IMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IMR_P6_Msk = 0x40
	// Bit P6.
	PIO_IMR_P6 = 0x40
	// Position of P7 field.
	PIO_IMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IMR_P7_Msk = 0x80
	// Bit P7.
	PIO_IMR_P7 = 0x80
	// Position of P8 field.
	PIO_IMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IMR_P8_Msk = 0x100
	// Bit P8.
	PIO_IMR_P8 = 0x100
	// Position of P9 field.
	PIO_IMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IMR_P9_Msk = 0x200
	// Bit P9.
	PIO_IMR_P9 = 0x200
	// Position of P10 field.
	PIO_IMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IMR_P10_Msk = 0x400
	// Bit P10.
	PIO_IMR_P10 = 0x400
	// Position of P11 field.
	PIO_IMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IMR_P11_Msk = 0x800
	// Bit P11.
	PIO_IMR_P11 = 0x800
	// Position of P12 field.
	PIO_IMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IMR_P12 = 0x1000
	// Position of P13 field.
	PIO_IMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IMR_P13 = 0x2000
	// Position of P14 field.
	PIO_IMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IMR_P14 = 0x4000
	// Position of P15 field.
	PIO_IMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IMR_P15 = 0x8000
	// Position of P16 field.
	PIO_IMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IMR_P16 = 0x10000
	// Position of P17 field.
	PIO_IMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IMR_P17 = 0x20000
	// Position of P18 field.
	PIO_IMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IMR_P18 = 0x40000
	// Position of P19 field.
	PIO_IMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IMR_P19 = 0x80000
	// Position of P20 field.
	PIO_IMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IMR_P20 = 0x100000
	// Position of P21 field.
	PIO_IMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IMR_P21 = 0x200000
	// Position of P22 field.
	PIO_IMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IMR_P22 = 0x400000
	// Position of P23 field.
	PIO_IMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IMR_P23 = 0x800000
	// Position of P24 field.
	PIO_IMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IMR_P31 = 0x80000000

	// ISR: Interrupt Status Register
	// Position of P0 field.
	PIO_ISR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ISR_P0_Msk = 0x1
	// Bit P0.
	PIO_ISR_P0 = 0x1
	// Position of P1 field.
	PIO_ISR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ISR_P1_Msk = 0x2
	// Bit P1.
	PIO_ISR_P1 = 0x2
	// Position of P2 field.
	PIO_ISR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ISR_P2_Msk = 0x4
	// Bit P2.
	PIO_ISR_P2 = 0x4
	// Position of P3 field.
	PIO_ISR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ISR_P3_Msk = 0x8
	// Bit P3.
	PIO_ISR_P3 = 0x8
	// Position of P4 field.
	PIO_ISR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ISR_P4_Msk = 0x10
	// Bit P4.
	PIO_ISR_P4 = 0x10
	// Position of P5 field.
	PIO_ISR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ISR_P5_Msk = 0x20
	// Bit P5.
	PIO_ISR_P5 = 0x20
	// Position of P6 field.
	PIO_ISR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ISR_P6_Msk = 0x40
	// Bit P6.
	PIO_ISR_P6 = 0x40
	// Position of P7 field.
	PIO_ISR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ISR_P7_Msk = 0x80
	// Bit P7.
	PIO_ISR_P7 = 0x80
	// Position of P8 field.
	PIO_ISR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ISR_P8_Msk = 0x100
	// Bit P8.
	PIO_ISR_P8 = 0x100
	// Position of P9 field.
	PIO_ISR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ISR_P9_Msk = 0x200
	// Bit P9.
	PIO_ISR_P9 = 0x200
	// Position of P10 field.
	PIO_ISR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ISR_P10_Msk = 0x400
	// Bit P10.
	PIO_ISR_P10 = 0x400
	// Position of P11 field.
	PIO_ISR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ISR_P11_Msk = 0x800
	// Bit P11.
	PIO_ISR_P11 = 0x800
	// Position of P12 field.
	PIO_ISR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ISR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ISR_P12 = 0x1000
	// Position of P13 field.
	PIO_ISR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ISR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ISR_P13 = 0x2000
	// Position of P14 field.
	PIO_ISR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ISR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ISR_P14 = 0x4000
	// Position of P15 field.
	PIO_ISR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ISR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ISR_P15 = 0x8000
	// Position of P16 field.
	PIO_ISR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ISR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ISR_P16 = 0x10000
	// Position of P17 field.
	PIO_ISR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ISR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ISR_P17 = 0x20000
	// Position of P18 field.
	PIO_ISR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ISR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ISR_P18 = 0x40000
	// Position of P19 field.
	PIO_ISR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ISR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ISR_P19 = 0x80000
	// Position of P20 field.
	PIO_ISR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ISR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ISR_P20 = 0x100000
	// Position of P21 field.
	PIO_ISR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ISR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ISR_P21 = 0x200000
	// Position of P22 field.
	PIO_ISR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ISR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ISR_P22 = 0x400000
	// Position of P23 field.
	PIO_ISR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ISR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ISR_P23 = 0x800000
	// Position of P24 field.
	PIO_ISR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ISR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ISR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ISR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ISR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ISR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ISR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ISR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ISR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ISR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ISR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ISR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ISR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ISR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ISR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ISR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ISR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ISR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ISR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ISR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ISR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ISR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ISR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ISR_P31 = 0x80000000

	// MDER: Multi-driver Enable Register
	// Position of P0 field.
	PIO_MDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDER_P0_Msk = 0x1
	// Bit P0.
	PIO_MDER_P0 = 0x1
	// Position of P1 field.
	PIO_MDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDER_P1_Msk = 0x2
	// Bit P1.
	PIO_MDER_P1 = 0x2
	// Position of P2 field.
	PIO_MDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDER_P2_Msk = 0x4
	// Bit P2.
	PIO_MDER_P2 = 0x4
	// Position of P3 field.
	PIO_MDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDER_P3_Msk = 0x8
	// Bit P3.
	PIO_MDER_P3 = 0x8
	// Position of P4 field.
	PIO_MDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDER_P4_Msk = 0x10
	// Bit P4.
	PIO_MDER_P4 = 0x10
	// Position of P5 field.
	PIO_MDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDER_P5_Msk = 0x20
	// Bit P5.
	PIO_MDER_P5 = 0x20
	// Position of P6 field.
	PIO_MDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDER_P6_Msk = 0x40
	// Bit P6.
	PIO_MDER_P6 = 0x40
	// Position of P7 field.
	PIO_MDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDER_P7_Msk = 0x80
	// Bit P7.
	PIO_MDER_P7 = 0x80
	// Position of P8 field.
	PIO_MDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDER_P8_Msk = 0x100
	// Bit P8.
	PIO_MDER_P8 = 0x100
	// Position of P9 field.
	PIO_MDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDER_P9_Msk = 0x200
	// Bit P9.
	PIO_MDER_P9 = 0x200
	// Position of P10 field.
	PIO_MDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDER_P10_Msk = 0x400
	// Bit P10.
	PIO_MDER_P10 = 0x400
	// Position of P11 field.
	PIO_MDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDER_P11_Msk = 0x800
	// Bit P11.
	PIO_MDER_P11 = 0x800
	// Position of P12 field.
	PIO_MDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDER_P12 = 0x1000
	// Position of P13 field.
	PIO_MDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDER_P13 = 0x2000
	// Position of P14 field.
	PIO_MDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDER_P14 = 0x4000
	// Position of P15 field.
	PIO_MDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDER_P15 = 0x8000
	// Position of P16 field.
	PIO_MDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDER_P16 = 0x10000
	// Position of P17 field.
	PIO_MDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDER_P17 = 0x20000
	// Position of P18 field.
	PIO_MDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDER_P18 = 0x40000
	// Position of P19 field.
	PIO_MDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDER_P19 = 0x80000
	// Position of P20 field.
	PIO_MDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDER_P20 = 0x100000
	// Position of P21 field.
	PIO_MDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDER_P21 = 0x200000
	// Position of P22 field.
	PIO_MDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDER_P22 = 0x400000
	// Position of P23 field.
	PIO_MDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDER_P23 = 0x800000
	// Position of P24 field.
	PIO_MDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDER_P31 = 0x80000000

	// MDDR: Multi-driver Disable Register
	// Position of P0 field.
	PIO_MDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDDR_P0 = 0x1
	// Position of P1 field.
	PIO_MDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDDR_P1 = 0x2
	// Position of P2 field.
	PIO_MDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDDR_P2 = 0x4
	// Position of P3 field.
	PIO_MDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDDR_P3 = 0x8
	// Position of P4 field.
	PIO_MDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDDR_P4 = 0x10
	// Position of P5 field.
	PIO_MDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDDR_P5 = 0x20
	// Position of P6 field.
	PIO_MDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDDR_P6 = 0x40
	// Position of P7 field.
	PIO_MDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDDR_P7 = 0x80
	// Position of P8 field.
	PIO_MDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDDR_P8 = 0x100
	// Position of P9 field.
	PIO_MDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDDR_P9 = 0x200
	// Position of P10 field.
	PIO_MDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDDR_P10 = 0x400
	// Position of P11 field.
	PIO_MDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDDR_P11 = 0x800
	// Position of P12 field.
	PIO_MDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDDR_P31 = 0x80000000

	// MDSR: Multi-driver Status Register
	// Position of P0 field.
	PIO_MDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDSR_P0 = 0x1
	// Position of P1 field.
	PIO_MDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDSR_P1 = 0x2
	// Position of P2 field.
	PIO_MDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDSR_P2 = 0x4
	// Position of P3 field.
	PIO_MDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDSR_P3 = 0x8
	// Position of P4 field.
	PIO_MDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDSR_P4 = 0x10
	// Position of P5 field.
	PIO_MDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDSR_P5 = 0x20
	// Position of P6 field.
	PIO_MDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDSR_P6 = 0x40
	// Position of P7 field.
	PIO_MDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDSR_P7 = 0x80
	// Position of P8 field.
	PIO_MDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDSR_P8 = 0x100
	// Position of P9 field.
	PIO_MDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDSR_P9 = 0x200
	// Position of P10 field.
	PIO_MDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDSR_P10 = 0x400
	// Position of P11 field.
	PIO_MDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDSR_P11 = 0x800
	// Position of P12 field.
	PIO_MDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDSR_P31 = 0x80000000

	// PUDR: Pull-up Disable Register
	// Position of P0 field.
	PIO_PUDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUDR_P0 = 0x1
	// Position of P1 field.
	PIO_PUDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUDR_P1 = 0x2
	// Position of P2 field.
	PIO_PUDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUDR_P2 = 0x4
	// Position of P3 field.
	PIO_PUDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUDR_P3 = 0x8
	// Position of P4 field.
	PIO_PUDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUDR_P4 = 0x10
	// Position of P5 field.
	PIO_PUDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUDR_P5 = 0x20
	// Position of P6 field.
	PIO_PUDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUDR_P6 = 0x40
	// Position of P7 field.
	PIO_PUDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUDR_P7 = 0x80
	// Position of P8 field.
	PIO_PUDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUDR_P8 = 0x100
	// Position of P9 field.
	PIO_PUDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUDR_P9 = 0x200
	// Position of P10 field.
	PIO_PUDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUDR_P10 = 0x400
	// Position of P11 field.
	PIO_PUDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUDR_P11 = 0x800
	// Position of P12 field.
	PIO_PUDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUDR_P31 = 0x80000000

	// PUER: Pull-up Enable Register
	// Position of P0 field.
	PIO_PUER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUER_P0_Msk = 0x1
	// Bit P0.
	PIO_PUER_P0 = 0x1
	// Position of P1 field.
	PIO_PUER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUER_P1_Msk = 0x2
	// Bit P1.
	PIO_PUER_P1 = 0x2
	// Position of P2 field.
	PIO_PUER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUER_P2_Msk = 0x4
	// Bit P2.
	PIO_PUER_P2 = 0x4
	// Position of P3 field.
	PIO_PUER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUER_P3_Msk = 0x8
	// Bit P3.
	PIO_PUER_P3 = 0x8
	// Position of P4 field.
	PIO_PUER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUER_P4_Msk = 0x10
	// Bit P4.
	PIO_PUER_P4 = 0x10
	// Position of P5 field.
	PIO_PUER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUER_P5_Msk = 0x20
	// Bit P5.
	PIO_PUER_P5 = 0x20
	// Position of P6 field.
	PIO_PUER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUER_P6_Msk = 0x40
	// Bit P6.
	PIO_PUER_P6 = 0x40
	// Position of P7 field.
	PIO_PUER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUER_P7_Msk = 0x80
	// Bit P7.
	PIO_PUER_P7 = 0x80
	// Position of P8 field.
	PIO_PUER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUER_P8_Msk = 0x100
	// Bit P8.
	PIO_PUER_P8 = 0x100
	// Position of P9 field.
	PIO_PUER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUER_P9_Msk = 0x200
	// Bit P9.
	PIO_PUER_P9 = 0x200
	// Position of P10 field.
	PIO_PUER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUER_P10_Msk = 0x400
	// Bit P10.
	PIO_PUER_P10 = 0x400
	// Position of P11 field.
	PIO_PUER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUER_P11_Msk = 0x800
	// Bit P11.
	PIO_PUER_P11 = 0x800
	// Position of P12 field.
	PIO_PUER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUER_P12 = 0x1000
	// Position of P13 field.
	PIO_PUER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUER_P13 = 0x2000
	// Position of P14 field.
	PIO_PUER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUER_P14 = 0x4000
	// Position of P15 field.
	PIO_PUER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUER_P15 = 0x8000
	// Position of P16 field.
	PIO_PUER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUER_P16 = 0x10000
	// Position of P17 field.
	PIO_PUER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUER_P17 = 0x20000
	// Position of P18 field.
	PIO_PUER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUER_P18 = 0x40000
	// Position of P19 field.
	PIO_PUER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUER_P19 = 0x80000
	// Position of P20 field.
	PIO_PUER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUER_P20 = 0x100000
	// Position of P21 field.
	PIO_PUER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUER_P21 = 0x200000
	// Position of P22 field.
	PIO_PUER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUER_P22 = 0x400000
	// Position of P23 field.
	PIO_PUER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUER_P23 = 0x800000
	// Position of P24 field.
	PIO_PUER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUER_P31 = 0x80000000

	// PUSR: Pad Pull-up Status Register
	// Position of P0 field.
	PIO_PUSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUSR_P0 = 0x1
	// Position of P1 field.
	PIO_PUSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUSR_P1 = 0x2
	// Position of P2 field.
	PIO_PUSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUSR_P2 = 0x4
	// Position of P3 field.
	PIO_PUSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUSR_P3 = 0x8
	// Position of P4 field.
	PIO_PUSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUSR_P4 = 0x10
	// Position of P5 field.
	PIO_PUSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUSR_P5 = 0x20
	// Position of P6 field.
	PIO_PUSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUSR_P6 = 0x40
	// Position of P7 field.
	PIO_PUSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUSR_P7 = 0x80
	// Position of P8 field.
	PIO_PUSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUSR_P8 = 0x100
	// Position of P9 field.
	PIO_PUSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUSR_P9 = 0x200
	// Position of P10 field.
	PIO_PUSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUSR_P10 = 0x400
	// Position of P11 field.
	PIO_PUSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUSR_P11 = 0x800
	// Position of P12 field.
	PIO_PUSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUSR_P31 = 0x80000000

	// ABCDSR: Peripheral Select Register
	// Position of P0 field.
	PIO_ABCDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ABCDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ABCDSR_P0 = 0x1
	// Position of P1 field.
	PIO_ABCDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ABCDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ABCDSR_P1 = 0x2
	// Position of P2 field.
	PIO_ABCDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ABCDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ABCDSR_P2 = 0x4
	// Position of P3 field.
	PIO_ABCDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ABCDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ABCDSR_P3 = 0x8
	// Position of P4 field.
	PIO_ABCDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ABCDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ABCDSR_P4 = 0x10
	// Position of P5 field.
	PIO_ABCDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ABCDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ABCDSR_P5 = 0x20
	// Position of P6 field.
	PIO_ABCDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ABCDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ABCDSR_P6 = 0x40
	// Position of P7 field.
	PIO_ABCDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ABCDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ABCDSR_P7 = 0x80
	// Position of P8 field.
	PIO_ABCDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ABCDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ABCDSR_P8 = 0x100
	// Position of P9 field.
	PIO_ABCDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ABCDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ABCDSR_P9 = 0x200
	// Position of P10 field.
	PIO_ABCDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ABCDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ABCDSR_P10 = 0x400
	// Position of P11 field.
	PIO_ABCDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ABCDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ABCDSR_P11 = 0x800
	// Position of P12 field.
	PIO_ABCDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ABCDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ABCDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ABCDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ABCDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ABCDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ABCDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ABCDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ABCDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ABCDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ABCDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ABCDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ABCDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ABCDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ABCDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ABCDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ABCDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ABCDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ABCDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ABCDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ABCDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ABCDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ABCDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ABCDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ABCDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ABCDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ABCDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ABCDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ABCDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ABCDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ABCDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ABCDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ABCDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ABCDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ABCDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ABCDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ABCDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ABCDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ABCDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ABCDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ABCDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ABCDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ABCDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ABCDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ABCDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ABCDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ABCDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ABCDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ABCDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ABCDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ABCDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ABCDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ABCDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ABCDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ABCDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ABCDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ABCDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ABCDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ABCDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ABCDSR_P31 = 0x80000000

	// IFSCDR: Input Filter Slow Clock Disable Register
	// Position of P0 field.
	PIO_IFSCDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCDR_P31 = 0x80000000

	// IFSCER: Input Filter Slow Clock Enable Register
	// Position of P0 field.
	PIO_IFSCER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCER_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCER_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCER_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCER_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCER_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCER_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCER_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCER_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCER_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCER_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCER_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCER_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCER_P31 = 0x80000000

	// IFSCSR: Input Filter Slow Clock Status Register
	// Position of P0 field.
	PIO_IFSCSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCSR_P31 = 0x80000000

	// SCDR: Slow Clock Divider Debouncing Register
	// Position of DIV field.
	PIO_SCDR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	PIO_SCDR_DIV_Msk = 0x3fff

	// PPDDR: Pad Pull-down Disable Register
	// Position of P0 field.
	PIO_PPDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDDR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDDR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDDR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDDR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDDR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDDR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDDR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDDR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDDR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDDR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDDR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDDR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDDR_P31 = 0x80000000

	// PPDER: Pad Pull-down Enable Register
	// Position of P0 field.
	PIO_PPDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDER_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDER_P0 = 0x1
	// Position of P1 field.
	PIO_PPDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDER_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDER_P1 = 0x2
	// Position of P2 field.
	PIO_PPDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDER_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDER_P2 = 0x4
	// Position of P3 field.
	PIO_PPDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDER_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDER_P3 = 0x8
	// Position of P4 field.
	PIO_PPDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDER_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDER_P4 = 0x10
	// Position of P5 field.
	PIO_PPDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDER_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDER_P5 = 0x20
	// Position of P6 field.
	PIO_PPDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDER_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDER_P6 = 0x40
	// Position of P7 field.
	PIO_PPDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDER_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDER_P7 = 0x80
	// Position of P8 field.
	PIO_PPDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDER_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDER_P8 = 0x100
	// Position of P9 field.
	PIO_PPDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDER_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDER_P9 = 0x200
	// Position of P10 field.
	PIO_PPDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDER_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDER_P10 = 0x400
	// Position of P11 field.
	PIO_PPDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDER_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDER_P11 = 0x800
	// Position of P12 field.
	PIO_PPDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDER_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDER_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDER_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDER_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDER_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDER_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDER_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDER_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDER_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDER_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDER_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDER_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDER_P31 = 0x80000000

	// PPDSR: Pad Pull-down Status Register
	// Position of P0 field.
	PIO_PPDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDSR_P31 = 0x80000000

	// OWER: Output Write Enable
	// Position of P0 field.
	PIO_OWER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWER_P0_Msk = 0x1
	// Bit P0.
	PIO_OWER_P0 = 0x1
	// Position of P1 field.
	PIO_OWER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWER_P1_Msk = 0x2
	// Bit P1.
	PIO_OWER_P1 = 0x2
	// Position of P2 field.
	PIO_OWER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWER_P2_Msk = 0x4
	// Bit P2.
	PIO_OWER_P2 = 0x4
	// Position of P3 field.
	PIO_OWER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWER_P3_Msk = 0x8
	// Bit P3.
	PIO_OWER_P3 = 0x8
	// Position of P4 field.
	PIO_OWER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWER_P4_Msk = 0x10
	// Bit P4.
	PIO_OWER_P4 = 0x10
	// Position of P5 field.
	PIO_OWER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWER_P5_Msk = 0x20
	// Bit P5.
	PIO_OWER_P5 = 0x20
	// Position of P6 field.
	PIO_OWER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWER_P6_Msk = 0x40
	// Bit P6.
	PIO_OWER_P6 = 0x40
	// Position of P7 field.
	PIO_OWER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWER_P7_Msk = 0x80
	// Bit P7.
	PIO_OWER_P7 = 0x80
	// Position of P8 field.
	PIO_OWER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWER_P8_Msk = 0x100
	// Bit P8.
	PIO_OWER_P8 = 0x100
	// Position of P9 field.
	PIO_OWER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWER_P9_Msk = 0x200
	// Bit P9.
	PIO_OWER_P9 = 0x200
	// Position of P10 field.
	PIO_OWER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWER_P10_Msk = 0x400
	// Bit P10.
	PIO_OWER_P10 = 0x400
	// Position of P11 field.
	PIO_OWER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWER_P11_Msk = 0x800
	// Bit P11.
	PIO_OWER_P11 = 0x800
	// Position of P12 field.
	PIO_OWER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWER_P12 = 0x1000
	// Position of P13 field.
	PIO_OWER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWER_P13 = 0x2000
	// Position of P14 field.
	PIO_OWER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWER_P14 = 0x4000
	// Position of P15 field.
	PIO_OWER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWER_P15 = 0x8000
	// Position of P16 field.
	PIO_OWER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWER_P16 = 0x10000
	// Position of P17 field.
	PIO_OWER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWER_P17 = 0x20000
	// Position of P18 field.
	PIO_OWER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWER_P18 = 0x40000
	// Position of P19 field.
	PIO_OWER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWER_P19 = 0x80000
	// Position of P20 field.
	PIO_OWER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWER_P20 = 0x100000
	// Position of P21 field.
	PIO_OWER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWER_P21 = 0x200000
	// Position of P22 field.
	PIO_OWER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWER_P22 = 0x400000
	// Position of P23 field.
	PIO_OWER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWER_P23 = 0x800000
	// Position of P24 field.
	PIO_OWER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWER_P31 = 0x80000000

	// OWDR: Output Write Disable
	// Position of P0 field.
	PIO_OWDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWDR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWDR_P0 = 0x1
	// Position of P1 field.
	PIO_OWDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWDR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWDR_P1 = 0x2
	// Position of P2 field.
	PIO_OWDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWDR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWDR_P2 = 0x4
	// Position of P3 field.
	PIO_OWDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWDR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWDR_P3 = 0x8
	// Position of P4 field.
	PIO_OWDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWDR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWDR_P4 = 0x10
	// Position of P5 field.
	PIO_OWDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWDR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWDR_P5 = 0x20
	// Position of P6 field.
	PIO_OWDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWDR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWDR_P6 = 0x40
	// Position of P7 field.
	PIO_OWDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWDR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWDR_P7 = 0x80
	// Position of P8 field.
	PIO_OWDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWDR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWDR_P8 = 0x100
	// Position of P9 field.
	PIO_OWDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWDR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWDR_P9 = 0x200
	// Position of P10 field.
	PIO_OWDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWDR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWDR_P10 = 0x400
	// Position of P11 field.
	PIO_OWDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWDR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWDR_P11 = 0x800
	// Position of P12 field.
	PIO_OWDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWDR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWDR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWDR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWDR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWDR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWDR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWDR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWDR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWDR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWDR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWDR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWDR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWDR_P31 = 0x80000000

	// OWSR: Output Write Status Register
	// Position of P0 field.
	PIO_OWSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWSR_P0 = 0x1
	// Position of P1 field.
	PIO_OWSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWSR_P1 = 0x2
	// Position of P2 field.
	PIO_OWSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWSR_P2 = 0x4
	// Position of P3 field.
	PIO_OWSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWSR_P3 = 0x8
	// Position of P4 field.
	PIO_OWSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWSR_P4 = 0x10
	// Position of P5 field.
	PIO_OWSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWSR_P5 = 0x20
	// Position of P6 field.
	PIO_OWSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWSR_P6 = 0x40
	// Position of P7 field.
	PIO_OWSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWSR_P7 = 0x80
	// Position of P8 field.
	PIO_OWSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWSR_P8 = 0x100
	// Position of P9 field.
	PIO_OWSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWSR_P9 = 0x200
	// Position of P10 field.
	PIO_OWSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWSR_P10 = 0x400
	// Position of P11 field.
	PIO_OWSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWSR_P11 = 0x800
	// Position of P12 field.
	PIO_OWSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWSR_P31 = 0x80000000

	// AIMER: Additional Interrupt Modes Enable Register
	// Position of P0 field.
	PIO_AIMER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMER_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMER_P0 = 0x1
	// Position of P1 field.
	PIO_AIMER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMER_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMER_P1 = 0x2
	// Position of P2 field.
	PIO_AIMER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMER_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMER_P2 = 0x4
	// Position of P3 field.
	PIO_AIMER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMER_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMER_P3 = 0x8
	// Position of P4 field.
	PIO_AIMER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMER_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMER_P4 = 0x10
	// Position of P5 field.
	PIO_AIMER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMER_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMER_P5 = 0x20
	// Position of P6 field.
	PIO_AIMER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMER_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMER_P6 = 0x40
	// Position of P7 field.
	PIO_AIMER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMER_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMER_P7 = 0x80
	// Position of P8 field.
	PIO_AIMER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMER_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMER_P8 = 0x100
	// Position of P9 field.
	PIO_AIMER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMER_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMER_P9 = 0x200
	// Position of P10 field.
	PIO_AIMER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMER_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMER_P10 = 0x400
	// Position of P11 field.
	PIO_AIMER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMER_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMER_P11 = 0x800
	// Position of P12 field.
	PIO_AIMER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMER_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMER_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMER_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMER_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMER_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMER_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMER_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMER_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMER_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMER_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMER_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMER_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMER_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMER_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMER_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMER_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMER_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMER_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMER_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMER_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMER_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMER_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMER_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMER_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMER_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMER_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMER_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMER_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMER_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMER_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMER_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMER_P31 = 0x80000000

	// AIMDR: Additional Interrupt Modes Disables Register
	// Position of P0 field.
	PIO_AIMDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMDR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMDR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMDR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMDR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMDR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMDR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMDR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMDR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMDR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMDR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMDR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMDR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMDR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMDR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMDR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMDR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMDR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMDR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMDR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMDR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMDR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMDR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMDR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMDR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMDR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMDR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMDR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMDR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMDR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMDR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMDR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMDR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMDR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMDR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMDR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMDR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMDR_P31 = 0x80000000

	// AIMMR: Additional Interrupt Modes Mask Register
	// Position of P0 field.
	PIO_AIMMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMMR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMMR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMMR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMMR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMMR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMMR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMMR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMMR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMMR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMMR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMMR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMMR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMMR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMMR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMMR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMMR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMMR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMMR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMMR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMMR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMMR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMMR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMMR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMMR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMMR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMMR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMMR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMMR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMMR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMMR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMMR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMMR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMMR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMMR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMMR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMMR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMMR_P31 = 0x80000000

	// ESR: Edge Select Register
	// Position of P0 field.
	PIO_ESR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ESR_P0_Msk = 0x1
	// Bit P0.
	PIO_ESR_P0 = 0x1
	// Position of P1 field.
	PIO_ESR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ESR_P1_Msk = 0x2
	// Bit P1.
	PIO_ESR_P1 = 0x2
	// Position of P2 field.
	PIO_ESR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ESR_P2_Msk = 0x4
	// Bit P2.
	PIO_ESR_P2 = 0x4
	// Position of P3 field.
	PIO_ESR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ESR_P3_Msk = 0x8
	// Bit P3.
	PIO_ESR_P3 = 0x8
	// Position of P4 field.
	PIO_ESR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ESR_P4_Msk = 0x10
	// Bit P4.
	PIO_ESR_P4 = 0x10
	// Position of P5 field.
	PIO_ESR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ESR_P5_Msk = 0x20
	// Bit P5.
	PIO_ESR_P5 = 0x20
	// Position of P6 field.
	PIO_ESR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ESR_P6_Msk = 0x40
	// Bit P6.
	PIO_ESR_P6 = 0x40
	// Position of P7 field.
	PIO_ESR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ESR_P7_Msk = 0x80
	// Bit P7.
	PIO_ESR_P7 = 0x80
	// Position of P8 field.
	PIO_ESR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ESR_P8_Msk = 0x100
	// Bit P8.
	PIO_ESR_P8 = 0x100
	// Position of P9 field.
	PIO_ESR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ESR_P9_Msk = 0x200
	// Bit P9.
	PIO_ESR_P9 = 0x200
	// Position of P10 field.
	PIO_ESR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ESR_P10_Msk = 0x400
	// Bit P10.
	PIO_ESR_P10 = 0x400
	// Position of P11 field.
	PIO_ESR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ESR_P11_Msk = 0x800
	// Bit P11.
	PIO_ESR_P11 = 0x800
	// Position of P12 field.
	PIO_ESR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ESR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ESR_P12 = 0x1000
	// Position of P13 field.
	PIO_ESR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ESR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ESR_P13 = 0x2000
	// Position of P14 field.
	PIO_ESR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ESR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ESR_P14 = 0x4000
	// Position of P15 field.
	PIO_ESR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ESR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ESR_P15 = 0x8000
	// Position of P16 field.
	PIO_ESR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ESR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ESR_P16 = 0x10000
	// Position of P17 field.
	PIO_ESR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ESR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ESR_P17 = 0x20000
	// Position of P18 field.
	PIO_ESR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ESR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ESR_P18 = 0x40000
	// Position of P19 field.
	PIO_ESR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ESR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ESR_P19 = 0x80000
	// Position of P20 field.
	PIO_ESR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ESR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ESR_P20 = 0x100000
	// Position of P21 field.
	PIO_ESR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ESR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ESR_P21 = 0x200000
	// Position of P22 field.
	PIO_ESR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ESR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ESR_P22 = 0x400000
	// Position of P23 field.
	PIO_ESR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ESR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ESR_P23 = 0x800000
	// Position of P24 field.
	PIO_ESR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ESR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ESR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ESR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ESR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ESR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ESR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ESR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ESR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ESR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ESR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ESR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ESR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ESR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ESR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ESR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ESR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ESR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ESR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ESR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ESR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ESR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ESR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ESR_P31 = 0x80000000

	// LSR: Level Select Register
	// Position of P0 field.
	PIO_LSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LSR_P0 = 0x1
	// Position of P1 field.
	PIO_LSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LSR_P1 = 0x2
	// Position of P2 field.
	PIO_LSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LSR_P2 = 0x4
	// Position of P3 field.
	PIO_LSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LSR_P3 = 0x8
	// Position of P4 field.
	PIO_LSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LSR_P4 = 0x10
	// Position of P5 field.
	PIO_LSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LSR_P5 = 0x20
	// Position of P6 field.
	PIO_LSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LSR_P6 = 0x40
	// Position of P7 field.
	PIO_LSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LSR_P7 = 0x80
	// Position of P8 field.
	PIO_LSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LSR_P8 = 0x100
	// Position of P9 field.
	PIO_LSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LSR_P9 = 0x200
	// Position of P10 field.
	PIO_LSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LSR_P10 = 0x400
	// Position of P11 field.
	PIO_LSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LSR_P11 = 0x800
	// Position of P12 field.
	PIO_LSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LSR_P31 = 0x80000000

	// ELSR: Edge/Level Status Register
	// Position of P0 field.
	PIO_ELSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ELSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ELSR_P0 = 0x1
	// Position of P1 field.
	PIO_ELSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ELSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ELSR_P1 = 0x2
	// Position of P2 field.
	PIO_ELSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ELSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ELSR_P2 = 0x4
	// Position of P3 field.
	PIO_ELSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ELSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ELSR_P3 = 0x8
	// Position of P4 field.
	PIO_ELSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ELSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ELSR_P4 = 0x10
	// Position of P5 field.
	PIO_ELSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ELSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ELSR_P5 = 0x20
	// Position of P6 field.
	PIO_ELSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ELSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ELSR_P6 = 0x40
	// Position of P7 field.
	PIO_ELSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ELSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ELSR_P7 = 0x80
	// Position of P8 field.
	PIO_ELSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ELSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ELSR_P8 = 0x100
	// Position of P9 field.
	PIO_ELSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ELSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ELSR_P9 = 0x200
	// Position of P10 field.
	PIO_ELSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ELSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ELSR_P10 = 0x400
	// Position of P11 field.
	PIO_ELSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ELSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ELSR_P11 = 0x800
	// Position of P12 field.
	PIO_ELSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ELSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ELSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ELSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ELSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ELSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ELSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ELSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ELSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ELSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ELSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ELSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ELSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ELSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ELSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ELSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ELSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ELSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ELSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ELSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ELSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ELSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ELSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ELSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ELSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ELSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ELSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ELSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ELSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ELSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ELSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ELSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ELSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ELSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ELSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ELSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ELSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ELSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ELSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ELSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ELSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ELSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ELSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ELSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ELSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ELSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ELSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ELSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ELSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ELSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ELSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ELSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ELSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ELSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ELSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ELSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ELSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ELSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ELSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ELSR_P31 = 0x80000000

	// FELLSR: Falling Edge/Low Level Select Register
	// Position of P0 field.
	PIO_FELLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FELLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FELLSR_P0 = 0x1
	// Position of P1 field.
	PIO_FELLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FELLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FELLSR_P1 = 0x2
	// Position of P2 field.
	PIO_FELLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FELLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FELLSR_P2 = 0x4
	// Position of P3 field.
	PIO_FELLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FELLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FELLSR_P3 = 0x8
	// Position of P4 field.
	PIO_FELLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FELLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FELLSR_P4 = 0x10
	// Position of P5 field.
	PIO_FELLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FELLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FELLSR_P5 = 0x20
	// Position of P6 field.
	PIO_FELLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FELLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FELLSR_P6 = 0x40
	// Position of P7 field.
	PIO_FELLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FELLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FELLSR_P7 = 0x80
	// Position of P8 field.
	PIO_FELLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FELLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FELLSR_P8 = 0x100
	// Position of P9 field.
	PIO_FELLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FELLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FELLSR_P9 = 0x200
	// Position of P10 field.
	PIO_FELLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FELLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FELLSR_P10 = 0x400
	// Position of P11 field.
	PIO_FELLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FELLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FELLSR_P11 = 0x800
	// Position of P12 field.
	PIO_FELLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FELLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FELLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FELLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FELLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FELLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FELLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FELLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FELLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FELLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FELLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FELLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FELLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FELLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FELLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FELLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FELLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FELLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FELLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FELLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FELLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FELLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FELLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FELLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FELLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FELLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FELLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FELLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FELLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FELLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FELLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FELLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FELLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FELLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FELLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FELLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FELLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FELLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FELLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FELLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FELLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FELLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FELLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FELLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FELLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FELLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FELLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FELLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FELLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FELLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FELLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FELLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FELLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FELLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FELLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FELLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FELLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FELLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FELLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FELLSR_P31 = 0x80000000

	// REHLSR: Rising Edge/ High Level Select Register
	// Position of P0 field.
	PIO_REHLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_REHLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_REHLSR_P0 = 0x1
	// Position of P1 field.
	PIO_REHLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_REHLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_REHLSR_P1 = 0x2
	// Position of P2 field.
	PIO_REHLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_REHLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_REHLSR_P2 = 0x4
	// Position of P3 field.
	PIO_REHLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_REHLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_REHLSR_P3 = 0x8
	// Position of P4 field.
	PIO_REHLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_REHLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_REHLSR_P4 = 0x10
	// Position of P5 field.
	PIO_REHLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_REHLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_REHLSR_P5 = 0x20
	// Position of P6 field.
	PIO_REHLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_REHLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_REHLSR_P6 = 0x40
	// Position of P7 field.
	PIO_REHLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_REHLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_REHLSR_P7 = 0x80
	// Position of P8 field.
	PIO_REHLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_REHLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_REHLSR_P8 = 0x100
	// Position of P9 field.
	PIO_REHLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_REHLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_REHLSR_P9 = 0x200
	// Position of P10 field.
	PIO_REHLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_REHLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_REHLSR_P10 = 0x400
	// Position of P11 field.
	PIO_REHLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_REHLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_REHLSR_P11 = 0x800
	// Position of P12 field.
	PIO_REHLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_REHLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_REHLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_REHLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_REHLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_REHLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_REHLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_REHLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_REHLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_REHLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_REHLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_REHLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_REHLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_REHLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_REHLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_REHLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_REHLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_REHLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_REHLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_REHLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_REHLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_REHLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_REHLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_REHLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_REHLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_REHLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_REHLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_REHLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_REHLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_REHLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_REHLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_REHLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_REHLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_REHLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_REHLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_REHLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_REHLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_REHLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_REHLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_REHLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_REHLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_REHLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_REHLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_REHLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_REHLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_REHLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_REHLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_REHLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_REHLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_REHLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_REHLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_REHLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_REHLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_REHLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_REHLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_REHLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_REHLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_REHLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_REHLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_REHLSR_P31 = 0x80000000

	// FRLHSR: Fall/Rise - Low/High Status Register
	// Position of P0 field.
	PIO_FRLHSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FRLHSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FRLHSR_P0 = 0x1
	// Position of P1 field.
	PIO_FRLHSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FRLHSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FRLHSR_P1 = 0x2
	// Position of P2 field.
	PIO_FRLHSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FRLHSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FRLHSR_P2 = 0x4
	// Position of P3 field.
	PIO_FRLHSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FRLHSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FRLHSR_P3 = 0x8
	// Position of P4 field.
	PIO_FRLHSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FRLHSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FRLHSR_P4 = 0x10
	// Position of P5 field.
	PIO_FRLHSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FRLHSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FRLHSR_P5 = 0x20
	// Position of P6 field.
	PIO_FRLHSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FRLHSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FRLHSR_P6 = 0x40
	// Position of P7 field.
	PIO_FRLHSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FRLHSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FRLHSR_P7 = 0x80
	// Position of P8 field.
	PIO_FRLHSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FRLHSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FRLHSR_P8 = 0x100
	// Position of P9 field.
	PIO_FRLHSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FRLHSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FRLHSR_P9 = 0x200
	// Position of P10 field.
	PIO_FRLHSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FRLHSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FRLHSR_P10 = 0x400
	// Position of P11 field.
	PIO_FRLHSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FRLHSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FRLHSR_P11 = 0x800
	// Position of P12 field.
	PIO_FRLHSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FRLHSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FRLHSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FRLHSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FRLHSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FRLHSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FRLHSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FRLHSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FRLHSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FRLHSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FRLHSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FRLHSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FRLHSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FRLHSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FRLHSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FRLHSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FRLHSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FRLHSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FRLHSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FRLHSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FRLHSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FRLHSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FRLHSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FRLHSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FRLHSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FRLHSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FRLHSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FRLHSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FRLHSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FRLHSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FRLHSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FRLHSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FRLHSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FRLHSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FRLHSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FRLHSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FRLHSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FRLHSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FRLHSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FRLHSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FRLHSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FRLHSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FRLHSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FRLHSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FRLHSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FRLHSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FRLHSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FRLHSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FRLHSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FRLHSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FRLHSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FRLHSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FRLHSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FRLHSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FRLHSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FRLHSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FRLHSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FRLHSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FRLHSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FRLHSR_P31 = 0x80000000

	// LOCKSR: Lock Status
	// Position of P0 field.
	PIO_LOCKSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LOCKSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LOCKSR_P0 = 0x1
	// Position of P1 field.
	PIO_LOCKSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LOCKSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LOCKSR_P1 = 0x2
	// Position of P2 field.
	PIO_LOCKSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LOCKSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LOCKSR_P2 = 0x4
	// Position of P3 field.
	PIO_LOCKSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LOCKSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LOCKSR_P3 = 0x8
	// Position of P4 field.
	PIO_LOCKSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LOCKSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LOCKSR_P4 = 0x10
	// Position of P5 field.
	PIO_LOCKSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LOCKSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LOCKSR_P5 = 0x20
	// Position of P6 field.
	PIO_LOCKSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LOCKSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LOCKSR_P6 = 0x40
	// Position of P7 field.
	PIO_LOCKSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LOCKSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LOCKSR_P7 = 0x80
	// Position of P8 field.
	PIO_LOCKSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LOCKSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LOCKSR_P8 = 0x100
	// Position of P9 field.
	PIO_LOCKSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LOCKSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LOCKSR_P9 = 0x200
	// Position of P10 field.
	PIO_LOCKSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LOCKSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LOCKSR_P10 = 0x400
	// Position of P11 field.
	PIO_LOCKSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LOCKSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LOCKSR_P11 = 0x800
	// Position of P12 field.
	PIO_LOCKSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LOCKSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LOCKSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LOCKSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LOCKSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LOCKSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LOCKSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LOCKSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LOCKSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LOCKSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LOCKSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LOCKSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LOCKSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LOCKSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LOCKSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LOCKSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LOCKSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LOCKSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LOCKSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LOCKSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LOCKSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LOCKSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LOCKSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LOCKSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LOCKSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LOCKSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LOCKSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LOCKSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LOCKSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LOCKSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LOCKSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LOCKSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LOCKSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LOCKSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LOCKSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LOCKSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LOCKSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LOCKSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LOCKSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LOCKSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LOCKSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LOCKSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LOCKSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LOCKSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LOCKSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LOCKSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LOCKSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LOCKSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LOCKSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LOCKSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LOCKSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LOCKSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LOCKSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LOCKSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LOCKSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LOCKSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LOCKSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LOCKSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LOCKSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LOCKSR_P31 = 0x80000000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	PIO_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PIO_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PIO_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PIO_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PIO_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	PIO_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PIO_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PIO_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PIO_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PIO_WPSR_WPVSRC_Msk = 0xffff00

	// SCHMITT: Schmitt Trigger Register
	// Position of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Pos = 0x0
	// Bit mask of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Msk = 0x1
	// Bit SCHMITT0.
	PIO_SCHMITT_SCHMITT0 = 0x1
	// Position of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Pos = 0x1
	// Bit mask of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Msk = 0x2
	// Bit SCHMITT1.
	PIO_SCHMITT_SCHMITT1 = 0x2
	// Position of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Pos = 0x2
	// Bit mask of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Msk = 0x4
	// Bit SCHMITT2.
	PIO_SCHMITT_SCHMITT2 = 0x4
	// Position of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Pos = 0x3
	// Bit mask of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Msk = 0x8
	// Bit SCHMITT3.
	PIO_SCHMITT_SCHMITT3 = 0x8
	// Position of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Pos = 0x4
	// Bit mask of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Msk = 0x10
	// Bit SCHMITT4.
	PIO_SCHMITT_SCHMITT4 = 0x10
	// Position of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Pos = 0x5
	// Bit mask of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Msk = 0x20
	// Bit SCHMITT5.
	PIO_SCHMITT_SCHMITT5 = 0x20
	// Position of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Pos = 0x6
	// Bit mask of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Msk = 0x40
	// Bit SCHMITT6.
	PIO_SCHMITT_SCHMITT6 = 0x40
	// Position of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Pos = 0x7
	// Bit mask of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Msk = 0x80
	// Bit SCHMITT7.
	PIO_SCHMITT_SCHMITT7 = 0x80
	// Position of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Pos = 0x8
	// Bit mask of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Msk = 0x100
	// Bit SCHMITT8.
	PIO_SCHMITT_SCHMITT8 = 0x100
	// Position of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Pos = 0x9
	// Bit mask of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Msk = 0x200
	// Bit SCHMITT9.
	PIO_SCHMITT_SCHMITT9 = 0x200
	// Position of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Pos = 0xa
	// Bit mask of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Msk = 0x400
	// Bit SCHMITT10.
	PIO_SCHMITT_SCHMITT10 = 0x400
	// Position of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Pos = 0xb
	// Bit mask of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Msk = 0x800
	// Bit SCHMITT11.
	PIO_SCHMITT_SCHMITT11 = 0x800
	// Position of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Pos = 0xc
	// Bit mask of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Msk = 0x1000
	// Bit SCHMITT12.
	PIO_SCHMITT_SCHMITT12 = 0x1000
	// Position of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Pos = 0xd
	// Bit mask of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Msk = 0x2000
	// Bit SCHMITT13.
	PIO_SCHMITT_SCHMITT13 = 0x2000
	// Position of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Pos = 0xe
	// Bit mask of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Msk = 0x4000
	// Bit SCHMITT14.
	PIO_SCHMITT_SCHMITT14 = 0x4000
	// Position of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Pos = 0xf
	// Bit mask of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Msk = 0x8000
	// Bit SCHMITT15.
	PIO_SCHMITT_SCHMITT15 = 0x8000
	// Position of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Pos = 0x10
	// Bit mask of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Msk = 0x10000
	// Bit SCHMITT16.
	PIO_SCHMITT_SCHMITT16 = 0x10000
	// Position of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Pos = 0x11
	// Bit mask of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Msk = 0x20000
	// Bit SCHMITT17.
	PIO_SCHMITT_SCHMITT17 = 0x20000
	// Position of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Pos = 0x12
	// Bit mask of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Msk = 0x40000
	// Bit SCHMITT18.
	PIO_SCHMITT_SCHMITT18 = 0x40000
	// Position of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Pos = 0x13
	// Bit mask of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Msk = 0x80000
	// Bit SCHMITT19.
	PIO_SCHMITT_SCHMITT19 = 0x80000
	// Position of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Pos = 0x14
	// Bit mask of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Msk = 0x100000
	// Bit SCHMITT20.
	PIO_SCHMITT_SCHMITT20 = 0x100000
	// Position of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Pos = 0x15
	// Bit mask of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Msk = 0x200000
	// Bit SCHMITT21.
	PIO_SCHMITT_SCHMITT21 = 0x200000
	// Position of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Pos = 0x16
	// Bit mask of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Msk = 0x400000
	// Bit SCHMITT22.
	PIO_SCHMITT_SCHMITT22 = 0x400000
	// Position of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Pos = 0x17
	// Bit mask of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Msk = 0x800000
	// Bit SCHMITT23.
	PIO_SCHMITT_SCHMITT23 = 0x800000
	// Position of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Pos = 0x18
	// Bit mask of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Msk = 0x1000000
	// Bit SCHMITT24.
	PIO_SCHMITT_SCHMITT24 = 0x1000000
	// Position of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Pos = 0x19
	// Bit mask of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Msk = 0x2000000
	// Bit SCHMITT25.
	PIO_SCHMITT_SCHMITT25 = 0x2000000
	// Position of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Pos = 0x1a
	// Bit mask of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Msk = 0x4000000
	// Bit SCHMITT26.
	PIO_SCHMITT_SCHMITT26 = 0x4000000
	// Position of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Pos = 0x1b
	// Bit mask of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Msk = 0x8000000
	// Bit SCHMITT27.
	PIO_SCHMITT_SCHMITT27 = 0x8000000
	// Position of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Pos = 0x1c
	// Bit mask of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Msk = 0x10000000
	// Bit SCHMITT28.
	PIO_SCHMITT_SCHMITT28 = 0x10000000
	// Position of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Pos = 0x1d
	// Bit mask of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Msk = 0x20000000
	// Bit SCHMITT29.
	PIO_SCHMITT_SCHMITT29 = 0x20000000
	// Position of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Pos = 0x1e
	// Bit mask of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Msk = 0x40000000
	// Bit SCHMITT30.
	PIO_SCHMITT_SCHMITT30 = 0x40000000
	// Position of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Pos = 0x1f
	// Bit mask of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Msk = 0x80000000
	// Bit SCHMITT31.
	PIO_SCHMITT_SCHMITT31 = 0x80000000

	// DRIVER1: I/O Drive Register 1
	// Position of LINE0 field.
	PIO_DRIVER1_LINE0_Pos = 0x0
	// Bit mask of LINE0 field.
	PIO_DRIVER1_LINE0_Msk = 0x3
	// Low drive
	PIO_DRIVER1_LINE0_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE0_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE0_HI_DRIVE = 0x3
	// Position of LINE1 field.
	PIO_DRIVER1_LINE1_Pos = 0x2
	// Bit mask of LINE1 field.
	PIO_DRIVER1_LINE1_Msk = 0xc
	// Low drive
	PIO_DRIVER1_LINE1_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE1_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE1_HI_DRIVE = 0x3
	// Position of LINE2 field.
	PIO_DRIVER1_LINE2_Pos = 0x4
	// Bit mask of LINE2 field.
	PIO_DRIVER1_LINE2_Msk = 0x30
	// Low drive
	PIO_DRIVER1_LINE2_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE2_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE2_HI_DRIVE = 0x3
	// Position of LINE3 field.
	PIO_DRIVER1_LINE3_Pos = 0x6
	// Bit mask of LINE3 field.
	PIO_DRIVER1_LINE3_Msk = 0xc0
	// Low drive
	PIO_DRIVER1_LINE3_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE3_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE3_HI_DRIVE = 0x3
	// Position of LINE4 field.
	PIO_DRIVER1_LINE4_Pos = 0x8
	// Bit mask of LINE4 field.
	PIO_DRIVER1_LINE4_Msk = 0x300
	// Low drive
	PIO_DRIVER1_LINE4_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE4_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE4_HI_DRIVE = 0x3
	// Position of LINE5 field.
	PIO_DRIVER1_LINE5_Pos = 0xa
	// Bit mask of LINE5 field.
	PIO_DRIVER1_LINE5_Msk = 0xc00
	// Low drive
	PIO_DRIVER1_LINE5_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE5_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE5_HI_DRIVE = 0x3
	// Position of LINE6 field.
	PIO_DRIVER1_LINE6_Pos = 0xc
	// Bit mask of LINE6 field.
	PIO_DRIVER1_LINE6_Msk = 0x3000
	// Low drive
	PIO_DRIVER1_LINE6_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE6_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE6_HI_DRIVE = 0x3
	// Position of LINE7 field.
	PIO_DRIVER1_LINE7_Pos = 0xe
	// Bit mask of LINE7 field.
	PIO_DRIVER1_LINE7_Msk = 0xc000
	// Low drive
	PIO_DRIVER1_LINE7_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE7_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE7_HI_DRIVE = 0x3
	// Position of LINE8 field.
	PIO_DRIVER1_LINE8_Pos = 0x10
	// Bit mask of LINE8 field.
	PIO_DRIVER1_LINE8_Msk = 0x30000
	// Low drive
	PIO_DRIVER1_LINE8_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE8_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE8_HI_DRIVE = 0x3
	// Position of LINE9 field.
	PIO_DRIVER1_LINE9_Pos = 0x12
	// Bit mask of LINE9 field.
	PIO_DRIVER1_LINE9_Msk = 0xc0000
	// Low drive
	PIO_DRIVER1_LINE9_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE9_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE9_HI_DRIVE = 0x3
	// Position of LINE10 field.
	PIO_DRIVER1_LINE10_Pos = 0x14
	// Bit mask of LINE10 field.
	PIO_DRIVER1_LINE10_Msk = 0x300000
	// Low drive
	PIO_DRIVER1_LINE10_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE10_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE10_HI_DRIVE = 0x3
	// Position of LINE11 field.
	PIO_DRIVER1_LINE11_Pos = 0x16
	// Bit mask of LINE11 field.
	PIO_DRIVER1_LINE11_Msk = 0xc00000
	// Low drive
	PIO_DRIVER1_LINE11_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE11_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE11_HI_DRIVE = 0x3
	// Position of LINE12 field.
	PIO_DRIVER1_LINE12_Pos = 0x18
	// Bit mask of LINE12 field.
	PIO_DRIVER1_LINE12_Msk = 0x3000000
	// Low drive
	PIO_DRIVER1_LINE12_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE12_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE12_HI_DRIVE = 0x3
	// Position of LINE13 field.
	PIO_DRIVER1_LINE13_Pos = 0x1a
	// Bit mask of LINE13 field.
	PIO_DRIVER1_LINE13_Msk = 0xc000000
	// Low drive
	PIO_DRIVER1_LINE13_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE13_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE13_HI_DRIVE = 0x3
	// Position of LINE14 field.
	PIO_DRIVER1_LINE14_Pos = 0x1c
	// Bit mask of LINE14 field.
	PIO_DRIVER1_LINE14_Msk = 0x30000000
	// Low drive
	PIO_DRIVER1_LINE14_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE14_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE14_HI_DRIVE = 0x3
	// Position of LINE15 field.
	PIO_DRIVER1_LINE15_Pos = 0x1e
	// Bit mask of LINE15 field.
	PIO_DRIVER1_LINE15_Msk = 0xc0000000
	// Low drive
	PIO_DRIVER1_LINE15_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE15_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE15_HI_DRIVE = 0x3

	// DRIVER2: I/O Drive Register 2
	// Position of LINE16 field.
	PIO_DRIVER2_LINE16_Pos = 0x0
	// Bit mask of LINE16 field.
	PIO_DRIVER2_LINE16_Msk = 0x3
	// Low drive
	PIO_DRIVER2_LINE16_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE16_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE16_HI_DRIVE = 0x3
	// Position of LINE17 field.
	PIO_DRIVER2_LINE17_Pos = 0x2
	// Bit mask of LINE17 field.
	PIO_DRIVER2_LINE17_Msk = 0xc
	// Low drive
	PIO_DRIVER2_LINE17_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE17_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE17_HI_DRIVE = 0x3
	// Position of LINE18 field.
	PIO_DRIVER2_LINE18_Pos = 0x4
	// Bit mask of LINE18 field.
	PIO_DRIVER2_LINE18_Msk = 0x30
	// Low drive
	PIO_DRIVER2_LINE18_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE18_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE18_HI_DRIVE = 0x3
	// Position of LINE19 field.
	PIO_DRIVER2_LINE19_Pos = 0x6
	// Bit mask of LINE19 field.
	PIO_DRIVER2_LINE19_Msk = 0xc0
	// Low drive
	PIO_DRIVER2_LINE19_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE19_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE19_HI_DRIVE = 0x3
	// Position of LINE20 field.
	PIO_DRIVER2_LINE20_Pos = 0x8
	// Bit mask of LINE20 field.
	PIO_DRIVER2_LINE20_Msk = 0x300
	// Low drive
	PIO_DRIVER2_LINE20_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE20_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE20_HI_DRIVE = 0x3
	// Position of LINE21 field.
	PIO_DRIVER2_LINE21_Pos = 0xa
	// Bit mask of LINE21 field.
	PIO_DRIVER2_LINE21_Msk = 0xc00
	// Low drive
	PIO_DRIVER2_LINE21_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE21_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE21_HI_DRIVE = 0x3
	// Position of LINE22 field.
	PIO_DRIVER2_LINE22_Pos = 0xc
	// Bit mask of LINE22 field.
	PIO_DRIVER2_LINE22_Msk = 0x3000
	// Low drive
	PIO_DRIVER2_LINE22_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE22_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE22_HI_DRIVE = 0x3
	// Position of LINE23 field.
	PIO_DRIVER2_LINE23_Pos = 0xe
	// Bit mask of LINE23 field.
	PIO_DRIVER2_LINE23_Msk = 0xc000
	// Low drive
	PIO_DRIVER2_LINE23_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE23_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE23_HI_DRIVE = 0x3
	// Position of LINE24 field.
	PIO_DRIVER2_LINE24_Pos = 0x10
	// Bit mask of LINE24 field.
	PIO_DRIVER2_LINE24_Msk = 0x30000
	// Low drive
	PIO_DRIVER2_LINE24_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE24_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE24_HI_DRIVE = 0x3
	// Position of LINE25 field.
	PIO_DRIVER2_LINE25_Pos = 0x12
	// Bit mask of LINE25 field.
	PIO_DRIVER2_LINE25_Msk = 0xc0000
	// Low drive
	PIO_DRIVER2_LINE25_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE25_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE25_HI_DRIVE = 0x3
	// Position of LINE26 field.
	PIO_DRIVER2_LINE26_Pos = 0x14
	// Bit mask of LINE26 field.
	PIO_DRIVER2_LINE26_Msk = 0x300000
	// Low drive
	PIO_DRIVER2_LINE26_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE26_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE26_HI_DRIVE = 0x3
	// Position of LINE27 field.
	PIO_DRIVER2_LINE27_Pos = 0x16
	// Bit mask of LINE27 field.
	PIO_DRIVER2_LINE27_Msk = 0xc00000
	// Low drive
	PIO_DRIVER2_LINE27_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE27_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE27_HI_DRIVE = 0x3
	// Position of LINE28 field.
	PIO_DRIVER2_LINE28_Pos = 0x18
	// Bit mask of LINE28 field.
	PIO_DRIVER2_LINE28_Msk = 0x3000000
	// Low drive
	PIO_DRIVER2_LINE28_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE28_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE28_HI_DRIVE = 0x3
	// Position of LINE29 field.
	PIO_DRIVER2_LINE29_Pos = 0x1a
	// Bit mask of LINE29 field.
	PIO_DRIVER2_LINE29_Msk = 0xc000000
	// Low drive
	PIO_DRIVER2_LINE29_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE29_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE29_HI_DRIVE = 0x3
	// Position of LINE30 field.
	PIO_DRIVER2_LINE30_Pos = 0x1c
	// Bit mask of LINE30 field.
	PIO_DRIVER2_LINE30_Msk = 0x30000000
	// Low drive
	PIO_DRIVER2_LINE30_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE30_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE30_HI_DRIVE = 0x3
	// Position of LINE31 field.
	PIO_DRIVER2_LINE31_Pos = 0x1e
	// Bit mask of LINE31 field.
	PIO_DRIVER2_LINE31_Msk = 0xc0000000
	// Low drive
	PIO_DRIVER2_LINE31_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE31_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE31_HI_DRIVE = 0x3
)

// Constants for PMC: Power Management Controller
const (
	// PMC_SCER: System Clock Enable Register
	// Position of DDRCK field.
	PMC_PMC_SCER_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCER_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCER_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCER_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCER_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCER_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCER_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCER_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCER_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCER_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCER_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCER_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCER_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCER_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCER_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCER_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCER_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCER_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCER_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCER_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCER_PCK2 = 0x400

	// PMC_SCDR: System Clock Disable Register
	// Position of PCK field.
	PMC_PMC_SCDR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCDR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCDR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCDR_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCDR_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCDR_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCDR_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCDR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCDR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCDR_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCDR_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCDR_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCDR_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCDR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCDR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCDR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCDR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCDR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCDR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCDR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCDR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCDR_PCK2 = 0x400

	// PMC_SCSR: System Clock Status Register
	// Position of PCK field.
	PMC_PMC_SCSR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCSR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCSR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCSR_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCSR_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCSR_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCSR_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCSR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCSR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCSR_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCSR_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCSR_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCSR_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCSR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCSR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCSR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCSR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCSR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCSR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCSR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCSR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCSR_PCK2 = 0x400

	// PMC_PCER0: Peripheral Clock Enable Register 0
	// Position of PID2 field.
	PMC_PMC_PCER0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCER0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCER0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCER0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCER0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCER0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCER0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCER0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCER0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCER0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCER0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCER0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCER0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCER0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCER0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCER0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCER0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCER0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCER0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCER0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCER0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCER0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCER0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCER0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCER0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCER0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCER0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCER0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCER0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCER0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCER0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCER0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCER0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCER0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCER0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCER0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCER0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCER0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCER0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCER0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCER0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCER0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCER0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCER0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCER0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCER0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCER0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCER0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCER0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCER0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCER0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCER0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCER0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCER0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCER0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCER0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCER0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCER0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCER0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCER0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCER0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCER0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCER0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCER0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCER0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCER0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCER0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCER0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCER0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCER0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCER0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCER0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCER0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCER0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCER0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCER0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCER0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCER0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCER0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCER0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCER0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCER0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCER0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCER0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCER0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCER0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCER0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCER0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCER0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCER0_PID31 = 0x80000000

	// PMC_PCDR0: Peripheral Clock Disable Register 0
	// Position of PID2 field.
	PMC_PMC_PCDR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCDR0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCDR0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCDR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCDR0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCDR0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCDR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCDR0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCDR0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCDR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCDR0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCDR0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCDR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCDR0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCDR0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCDR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCDR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCDR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCDR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCDR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCDR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCDR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCDR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCDR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCDR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCDR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCDR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCDR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCDR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCDR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCDR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCDR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCDR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCDR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCDR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCDR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCDR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCDR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCDR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCDR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCDR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCDR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCDR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCDR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCDR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCDR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCDR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCDR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCDR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCDR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCDR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCDR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCDR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCDR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCDR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCDR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCDR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCDR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCDR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCDR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCDR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCDR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCDR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCDR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCDR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCDR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCDR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCDR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCDR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCDR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCDR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCDR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCDR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCDR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCDR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCDR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCDR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCDR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCDR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCDR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCDR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCDR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCDR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCDR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCDR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCDR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCDR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCDR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCDR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCDR0_PID31 = 0x80000000

	// PMC_PCSR0: Peripheral Clock Status Register 0
	// Position of PID2 field.
	PMC_PMC_PCSR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCSR0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCSR0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCSR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCSR0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCSR0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCSR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCSR0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCSR0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCSR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCSR0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCSR0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCSR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCSR0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCSR0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCSR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCSR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCSR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCSR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCSR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCSR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCSR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCSR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCSR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCSR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCSR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCSR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCSR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCSR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCSR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCSR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCSR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCSR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCSR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCSR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCSR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCSR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCSR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCSR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCSR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCSR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCSR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCSR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCSR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCSR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCSR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCSR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCSR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCSR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCSR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCSR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCSR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCSR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCSR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCSR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCSR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCSR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCSR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCSR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCSR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCSR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCSR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCSR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCSR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCSR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCSR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCSR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCSR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCSR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCSR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCSR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCSR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCSR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCSR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCSR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCSR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCSR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCSR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCSR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCSR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCSR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCSR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCSR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCSR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCSR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCSR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCSR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCSR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCSR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCSR0_PID31 = 0x80000000

	// CKGR_UCKR: UTMI Clock Register
	// Position of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Pos = 0x10
	// Bit mask of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Msk = 0x10000
	// Bit UPLLEN.
	PMC_CKGR_UCKR_UPLLEN = 0x10000
	// Position of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Pos = 0x14
	// Bit mask of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Msk = 0xf00000
	// Position of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Pos = 0x18
	// Bit mask of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Msk = 0x1000000
	// Bit BIASEN.
	PMC_CKGR_UCKR_BIASEN = 0x1000000
	// Position of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Pos = 0x1c
	// Bit mask of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Msk = 0xf0000000

	// CKGR_MOR: Main Oscillator Register
	// Position of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Pos = 0x0
	// Bit mask of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Msk = 0x1
	// Bit MOSCXTEN.
	PMC_CKGR_MOR_MOSCXTEN = 0x1
	// Position of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Pos = 0x1
	// Bit mask of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Msk = 0x2
	// Bit MOSCXTBY.
	PMC_CKGR_MOR_MOSCXTBY = 0x2
	// Position of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Pos = 0x3
	// Bit mask of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Msk = 0x8
	// Bit MOSCRCEN.
	PMC_CKGR_MOR_MOSCRCEN = 0x8
	// Position of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Pos = 0x8
	// Bit mask of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Msk = 0xff00
	// Position of KEY field.
	PMC_CKGR_MOR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	PMC_CKGR_MOR_KEY_Msk = 0xff0000
	// Position of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Pos = 0x18
	// Bit mask of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Msk = 0x1000000
	// Bit MOSCSEL.
	PMC_CKGR_MOR_MOSCSEL = 0x1000000
	// Position of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Pos = 0x19
	// Bit mask of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Msk = 0x2000000
	// Bit CFDEN.
	PMC_CKGR_MOR_CFDEN = 0x2000000

	// CKGR_MCFR: Main Clock Frequency Register
	// Position of MAINF field.
	PMC_CKGR_MCFR_MAINF_Pos = 0x0
	// Bit mask of MAINF field.
	PMC_CKGR_MCFR_MAINF_Msk = 0xffff
	// Position of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Pos = 0x10
	// Bit mask of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Msk = 0x10000
	// Bit MAINFRDY.
	PMC_CKGR_MCFR_MAINFRDY = 0x10000

	// CKGR_PLLAR: PLLA Register
	// Position of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Msk = 0xff
	// Position of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Pos = 0x8
	// Bit mask of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Msk = 0x3f00
	// Position of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Pos = 0xe
	// Bit mask of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Msk = 0xc000
	// Position of MULA field.
	PMC_CKGR_PLLAR_MULA_Pos = 0x10
	// Bit mask of MULA field.
	PMC_CKGR_PLLAR_MULA_Msk = 0x7ff0000
	// Position of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Pos = 0x1d
	// Bit mask of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Msk = 0x20000000
	// Bit STUCKTO1.
	PMC_CKGR_PLLAR_STUCKTO1 = 0x20000000

	// PMC_MCKR: Master Clock Register
	// Position of CSS field.
	PMC_PMC_MCKR_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_MCKR_CSS_Msk = 0x3
	// Slow Clock is selected
	PMC_PMC_MCKR_CSS_SLOW_CLK = 0x0
	// Main Clock is selected
	PMC_PMC_MCKR_CSS_MAIN_CLK = 0x1
	// PLLACK/PLLADIV2 is selected
	PMC_PMC_MCKR_CSS_PLLA_CLK = 0x2
	// UPLL Clock is selected
	PMC_PMC_MCKR_CSS_UPLL_CLK = 0x3
	// Position of PRES field.
	PMC_PMC_MCKR_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_PMC_MCKR_PRES_Msk = 0x70
	// Selected clock
	PMC_PMC_MCKR_PRES_CLOCK = 0x0
	// Selected clock divided by 2
	PMC_PMC_MCKR_PRES_CLOCK_DIV2 = 0x1
	// Selected clock divided by 4
	PMC_PMC_MCKR_PRES_CLOCK_DIV4 = 0x2
	// Selected clock divided by 8
	PMC_PMC_MCKR_PRES_CLOCK_DIV8 = 0x3
	// Selected clock divided by 16
	PMC_PMC_MCKR_PRES_CLOCK_DIV16 = 0x4
	// Selected clock divided by 32
	PMC_PMC_MCKR_PRES_CLOCK_DIV32 = 0x5
	// Selected clock divided by 64
	PMC_PMC_MCKR_PRES_CLOCK_DIV64 = 0x6
	// Position of MDIV field.
	PMC_PMC_MCKR_MDIV_Pos = 0x8
	// Bit mask of MDIV field.
	PMC_PMC_MCKR_MDIV_Msk = 0x300
	// Master Clock is Prescaler Output Clock divided by 1.Warning: SysClk DDR and DDRCK are not available.
	PMC_PMC_MCKR_MDIV_EQ_PCK = 0x0
	// Master Clock is Prescaler Output Clock divided by 2.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV2 = 0x1
	// Master Clock is Prescaler Output Clock divided by 4.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV4 = 0x2
	// Master Clock is Prescaler Output Clock divided by 3.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV3 = 0x3
	// Position of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Pos = 0xc
	// Bit mask of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Msk = 0x1000
	// Bit PLLADIV2.
	PMC_PMC_MCKR_PLLADIV2 = 0x1000
	// PLLA clock frequency is divided by 1.
	PMC_PMC_MCKR_PLLADIV2_NOT_DIV2 = 0x0
	// PLLA clock frequency is divided by 2.
	PMC_PMC_MCKR_PLLADIV2_DIV2 = 0x1

	// PMC_USB: USB Clock Register
	// Position of USBS field.
	PMC_PMC_USB_USBS_Pos = 0x0
	// Bit mask of USBS field.
	PMC_PMC_USB_USBS_Msk = 0x1
	// Bit USBS.
	PMC_PMC_USB_USBS = 0x1
	// Position of USBDIV field.
	PMC_PMC_USB_USBDIV_Pos = 0x8
	// Bit mask of USBDIV field.
	PMC_PMC_USB_USBDIV_Msk = 0xf00

	// PMC_SMD: Soft Modem Clock Register
	// Position of SMDS field.
	PMC_PMC_SMD_SMDS_Pos = 0x0
	// Bit mask of SMDS field.
	PMC_PMC_SMD_SMDS_Msk = 0x1
	// Bit SMDS.
	PMC_PMC_SMD_SMDS = 0x1
	// Position of SMDDIV field.
	PMC_PMC_SMD_SMDDIV_Pos = 0x8
	// Bit mask of SMDDIV field.
	PMC_PMC_SMD_SMDDIV_Msk = 0x1f00

	// PMC_PCK: Programmable Clock 0 Register
	// Position of CSS field.
	PMC_PMC_PCK_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_PCK_CSS_Msk = 0x7
	// Slow Clock is selected
	PMC_PMC_PCK_CSS_SLOW_CLK = 0x0
	// Main Clock is selected
	PMC_PMC_PCK_CSS_MAIN_CLK = 0x1
	// PLLACK/PLLADIV2 is selected
	PMC_PMC_PCK_CSS_PLLA_CLK = 0x2
	// UPLL Clock is selected
	PMC_PMC_PCK_CSS_UPLL_CLK = 0x3
	// Master Clock is selected
	PMC_PMC_PCK_CSS_MCK_CLK = 0x4
	// Position of PRES field.
	PMC_PMC_PCK_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_PMC_PCK_PRES_Msk = 0x70
	// Selected clock
	PMC_PMC_PCK_PRES_CLOCK = 0x0
	// Selected clock divided by 2
	PMC_PMC_PCK_PRES_CLOCK_DIV2 = 0x1
	// Selected clock divided by 4
	PMC_PMC_PCK_PRES_CLOCK_DIV4 = 0x2
	// Selected clock divided by 8
	PMC_PMC_PCK_PRES_CLOCK_DIV8 = 0x3
	// Selected clock divided by 16
	PMC_PMC_PCK_PRES_CLOCK_DIV16 = 0x4
	// Selected clock divided by 32
	PMC_PMC_PCK_PRES_CLOCK_DIV32 = 0x5
	// Selected clock divided by 64
	PMC_PMC_PCK_PRES_CLOCK_DIV64 = 0x6

	// PMC_IER: Interrupt Enable Register
	// Position of MOSCXTS field.
	PMC_PMC_IER_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IER_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IER_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IER_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IER_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IER_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IER_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IER_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IER_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IER_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IER_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IER_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IER_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IER_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IER_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IER_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IER_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IER_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IER_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IER_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IER_CFDEV = 0x40000

	// PMC_IDR: Interrupt Disable Register
	// Position of MOSCXTS field.
	PMC_PMC_IDR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IDR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IDR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IDR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IDR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IDR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IDR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IDR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IDR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IDR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IDR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IDR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IDR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IDR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IDR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IDR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IDR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IDR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IDR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IDR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IDR_CFDEV = 0x40000

	// PMC_SR: Status Register
	// Position of MOSCXTS field.
	PMC_PMC_SR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_SR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_SR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_SR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_SR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_SR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_SR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_SR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_SR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_SR_LOCKU = 0x40
	// Position of OSCSELS field.
	PMC_PMC_SR_OSCSELS_Pos = 0x7
	// Bit mask of OSCSELS field.
	PMC_PMC_SR_OSCSELS_Msk = 0x80
	// Bit OSCSELS.
	PMC_PMC_SR_OSCSELS = 0x80
	// Position of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_SR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_SR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_SR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_SR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_SR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_SR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_SR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_SR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_SR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_SR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_SR_CFDEV = 0x40000
	// Position of CFDS field.
	PMC_PMC_SR_CFDS_Pos = 0x13
	// Bit mask of CFDS field.
	PMC_PMC_SR_CFDS_Msk = 0x80000
	// Bit CFDS.
	PMC_PMC_SR_CFDS = 0x80000
	// Position of FOS field.
	PMC_PMC_SR_FOS_Pos = 0x14
	// Bit mask of FOS field.
	PMC_PMC_SR_FOS_Msk = 0x100000
	// Bit FOS.
	PMC_PMC_SR_FOS = 0x100000

	// PMC_IMR: Interrupt Mask Register
	// Position of MOSCXTS field.
	PMC_PMC_IMR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IMR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IMR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IMR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IMR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IMR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IMR_MCKRDY = 0x8
	// Position of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IMR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IMR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IMR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IMR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IMR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IMR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IMR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IMR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IMR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IMR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IMR_CFDEV = 0x40000

	// PMC_PLLICPR: PLL Charge Pump Current Register
	// Position of ICPLLA field.
	PMC_PMC_PLLICPR_ICPLLA_Pos = 0x0
	// Bit mask of ICPLLA field.
	PMC_PMC_PLLICPR_ICPLLA_Msk = 0x1
	// Bit ICPLLA.
	PMC_PMC_PLLICPR_ICPLLA = 0x1

	// PMC_WPMR: Write Protect Mode Register
	// Position of WPEN field.
	PMC_PMC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PMC_PMC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PMC_PMC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PMC_PMC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PMC_PMC_WPMR_WPKEY_Msk = 0xffffff00

	// PMC_WPSR: Write Protect Status Register
	// Position of WPVS field.
	PMC_PMC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PMC_PMC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PMC_PMC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PMC_PMC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PMC_PMC_WPSR_WPVSRC_Msk = 0xffff00

	// PMC_PCER1: Peripheral Clock Enable Register 1
	// Position of PID32 field.
	PMC_PMC_PCER1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCER1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCER1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCER1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCER1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCER1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCER1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCER1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCER1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCER1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCER1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCER1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCER1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCER1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCER1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCER1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCER1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCER1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCER1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCER1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCER1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCER1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCER1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCER1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCER1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCER1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCER1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCER1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCER1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCER1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCER1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCER1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCER1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCER1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCER1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCER1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCER1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCER1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCER1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCER1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCER1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCER1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCER1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCER1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCER1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCER1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCER1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCER1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCER1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCER1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCER1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCER1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCER1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCER1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCER1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCER1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCER1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCER1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCER1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCER1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCER1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCER1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCER1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCER1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCER1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCER1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCER1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCER1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCER1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCER1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCER1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCER1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCER1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCER1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCER1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCER1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCER1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCER1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCER1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCER1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCER1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCER1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCER1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCER1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCER1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCER1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCER1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCER1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCER1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCER1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCER1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCER1_PID63 = 0x80000000

	// PMC_PCDR1: Peripheral Clock Disable Register 1
	// Position of PID32 field.
	PMC_PMC_PCDR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCDR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCDR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCDR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCDR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCDR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCDR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCDR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCDR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCDR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCDR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCDR1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCDR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCDR1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCDR1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCDR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCDR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCDR1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCDR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCDR1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCDR1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCDR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCDR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCDR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCDR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCDR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCDR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCDR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCDR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCDR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCDR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCDR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCDR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCDR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCDR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCDR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCDR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCDR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCDR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCDR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCDR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCDR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCDR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCDR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCDR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCDR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCDR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCDR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCDR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCDR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCDR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCDR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCDR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCDR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCDR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCDR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCDR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCDR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCDR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCDR1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCDR1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCDR1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCDR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCDR1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCDR1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCDR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCDR1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCDR1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCDR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCDR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCDR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCDR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCDR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCDR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCDR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCDR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCDR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCDR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCDR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCDR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCDR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCDR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCDR1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCDR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCDR1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCDR1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCDR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCDR1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCDR1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCDR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCDR1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCDR1_PID63 = 0x80000000

	// PMC_PCSR1: Peripheral Clock Status Register 1
	// Position of PID32 field.
	PMC_PMC_PCSR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCSR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCSR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCSR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCSR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCSR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCSR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCSR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCSR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCSR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCSR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCSR1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCSR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCSR1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCSR1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCSR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCSR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCSR1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCSR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCSR1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCSR1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCSR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCSR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCSR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCSR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCSR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCSR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCSR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCSR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCSR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCSR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCSR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCSR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCSR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCSR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCSR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCSR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCSR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCSR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCSR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCSR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCSR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCSR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCSR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCSR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCSR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCSR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCSR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCSR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCSR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCSR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCSR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCSR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCSR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCSR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCSR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCSR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCSR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCSR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCSR1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCSR1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCSR1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCSR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCSR1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCSR1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCSR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCSR1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCSR1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCSR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCSR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCSR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCSR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCSR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCSR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCSR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCSR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCSR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCSR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCSR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCSR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCSR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCSR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCSR1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCSR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCSR1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCSR1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCSR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCSR1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCSR1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCSR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCSR1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCSR1_PID63 = 0x80000000

	// PMC_PCR: Peripheral Control Register
	// Position of PID field.
	PMC_PMC_PCR_PID_Pos = 0x0
	// Bit mask of PID field.
	PMC_PMC_PCR_PID_Msk = 0x3f
	// Position of CMD field.
	PMC_PMC_PCR_CMD_Pos = 0xc
	// Bit mask of CMD field.
	PMC_PMC_PCR_CMD_Msk = 0x1000
	// Bit CMD.
	PMC_PMC_PCR_CMD = 0x1000
	// Position of DIV field.
	PMC_PMC_PCR_DIV_Pos = 0x10
	// Bit mask of DIV field.
	PMC_PMC_PCR_DIV_Msk = 0x30000
	// Peripheral clock is MCK
	PMC_PMC_PCR_DIV_PERIPH_DIV_MCK = 0x0
	// Peripheral clock is MCK/2
	PMC_PMC_PCR_DIV_PERIPH_DIV2_MCK = 0x1
	// Peripheral clock is MCK/4
	PMC_PMC_PCR_DIV_PERIPH_DIV4_MCK = 0x2
	// Peripheral clock is MCK/8
	PMC_PMC_PCR_DIV_PERIPH_DIV8_MCK = 0x3
	// Position of EN field.
	PMC_PMC_PCR_EN_Pos = 0x1c
	// Bit mask of EN field.
	PMC_PMC_PCR_EN_Msk = 0x10000000
	// Bit EN.
	PMC_PMC_PCR_EN = 0x10000000
)

// Constants for RSTC: Reset Controller
const (
	// CR: Control Register
	// Position of PROCRST field.
	SYSC_CR_PROCRST_Pos = 0x0
	// Bit mask of PROCRST field.
	SYSC_CR_PROCRST_Msk = 0x1
	// Bit PROCRST.
	SYSC_CR_PROCRST = 0x1
	// Position of PERRST field.
	SYSC_CR_PERRST_Pos = 0x2
	// Bit mask of PERRST field.
	SYSC_CR_PERRST_Msk = 0x4
	// Bit PERRST.
	SYSC_CR_PERRST = 0x4
	// Position of EXTRST field.
	SYSC_CR_EXTRST_Pos = 0x3
	// Bit mask of EXTRST field.
	SYSC_CR_EXTRST_Msk = 0x8
	// Bit EXTRST.
	SYSC_CR_EXTRST = 0x8
	// Position of KEY field.
	SYSC_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_CR_KEY_Msk = 0xff000000

	// SR: Status Register
	// Position of URSTS field.
	SYSC_SR_URSTS_Pos = 0x0
	// Bit mask of URSTS field.
	SYSC_SR_URSTS_Msk = 0x1
	// Bit URSTS.
	SYSC_SR_URSTS = 0x1
	// Position of RSTTYP field.
	SYSC_SR_RSTTYP_Pos = 0x8
	// Bit mask of RSTTYP field.
	SYSC_SR_RSTTYP_Msk = 0x700
	// Position of NRSTL field.
	SYSC_SR_NRSTL_Pos = 0x10
	// Bit mask of NRSTL field.
	SYSC_SR_NRSTL_Msk = 0x10000
	// Bit NRSTL.
	SYSC_SR_NRSTL = 0x10000
	// Position of SRCMP field.
	SYSC_SR_SRCMP_Pos = 0x11
	// Bit mask of SRCMP field.
	SYSC_SR_SRCMP_Msk = 0x20000
	// Bit SRCMP.
	SYSC_SR_SRCMP = 0x20000

	// MR: Mode Register
	// Position of ERSTL field.
	SYSC_MR_ERSTL_Pos = 0x8
	// Bit mask of ERSTL field.
	SYSC_MR_ERSTL_Msk = 0xf00
	// Position of KEY field.
	SYSC_MR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_MR_KEY_Msk = 0xff000000
)
