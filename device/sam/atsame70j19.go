// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from ATSAME70J19.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Atmel

//go:build sam && atsame70j19

/*
// Microchip ATSAME70J19 Microcontroller
*/

package sam

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "ATSAME70J19"
	CPU          = "CM7"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Supply Controller
	IRQ_SUPC = 0

	// Reset Controller
	IRQ_RSTC = 1

	// Real-time Clock
	IRQ_RTC = 2

	// Real-time Timer
	IRQ_RTT = 3

	// Watchdog Timer
	IRQ_WDT = 4

	// Power Management Controller
	IRQ_PMC = 5

	// Embedded Flash Controller
	IRQ_EFC = 6

	// Universal Asynchronous Receiver Transmitter
	IRQ_UART0 = 7

	IRQ_UART1 = 8

	// Parallel Input/Output Controller
	IRQ_PIOA = 10

	IRQ_PIOB = 11

	// Universal Synchronous Asynchronous Receiver Transmitter
	IRQ_USART0 = 13

	IRQ_USART1 = 14

	IRQ_PIOD = 16

	// Two-wire Interface High Speed
	IRQ_TWIHS0 = 19

	IRQ_TWIHS1 = 20

	// Synchronous Serial Controller
	IRQ_SSC = 22

	// Timer Counter
	IRQ_TC0 = 23

	// Timer Counter
	IRQ_TC1 = 24

	// Timer Counter
	IRQ_TC2 = 25

	IRQ_TC3 = 26

	IRQ_TC4 = 27

	IRQ_TC5 = 28

	// Analog Front-End Controller
	IRQ_AFEC0 = 29

	// Digital-to-Analog Converter Controller
	IRQ_DACC = 30

	// Pulse Width Modulation Controller
	IRQ_PWM0 = 31

	// Integrity Check Monitor
	IRQ_ICM = 32

	// Analog Comparator Controller
	IRQ_ACC = 33

	// USB High-Speed Interface
	IRQ_USBHS = 34

	// Controller Area Network
	IRQ_MCAN0_INT0 = 35

	// Controller Area Network
	IRQ_MCAN0_INT1 = 36

	// Gigabit Ethernet MAC
	IRQ_GMAC = 39

	IRQ_AFEC1 = 40

	// Quad Serial Peripheral Interface
	IRQ_QSPI = 43

	IRQ_UART2 = 44

	IRQ_TC6 = 47

	IRQ_TC7 = 48

	IRQ_TC8 = 49

	IRQ_TC9 = 50

	IRQ_TC10 = 51

	IRQ_TC11 = 52

	// Advanced Encryption Standard
	IRQ_AES = 56

	// True Random Number Generator
	IRQ_TRNG = 57

	// Extensible DMA Controller
	IRQ_XDMAC = 58

	// Image Sensor Interface
	IRQ_ISI = 59

	IRQ_PWM1 = 60

	// Floating Point Unit
	IRQ_FPU = 61

	// Reinforced Safety Watchdog Timer
	IRQ_RSWDT = 63

	// Gigabit Ethernet MAC
	IRQ_GMAC_Q1 = 66

	// Gigabit Ethernet MAC
	IRQ_GMAC_Q2 = 67

	// Floating Point Unit
	IRQ_IXC = 68

	// Highest interrupt number on this device.
	IRQ_max = 68
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export SUPC_IRQHandler
func interruptSUPC() {
	callHandlers(IRQ_SUPC)
}

//export RSTC_IRQHandler
func interruptRSTC() {
	callHandlers(IRQ_RSTC)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export RTT_IRQHandler
func interruptRTT() {
	callHandlers(IRQ_RTT)
}

//export WDT_IRQHandler
func interruptWDT() {
	callHandlers(IRQ_WDT)
}

//export PMC_IRQHandler
func interruptPMC() {
	callHandlers(IRQ_PMC)
}

//export EFC_IRQHandler
func interruptEFC() {
	callHandlers(IRQ_EFC)
}

//export UART0_IRQHandler
func interruptUART0() {
	callHandlers(IRQ_UART0)
}

//export UART1_IRQHandler
func interruptUART1() {
	callHandlers(IRQ_UART1)
}

//export PIOA_IRQHandler
func interruptPIOA() {
	callHandlers(IRQ_PIOA)
}

//export PIOB_IRQHandler
func interruptPIOB() {
	callHandlers(IRQ_PIOB)
}

//export USART0_IRQHandler
func interruptUSART0() {
	callHandlers(IRQ_USART0)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export PIOD_IRQHandler
func interruptPIOD() {
	callHandlers(IRQ_PIOD)
}

//export TWIHS0_IRQHandler
func interruptTWIHS0() {
	callHandlers(IRQ_TWIHS0)
}

//export TWIHS1_IRQHandler
func interruptTWIHS1() {
	callHandlers(IRQ_TWIHS1)
}

//export SSC_IRQHandler
func interruptSSC() {
	callHandlers(IRQ_SSC)
}

//export TC0_IRQHandler
func interruptTC0() {
	callHandlers(IRQ_TC0)
}

//export TC1_IRQHandler
func interruptTC1() {
	callHandlers(IRQ_TC1)
}

//export TC2_IRQHandler
func interruptTC2() {
	callHandlers(IRQ_TC2)
}

//export TC3_IRQHandler
func interruptTC3() {
	callHandlers(IRQ_TC3)
}

//export TC4_IRQHandler
func interruptTC4() {
	callHandlers(IRQ_TC4)
}

//export TC5_IRQHandler
func interruptTC5() {
	callHandlers(IRQ_TC5)
}

//export AFEC0_IRQHandler
func interruptAFEC0() {
	callHandlers(IRQ_AFEC0)
}

//export DACC_IRQHandler
func interruptDACC() {
	callHandlers(IRQ_DACC)
}

//export PWM0_IRQHandler
func interruptPWM0() {
	callHandlers(IRQ_PWM0)
}

//export ICM_IRQHandler
func interruptICM() {
	callHandlers(IRQ_ICM)
}

//export ACC_IRQHandler
func interruptACC() {
	callHandlers(IRQ_ACC)
}

//export USBHS_IRQHandler
func interruptUSBHS() {
	callHandlers(IRQ_USBHS)
}

//export MCAN0_INT0_IRQHandler
func interruptMCAN0_INT0() {
	callHandlers(IRQ_MCAN0_INT0)
}

//export MCAN0_INT1_IRQHandler
func interruptMCAN0_INT1() {
	callHandlers(IRQ_MCAN0_INT1)
}

//export GMAC_IRQHandler
func interruptGMAC() {
	callHandlers(IRQ_GMAC)
}

//export AFEC1_IRQHandler
func interruptAFEC1() {
	callHandlers(IRQ_AFEC1)
}

//export QSPI_IRQHandler
func interruptQSPI() {
	callHandlers(IRQ_QSPI)
}

//export UART2_IRQHandler
func interruptUART2() {
	callHandlers(IRQ_UART2)
}

//export TC6_IRQHandler
func interruptTC6() {
	callHandlers(IRQ_TC6)
}

//export TC7_IRQHandler
func interruptTC7() {
	callHandlers(IRQ_TC7)
}

//export TC8_IRQHandler
func interruptTC8() {
	callHandlers(IRQ_TC8)
}

//export TC9_IRQHandler
func interruptTC9() {
	callHandlers(IRQ_TC9)
}

//export TC10_IRQHandler
func interruptTC10() {
	callHandlers(IRQ_TC10)
}

//export TC11_IRQHandler
func interruptTC11() {
	callHandlers(IRQ_TC11)
}

//export AES_IRQHandler
func interruptAES() {
	callHandlers(IRQ_AES)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export XDMAC_IRQHandler
func interruptXDMAC() {
	callHandlers(IRQ_XDMAC)
}

//export ISI_IRQHandler
func interruptISI() {
	callHandlers(IRQ_ISI)
}

//export PWM1_IRQHandler
func interruptPWM1() {
	callHandlers(IRQ_PWM1)
}

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

//export RSWDT_IRQHandler
func interruptRSWDT() {
	callHandlers(IRQ_RSWDT)
}

//export GMAC_Q1_IRQHandler
func interruptGMAC_Q1() {
	callHandlers(IRQ_GMAC_Q1)
}

//export GMAC_Q2_IRQHandler
func interruptGMAC_Q2() {
	callHandlers(IRQ_GMAC_Q2)
}

//export IXC_IRQHandler
func interruptIXC() {
	callHandlers(IRQ_IXC)
}

// Peripherals.
var (
	// Analog Comparator Controller
	ACC = (*ACC_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Advanced Encryption Standard
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x4006c000)))

	// Analog Front-End Controller
	AFEC0 = (*AFEC_Type)(unsafe.Pointer(uintptr(0x4003c000)))

	// Chip Identifier
	CHIPID = (*CHIPID_Type)(unsafe.Pointer(uintptr(0x400e0940)))

	// Digital-to-Analog Converter Controller
	DACC = (*DACC_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Embedded Flash Controller
	EFC = (*EFC_Type)(unsafe.Pointer(uintptr(0x400e0c00)))

	// Gigabit Ethernet MAC
	GMAC = (*GMAC_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// General Purpose Backup Registers
	GPBR = (*GPBR_Type)(unsafe.Pointer(uintptr(0x400e1890)))

	// Integrity Check Monitor
	ICM = (*ICM_Type)(unsafe.Pointer(uintptr(0x40048000)))

	// Image Sensor Interface
	ISI = (*ISI_Type)(unsafe.Pointer(uintptr(0x4004c000)))

	// AHB Bus Matrix
	MATRIX = (*MATRIX_Type)(unsafe.Pointer(uintptr(0x40088000)))

	// Controller Area Network
	MCAN0 = (*MCAN_Type)(unsafe.Pointer(uintptr(0x40030000)))

	// Parallel Input/Output Controller
	PIOA = (*PIO_Type)(unsafe.Pointer(uintptr(0x400e0e00)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0x400e0600)))

	// Pulse Width Modulation Controller
	PWM0 = (*PWM_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Quad Serial Peripheral Interface
	QSPI = (*QSPI_Type)(unsafe.Pointer(uintptr(0x4007c000)))

	// Reset Controller
	RSTC = (*RSTC_Type)(unsafe.Pointer(uintptr(0x400e1800)))

	// Reinforced Safety Watchdog Timer
	RSWDT = (*RSWDT_Type)(unsafe.Pointer(uintptr(0x400e1900)))

	// Real-time Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x400e1860)))

	// Real-time Timer
	RTT = (*RTT_Type)(unsafe.Pointer(uintptr(0x400e1830)))

	// Synchronous Serial Controller
	SSC = (*SSC_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Supply Controller
	SUPC = (*SUPC_Type)(unsafe.Pointer(uintptr(0x400e1810)))

	// Timer Counter
	TC0 = (*TC_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// True Random Number Generator
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0x40070000)))

	// Two-wire Interface High Speed
	TWIHS0 = (*TWIHS_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Universal Asynchronous Receiver Transmitter
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x400e0800)))

	// Universal Synchronous Asynchronous Receiver Transmitter
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// USB High-Speed Interface
	USBHS = (*USBHS_Type)(unsafe.Pointer(uintptr(0x40038000)))

	// USB Transmitter Interface Macrocell
	UTMI = (*UTMI_Type)(unsafe.Pointer(uintptr(0x400e0400)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x400e1850)))

	// Extensible DMA Controller
	XDMAC = (*XDMAC_Type)(unsafe.Pointer(uintptr(0x40078000)))

	LOCKBIT = (*LOCKBIT_Type)(unsafe.Pointer(uintptr(0x0)))

	// System control not in SCB
	SCnSCB = (*SCnSCB_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// System Control Block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// System timer
	SysTick = (*SysTick_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Memory Protection Unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// Floating Point Unit
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ef30)))

	// Analog Front-End Controller
	AFEC1 = (*AFEC_Type)(unsafe.Pointer(uintptr(0x40064000)))

	// Parallel Input/Output Controller
	PIOB = (*PIO_Type)(unsafe.Pointer(uintptr(0x400e1000)))

	// Parallel Input/Output Controller
	PIOD = (*PIO_Type)(unsafe.Pointer(uintptr(0x400e1400)))

	// Pulse Width Modulation Controller
	PWM1 = (*PWM_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// Timer Counter
	TC1 = (*TC_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Timer Counter
	TC2 = (*TC_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Timer Counter
	TC3 = (*TC_Type)(unsafe.Pointer(uintptr(0x40054000)))

	// Two-wire Interface High Speed
	TWIHS1 = (*TWIHS_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Universal Asynchronous Receiver Transmitter
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0x400e0a00)))

	// Universal Asynchronous Receiver Transmitter
	UART2 = (*UART_Type)(unsafe.Pointer(uintptr(0x400e1a00)))

	// Universal Synchronous Asynchronous Receiver Transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40028000)))
)

// Analog Comparator Controller
type ACC_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	_    [28]byte
	IER  volatile.Register32 // 0x24
	IDR  volatile.Register32 // 0x28
	IMR  volatile.Register32 // 0x2C
	ISR  volatile.Register32 // 0x30
	_    [96]byte
	ACR  volatile.Register32 // 0x94
	_    [76]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// ACC.CR: Control Register
func (o *ACC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// ACC.MR: Mode Register
func (o *ACC_Type) SetMR_SELMINUS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7)|value)
}
func (o *ACC_Type) GetMR_SELMINUS() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x7
}
func (o *ACC_Type) SetMR_SELPLUS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x70)|value<<4)
}
func (o *ACC_Type) GetMR_SELPLUS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x70) >> 4
}
func (o *ACC_Type) SetMR_ACEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *ACC_Type) GetMR_ACEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}
func (o *ACC_Type) SetMR_EDGETYP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x600)|value<<9)
}
func (o *ACC_Type) GetMR_EDGETYP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x600) >> 9
}
func (o *ACC_Type) SetMR_INV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *ACC_Type) GetMR_INV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *ACC_Type) SetMR_SELFS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *ACC_Type) GetMR_SELFS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *ACC_Type) SetMR_FE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000)|value<<14)
}
func (o *ACC_Type) GetMR_FE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000) >> 14
}

// ACC.IER: Interrupt Enable Register
func (o *ACC_Type) SetIER_CE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetIER_CE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// ACC.IDR: Interrupt Disable Register
func (o *ACC_Type) SetIDR_CE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetIDR_CE() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// ACC.IMR: Interrupt Mask Register
func (o *ACC_Type) SetIMR_CE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetIMR_CE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// ACC.ISR: Interrupt Status Register
func (o *ACC_Type) SetISR_CE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetISR_CE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *ACC_Type) SetISR_SCO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ACC_Type) GetISR_SCO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ACC_Type) SetISR_MASK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *ACC_Type) GetISR_MASK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// ACC.ACR: Analog Control Register
func (o *ACC_Type) SetACR_ISEL(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetACR_ISEL() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *ACC_Type) SetACR_HYST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x6)|value<<1)
}
func (o *ACC_Type) GetACR_HYST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x6) >> 1
}

// ACC.WPMR: Write Protection Mode Register
func (o *ACC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *ACC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ACC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// ACC.WPSR: Write Protection Status Register
func (o *ACC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *ACC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}

// Advanced Encryption Standard
type AES_Type struct {
	CR      volatile.Register32 // 0x0
	MR      volatile.Register32 // 0x4
	_       [8]byte
	IER     volatile.Register32    // 0x10
	IDR     volatile.Register32    // 0x14
	IMR     volatile.Register32    // 0x18
	ISR     volatile.Register32    // 0x1C
	KEYWR   [8]volatile.Register32 // 0x20
	IDATAR  [4]volatile.Register32 // 0x40
	ODATAR  [4]volatile.Register32 // 0x50
	IVR     [4]volatile.Register32 // 0x60
	AADLENR volatile.Register32    // 0x70
	CLENR   volatile.Register32    // 0x74
	GHASHR  [4]volatile.Register32 // 0x78
	TAGR    [4]volatile.Register32 // 0x88
	CTRR    volatile.Register32    // 0x98
	GCMHR   [4]volatile.Register32 // 0x9C
}

// AES.CR: Control Register
func (o *AES_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *AES_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// AES.MR: Mode Register
func (o *AES_Type) SetMR_CIPHER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetMR_CIPHER() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *AES_Type) SetMR_GTAGEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetMR_GTAGEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *AES_Type) SetMR_DUALBUFF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8)|value<<3)
}
func (o *AES_Type) GetMR_DUALBUFF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8) >> 3
}
func (o *AES_Type) SetMR_PROCDLY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0)|value<<4)
}
func (o *AES_Type) GetMR_PROCDLY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0) >> 4
}
func (o *AES_Type) SetMR_SMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x300)|value<<8)
}
func (o *AES_Type) GetMR_SMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x300) >> 8
}
func (o *AES_Type) SetMR_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc00)|value<<10)
}
func (o *AES_Type) GetMR_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc00) >> 10
}
func (o *AES_Type) SetMR_OPMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000)|value<<12)
}
func (o *AES_Type) GetMR_OPMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000) >> 12
}
func (o *AES_Type) SetMR_LOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *AES_Type) GetMR_LOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *AES_Type) SetMR_CFBS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x70000)|value<<16)
}
func (o *AES_Type) GetMR_CFBS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x70000) >> 16
}
func (o *AES_Type) SetMR_CKEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00000)|value<<20)
}
func (o *AES_Type) GetMR_CKEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00000) >> 20
}

// AES.IER: Interrupt Enable Register
func (o *AES_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *AES_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetIER_TAGRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetIER_TAGRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}

// AES.IDR: Interrupt Disable Register
func (o *AES_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *AES_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetIDR_TAGRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetIDR_TAGRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}

// AES.IMR: Interrupt Mask Register
func (o *AES_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *AES_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetIMR_TAGRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetIMR_TAGRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}

// AES.ISR: Interrupt Status Register
func (o *AES_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *AES_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetISR_URAT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf000)|value<<12)
}
func (o *AES_Type) GetISR_URAT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf000) >> 12
}
func (o *AES_Type) SetISR_TAGRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetISR_TAGRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}

// AES.KEYWR: Key Word Register 0
func (o *AES_Type) SetKEYWR(idx int, value uint32) {
	volatile.StoreUint32(&o.KEYWR[idx].Reg, value)
}
func (o *AES_Type) GetKEYWR(idx int) uint32 {
	return volatile.LoadUint32(&o.KEYWR[idx].Reg)
}

// AES.IDATAR: Input Data Register 0
func (o *AES_Type) SetIDATAR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDATAR[idx].Reg, value)
}
func (o *AES_Type) GetIDATAR(idx int) uint32 {
	return volatile.LoadUint32(&o.IDATAR[idx].Reg)
}

// AES.ODATAR: Output Data Register 0
func (o *AES_Type) SetODATAR(idx int, value uint32) {
	volatile.StoreUint32(&o.ODATAR[idx].Reg, value)
}
func (o *AES_Type) GetODATAR(idx int) uint32 {
	return volatile.LoadUint32(&o.ODATAR[idx].Reg)
}

// AES.IVR: Initialization Vector Register 0
func (o *AES_Type) SetIVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IVR[idx].Reg, value)
}
func (o *AES_Type) GetIVR(idx int) uint32 {
	return volatile.LoadUint32(&o.IVR[idx].Reg)
}

// AES.AADLENR: Additional Authenticated Data Length Register
func (o *AES_Type) SetAADLENR(value uint32) {
	volatile.StoreUint32(&o.AADLENR.Reg, value)
}
func (o *AES_Type) GetAADLENR() uint32 {
	return volatile.LoadUint32(&o.AADLENR.Reg)
}

// AES.CLENR: Plaintext/Ciphertext Length Register
func (o *AES_Type) SetCLENR(value uint32) {
	volatile.StoreUint32(&o.CLENR.Reg, value)
}
func (o *AES_Type) GetCLENR() uint32 {
	return volatile.LoadUint32(&o.CLENR.Reg)
}

// AES.GHASHR: GCM Intermediate Hash Word Register 0
func (o *AES_Type) SetGHASHR(idx int, value uint32) {
	volatile.StoreUint32(&o.GHASHR[idx].Reg, value)
}
func (o *AES_Type) GetGHASHR(idx int) uint32 {
	return volatile.LoadUint32(&o.GHASHR[idx].Reg)
}

// AES.TAGR: GCM Authentication Tag Word Register 0
func (o *AES_Type) SetTAGR(idx int, value uint32) {
	volatile.StoreUint32(&o.TAGR[idx].Reg, value)
}
func (o *AES_Type) GetTAGR(idx int) uint32 {
	return volatile.LoadUint32(&o.TAGR[idx].Reg)
}

// AES.CTRR: GCM Encryption Counter Value Register
func (o *AES_Type) SetCTRR(value uint32) {
	volatile.StoreUint32(&o.CTRR.Reg, value)
}
func (o *AES_Type) GetCTRR() uint32 {
	return volatile.LoadUint32(&o.CTRR.Reg)
}

// AES.GCMHR: GCM H Word Register 0
func (o *AES_Type) SetGCMHR(idx int, value uint32) {
	volatile.StoreUint32(&o.GCMHR[idx].Reg, value)
}
func (o *AES_Type) GetGCMHR(idx int) uint32 {
	return volatile.LoadUint32(&o.GCMHR[idx].Reg)
}

// Analog Front-End Controller
type AFEC_Type struct {
	CR      volatile.Register32 // 0x0
	MR      volatile.Register32 // 0x4
	EMR     volatile.Register32 // 0x8
	SEQ1R   volatile.Register32 // 0xC
	SEQ2R   volatile.Register32 // 0x10
	CHER    volatile.Register32 // 0x14
	CHDR    volatile.Register32 // 0x18
	CHSR    volatile.Register32 // 0x1C
	LCDR    volatile.Register32 // 0x20
	IER     volatile.Register32 // 0x24
	IDR     volatile.Register32 // 0x28
	IMR     volatile.Register32 // 0x2C
	ISR     volatile.Register32 // 0x30
	_       [24]byte
	OVER    volatile.Register32 // 0x4C
	CWR     volatile.Register32 // 0x50
	CGR     volatile.Register32 // 0x54
	_       [8]byte
	DIFFR   volatile.Register32 // 0x60
	CSELR   volatile.Register32 // 0x64
	CDR     volatile.Register32 // 0x68
	COCR    volatile.Register32 // 0x6C
	TEMPMR  volatile.Register32 // 0x70
	TEMPCWR volatile.Register32 // 0x74
	_       [28]byte
	ACR     volatile.Register32 // 0x94
	_       [8]byte
	SHMR    volatile.Register32 // 0xA0
	_       [44]byte
	COSR    volatile.Register32 // 0xD0
	CVR     volatile.Register32 // 0xD4
	CECR    volatile.Register32 // 0xD8
	_       [8]byte
	WPMR    volatile.Register32 // 0xE4
	WPSR    volatile.Register32 // 0xE8
}

// AFEC.CR: AFEC Control Register
func (o *AFEC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *AFEC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}

// AFEC.MR: AFEC Mode Register
func (o *AFEC_Type) SetMR_TRGEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetMR_TRGEN() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *AFEC_Type) SetMR_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe)|value<<1)
}
func (o *AFEC_Type) GetMR_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe) >> 1
}
func (o *AFEC_Type) SetMR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetMR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetMR_FWUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetMR_FWUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetMR_FREERUN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetMR_FREERUN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetMR_PRESCAL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *AFEC_Type) GetMR_PRESCAL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}
func (o *AFEC_Type) SetMR_STARTUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *AFEC_Type) GetMR_STARTUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *AFEC_Type) SetMR_ONE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *AFEC_Type) GetMR_ONE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *AFEC_Type) SetMR_TRACKTIM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *AFEC_Type) GetMR_TRACKTIM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}
func (o *AFEC_Type) SetMR_TRANSFER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30000000)|value<<28)
}
func (o *AFEC_Type) GetMR_TRANSFER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30000000) >> 28
}
func (o *AFEC_Type) SetMR_USEQ(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *AFEC_Type) GetMR_USEQ() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// AFEC.EMR: AFEC Extended Mode Register
func (o *AFEC_Type) SetEMR_CMPMODE(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3)|value)
}
func (o *AFEC_Type) GetEMR_CMPMODE() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x3
}
func (o *AFEC_Type) SetEMR_CMPSEL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xf8)|value<<3)
}
func (o *AFEC_Type) GetEMR_CMPSEL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xf8) >> 3
}
func (o *AFEC_Type) SetEMR_CMPALL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetEMR_CMPALL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetEMR_CMPFILTER(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3000)|value<<12)
}
func (o *AFEC_Type) GetEMR_CMPFILTER() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x3000) >> 12
}
func (o *AFEC_Type) SetEMR_RES(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x70000)|value<<16)
}
func (o *AFEC_Type) GetEMR_RES() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x70000) >> 16
}
func (o *AFEC_Type) SetEMR_TAG(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1000000)|value<<24)
}
func (o *AFEC_Type) GetEMR_TAG() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x1000000) >> 24
}
func (o *AFEC_Type) SetEMR_STM(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2000000)|value<<25)
}
func (o *AFEC_Type) GetEMR_STM() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2000000) >> 25
}
func (o *AFEC_Type) SetEMR_SIGNMODE(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30000000)|value<<28)
}
func (o *AFEC_Type) GetEMR_SIGNMODE() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30000000) >> 28
}

// AFEC.SEQ1R: AFEC Channel Sequence 1 Register
func (o *AFEC_Type) SetSEQ1R_USCH0(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf)|value)
}
func (o *AFEC_Type) GetSEQ1R_USCH0() uint32 {
	return volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf
}
func (o *AFEC_Type) SetSEQ1R_USCH1(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf0)|value<<4)
}
func (o *AFEC_Type) GetSEQ1R_USCH1() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf0) >> 4
}
func (o *AFEC_Type) SetSEQ1R_USCH2(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf00)|value<<8)
}
func (o *AFEC_Type) GetSEQ1R_USCH2() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf00) >> 8
}
func (o *AFEC_Type) SetSEQ1R_USCH3(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf000)|value<<12)
}
func (o *AFEC_Type) GetSEQ1R_USCH3() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf000) >> 12
}
func (o *AFEC_Type) SetSEQ1R_USCH4(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf0000)|value<<16)
}
func (o *AFEC_Type) GetSEQ1R_USCH4() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf0000) >> 16
}
func (o *AFEC_Type) SetSEQ1R_USCH5(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf00000)|value<<20)
}
func (o *AFEC_Type) GetSEQ1R_USCH5() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf00000) >> 20
}
func (o *AFEC_Type) SetSEQ1R_USCH6(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf000000)|value<<24)
}
func (o *AFEC_Type) GetSEQ1R_USCH6() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf000000) >> 24
}
func (o *AFEC_Type) SetSEQ1R_USCH7(value uint32) {
	volatile.StoreUint32(&o.SEQ1R.Reg, volatile.LoadUint32(&o.SEQ1R.Reg)&^(0xf0000000)|value<<28)
}
func (o *AFEC_Type) GetSEQ1R_USCH7() uint32 {
	return (volatile.LoadUint32(&o.SEQ1R.Reg) & 0xf0000000) >> 28
}

// AFEC.SEQ2R: AFEC Channel Sequence 2 Register
func (o *AFEC_Type) SetSEQ2R_USCH8(value uint32) {
	volatile.StoreUint32(&o.SEQ2R.Reg, volatile.LoadUint32(&o.SEQ2R.Reg)&^(0xf)|value)
}
func (o *AFEC_Type) GetSEQ2R_USCH8() uint32 {
	return volatile.LoadUint32(&o.SEQ2R.Reg) & 0xf
}
func (o *AFEC_Type) SetSEQ2R_USCH9(value uint32) {
	volatile.StoreUint32(&o.SEQ2R.Reg, volatile.LoadUint32(&o.SEQ2R.Reg)&^(0xf0)|value<<4)
}
func (o *AFEC_Type) GetSEQ2R_USCH9() uint32 {
	return (volatile.LoadUint32(&o.SEQ2R.Reg) & 0xf0) >> 4
}
func (o *AFEC_Type) SetSEQ2R_USCH10(value uint32) {
	volatile.StoreUint32(&o.SEQ2R.Reg, volatile.LoadUint32(&o.SEQ2R.Reg)&^(0xf00)|value<<8)
}
func (o *AFEC_Type) GetSEQ2R_USCH10() uint32 {
	return (volatile.LoadUint32(&o.SEQ2R.Reg) & 0xf00) >> 8
}
func (o *AFEC_Type) SetSEQ2R_USCH11(value uint32) {
	volatile.StoreUint32(&o.SEQ2R.Reg, volatile.LoadUint32(&o.SEQ2R.Reg)&^(0xf000)|value<<12)
}
func (o *AFEC_Type) GetSEQ2R_USCH11() uint32 {
	return (volatile.LoadUint32(&o.SEQ2R.Reg) & 0xf000) >> 12
}

// AFEC.CHER: AFEC Channel Enable Register
func (o *AFEC_Type) SetCHER_CH0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCHER_CH0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *AFEC_Type) SetCHER_CH1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetCHER_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetCHER_CH2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetCHER_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetCHER_CH3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetCHER_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetCHER_CH4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetCHER_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetCHER_CH5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetCHER_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetCHER_CH6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetCHER_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetCHER_CH7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetCHER_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetCHER_CH8(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetCHER_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetCHER_CH9(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetCHER_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetCHER_CH10(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetCHER_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetCHER_CH11(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetCHER_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}

// AFEC.CHDR: AFEC Channel Disable Register
func (o *AFEC_Type) SetCHDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCHDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *AFEC_Type) SetCHDR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetCHDR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetCHDR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetCHDR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetCHDR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetCHDR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetCHDR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetCHDR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetCHDR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetCHDR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetCHDR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetCHDR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetCHDR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetCHDR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetCHDR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetCHDR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetCHDR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetCHDR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetCHDR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetCHDR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetCHDR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetCHDR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}

// AFEC.CHSR: AFEC Channel Status Register
func (o *AFEC_Type) SetCHSR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCHSR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *AFEC_Type) SetCHSR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetCHSR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetCHSR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetCHSR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetCHSR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetCHSR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetCHSR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetCHSR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetCHSR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetCHSR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetCHSR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetCHSR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetCHSR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetCHSR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetCHSR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetCHSR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetCHSR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetCHSR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetCHSR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetCHSR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetCHSR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetCHSR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}

// AFEC.LCDR: AFEC Last Converted Data Register
func (o *AFEC_Type) SetLCDR_LDATA(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xffff)|value)
}
func (o *AFEC_Type) GetLCDR_LDATA() uint32 {
	return volatile.LoadUint32(&o.LCDR.Reg) & 0xffff
}
func (o *AFEC_Type) SetLCDR_CHNB(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xf000000)|value<<24)
}
func (o *AFEC_Type) GetLCDR_CHNB() uint32 {
	return (volatile.LoadUint32(&o.LCDR.Reg) & 0xf000000) >> 24
}

// AFEC.IER: AFEC Interrupt Enable Register
func (o *AFEC_Type) SetIER_EOC0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetIER_EOC0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *AFEC_Type) SetIER_EOC1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetIER_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetIER_EOC2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetIER_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetIER_EOC3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetIER_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetIER_EOC4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetIER_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetIER_EOC5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetIER_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetIER_EOC6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetIER_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetIER_EOC7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetIER_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetIER_EOC8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetIER_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetIER_EOC9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetIER_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetIER_EOC10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetIER_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetIER_EOC11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetIER_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *AFEC_Type) SetIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *AFEC_Type) GetIER_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *AFEC_Type) SetIER_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *AFEC_Type) GetIER_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *AFEC_Type) SetIER_COMPE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *AFEC_Type) GetIER_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *AFEC_Type) SetIER_TEMPCHG(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *AFEC_Type) GetIER_TEMPCHG() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}

// AFEC.IDR: AFEC Interrupt Disable Register
func (o *AFEC_Type) SetIDR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetIDR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *AFEC_Type) SetIDR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetIDR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetIDR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetIDR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetIDR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetIDR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetIDR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetIDR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetIDR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetIDR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetIDR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetIDR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetIDR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetIDR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetIDR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetIDR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetIDR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetIDR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetIDR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetIDR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetIDR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetIDR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *AFEC_Type) SetIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *AFEC_Type) GetIDR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *AFEC_Type) SetIDR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *AFEC_Type) GetIDR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *AFEC_Type) SetIDR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *AFEC_Type) GetIDR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *AFEC_Type) SetIDR_TEMPCHG(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *AFEC_Type) GetIDR_TEMPCHG() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}

// AFEC.IMR: AFEC Interrupt Mask Register
func (o *AFEC_Type) SetIMR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetIMR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *AFEC_Type) SetIMR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetIMR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetIMR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetIMR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetIMR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetIMR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetIMR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetIMR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetIMR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetIMR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetIMR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetIMR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetIMR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetIMR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetIMR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetIMR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetIMR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetIMR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetIMR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetIMR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetIMR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetIMR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *AFEC_Type) SetIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *AFEC_Type) GetIMR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *AFEC_Type) SetIMR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *AFEC_Type) GetIMR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *AFEC_Type) SetIMR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *AFEC_Type) GetIMR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *AFEC_Type) SetIMR_TEMPCHG(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *AFEC_Type) GetIMR_TEMPCHG() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}

// AFEC.ISR: AFEC Interrupt Status Register
func (o *AFEC_Type) SetISR_EOC0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetISR_EOC0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *AFEC_Type) SetISR_EOC1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetISR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetISR_EOC2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetISR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetISR_EOC3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetISR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetISR_EOC4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetISR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetISR_EOC5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetISR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetISR_EOC6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetISR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetISR_EOC7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetISR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetISR_EOC8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetISR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetISR_EOC9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetISR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetISR_EOC10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetISR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetISR_EOC11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetISR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *AFEC_Type) SetISR_DRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *AFEC_Type) GetISR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *AFEC_Type) SetISR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *AFEC_Type) GetISR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *AFEC_Type) SetISR_COMPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *AFEC_Type) GetISR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *AFEC_Type) SetISR_TEMPCHG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *AFEC_Type) GetISR_TEMPCHG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}

// AFEC.OVER: AFEC Overrun Status Register
func (o *AFEC_Type) SetOVER_OVRE0(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetOVER_OVRE0() uint32 {
	return volatile.LoadUint32(&o.OVER.Reg) & 0x1
}
func (o *AFEC_Type) SetOVER_OVRE1(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetOVER_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetOVER_OVRE2(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetOVER_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetOVER_OVRE3(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetOVER_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetOVER_OVRE4(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetOVER_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetOVER_OVRE5(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetOVER_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetOVER_OVRE6(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetOVER_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetOVER_OVRE7(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetOVER_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetOVER_OVRE8(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetOVER_OVRE8() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetOVER_OVRE9(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetOVER_OVRE9() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetOVER_OVRE10(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetOVER_OVRE10() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetOVER_OVRE11(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetOVER_OVRE11() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x800) >> 11
}

// AFEC.CWR: AFEC Compare Window Register
func (o *AFEC_Type) SetCWR_LOWTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xffff)|value)
}
func (o *AFEC_Type) GetCWR_LOWTHRES() uint32 {
	return volatile.LoadUint32(&o.CWR.Reg) & 0xffff
}
func (o *AFEC_Type) SetCWR_HIGHTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xffff0000)|value<<16)
}
func (o *AFEC_Type) GetCWR_HIGHTHRES() uint32 {
	return (volatile.LoadUint32(&o.CWR.Reg) & 0xffff0000) >> 16
}

// AFEC.CGR: AFEC Channel Gain Register
func (o *AFEC_Type) SetCGR_GAIN0(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3)|value)
}
func (o *AFEC_Type) GetCGR_GAIN0() uint32 {
	return volatile.LoadUint32(&o.CGR.Reg) & 0x3
}
func (o *AFEC_Type) SetCGR_GAIN1(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc)|value<<2)
}
func (o *AFEC_Type) GetCGR_GAIN1() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc) >> 2
}
func (o *AFEC_Type) SetCGR_GAIN2(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30)|value<<4)
}
func (o *AFEC_Type) GetCGR_GAIN2() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30) >> 4
}
func (o *AFEC_Type) SetCGR_GAIN3(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0)|value<<6)
}
func (o *AFEC_Type) GetCGR_GAIN3() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0) >> 6
}
func (o *AFEC_Type) SetCGR_GAIN4(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300)|value<<8)
}
func (o *AFEC_Type) GetCGR_GAIN4() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300) >> 8
}
func (o *AFEC_Type) SetCGR_GAIN5(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00)|value<<10)
}
func (o *AFEC_Type) GetCGR_GAIN5() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00) >> 10
}
func (o *AFEC_Type) SetCGR_GAIN6(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3000)|value<<12)
}
func (o *AFEC_Type) GetCGR_GAIN6() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x3000) >> 12
}
func (o *AFEC_Type) SetCGR_GAIN7(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc000)|value<<14)
}
func (o *AFEC_Type) GetCGR_GAIN7() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc000) >> 14
}
func (o *AFEC_Type) SetCGR_GAIN8(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30000)|value<<16)
}
func (o *AFEC_Type) GetCGR_GAIN8() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30000) >> 16
}
func (o *AFEC_Type) SetCGR_GAIN9(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0000)|value<<18)
}
func (o *AFEC_Type) GetCGR_GAIN9() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0000) >> 18
}
func (o *AFEC_Type) SetCGR_GAIN10(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300000)|value<<20)
}
func (o *AFEC_Type) GetCGR_GAIN10() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300000) >> 20
}
func (o *AFEC_Type) SetCGR_GAIN11(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00000)|value<<22)
}
func (o *AFEC_Type) GetCGR_GAIN11() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00000) >> 22
}

// AFEC.DIFFR: AFEC Channel Differential Register
func (o *AFEC_Type) SetDIFFR_DIFF0(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetDIFFR_DIFF0() uint32 {
	return volatile.LoadUint32(&o.DIFFR.Reg) & 0x1
}
func (o *AFEC_Type) SetDIFFR_DIFF1(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetDIFFR_DIFF1() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetDIFFR_DIFF2(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetDIFFR_DIFF2() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetDIFFR_DIFF3(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetDIFFR_DIFF3() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetDIFFR_DIFF4(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetDIFFR_DIFF4() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetDIFFR_DIFF5(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetDIFFR_DIFF5() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetDIFFR_DIFF6(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetDIFFR_DIFF6() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetDIFFR_DIFF7(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetDIFFR_DIFF7() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetDIFFR_DIFF8(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetDIFFR_DIFF8() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetDIFFR_DIFF9(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetDIFFR_DIFF9() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetDIFFR_DIFF10(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetDIFFR_DIFF10() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetDIFFR_DIFF11(value uint32) {
	volatile.StoreUint32(&o.DIFFR.Reg, volatile.LoadUint32(&o.DIFFR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetDIFFR_DIFF11() uint32 {
	return (volatile.LoadUint32(&o.DIFFR.Reg) & 0x800) >> 11
}

// AFEC.CSELR: AFEC Channel Selection Register
func (o *AFEC_Type) SetCSELR_CSEL(value uint32) {
	volatile.StoreUint32(&o.CSELR.Reg, volatile.LoadUint32(&o.CSELR.Reg)&^(0xf)|value)
}
func (o *AFEC_Type) GetCSELR_CSEL() uint32 {
	return volatile.LoadUint32(&o.CSELR.Reg) & 0xf
}

// AFEC.CDR: AFEC Channel Data Register
func (o *AFEC_Type) SetCDR_DATA(value uint32) {
	volatile.StoreUint32(&o.CDR.Reg, volatile.LoadUint32(&o.CDR.Reg)&^(0xffff)|value)
}
func (o *AFEC_Type) GetCDR_DATA() uint32 {
	return volatile.LoadUint32(&o.CDR.Reg) & 0xffff
}

// AFEC.COCR: AFEC Channel Offset Compensation Register
func (o *AFEC_Type) SetCOCR_AOFF(value uint32) {
	volatile.StoreUint32(&o.COCR.Reg, volatile.LoadUint32(&o.COCR.Reg)&^(0x3ff)|value)
}
func (o *AFEC_Type) GetCOCR_AOFF() uint32 {
	return volatile.LoadUint32(&o.COCR.Reg) & 0x3ff
}

// AFEC.TEMPMR: AFEC Temperature Sensor Mode Register
func (o *AFEC_Type) SetTEMPMR_RTCT(value uint32) {
	volatile.StoreUint32(&o.TEMPMR.Reg, volatile.LoadUint32(&o.TEMPMR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetTEMPMR_RTCT() uint32 {
	return volatile.LoadUint32(&o.TEMPMR.Reg) & 0x1
}
func (o *AFEC_Type) SetTEMPMR_TEMPCMPMOD(value uint32) {
	volatile.StoreUint32(&o.TEMPMR.Reg, volatile.LoadUint32(&o.TEMPMR.Reg)&^(0x30)|value<<4)
}
func (o *AFEC_Type) GetTEMPMR_TEMPCMPMOD() uint32 {
	return (volatile.LoadUint32(&o.TEMPMR.Reg) & 0x30) >> 4
}

// AFEC.TEMPCWR: AFEC Temperature Compare Window Register
func (o *AFEC_Type) SetTEMPCWR_TLOWTHRES(value uint32) {
	volatile.StoreUint32(&o.TEMPCWR.Reg, volatile.LoadUint32(&o.TEMPCWR.Reg)&^(0xffff)|value)
}
func (o *AFEC_Type) GetTEMPCWR_TLOWTHRES() uint32 {
	return volatile.LoadUint32(&o.TEMPCWR.Reg) & 0xffff
}
func (o *AFEC_Type) SetTEMPCWR_THIGHTHRES(value uint32) {
	volatile.StoreUint32(&o.TEMPCWR.Reg, volatile.LoadUint32(&o.TEMPCWR.Reg)&^(0xffff0000)|value<<16)
}
func (o *AFEC_Type) GetTEMPCWR_THIGHTHRES() uint32 {
	return (volatile.LoadUint32(&o.TEMPCWR.Reg) & 0xffff0000) >> 16
}

// AFEC.ACR: AFEC Analog Control Register
func (o *AFEC_Type) SetACR_PGA0EN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetACR_PGA0EN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetACR_PGA1EN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetACR_PGA1EN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetACR_IBCTL(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x300)|value<<8)
}
func (o *AFEC_Type) GetACR_IBCTL() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x300) >> 8
}

// AFEC.SHMR: AFEC Sample & Hold Mode Register
func (o *AFEC_Type) SetSHMR_DUAL0(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetSHMR_DUAL0() uint32 {
	return volatile.LoadUint32(&o.SHMR.Reg) & 0x1
}
func (o *AFEC_Type) SetSHMR_DUAL1(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetSHMR_DUAL1() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetSHMR_DUAL2(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetSHMR_DUAL2() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetSHMR_DUAL3(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetSHMR_DUAL3() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetSHMR_DUAL4(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetSHMR_DUAL4() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetSHMR_DUAL5(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetSHMR_DUAL5() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetSHMR_DUAL6(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetSHMR_DUAL6() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetSHMR_DUAL7(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetSHMR_DUAL7() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetSHMR_DUAL8(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetSHMR_DUAL8() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetSHMR_DUAL9(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetSHMR_DUAL9() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetSHMR_DUAL10(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetSHMR_DUAL10() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetSHMR_DUAL11(value uint32) {
	volatile.StoreUint32(&o.SHMR.Reg, volatile.LoadUint32(&o.SHMR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetSHMR_DUAL11() uint32 {
	return (volatile.LoadUint32(&o.SHMR.Reg) & 0x800) >> 11
}

// AFEC.COSR: AFEC Correction Select Register
func (o *AFEC_Type) SetCOSR_CSEL(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCOSR_CSEL() uint32 {
	return volatile.LoadUint32(&o.COSR.Reg) & 0x1
}

// AFEC.CVR: AFEC Correction Values Register
func (o *AFEC_Type) SetCVR_OFFSETCORR(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffff)|value)
}
func (o *AFEC_Type) GetCVR_OFFSETCORR() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffff
}
func (o *AFEC_Type) SetCVR_GAINCORR(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffff0000)|value<<16)
}
func (o *AFEC_Type) GetCVR_GAINCORR() uint32 {
	return (volatile.LoadUint32(&o.CVR.Reg) & 0xffff0000) >> 16
}

// AFEC.CECR: AFEC Channel Error Correction Register
func (o *AFEC_Type) SetCECR_ECORR0(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetCECR_ECORR0() uint32 {
	return volatile.LoadUint32(&o.CECR.Reg) & 0x1
}
func (o *AFEC_Type) SetCECR_ECORR1(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x2)|value<<1)
}
func (o *AFEC_Type) GetCECR_ECORR1() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x2) >> 1
}
func (o *AFEC_Type) SetCECR_ECORR2(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x4)|value<<2)
}
func (o *AFEC_Type) GetCECR_ECORR2() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x4) >> 2
}
func (o *AFEC_Type) SetCECR_ECORR3(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x8)|value<<3)
}
func (o *AFEC_Type) GetCECR_ECORR3() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x8) >> 3
}
func (o *AFEC_Type) SetCECR_ECORR4(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x10)|value<<4)
}
func (o *AFEC_Type) GetCECR_ECORR4() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x10) >> 4
}
func (o *AFEC_Type) SetCECR_ECORR5(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x20)|value<<5)
}
func (o *AFEC_Type) GetCECR_ECORR5() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x20) >> 5
}
func (o *AFEC_Type) SetCECR_ECORR6(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x40)|value<<6)
}
func (o *AFEC_Type) GetCECR_ECORR6() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x40) >> 6
}
func (o *AFEC_Type) SetCECR_ECORR7(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x80)|value<<7)
}
func (o *AFEC_Type) GetCECR_ECORR7() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x80) >> 7
}
func (o *AFEC_Type) SetCECR_ECORR8(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x100)|value<<8)
}
func (o *AFEC_Type) GetCECR_ECORR8() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x100) >> 8
}
func (o *AFEC_Type) SetCECR_ECORR9(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x200)|value<<9)
}
func (o *AFEC_Type) GetCECR_ECORR9() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x200) >> 9
}
func (o *AFEC_Type) SetCECR_ECORR10(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x400)|value<<10)
}
func (o *AFEC_Type) GetCECR_ECORR10() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x400) >> 10
}
func (o *AFEC_Type) SetCECR_ECORR11(value uint32) {
	volatile.StoreUint32(&o.CECR.Reg, volatile.LoadUint32(&o.CECR.Reg)&^(0x800)|value<<11)
}
func (o *AFEC_Type) GetCECR_ECORR11() uint32 {
	return (volatile.LoadUint32(&o.CECR.Reg) & 0x800) >> 11
}

// AFEC.WPMR: AFEC Write Protection Mode Register
func (o *AFEC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *AFEC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *AFEC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// AFEC.WPSR: AFEC Write Protection Status Register
func (o *AFEC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *AFEC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *AFEC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *AFEC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Chip Identifier
type CHIPID_Type struct {
	CIDR volatile.Register32 // 0x0
	EXID volatile.Register32 // 0x4
}

// CHIPID.CIDR: Chip ID Register
func (o *CHIPID_Type) SetCIDR_VERSION(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x1f)|value)
}
func (o *CHIPID_Type) GetCIDR_VERSION() uint32 {
	return volatile.LoadUint32(&o.CIDR.Reg) & 0x1f
}
func (o *CHIPID_Type) SetCIDR_EPROC(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xe0)|value<<5)
}
func (o *CHIPID_Type) GetCIDR_EPROC() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xe0) >> 5
}
func (o *CHIPID_Type) SetCIDR_NVPSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf00)|value<<8)
}
func (o *CHIPID_Type) GetCIDR_NVPSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf00) >> 8
}
func (o *CHIPID_Type) SetCIDR_NVPSIZ2(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf000)|value<<12)
}
func (o *CHIPID_Type) GetCIDR_NVPSIZ2() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf000) >> 12
}
func (o *CHIPID_Type) SetCIDR_SRAMSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf0000)|value<<16)
}
func (o *CHIPID_Type) GetCIDR_SRAMSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf0000) >> 16
}
func (o *CHIPID_Type) SetCIDR_ARCH(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xff00000)|value<<20)
}
func (o *CHIPID_Type) GetCIDR_ARCH() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xff00000) >> 20
}
func (o *CHIPID_Type) SetCIDR_NVPTYP(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x70000000)|value<<28)
}
func (o *CHIPID_Type) GetCIDR_NVPTYP() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x70000000) >> 28
}
func (o *CHIPID_Type) SetCIDR_EXT(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *CHIPID_Type) GetCIDR_EXT() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x80000000) >> 31
}

// CHIPID.EXID: Chip ID Extension Register
func (o *CHIPID_Type) SetEXID(value uint32) {
	volatile.StoreUint32(&o.EXID.Reg, value)
}
func (o *CHIPID_Type) GetEXID() uint32 {
	return volatile.LoadUint32(&o.EXID.Reg)
}

// Digital-to-Analog Converter Controller
type DACC_Type struct {
	CR    volatile.Register32 // 0x0
	MR    volatile.Register32 // 0x4
	TRIGR volatile.Register32 // 0x8
	_     [4]byte
	CHER  volatile.Register32    // 0x10
	CHDR  volatile.Register32    // 0x14
	CHSR  volatile.Register32    // 0x18
	CDR   [2]volatile.Register32 // 0x1C
	IER   volatile.Register32    // 0x24
	IDR   volatile.Register32    // 0x28
	IMR   volatile.Register32    // 0x2C
	ISR   volatile.Register32    // 0x30
	_     [96]byte
	ACR   volatile.Register32 // 0x94
	_     [76]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// DACC.CR: Control Register
func (o *DACC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DACC.MR: Mode Register
func (o *DACC_Type) SetMR_MAXS0(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetMR_MAXS0() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *DACC_Type) SetMR_MAXS1(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetMR_MAXS1() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetMR_WORD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *DACC_Type) GetMR_WORD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *DACC_Type) SetMR_ZERO(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *DACC_Type) GetMR_ZERO() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *DACC_Type) SetMR_DIFF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *DACC_Type) GetMR_DIFF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *DACC_Type) SetMR_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *DACC_Type) GetMR_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}

// DACC.TRIGR: Trigger Register
func (o *DACC_Type) SetTRIGR_TRGEN0(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetTRIGR_TRGEN0() uint32 {
	return volatile.LoadUint32(&o.TRIGR.Reg) & 0x1
}
func (o *DACC_Type) SetTRIGR_TRGEN1(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetTRIGR_TRGEN1() uint32 {
	return (volatile.LoadUint32(&o.TRIGR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetTRIGR_TRGSEL0(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x70)|value<<4)
}
func (o *DACC_Type) GetTRIGR_TRGSEL0() uint32 {
	return (volatile.LoadUint32(&o.TRIGR.Reg) & 0x70) >> 4
}
func (o *DACC_Type) SetTRIGR_TRGSEL1(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x700)|value<<8)
}
func (o *DACC_Type) GetTRIGR_TRGSEL1() uint32 {
	return (volatile.LoadUint32(&o.TRIGR.Reg) & 0x700) >> 8
}
func (o *DACC_Type) SetTRIGR_OSR0(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x70000)|value<<16)
}
func (o *DACC_Type) GetTRIGR_OSR0() uint32 {
	return (volatile.LoadUint32(&o.TRIGR.Reg) & 0x70000) >> 16
}
func (o *DACC_Type) SetTRIGR_OSR1(value uint32) {
	volatile.StoreUint32(&o.TRIGR.Reg, volatile.LoadUint32(&o.TRIGR.Reg)&^(0x700000)|value<<20)
}
func (o *DACC_Type) GetTRIGR_OSR1() uint32 {
	return (volatile.LoadUint32(&o.TRIGR.Reg) & 0x700000) >> 20
}

// DACC.CHER: Channel Enable Register
func (o *DACC_Type) SetCHER_CH0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetCHER_CH0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *DACC_Type) SetCHER_CH1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetCHER_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}

// DACC.CHDR: Channel Disable Register
func (o *DACC_Type) SetCHDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetCHDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *DACC_Type) SetCHDR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetCHDR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}

// DACC.CHSR: Channel Status Register
func (o *DACC_Type) SetCHSR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetCHSR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *DACC_Type) SetCHSR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetCHSR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetCHSR_DACRDY0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *DACC_Type) GetCHSR_DACRDY0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *DACC_Type) SetCHSR_DACRDY1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *DACC_Type) GetCHSR_DACRDY1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}

// DACC.CDR: Conversion Data Register 0
func (o *DACC_Type) SetCDR_DATA0(idx int, value uint32) {
	volatile.StoreUint32(&o.CDR[idx].Reg, volatile.LoadUint32(&o.CDR[idx].Reg)&^(0xffff)|value)
}
func (o *DACC_Type) GetCDR_DATA0(idx int) uint32 {
	return volatile.LoadUint32(&o.CDR[idx].Reg) & 0xffff
}
func (o *DACC_Type) SetCDR_DATA1(idx int, value uint32) {
	volatile.StoreUint32(&o.CDR[idx].Reg, volatile.LoadUint32(&o.CDR[idx].Reg)&^(0xffff0000)|value<<16)
}
func (o *DACC_Type) GetCDR_DATA1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CDR[idx].Reg) & 0xffff0000) >> 16
}

// DACC.IER: Interrupt Enable Register
func (o *DACC_Type) SetIER_TXRDY0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetIER_TXRDY0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *DACC_Type) SetIER_TXRDY1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetIER_TXRDY1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetIER_EOC0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *DACC_Type) GetIER_EOC0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *DACC_Type) SetIER_EOC1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *DACC_Type) GetIER_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}

// DACC.IDR: Interrupt Disable Register
func (o *DACC_Type) SetIDR_TXRDY0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetIDR_TXRDY0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *DACC_Type) SetIDR_TXRDY1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetIDR_TXRDY1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetIDR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *DACC_Type) GetIDR_EOC0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *DACC_Type) SetIDR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *DACC_Type) GetIDR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}

// DACC.IMR: Interrupt Mask Register
func (o *DACC_Type) SetIMR_TXRDY0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetIMR_TXRDY0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *DACC_Type) SetIMR_TXRDY1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetIMR_TXRDY1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetIMR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *DACC_Type) GetIMR_EOC0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *DACC_Type) SetIMR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *DACC_Type) GetIMR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}

// DACC.ISR: Interrupt Status Register
func (o *DACC_Type) SetISR_TXRDY0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetISR_TXRDY0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *DACC_Type) SetISR_TXRDY1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DACC_Type) GetISR_TXRDY1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DACC_Type) SetISR_EOC0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DACC_Type) GetISR_EOC0() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DACC_Type) SetISR_EOC1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DACC_Type) GetISR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}

// DACC.ACR: Analog Current Register
func (o *DACC_Type) SetACR_IBCTLCH0(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x3)|value)
}
func (o *DACC_Type) GetACR_IBCTLCH0() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x3
}
func (o *DACC_Type) SetACR_IBCTLCH1(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xc)|value<<2)
}
func (o *DACC_Type) GetACR_IBCTLCH1() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xc) >> 2
}

// DACC.WPMR: Write Protection Mode Register
func (o *DACC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *DACC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DACC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// DACC.WPSR: Write Protection Status Register
func (o *DACC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *DACC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *DACC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xff00)|value<<8)
}
func (o *DACC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xff00) >> 8
}

// Embedded Flash Controller
type EFC_Type struct {
	EEFC_FMR  volatile.Register32 // 0x0
	EEFC_FCR  volatile.Register32 // 0x4
	EEFC_FSR  volatile.Register32 // 0x8
	EEFC_FRR  volatile.Register32 // 0xC
	_         [212]byte
	EEFC_WPMR volatile.Register32 // 0xE4
}

// EFC.EEFC_FMR: EEFC Flash Mode Register
func (o *EFC_Type) SetEEFC_FMR_FRDY(value uint32) {
	volatile.StoreUint32(&o.EEFC_FMR.Reg, volatile.LoadUint32(&o.EEFC_FMR.Reg)&^(0x1)|value)
}
func (o *EFC_Type) GetEEFC_FMR_FRDY() uint32 {
	return volatile.LoadUint32(&o.EEFC_FMR.Reg) & 0x1
}
func (o *EFC_Type) SetEEFC_FMR_FWS(value uint32) {
	volatile.StoreUint32(&o.EEFC_FMR.Reg, volatile.LoadUint32(&o.EEFC_FMR.Reg)&^(0xf00)|value<<8)
}
func (o *EFC_Type) GetEEFC_FMR_FWS() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FMR.Reg) & 0xf00) >> 8
}
func (o *EFC_Type) SetEEFC_FMR_SCOD(value uint32) {
	volatile.StoreUint32(&o.EEFC_FMR.Reg, volatile.LoadUint32(&o.EEFC_FMR.Reg)&^(0x10000)|value<<16)
}
func (o *EFC_Type) GetEEFC_FMR_SCOD() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FMR.Reg) & 0x10000) >> 16
}
func (o *EFC_Type) SetEEFC_FMR_CLOE(value uint32) {
	volatile.StoreUint32(&o.EEFC_FMR.Reg, volatile.LoadUint32(&o.EEFC_FMR.Reg)&^(0x4000000)|value<<26)
}
func (o *EFC_Type) GetEEFC_FMR_CLOE() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FMR.Reg) & 0x4000000) >> 26
}

// EFC.EEFC_FCR: EEFC Flash Command Register
func (o *EFC_Type) SetEEFC_FCR_FCMD(value uint32) {
	volatile.StoreUint32(&o.EEFC_FCR.Reg, volatile.LoadUint32(&o.EEFC_FCR.Reg)&^(0xff)|value)
}
func (o *EFC_Type) GetEEFC_FCR_FCMD() uint32 {
	return volatile.LoadUint32(&o.EEFC_FCR.Reg) & 0xff
}
func (o *EFC_Type) SetEEFC_FCR_FARG(value uint32) {
	volatile.StoreUint32(&o.EEFC_FCR.Reg, volatile.LoadUint32(&o.EEFC_FCR.Reg)&^(0xffff00)|value<<8)
}
func (o *EFC_Type) GetEEFC_FCR_FARG() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FCR.Reg) & 0xffff00) >> 8
}
func (o *EFC_Type) SetEEFC_FCR_FKEY(value uint32) {
	volatile.StoreUint32(&o.EEFC_FCR.Reg, volatile.LoadUint32(&o.EEFC_FCR.Reg)&^(0xff000000)|value<<24)
}
func (o *EFC_Type) GetEEFC_FCR_FKEY() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FCR.Reg) & 0xff000000) >> 24
}

// EFC.EEFC_FSR: EEFC Flash Status Register
func (o *EFC_Type) SetEEFC_FSR_FRDY(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x1)|value)
}
func (o *EFC_Type) GetEEFC_FSR_FRDY() uint32 {
	return volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x1
}
func (o *EFC_Type) SetEEFC_FSR_FCMDE(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x2)|value<<1)
}
func (o *EFC_Type) GetEEFC_FSR_FCMDE() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x2) >> 1
}
func (o *EFC_Type) SetEEFC_FSR_FLOCKE(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x4)|value<<2)
}
func (o *EFC_Type) GetEEFC_FSR_FLOCKE() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x4) >> 2
}
func (o *EFC_Type) SetEEFC_FSR_FLERR(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x8)|value<<3)
}
func (o *EFC_Type) GetEEFC_FSR_FLERR() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x8) >> 3
}
func (o *EFC_Type) SetEEFC_FSR_UECCELSB(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x10000)|value<<16)
}
func (o *EFC_Type) GetEEFC_FSR_UECCELSB() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x10000) >> 16
}
func (o *EFC_Type) SetEEFC_FSR_MECCELSB(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x20000)|value<<17)
}
func (o *EFC_Type) GetEEFC_FSR_MECCELSB() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x20000) >> 17
}
func (o *EFC_Type) SetEEFC_FSR_UECCEMSB(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x40000)|value<<18)
}
func (o *EFC_Type) GetEEFC_FSR_UECCEMSB() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x40000) >> 18
}
func (o *EFC_Type) SetEEFC_FSR_MECCEMSB(value uint32) {
	volatile.StoreUint32(&o.EEFC_FSR.Reg, volatile.LoadUint32(&o.EEFC_FSR.Reg)&^(0x80000)|value<<19)
}
func (o *EFC_Type) GetEEFC_FSR_MECCEMSB() uint32 {
	return (volatile.LoadUint32(&o.EEFC_FSR.Reg) & 0x80000) >> 19
}

// EFC.EEFC_FRR: EEFC Flash Result Register
func (o *EFC_Type) SetEEFC_FRR(value uint32) {
	volatile.StoreUint32(&o.EEFC_FRR.Reg, value)
}
func (o *EFC_Type) GetEEFC_FRR() uint32 {
	return volatile.LoadUint32(&o.EEFC_FRR.Reg)
}

// EFC.EEFC_WPMR: Write Protection Mode Register
func (o *EFC_Type) SetEEFC_WPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.EEFC_WPMR.Reg, volatile.LoadUint32(&o.EEFC_WPMR.Reg)&^(0x1)|value)
}
func (o *EFC_Type) GetEEFC_WPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.EEFC_WPMR.Reg) & 0x1
}
func (o *EFC_Type) SetEEFC_WPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.EEFC_WPMR.Reg, volatile.LoadUint32(&o.EEFC_WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *EFC_Type) GetEEFC_WPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.EEFC_WPMR.Reg) & 0xffffff00) >> 8
}

// Gigabit Ethernet MAC
type GMAC_Type struct {
	NCR       volatile.Register32 // 0x0
	NCFGR     volatile.Register32 // 0x4
	NSR       volatile.Register32 // 0x8
	UR        volatile.Register32 // 0xC
	DCFGR     volatile.Register32 // 0x10
	TSR       volatile.Register32 // 0x14
	RBQB      volatile.Register32 // 0x18
	TBQB      volatile.Register32 // 0x1C
	RSR       volatile.Register32 // 0x20
	ISR       volatile.Register32 // 0x24
	IER       volatile.Register32 // 0x28
	IDR       volatile.Register32 // 0x2C
	IMR       volatile.Register32 // 0x30
	MAN       volatile.Register32 // 0x34
	RPQ       volatile.Register32 // 0x38
	TPQ       volatile.Register32 // 0x3C
	TPSF      volatile.Register32 // 0x40
	RPSF      volatile.Register32 // 0x44
	RJFML     volatile.Register32 // 0x48
	_         [52]byte
	HRB       volatile.Register32  // 0x80
	HRT       volatile.Register32  // 0x84
	GMAC_SA   [4]GMAC_GMAC_SA_Type // 0x88
	TIDM1     volatile.Register32  // 0xA8
	TIDM2     volatile.Register32  // 0xAC
	TIDM3     volatile.Register32  // 0xB0
	TIDM4     volatile.Register32  // 0xB4
	WOL       volatile.Register32  // 0xB8
	IPGS      volatile.Register32  // 0xBC
	SVLAN     volatile.Register32  // 0xC0
	TPFCP     volatile.Register32  // 0xC4
	SAMB1     volatile.Register32  // 0xC8
	SAMT1     volatile.Register32  // 0xCC
	_         [12]byte
	NSC       volatile.Register32 // 0xDC
	SCL       volatile.Register32 // 0xE0
	SCH       volatile.Register32 // 0xE4
	EFTSH     volatile.Register32 // 0xE8
	EFRSH     volatile.Register32 // 0xEC
	PEFTSH    volatile.Register32 // 0xF0
	PEFRSH    volatile.Register32 // 0xF4
	_         [8]byte
	OTLO      volatile.Register32 // 0x100
	OTHI      volatile.Register32 // 0x104
	FT        volatile.Register32 // 0x108
	BCFT      volatile.Register32 // 0x10C
	MFT       volatile.Register32 // 0x110
	PFT       volatile.Register32 // 0x114
	BFT64     volatile.Register32 // 0x118
	TBFT127   volatile.Register32 // 0x11C
	TBFT255   volatile.Register32 // 0x120
	TBFT511   volatile.Register32 // 0x124
	TBFT1023  volatile.Register32 // 0x128
	TBFT1518  volatile.Register32 // 0x12C
	GTBFT1518 volatile.Register32 // 0x130
	TUR       volatile.Register32 // 0x134
	SCF       volatile.Register32 // 0x138
	MCF       volatile.Register32 // 0x13C
	EC        volatile.Register32 // 0x140
	LC        volatile.Register32 // 0x144
	DTF       volatile.Register32 // 0x148
	CSE       volatile.Register32 // 0x14C
	ORLO      volatile.Register32 // 0x150
	ORHI      volatile.Register32 // 0x154
	FR        volatile.Register32 // 0x158
	BCFR      volatile.Register32 // 0x15C
	MFR       volatile.Register32 // 0x160
	PFR       volatile.Register32 // 0x164
	BFR64     volatile.Register32 // 0x168
	TBFR127   volatile.Register32 // 0x16C
	TBFR255   volatile.Register32 // 0x170
	TBFR511   volatile.Register32 // 0x174
	TBFR1023  volatile.Register32 // 0x178
	TBFR1518  volatile.Register32 // 0x17C
	TMXBFR    volatile.Register32 // 0x180
	UFR       volatile.Register32 // 0x184
	OFR       volatile.Register32 // 0x188
	JR        volatile.Register32 // 0x18C
	FCSE      volatile.Register32 // 0x190
	LFFE      volatile.Register32 // 0x194
	RSE       volatile.Register32 // 0x198
	AE        volatile.Register32 // 0x19C
	RRE       volatile.Register32 // 0x1A0
	ROE       volatile.Register32 // 0x1A4
	IHCE      volatile.Register32 // 0x1A8
	TCE       volatile.Register32 // 0x1AC
	UCE       volatile.Register32 // 0x1B0
	_         [8]byte
	TISUBN    volatile.Register32 // 0x1BC
	TSH       volatile.Register32 // 0x1C0
	_         [12]byte
	TSL       volatile.Register32 // 0x1D0
	TN        volatile.Register32 // 0x1D4
	TA        volatile.Register32 // 0x1D8
	TI        volatile.Register32 // 0x1DC
	EFTSL     volatile.Register32 // 0x1E0
	EFTN      volatile.Register32 // 0x1E4
	EFRSL     volatile.Register32 // 0x1E8
	EFRN      volatile.Register32 // 0x1EC
	PEFTSL    volatile.Register32 // 0x1F0
	PEFTN     volatile.Register32 // 0x1F4
	PEFRSL    volatile.Register32 // 0x1F8
	PEFRN     volatile.Register32 // 0x1FC
	_         [508]byte
	ISRPQ     [2]volatile.Register32 // 0x3FC
	_         [56]byte
	TBQBAPQ   [2]volatile.Register32 // 0x43C
	_         [56]byte
	RBQBAPQ   [2]volatile.Register32 // 0x47C
	_         [24]byte
	RBSRPQ    [2]volatile.Register32 // 0x49C
	_         [24]byte
	CBSCR     volatile.Register32 // 0x4BC
	CBSISQA   volatile.Register32 // 0x4C0
	CBSISQB   volatile.Register32 // 0x4C4
	_         [56]byte
	ST1RPQ    [4]volatile.Register32 // 0x500
	_         [48]byte
	ST2RPQ    [8]volatile.Register32 // 0x540
	_         [156]byte
	IERPQ     [2]volatile.Register32 // 0x5FC
	_         [24]byte
	IDRPQ     [2]volatile.Register32 // 0x61C
	_         [24]byte
	IMRPQ     [2]volatile.Register32 // 0x63C
	_         [156]byte
	ST2ER     [4]volatile.Register32 // 0x6E0
	_         [16]byte
	ST2CW00   volatile.Register32 // 0x700
	ST2CW10   volatile.Register32 // 0x704
	ST2CW01   volatile.Register32 // 0x708
	ST2CW11   volatile.Register32 // 0x70C
	ST2CW02   volatile.Register32 // 0x710
	ST2CW12   volatile.Register32 // 0x714
	ST2CW03   volatile.Register32 // 0x718
	ST2CW13   volatile.Register32 // 0x71C
	ST2CW04   volatile.Register32 // 0x720
	ST2CW14   volatile.Register32 // 0x724
	ST2CW05   volatile.Register32 // 0x728
	ST2CW15   volatile.Register32 // 0x72C
	ST2CW06   volatile.Register32 // 0x730
	ST2CW16   volatile.Register32 // 0x734
	ST2CW07   volatile.Register32 // 0x738
	ST2CW17   volatile.Register32 // 0x73C
	ST2CW08   volatile.Register32 // 0x740
	ST2CW18   volatile.Register32 // 0x744
	ST2CW09   volatile.Register32 // 0x748
	ST2CW19   volatile.Register32 // 0x74C
	ST2CW010  volatile.Register32 // 0x750
	ST2CW110  volatile.Register32 // 0x754
	ST2CW011  volatile.Register32 // 0x758
	ST2CW111  volatile.Register32 // 0x75C
	ST2CW012  volatile.Register32 // 0x760
	ST2CW112  volatile.Register32 // 0x764
	ST2CW013  volatile.Register32 // 0x768
	ST2CW113  volatile.Register32 // 0x76C
	ST2CW014  volatile.Register32 // 0x770
	ST2CW114  volatile.Register32 // 0x774
	ST2CW015  volatile.Register32 // 0x778
	ST2CW115  volatile.Register32 // 0x77C
	ST2CW016  volatile.Register32 // 0x780
	ST2CW116  volatile.Register32 // 0x784
	ST2CW017  volatile.Register32 // 0x788
	ST2CW117  volatile.Register32 // 0x78C
	ST2CW018  volatile.Register32 // 0x790
	ST2CW118  volatile.Register32 // 0x794
	ST2CW019  volatile.Register32 // 0x798
	ST2CW119  volatile.Register32 // 0x79C
	ST2CW020  volatile.Register32 // 0x7A0
	ST2CW120  volatile.Register32 // 0x7A4
	ST2CW021  volatile.Register32 // 0x7A8
	ST2CW121  volatile.Register32 // 0x7AC
	ST2CW022  volatile.Register32 // 0x7B0
	ST2CW122  volatile.Register32 // 0x7B4
	ST2CW023  volatile.Register32 // 0x7B8
	ST2CW123  volatile.Register32 // 0x7BC
}

// GMAC.NCR: Network Control Register
func (o *GMAC_Type) SetNCR_LBL(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCR_LBL() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *GMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *GMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetNCR_TXPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetNCR_TXPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetNCR_TXZQPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCR_TXZQPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCR_SRTSM(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetNCR_SRTSM() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetNCR_ENPBPR(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCR_ENPBPR() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCR_TXPBPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCR_TXPBPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCR_FNP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetNCR_FNP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40000) >> 18
}

// GMAC.NCFGR: Network Configuration Register
func (o *GMAC_Type) SetNCFGR_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetNCFGR_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFGR.Reg) & 0x1
}
func (o *GMAC_Type) SetNCFGR_FD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCFGR_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCFGR_DNVLAN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCFGR_DNVLAN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCFGR_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCFGR_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCFGR_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCFGR_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCFGR_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCFGR_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCFGR_MTIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCFGR_MTIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCFGR_UNIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCFGR_UNIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCFGR_MAXFS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCFGR_MAXFS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCFGR_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCFGR_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCFGR_PEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetNCFGR_PEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetNCFGR_RXBUFO(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc000)|value<<14)
}
func (o *GMAC_Type) GetNCFGR_RXBUFO() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc000) >> 14
}
func (o *GMAC_Type) SetNCFGR_LFERD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCFGR_LFERD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCFGR_RFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCFGR_RFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCFGR_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1c0000)|value<<18)
}
func (o *GMAC_Type) GetNCFGR_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1c0000) >> 18
}
func (o *GMAC_Type) SetNCFGR_DBW(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x600000)|value<<21)
}
func (o *GMAC_Type) GetNCFGR_DBW() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x600000) >> 21
}
func (o *GMAC_Type) SetNCFGR_DCPF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetNCFGR_DCPF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetNCFGR_RXCOEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetNCFGR_RXCOEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetNCFGR_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetNCFGR_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetNCFGR_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetNCFGR_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetNCFGR_IPGSEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetNCFGR_IPGSEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetNCFGR_RXBP(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetNCFGR_RXBP() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000000) >> 29
}
func (o *GMAC_Type) SetNCFGR_IRXER(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetNCFGR_IRXER() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40000000) >> 30
}

// GMAC.NSR: Network Status Register
func (o *GMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// GMAC.UR: User Register
func (o *GMAC_Type) SetUR_RMII(value uint32) {
	volatile.StoreUint32(&o.UR.Reg, volatile.LoadUint32(&o.UR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetUR_RMII() uint32 {
	return volatile.LoadUint32(&o.UR.Reg) & 0x1
}

// GMAC.DCFGR: DMA Configuration Register
func (o *GMAC_Type) SetDCFGR_FBLDO(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1f)|value)
}
func (o *GMAC_Type) GetDCFGR_FBLDO() uint32 {
	return volatile.LoadUint32(&o.DCFGR.Reg) & 0x1f
}
func (o *GMAC_Type) SetDCFGR_ESMA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetDCFGR_ESMA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetDCFGR_ESPA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetDCFGR_ESPA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetDCFGR_RXBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x300)|value<<8)
}
func (o *GMAC_Type) GetDCFGR_RXBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x300) >> 8
}
func (o *GMAC_Type) SetDCFGR_TXPBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetDCFGR_TXPBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetDCFGR_TXCOEN(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetDCFGR_TXCOEN() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetDCFGR_DRBS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetDCFGR_DRBS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0xff0000) >> 16
}
func (o *GMAC_Type) SetDCFGR_DDRP(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetDCFGR_DDRP() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x1000000) >> 24
}

// GMAC.TSR: Transmit Status Register
func (o *GMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *GMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetTSR_RLE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetTSR_RLE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetTSR_TXGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetTSR_TXGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetTSR_TFC(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetTSR_TFC() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetTSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetTSR_TXCOMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetTSR_HRESP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetTSR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x100) >> 8
}

// GMAC.RBQB: Receive Buffer Queue Base Address Register
func (o *GMAC_Type) SetRBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQB.Reg, volatile.LoadUint32(&o.RBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetRBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.TBQB: Transmit Buffer Queue Base Address Register
func (o *GMAC_Type) SetTBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQB.Reg, volatile.LoadUint32(&o.TBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetTBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.RSR: Receive Status Register
func (o *GMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *GMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetRSR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetRSR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetRSR_HNO(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetRSR_HNO() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x8) >> 3
}

// GMAC.ISR: Interrupt Status Register
func (o *GMAC_Type) SetISR_MFS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetISR_MFS() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *GMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetISR_TUR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetISR_TUR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetISR_RLEX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetISR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetISR_TFC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetISR_TFC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetISR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetISR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetISR_PFTR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetISR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetISR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetISR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetISR_SFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetISR_SFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetISR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetISR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetISR_SFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetISR_SFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetISR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetISR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetISR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetISR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetISR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetISR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetISR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetISR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetISR_SRI(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetISR_SRI() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetISR_WOL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetISR_WOL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}

// GMAC.IER: Interrupt Enable Register
func (o *GMAC_Type) SetIER_MFS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIER_MFS() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *GMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIER_TUR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIER_TUR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIER_RLEX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIER_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIER_TFC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIER_TFC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIER_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIER_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIER_PFTR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIER_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIER_EXINT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIER_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIER_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIER_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIER_SFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIER_SFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIER_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIER_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIER_SFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIER_SFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIER_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIER_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIER_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIER_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIER_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIER_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIER_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIER_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIER_SRI(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIER_SRI() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIER_WOL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIER_WOL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}

// GMAC.IDR: Interrupt Disable Register
func (o *GMAC_Type) SetIDR_MFS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIDR_MFS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *GMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIDR_TUR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIDR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIDR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIDR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIDR_TFC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIDR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIDR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIDR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIDR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIDR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIDR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIDR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIDR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIDR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIDR_SFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIDR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIDR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIDR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIDR_SFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIDR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIDR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIDR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIDR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIDR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIDR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIDR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIDR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIDR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIDR_SRI(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIDR_SRI() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIDR_WOL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIDR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}

// GMAC.IMR: Interrupt Mask Register
func (o *GMAC_Type) SetIMR_MFS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIMR_MFS() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *GMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIMR_TUR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIMR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIMR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIMR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIMR_TFC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIMR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIMR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIMR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIMR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIMR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIMR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIMR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIMR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIMR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIMR_SFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIMR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIMR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIMR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIMR_SFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIMR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIMR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIMR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIMR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIMR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIMR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIMR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIMR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIMR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIMR_SRI(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIMR_SRI() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIMR_WOL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIMR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}

// GMAC.MAN: PHY Maintenance Register
func (o *GMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetMAN_WTN(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *GMAC_Type) GetMAN_WTN() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *GMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *GMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *GMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *GMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *GMAC_Type) SetMAN_OP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *GMAC_Type) GetMAN_OP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *GMAC_Type) SetMAN_CLTTO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetMAN_CLTTO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}
func (o *GMAC_Type) SetMAN_WZO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetMAN_WZO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x80000000) >> 31
}

// GMAC.RPQ: Received Pause Quantum Register
func (o *GMAC_Type) SetRPQ(value uint32) {
	volatile.StoreUint32(&o.RPQ.Reg, volatile.LoadUint32(&o.RPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRPQ() uint32 {
	return volatile.LoadUint32(&o.RPQ.Reg) & 0xffff
}

// GMAC.TPQ: Transmit Pause Quantum Register
func (o *GMAC_Type) SetTPQ(value uint32) {
	volatile.StoreUint32(&o.TPQ.Reg, volatile.LoadUint32(&o.TPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTPQ() uint32 {
	return volatile.LoadUint32(&o.TPQ.Reg) & 0xffff
}

// GMAC.TPSF: TX Partial Store and Forward Register
func (o *GMAC_Type) SetTPSF_TPB1ADR(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0xfff)|value)
}
func (o *GMAC_Type) GetTPSF_TPB1ADR() uint32 {
	return volatile.LoadUint32(&o.TPSF.Reg) & 0xfff
}
func (o *GMAC_Type) SetTPSF_ENTXP(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTPSF_ENTXP() uint32 {
	return (volatile.LoadUint32(&o.TPSF.Reg) & 0x80000000) >> 31
}

// GMAC.RPSF: RX Partial Store and Forward Register
func (o *GMAC_Type) SetRPSF_RPB1ADR(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0xfff)|value)
}
func (o *GMAC_Type) GetRPSF_RPB1ADR() uint32 {
	return volatile.LoadUint32(&o.RPSF.Reg) & 0xfff
}
func (o *GMAC_Type) SetRPSF_ENRXP(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetRPSF_ENRXP() uint32 {
	return (volatile.LoadUint32(&o.RPSF.Reg) & 0x80000000) >> 31
}

// GMAC.RJFML: RX Jumbo Frame Max Length Register
func (o *GMAC_Type) SetRJFML_FML(value uint32) {
	volatile.StoreUint32(&o.RJFML.Reg, volatile.LoadUint32(&o.RJFML.Reg)&^(0x3fff)|value)
}
func (o *GMAC_Type) GetRJFML_FML() uint32 {
	return volatile.LoadUint32(&o.RJFML.Reg) & 0x3fff
}

// GMAC.HRB: Hash Register Bottom
func (o *GMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *GMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// GMAC.HRT: Hash Register Top
func (o *GMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *GMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// GMAC.TIDM1: Type ID Match 1 Register
func (o *GMAC_Type) SetTIDM1_TID(value uint32) {
	volatile.StoreUint32(&o.TIDM1.Reg, volatile.LoadUint32(&o.TIDM1.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM1_TID() uint32 {
	return volatile.LoadUint32(&o.TIDM1.Reg) & 0xffff
}
func (o *GMAC_Type) SetTIDM1_ENID1(value uint32) {
	volatile.StoreUint32(&o.TIDM1.Reg, volatile.LoadUint32(&o.TIDM1.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTIDM1_ENID1() uint32 {
	return (volatile.LoadUint32(&o.TIDM1.Reg) & 0x80000000) >> 31
}

// GMAC.TIDM2: Type ID Match 2 Register
func (o *GMAC_Type) SetTIDM2_TID(value uint32) {
	volatile.StoreUint32(&o.TIDM2.Reg, volatile.LoadUint32(&o.TIDM2.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM2_TID() uint32 {
	return volatile.LoadUint32(&o.TIDM2.Reg) & 0xffff
}
func (o *GMAC_Type) SetTIDM2_ENID2(value uint32) {
	volatile.StoreUint32(&o.TIDM2.Reg, volatile.LoadUint32(&o.TIDM2.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTIDM2_ENID2() uint32 {
	return (volatile.LoadUint32(&o.TIDM2.Reg) & 0x80000000) >> 31
}

// GMAC.TIDM3: Type ID Match 3 Register
func (o *GMAC_Type) SetTIDM3_TID(value uint32) {
	volatile.StoreUint32(&o.TIDM3.Reg, volatile.LoadUint32(&o.TIDM3.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM3_TID() uint32 {
	return volatile.LoadUint32(&o.TIDM3.Reg) & 0xffff
}
func (o *GMAC_Type) SetTIDM3_ENID3(value uint32) {
	volatile.StoreUint32(&o.TIDM3.Reg, volatile.LoadUint32(&o.TIDM3.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTIDM3_ENID3() uint32 {
	return (volatile.LoadUint32(&o.TIDM3.Reg) & 0x80000000) >> 31
}

// GMAC.TIDM4: Type ID Match 4 Register
func (o *GMAC_Type) SetTIDM4_TID(value uint32) {
	volatile.StoreUint32(&o.TIDM4.Reg, volatile.LoadUint32(&o.TIDM4.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM4_TID() uint32 {
	return volatile.LoadUint32(&o.TIDM4.Reg) & 0xffff
}
func (o *GMAC_Type) SetTIDM4_ENID4(value uint32) {
	volatile.StoreUint32(&o.TIDM4.Reg, volatile.LoadUint32(&o.TIDM4.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTIDM4_ENID4() uint32 {
	return (volatile.LoadUint32(&o.TIDM4.Reg) & 0x80000000) >> 31
}

// GMAC.WOL: Wake on LAN Register
func (o *GMAC_Type) SetWOL_IP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetWOL_IP() uint32 {
	return volatile.LoadUint32(&o.WOL.Reg) & 0xffff
}
func (o *GMAC_Type) SetWOL_MAG(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetWOL_MAG() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetWOL_ARP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetWOL_ARP() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetWOL_SA1(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetWOL_SA1() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetWOL_MTI(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetWOL_MTI() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x80000) >> 19
}

// GMAC.IPGS: IPG Stretch Register
func (o *GMAC_Type) SetIPGS_FL(value uint32) {
	volatile.StoreUint32(&o.IPGS.Reg, volatile.LoadUint32(&o.IPGS.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetIPGS_FL() uint32 {
	return volatile.LoadUint32(&o.IPGS.Reg) & 0xffff
}

// GMAC.SVLAN: Stacked VLAN Register
func (o *GMAC_Type) SetSVLAN_VLAN_TYPE(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSVLAN_VLAN_TYPE() uint32 {
	return volatile.LoadUint32(&o.SVLAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetSVLAN_ESVLAN(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetSVLAN_ESVLAN() uint32 {
	return (volatile.LoadUint32(&o.SVLAN.Reg) & 0x80000000) >> 31
}

// GMAC.TPFCP: Transmit PFC Pause Register
func (o *GMAC_Type) SetTPFCP_PEV(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTPFCP_PEV() uint32 {
	return volatile.LoadUint32(&o.TPFCP.Reg) & 0xff
}
func (o *GMAC_Type) SetTPFCP_PQ(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTPFCP_PQ() uint32 {
	return (volatile.LoadUint32(&o.TPFCP.Reg) & 0xff00) >> 8
}

// GMAC.SAMB1: Specific Address 1 Mask Bottom Register
func (o *GMAC_Type) SetSAMB1(value uint32) {
	volatile.StoreUint32(&o.SAMB1.Reg, value)
}
func (o *GMAC_Type) GetSAMB1() uint32 {
	return volatile.LoadUint32(&o.SAMB1.Reg)
}

// GMAC.SAMT1: Specific Address 1 Mask Top Register
func (o *GMAC_Type) SetSAMT1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAMT1.Reg, volatile.LoadUint32(&o.SAMT1.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAMT1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAMT1.Reg) & 0xffff
}

// GMAC.NSC: 1588 Timer Nanosecond Comparison Register
func (o *GMAC_Type) SetNSC_NANOSEC(value uint32) {
	volatile.StoreUint32(&o.NSC.Reg, volatile.LoadUint32(&o.NSC.Reg)&^(0x3fffff)|value)
}
func (o *GMAC_Type) GetNSC_NANOSEC() uint32 {
	return volatile.LoadUint32(&o.NSC.Reg) & 0x3fffff
}

// GMAC.SCL: 1588 Timer Second Comparison Low Register
func (o *GMAC_Type) SetSCL(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, value)
}
func (o *GMAC_Type) GetSCL() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg)
}

// GMAC.SCH: 1588 Timer Second Comparison High Register
func (o *GMAC_Type) SetSCH_SEC(value uint32) {
	volatile.StoreUint32(&o.SCH.Reg, volatile.LoadUint32(&o.SCH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSCH_SEC() uint32 {
	return volatile.LoadUint32(&o.SCH.Reg) & 0xffff
}

// GMAC.EFTSH: PTP Event Frame Transmitted Seconds High Register
func (o *GMAC_Type) SetEFTSH_RUD(value uint32) {
	volatile.StoreUint32(&o.EFTSH.Reg, volatile.LoadUint32(&o.EFTSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetEFTSH_RUD() uint32 {
	return volatile.LoadUint32(&o.EFTSH.Reg) & 0xffff
}

// GMAC.EFRSH: PTP Event Frame Received Seconds High Register
func (o *GMAC_Type) SetEFRSH_RUD(value uint32) {
	volatile.StoreUint32(&o.EFRSH.Reg, volatile.LoadUint32(&o.EFRSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetEFRSH_RUD() uint32 {
	return volatile.LoadUint32(&o.EFRSH.Reg) & 0xffff
}

// GMAC.PEFTSH: PTP Peer Event Frame Transmitted Seconds High Register
func (o *GMAC_Type) SetPEFTSH_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFTSH.Reg, volatile.LoadUint32(&o.PEFTSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPEFTSH_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFTSH.Reg) & 0xffff
}

// GMAC.PEFRSH: PTP Peer Event Frame Received Seconds High Register
func (o *GMAC_Type) SetPEFRSH_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFRSH.Reg, volatile.LoadUint32(&o.PEFRSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPEFRSH_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFRSH.Reg) & 0xffff
}

// GMAC.OTLO: Octets Transmitted Low Register
func (o *GMAC_Type) SetOTLO(value uint32) {
	volatile.StoreUint32(&o.OTLO.Reg, value)
}
func (o *GMAC_Type) GetOTLO() uint32 {
	return volatile.LoadUint32(&o.OTLO.Reg)
}

// GMAC.OTHI: Octets Transmitted High Register
func (o *GMAC_Type) SetOTHI_TXO(value uint32) {
	volatile.StoreUint32(&o.OTHI.Reg, volatile.LoadUint32(&o.OTHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetOTHI_TXO() uint32 {
	return volatile.LoadUint32(&o.OTHI.Reg) & 0xffff
}

// GMAC.FT: Frames Transmitted Register
func (o *GMAC_Type) SetFT(value uint32) {
	volatile.StoreUint32(&o.FT.Reg, value)
}
func (o *GMAC_Type) GetFT() uint32 {
	return volatile.LoadUint32(&o.FT.Reg)
}

// GMAC.BCFT: Broadcast Frames Transmitted Register
func (o *GMAC_Type) SetBCFT(value uint32) {
	volatile.StoreUint32(&o.BCFT.Reg, value)
}
func (o *GMAC_Type) GetBCFT() uint32 {
	return volatile.LoadUint32(&o.BCFT.Reg)
}

// GMAC.MFT: Multicast Frames Transmitted Register
func (o *GMAC_Type) SetMFT(value uint32) {
	volatile.StoreUint32(&o.MFT.Reg, value)
}
func (o *GMAC_Type) GetMFT() uint32 {
	return volatile.LoadUint32(&o.MFT.Reg)
}

// GMAC.PFT: Pause Frames Transmitted Register
func (o *GMAC_Type) SetPFT_PFTX(value uint32) {
	volatile.StoreUint32(&o.PFT.Reg, volatile.LoadUint32(&o.PFT.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFT_PFTX() uint32 {
	return volatile.LoadUint32(&o.PFT.Reg) & 0xffff
}

// GMAC.BFT64: 64 Byte Frames Transmitted Register
func (o *GMAC_Type) SetBFT64(value uint32) {
	volatile.StoreUint32(&o.BFT64.Reg, value)
}
func (o *GMAC_Type) GetBFT64() uint32 {
	return volatile.LoadUint32(&o.BFT64.Reg)
}

// GMAC.TBFT127: 65 to 127 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT127(value uint32) {
	volatile.StoreUint32(&o.TBFT127.Reg, value)
}
func (o *GMAC_Type) GetTBFT127() uint32 {
	return volatile.LoadUint32(&o.TBFT127.Reg)
}

// GMAC.TBFT255: 128 to 255 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT255(value uint32) {
	volatile.StoreUint32(&o.TBFT255.Reg, value)
}
func (o *GMAC_Type) GetTBFT255() uint32 {
	return volatile.LoadUint32(&o.TBFT255.Reg)
}

// GMAC.TBFT511: 256 to 511 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT511(value uint32) {
	volatile.StoreUint32(&o.TBFT511.Reg, value)
}
func (o *GMAC_Type) GetTBFT511() uint32 {
	return volatile.LoadUint32(&o.TBFT511.Reg)
}

// GMAC.TBFT1023: 512 to 1023 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1023(value uint32) {
	volatile.StoreUint32(&o.TBFT1023.Reg, value)
}
func (o *GMAC_Type) GetTBFT1023() uint32 {
	return volatile.LoadUint32(&o.TBFT1023.Reg)
}

// GMAC.TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1518(value uint32) {
	volatile.StoreUint32(&o.TBFT1518.Reg, value)
}
func (o *GMAC_Type) GetTBFT1518() uint32 {
	return volatile.LoadUint32(&o.TBFT1518.Reg)
}

// GMAC.GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetGTBFT1518(value uint32) {
	volatile.StoreUint32(&o.GTBFT1518.Reg, value)
}
func (o *GMAC_Type) GetGTBFT1518() uint32 {
	return volatile.LoadUint32(&o.GTBFT1518.Reg)
}

// GMAC.TUR: Transmit Underruns Register
func (o *GMAC_Type) SetTUR_TXUNR(value uint32) {
	volatile.StoreUint32(&o.TUR.Reg, volatile.LoadUint32(&o.TUR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetTUR_TXUNR() uint32 {
	return volatile.LoadUint32(&o.TUR.Reg) & 0x3ff
}

// GMAC.SCF: Single Collision Frames Register
func (o *GMAC_Type) SetSCF_SCOL(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetSCF_SCOL() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0x3ffff
}

// GMAC.MCF: Multiple Collision Frames Register
func (o *GMAC_Type) SetMCF_MCOL(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetMCF_MCOL() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0x3ffff
}

// GMAC.EC: Excessive Collisions Register
func (o *GMAC_Type) SetEC_XCOL(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetEC_XCOL() uint32 {
	return volatile.LoadUint32(&o.EC.Reg) & 0x3ff
}

// GMAC.LC: Late Collisions Register
func (o *GMAC_Type) SetLC_LCOL(value uint32) {
	volatile.StoreUint32(&o.LC.Reg, volatile.LoadUint32(&o.LC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLC_LCOL() uint32 {
	return volatile.LoadUint32(&o.LC.Reg) & 0x3ff
}

// GMAC.DTF: Deferred Transmission Frames Register
func (o *GMAC_Type) SetDTF_DEFT(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetDTF_DEFT() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0x3ffff
}

// GMAC.CSE: Carrier Sense Errors Register
func (o *GMAC_Type) SetCSE_CSR(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetCSE_CSR() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0x3ff
}

// GMAC.ORLO: Octets Received Low Received Register
func (o *GMAC_Type) SetORLO(value uint32) {
	volatile.StoreUint32(&o.ORLO.Reg, value)
}
func (o *GMAC_Type) GetORLO() uint32 {
	return volatile.LoadUint32(&o.ORLO.Reg)
}

// GMAC.ORHI: Octets Received High Received Register
func (o *GMAC_Type) SetORHI_RXO(value uint32) {
	volatile.StoreUint32(&o.ORHI.Reg, volatile.LoadUint32(&o.ORHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetORHI_RXO() uint32 {
	return volatile.LoadUint32(&o.ORHI.Reg) & 0xffff
}

// GMAC.FR: Frames Received Register
func (o *GMAC_Type) SetFR(value uint32) {
	volatile.StoreUint32(&o.FR.Reg, value)
}
func (o *GMAC_Type) GetFR() uint32 {
	return volatile.LoadUint32(&o.FR.Reg)
}

// GMAC.BCFR: Broadcast Frames Received Register
func (o *GMAC_Type) SetBCFR(value uint32) {
	volatile.StoreUint32(&o.BCFR.Reg, value)
}
func (o *GMAC_Type) GetBCFR() uint32 {
	return volatile.LoadUint32(&o.BCFR.Reg)
}

// GMAC.MFR: Multicast Frames Received Register
func (o *GMAC_Type) SetMFR(value uint32) {
	volatile.StoreUint32(&o.MFR.Reg, value)
}
func (o *GMAC_Type) GetMFR() uint32 {
	return volatile.LoadUint32(&o.MFR.Reg)
}

// GMAC.PFR: Pause Frames Received Register
func (o *GMAC_Type) SetPFR_PFRX(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFR_PFRX() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// GMAC.BFR64: 64 Byte Frames Received Register
func (o *GMAC_Type) SetBFR64(value uint32) {
	volatile.StoreUint32(&o.BFR64.Reg, value)
}
func (o *GMAC_Type) GetBFR64() uint32 {
	return volatile.LoadUint32(&o.BFR64.Reg)
}

// GMAC.TBFR127: 65 to 127 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR127(value uint32) {
	volatile.StoreUint32(&o.TBFR127.Reg, value)
}
func (o *GMAC_Type) GetTBFR127() uint32 {
	return volatile.LoadUint32(&o.TBFR127.Reg)
}

// GMAC.TBFR255: 128 to 255 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR255(value uint32) {
	volatile.StoreUint32(&o.TBFR255.Reg, value)
}
func (o *GMAC_Type) GetTBFR255() uint32 {
	return volatile.LoadUint32(&o.TBFR255.Reg)
}

// GMAC.TBFR511: 256 to 511 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR511(value uint32) {
	volatile.StoreUint32(&o.TBFR511.Reg, value)
}
func (o *GMAC_Type) GetTBFR511() uint32 {
	return volatile.LoadUint32(&o.TBFR511.Reg)
}

// GMAC.TBFR1023: 512 to 1023 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1023(value uint32) {
	volatile.StoreUint32(&o.TBFR1023.Reg, value)
}
func (o *GMAC_Type) GetTBFR1023() uint32 {
	return volatile.LoadUint32(&o.TBFR1023.Reg)
}

// GMAC.TBFR1518: 1024 to 1518 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1518(value uint32) {
	volatile.StoreUint32(&o.TBFR1518.Reg, value)
}
func (o *GMAC_Type) GetTBFR1518() uint32 {
	return volatile.LoadUint32(&o.TBFR1518.Reg)
}

// GMAC.TMXBFR: 1519 to Maximum Byte Frames Received Register
func (o *GMAC_Type) SetTMXBFR(value uint32) {
	volatile.StoreUint32(&o.TMXBFR.Reg, value)
}
func (o *GMAC_Type) GetTMXBFR() uint32 {
	return volatile.LoadUint32(&o.TMXBFR.Reg)
}

// GMAC.UFR: Undersize Frames Received Register
func (o *GMAC_Type) SetUFR_UFRX(value uint32) {
	volatile.StoreUint32(&o.UFR.Reg, volatile.LoadUint32(&o.UFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetUFR_UFRX() uint32 {
	return volatile.LoadUint32(&o.UFR.Reg) & 0x3ff
}

// GMAC.OFR: Oversize Frames Received Register
func (o *GMAC_Type) SetOFR_OFRX(value uint32) {
	volatile.StoreUint32(&o.OFR.Reg, volatile.LoadUint32(&o.OFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetOFR_OFRX() uint32 {
	return volatile.LoadUint32(&o.OFR.Reg) & 0x3ff
}

// GMAC.JR: Jabbers Received Register
func (o *GMAC_Type) SetJR_JRX(value uint32) {
	volatile.StoreUint32(&o.JR.Reg, volatile.LoadUint32(&o.JR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetJR_JRX() uint32 {
	return volatile.LoadUint32(&o.JR.Reg) & 0x3ff
}

// GMAC.FCSE: Frame Check Sequence Errors Register
func (o *GMAC_Type) SetFCSE_FCKR(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetFCSE_FCKR() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0x3ff
}

// GMAC.LFFE: Length Field Frame Errors Register
func (o *GMAC_Type) SetLFFE_LFER(value uint32) {
	volatile.StoreUint32(&o.LFFE.Reg, volatile.LoadUint32(&o.LFFE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLFFE_LFER() uint32 {
	return volatile.LoadUint32(&o.LFFE.Reg) & 0x3ff
}

// GMAC.RSE: Receive Symbol Errors Register
func (o *GMAC_Type) SetRSE_RXSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetRSE_RXSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0x3ff
}

// GMAC.AE: Alignment Errors Register
func (o *GMAC_Type) SetAE_AER(value uint32) {
	volatile.StoreUint32(&o.AE.Reg, volatile.LoadUint32(&o.AE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetAE_AER() uint32 {
	return volatile.LoadUint32(&o.AE.Reg) & 0x3ff
}

// GMAC.RRE: Receive Resource Errors Register
func (o *GMAC_Type) SetRRE_RXRER(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetRRE_RXRER() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0x3ffff
}

// GMAC.ROE: Receive Overrun Register
func (o *GMAC_Type) SetROE_RXOVR(value uint32) {
	volatile.StoreUint32(&o.ROE.Reg, volatile.LoadUint32(&o.ROE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetROE_RXOVR() uint32 {
	return volatile.LoadUint32(&o.ROE.Reg) & 0x3ff
}

// GMAC.IHCE: IP Header Checksum Errors Register
func (o *GMAC_Type) SetIHCE_HCKER(value uint32) {
	volatile.StoreUint32(&o.IHCE.Reg, volatile.LoadUint32(&o.IHCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetIHCE_HCKER() uint32 {
	return volatile.LoadUint32(&o.IHCE.Reg) & 0xff
}

// GMAC.TCE: TCP Checksum Errors Register
func (o *GMAC_Type) SetTCE_TCKER(value uint32) {
	volatile.StoreUint32(&o.TCE.Reg, volatile.LoadUint32(&o.TCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTCE_TCKER() uint32 {
	return volatile.LoadUint32(&o.TCE.Reg) & 0xff
}

// GMAC.UCE: UDP Checksum Errors Register
func (o *GMAC_Type) SetUCE_UCKER(value uint32) {
	volatile.StoreUint32(&o.UCE.Reg, volatile.LoadUint32(&o.UCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetUCE_UCKER() uint32 {
	return volatile.LoadUint32(&o.UCE.Reg) & 0xff
}

// GMAC.TISUBN: 1588 Timer Increment Sub-nanoseconds Register
func (o *GMAC_Type) SetTISUBN_LSBTIR(value uint32) {
	volatile.StoreUint32(&o.TISUBN.Reg, volatile.LoadUint32(&o.TISUBN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTISUBN_LSBTIR() uint32 {
	return volatile.LoadUint32(&o.TISUBN.Reg) & 0xffff
}

// GMAC.TSH: 1588 Timer Seconds High Register
func (o *GMAC_Type) SetTSH_TCS(value uint32) {
	volatile.StoreUint32(&o.TSH.Reg, volatile.LoadUint32(&o.TSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTSH_TCS() uint32 {
	return volatile.LoadUint32(&o.TSH.Reg) & 0xffff
}

// GMAC.TSL: 1588 Timer Seconds Low Register
func (o *GMAC_Type) SetTSL(value uint32) {
	volatile.StoreUint32(&o.TSL.Reg, value)
}
func (o *GMAC_Type) GetTSL() uint32 {
	return volatile.LoadUint32(&o.TSL.Reg)
}

// GMAC.TN: 1588 Timer Nanoseconds Register
func (o *GMAC_Type) SetTN_TNS(value uint32) {
	volatile.StoreUint32(&o.TN.Reg, volatile.LoadUint32(&o.TN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTN_TNS() uint32 {
	return volatile.LoadUint32(&o.TN.Reg) & 0x3fffffff
}

// GMAC.TA: 1588 Timer Adjust Register
func (o *GMAC_Type) SetTA_ITDT(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTA_ITDT() uint32 {
	return volatile.LoadUint32(&o.TA.Reg) & 0x3fffffff
}
func (o *GMAC_Type) SetTA_ADJ(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTA_ADJ() uint32 {
	return (volatile.LoadUint32(&o.TA.Reg) & 0x80000000) >> 31
}

// GMAC.TI: 1588 Timer Increment Register
func (o *GMAC_Type) SetTI_CNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTI_CNS() uint32 {
	return volatile.LoadUint32(&o.TI.Reg) & 0xff
}
func (o *GMAC_Type) SetTI_ACNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTI_ACNS() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff00) >> 8
}
func (o *GMAC_Type) SetTI_NIT(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetTI_NIT() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff0000) >> 16
}

// GMAC.EFTSL: PTP Event Frame Transmitted Seconds Low Register
func (o *GMAC_Type) SetEFTSL(value uint32) {
	volatile.StoreUint32(&o.EFTSL.Reg, value)
}
func (o *GMAC_Type) GetEFTSL() uint32 {
	return volatile.LoadUint32(&o.EFTSL.Reg)
}

// GMAC.EFTN: PTP Event Frame Transmitted Nanoseconds Register
func (o *GMAC_Type) SetEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFTN.Reg, volatile.LoadUint32(&o.EFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFTN.Reg) & 0x3fffffff
}

// GMAC.EFRSL: PTP Event Frame Received Seconds Low Register
func (o *GMAC_Type) SetEFRSL(value uint32) {
	volatile.StoreUint32(&o.EFRSL.Reg, value)
}
func (o *GMAC_Type) GetEFRSL() uint32 {
	return volatile.LoadUint32(&o.EFRSL.Reg)
}

// GMAC.EFRN: PTP Event Frame Received Nanoseconds Register
func (o *GMAC_Type) SetEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFRN.Reg, volatile.LoadUint32(&o.EFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFRN.Reg) & 0x3fffffff
}

// GMAC.PEFTSL: PTP Peer Event Frame Transmitted Seconds Low Register
func (o *GMAC_Type) SetPEFTSL(value uint32) {
	volatile.StoreUint32(&o.PEFTSL.Reg, value)
}
func (o *GMAC_Type) GetPEFTSL() uint32 {
	return volatile.LoadUint32(&o.PEFTSL.Reg)
}

// GMAC.PEFTN: PTP Peer Event Frame Transmitted Nanoseconds Register
func (o *GMAC_Type) SetPEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFTN.Reg, volatile.LoadUint32(&o.PEFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFTN.Reg) & 0x3fffffff
}

// GMAC.PEFRSL: PTP Peer Event Frame Received Seconds Low Register
func (o *GMAC_Type) SetPEFRSL(value uint32) {
	volatile.StoreUint32(&o.PEFRSL.Reg, value)
}
func (o *GMAC_Type) GetPEFRSL() uint32 {
	return volatile.LoadUint32(&o.PEFRSL.Reg)
}

// GMAC.PEFRN: PTP Peer Event Frame Received Nanoseconds Register
func (o *GMAC_Type) SetPEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFRN.Reg, volatile.LoadUint32(&o.PEFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFRN.Reg) & 0x3fffffff
}

// GMAC.ISRPQ: Interrupt Status Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetISRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetISRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetISRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetISRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetISRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetISRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetISRPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetISRPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetISRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetISRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetISRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetISRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetISRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetISRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.TBQBAPQ: Transmit Buffer Queue Base Address Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetTBQBAPQ_TXBQBA(idx int, value uint32) {
	volatile.StoreUint32(&o.TBQBAPQ[idx].Reg, volatile.LoadUint32(&o.TBQBAPQ[idx].Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetTBQBAPQ_TXBQBA(idx int) uint32 {
	return (volatile.LoadUint32(&o.TBQBAPQ[idx].Reg) & 0xfffffffc) >> 2
}

// GMAC.RBQBAPQ: Receive Buffer Queue Base Address Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetRBQBAPQ_RXBQBA(idx int, value uint32) {
	volatile.StoreUint32(&o.RBQBAPQ[idx].Reg, volatile.LoadUint32(&o.RBQBAPQ[idx].Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetRBQBAPQ_RXBQBA(idx int) uint32 {
	return (volatile.LoadUint32(&o.RBQBAPQ[idx].Reg) & 0xfffffffc) >> 2
}

// GMAC.RBSRPQ: Receive Buffer Size Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetRBSRPQ_RBS(idx int, value uint32) {
	volatile.StoreUint32(&o.RBSRPQ[idx].Reg, volatile.LoadUint32(&o.RBSRPQ[idx].Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRBSRPQ_RBS(idx int) uint32 {
	return volatile.LoadUint32(&o.RBSRPQ[idx].Reg) & 0xffff
}

// GMAC.CBSCR: Credit-Based Shaping Control Register
func (o *GMAC_Type) SetCBSCR_QBE(value uint32) {
	volatile.StoreUint32(&o.CBSCR.Reg, volatile.LoadUint32(&o.CBSCR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetCBSCR_QBE() uint32 {
	return volatile.LoadUint32(&o.CBSCR.Reg) & 0x1
}
func (o *GMAC_Type) SetCBSCR_QAE(value uint32) {
	volatile.StoreUint32(&o.CBSCR.Reg, volatile.LoadUint32(&o.CBSCR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetCBSCR_QAE() uint32 {
	return (volatile.LoadUint32(&o.CBSCR.Reg) & 0x2) >> 1
}

// GMAC.CBSISQA: Credit-Based Shaping IdleSlope Register for Queue A
func (o *GMAC_Type) SetCBSISQA(value uint32) {
	volatile.StoreUint32(&o.CBSISQA.Reg, value)
}
func (o *GMAC_Type) GetCBSISQA() uint32 {
	return volatile.LoadUint32(&o.CBSISQA.Reg)
}

// GMAC.CBSISQB: Credit-Based Shaping IdleSlope Register for Queue B
func (o *GMAC_Type) SetCBSISQB(value uint32) {
	volatile.StoreUint32(&o.CBSISQB.Reg, value)
}
func (o *GMAC_Type) GetCBSISQB() uint32 {
	return volatile.LoadUint32(&o.CBSISQB.Reg)
}

// GMAC.ST1RPQ: Screening Type 1 Register Priority Queue (index = 0) 0
func (o *GMAC_Type) SetST1RPQ_QNB(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0x7)|value)
}
func (o *GMAC_Type) GetST1RPQ_QNB(idx int) uint32 {
	return volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0x7
}
func (o *GMAC_Type) SetST1RPQ_DSTCM(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0xff0)|value<<4)
}
func (o *GMAC_Type) GetST1RPQ_DSTCM(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0xff0) >> 4
}
func (o *GMAC_Type) SetST1RPQ_UDPM(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0xffff000)|value<<12)
}
func (o *GMAC_Type) GetST1RPQ_UDPM(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0xffff000) >> 12
}
func (o *GMAC_Type) SetST1RPQ_DSTCE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetST1RPQ_DSTCE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetST1RPQ_UDPE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetST1RPQ_UDPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0x20000000) >> 29
}

// GMAC.ST2RPQ: Screening Type 2 Register Priority Queue (index = 0) 0
func (o *GMAC_Type) SetST2RPQ_QNB(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x7)|value)
}
func (o *GMAC_Type) GetST2RPQ_QNB(idx int) uint32 {
	return volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x7
}
func (o *GMAC_Type) SetST2RPQ_VLANP(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x70)|value<<4)
}
func (o *GMAC_Type) GetST2RPQ_VLANP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x70) >> 4
}
func (o *GMAC_Type) SetST2RPQ_VLANE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetST2RPQ_VLANE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetST2RPQ_I2ETH(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0xe00)|value<<9)
}
func (o *GMAC_Type) GetST2RPQ_I2ETH(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0xe00) >> 9
}
func (o *GMAC_Type) SetST2RPQ_ETHE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetST2RPQ_ETHE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetST2RPQ_COMPA(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x3e000)|value<<13)
}
func (o *GMAC_Type) GetST2RPQ_COMPA(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x3e000) >> 13
}
func (o *GMAC_Type) SetST2RPQ_COMPAE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetST2RPQ_COMPAE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetST2RPQ_COMPB(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0xf80000)|value<<19)
}
func (o *GMAC_Type) GetST2RPQ_COMPB(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0xf80000) >> 19
}
func (o *GMAC_Type) SetST2RPQ_COMPBE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetST2RPQ_COMPBE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetST2RPQ_COMPC(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x3e000000)|value<<25)
}
func (o *GMAC_Type) GetST2RPQ_COMPC(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x3e000000) >> 25
}
func (o *GMAC_Type) SetST2RPQ_COMPCE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetST2RPQ_COMPCE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x40000000) >> 30
}

// GMAC.IERPQ: Interrupt Enable Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetIERPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIERPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIERPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIERPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIERPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIERPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIERPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIERPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIERPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIERPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIERPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIERPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIERPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIERPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.IDRPQ: Interrupt Disable Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetIDRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIDRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIDRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIDRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIDRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIDRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIDRPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIDRPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIDRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIDRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIDRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIDRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIDRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIDRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.IMRPQ: Interrupt Mask Register Priority Queue (index = 1) 0
func (o *GMAC_Type) SetIMRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIMRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIMRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIMRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIMRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIMRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIMRPQ_AHB(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIMRPQ_AHB(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIMRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIMRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIMRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIMRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIMRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIMRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.ST2ER: Screening Type 2 Ethertype Register (index = 0) 0
func (o *GMAC_Type) SetST2ER_COMPVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2ER[idx].Reg, volatile.LoadUint32(&o.ST2ER[idx].Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2ER_COMPVAL(idx int) uint32 {
	return volatile.LoadUint32(&o.ST2ER[idx].Reg) & 0xffff
}

// GMAC.ST2CW00: Screening Type 2 Compare Word 0 Register (index = 0)
func (o *GMAC_Type) SetST2CW00_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW00.Reg, volatile.LoadUint32(&o.ST2CW00.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW00_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW00.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW00_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW00.Reg, volatile.LoadUint32(&o.ST2CW00.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW00_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW00.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW10: Screening Type 2 Compare Word 1 Register (index = 0)
func (o *GMAC_Type) SetST2CW10_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW10.Reg, volatile.LoadUint32(&o.ST2CW10.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW10_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW10.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW10_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW10.Reg, volatile.LoadUint32(&o.ST2CW10.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW10_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW10.Reg) & 0x180) >> 7
}

// GMAC.ST2CW01: Screening Type 2 Compare Word 0 Register (index = 1)
func (o *GMAC_Type) SetST2CW01_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW01.Reg, volatile.LoadUint32(&o.ST2CW01.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW01_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW01.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW01_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW01.Reg, volatile.LoadUint32(&o.ST2CW01.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW01_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW01.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW11: Screening Type 2 Compare Word 1 Register (index = 1)
func (o *GMAC_Type) SetST2CW11_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW11.Reg, volatile.LoadUint32(&o.ST2CW11.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW11_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW11.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW11_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW11.Reg, volatile.LoadUint32(&o.ST2CW11.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW11_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW11.Reg) & 0x180) >> 7
}

// GMAC.ST2CW02: Screening Type 2 Compare Word 0 Register (index = 2)
func (o *GMAC_Type) SetST2CW02_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW02.Reg, volatile.LoadUint32(&o.ST2CW02.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW02_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW02.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW02_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW02.Reg, volatile.LoadUint32(&o.ST2CW02.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW02_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW02.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW12: Screening Type 2 Compare Word 1 Register (index = 2)
func (o *GMAC_Type) SetST2CW12_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW12.Reg, volatile.LoadUint32(&o.ST2CW12.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW12_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW12.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW12_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW12.Reg, volatile.LoadUint32(&o.ST2CW12.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW12_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW12.Reg) & 0x180) >> 7
}

// GMAC.ST2CW03: Screening Type 2 Compare Word 0 Register (index = 3)
func (o *GMAC_Type) SetST2CW03_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW03.Reg, volatile.LoadUint32(&o.ST2CW03.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW03_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW03.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW03_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW03.Reg, volatile.LoadUint32(&o.ST2CW03.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW03_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW03.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW13: Screening Type 2 Compare Word 1 Register (index = 3)
func (o *GMAC_Type) SetST2CW13_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW13.Reg, volatile.LoadUint32(&o.ST2CW13.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW13_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW13.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW13_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW13.Reg, volatile.LoadUint32(&o.ST2CW13.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW13_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW13.Reg) & 0x180) >> 7
}

// GMAC.ST2CW04: Screening Type 2 Compare Word 0 Register (index = 4)
func (o *GMAC_Type) SetST2CW04_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW04.Reg, volatile.LoadUint32(&o.ST2CW04.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW04_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW04.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW04_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW04.Reg, volatile.LoadUint32(&o.ST2CW04.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW04_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW04.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW14: Screening Type 2 Compare Word 1 Register (index = 4)
func (o *GMAC_Type) SetST2CW14_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW14.Reg, volatile.LoadUint32(&o.ST2CW14.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW14_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW14.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW14_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW14.Reg, volatile.LoadUint32(&o.ST2CW14.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW14_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW14.Reg) & 0x180) >> 7
}

// GMAC.ST2CW05: Screening Type 2 Compare Word 0 Register (index = 5)
func (o *GMAC_Type) SetST2CW05_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW05.Reg, volatile.LoadUint32(&o.ST2CW05.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW05_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW05.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW05_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW05.Reg, volatile.LoadUint32(&o.ST2CW05.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW05_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW05.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW15: Screening Type 2 Compare Word 1 Register (index = 5)
func (o *GMAC_Type) SetST2CW15_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW15.Reg, volatile.LoadUint32(&o.ST2CW15.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW15_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW15.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW15_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW15.Reg, volatile.LoadUint32(&o.ST2CW15.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW15_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW15.Reg) & 0x180) >> 7
}

// GMAC.ST2CW06: Screening Type 2 Compare Word 0 Register (index = 6)
func (o *GMAC_Type) SetST2CW06_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW06.Reg, volatile.LoadUint32(&o.ST2CW06.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW06_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW06.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW06_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW06.Reg, volatile.LoadUint32(&o.ST2CW06.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW06_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW06.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW16: Screening Type 2 Compare Word 1 Register (index = 6)
func (o *GMAC_Type) SetST2CW16_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW16.Reg, volatile.LoadUint32(&o.ST2CW16.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW16_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW16.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW16_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW16.Reg, volatile.LoadUint32(&o.ST2CW16.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW16_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW16.Reg) & 0x180) >> 7
}

// GMAC.ST2CW07: Screening Type 2 Compare Word 0 Register (index = 7)
func (o *GMAC_Type) SetST2CW07_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW07.Reg, volatile.LoadUint32(&o.ST2CW07.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW07_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW07.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW07_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW07.Reg, volatile.LoadUint32(&o.ST2CW07.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW07_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW07.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW17: Screening Type 2 Compare Word 1 Register (index = 7)
func (o *GMAC_Type) SetST2CW17_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW17.Reg, volatile.LoadUint32(&o.ST2CW17.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW17_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW17.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW17_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW17.Reg, volatile.LoadUint32(&o.ST2CW17.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW17_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW17.Reg) & 0x180) >> 7
}

// GMAC.ST2CW08: Screening Type 2 Compare Word 0 Register (index = 8)
func (o *GMAC_Type) SetST2CW08_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW08.Reg, volatile.LoadUint32(&o.ST2CW08.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW08_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW08.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW08_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW08.Reg, volatile.LoadUint32(&o.ST2CW08.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW08_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW08.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW18: Screening Type 2 Compare Word 1 Register (index = 8)
func (o *GMAC_Type) SetST2CW18_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW18.Reg, volatile.LoadUint32(&o.ST2CW18.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW18_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW18.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW18_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW18.Reg, volatile.LoadUint32(&o.ST2CW18.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW18_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW18.Reg) & 0x180) >> 7
}

// GMAC.ST2CW09: Screening Type 2 Compare Word 0 Register (index = 9)
func (o *GMAC_Type) SetST2CW09_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW09.Reg, volatile.LoadUint32(&o.ST2CW09.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW09_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW09.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW09_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW09.Reg, volatile.LoadUint32(&o.ST2CW09.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW09_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW09.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW19: Screening Type 2 Compare Word 1 Register (index = 9)
func (o *GMAC_Type) SetST2CW19_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW19.Reg, volatile.LoadUint32(&o.ST2CW19.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW19_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW19.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW19_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW19.Reg, volatile.LoadUint32(&o.ST2CW19.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW19_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW19.Reg) & 0x180) >> 7
}

// GMAC.ST2CW010: Screening Type 2 Compare Word 0 Register (index = 10)
func (o *GMAC_Type) SetST2CW010_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW010.Reg, volatile.LoadUint32(&o.ST2CW010.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW010_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW010.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW010_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW010.Reg, volatile.LoadUint32(&o.ST2CW010.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW010_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW010.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW110: Screening Type 2 Compare Word 1 Register (index = 10)
func (o *GMAC_Type) SetST2CW110_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW110.Reg, volatile.LoadUint32(&o.ST2CW110.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW110_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW110.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW110_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW110.Reg, volatile.LoadUint32(&o.ST2CW110.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW110_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW110.Reg) & 0x180) >> 7
}

// GMAC.ST2CW011: Screening Type 2 Compare Word 0 Register (index = 11)
func (o *GMAC_Type) SetST2CW011_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW011.Reg, volatile.LoadUint32(&o.ST2CW011.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW011_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW011.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW011_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW011.Reg, volatile.LoadUint32(&o.ST2CW011.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW011_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW011.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW111: Screening Type 2 Compare Word 1 Register (index = 11)
func (o *GMAC_Type) SetST2CW111_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW111.Reg, volatile.LoadUint32(&o.ST2CW111.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW111_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW111.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW111_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW111.Reg, volatile.LoadUint32(&o.ST2CW111.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW111_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW111.Reg) & 0x180) >> 7
}

// GMAC.ST2CW012: Screening Type 2 Compare Word 0 Register (index = 12)
func (o *GMAC_Type) SetST2CW012_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW012.Reg, volatile.LoadUint32(&o.ST2CW012.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW012_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW012.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW012_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW012.Reg, volatile.LoadUint32(&o.ST2CW012.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW012_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW012.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW112: Screening Type 2 Compare Word 1 Register (index = 12)
func (o *GMAC_Type) SetST2CW112_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW112.Reg, volatile.LoadUint32(&o.ST2CW112.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW112_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW112.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW112_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW112.Reg, volatile.LoadUint32(&o.ST2CW112.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW112_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW112.Reg) & 0x180) >> 7
}

// GMAC.ST2CW013: Screening Type 2 Compare Word 0 Register (index = 13)
func (o *GMAC_Type) SetST2CW013_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW013.Reg, volatile.LoadUint32(&o.ST2CW013.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW013_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW013.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW013_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW013.Reg, volatile.LoadUint32(&o.ST2CW013.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW013_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW013.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW113: Screening Type 2 Compare Word 1 Register (index = 13)
func (o *GMAC_Type) SetST2CW113_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW113.Reg, volatile.LoadUint32(&o.ST2CW113.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW113_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW113.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW113_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW113.Reg, volatile.LoadUint32(&o.ST2CW113.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW113_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW113.Reg) & 0x180) >> 7
}

// GMAC.ST2CW014: Screening Type 2 Compare Word 0 Register (index = 14)
func (o *GMAC_Type) SetST2CW014_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW014.Reg, volatile.LoadUint32(&o.ST2CW014.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW014_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW014.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW014_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW014.Reg, volatile.LoadUint32(&o.ST2CW014.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW014_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW014.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW114: Screening Type 2 Compare Word 1 Register (index = 14)
func (o *GMAC_Type) SetST2CW114_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW114.Reg, volatile.LoadUint32(&o.ST2CW114.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW114_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW114.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW114_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW114.Reg, volatile.LoadUint32(&o.ST2CW114.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW114_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW114.Reg) & 0x180) >> 7
}

// GMAC.ST2CW015: Screening Type 2 Compare Word 0 Register (index = 15)
func (o *GMAC_Type) SetST2CW015_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW015.Reg, volatile.LoadUint32(&o.ST2CW015.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW015_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW015.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW015_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW015.Reg, volatile.LoadUint32(&o.ST2CW015.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW015_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW015.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW115: Screening Type 2 Compare Word 1 Register (index = 15)
func (o *GMAC_Type) SetST2CW115_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW115.Reg, volatile.LoadUint32(&o.ST2CW115.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW115_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW115.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW115_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW115.Reg, volatile.LoadUint32(&o.ST2CW115.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW115_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW115.Reg) & 0x180) >> 7
}

// GMAC.ST2CW016: Screening Type 2 Compare Word 0 Register (index = 16)
func (o *GMAC_Type) SetST2CW016_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW016.Reg, volatile.LoadUint32(&o.ST2CW016.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW016_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW016.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW016_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW016.Reg, volatile.LoadUint32(&o.ST2CW016.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW016_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW016.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW116: Screening Type 2 Compare Word 1 Register (index = 16)
func (o *GMAC_Type) SetST2CW116_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW116.Reg, volatile.LoadUint32(&o.ST2CW116.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW116_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW116.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW116_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW116.Reg, volatile.LoadUint32(&o.ST2CW116.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW116_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW116.Reg) & 0x180) >> 7
}

// GMAC.ST2CW017: Screening Type 2 Compare Word 0 Register (index = 17)
func (o *GMAC_Type) SetST2CW017_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW017.Reg, volatile.LoadUint32(&o.ST2CW017.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW017_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW017.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW017_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW017.Reg, volatile.LoadUint32(&o.ST2CW017.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW017_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW017.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW117: Screening Type 2 Compare Word 1 Register (index = 17)
func (o *GMAC_Type) SetST2CW117_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW117.Reg, volatile.LoadUint32(&o.ST2CW117.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW117_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW117.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW117_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW117.Reg, volatile.LoadUint32(&o.ST2CW117.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW117_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW117.Reg) & 0x180) >> 7
}

// GMAC.ST2CW018: Screening Type 2 Compare Word 0 Register (index = 18)
func (o *GMAC_Type) SetST2CW018_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW018.Reg, volatile.LoadUint32(&o.ST2CW018.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW018_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW018.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW018_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW018.Reg, volatile.LoadUint32(&o.ST2CW018.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW018_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW018.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW118: Screening Type 2 Compare Word 1 Register (index = 18)
func (o *GMAC_Type) SetST2CW118_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW118.Reg, volatile.LoadUint32(&o.ST2CW118.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW118_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW118.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW118_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW118.Reg, volatile.LoadUint32(&o.ST2CW118.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW118_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW118.Reg) & 0x180) >> 7
}

// GMAC.ST2CW019: Screening Type 2 Compare Word 0 Register (index = 19)
func (o *GMAC_Type) SetST2CW019_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW019.Reg, volatile.LoadUint32(&o.ST2CW019.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW019_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW019.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW019_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW019.Reg, volatile.LoadUint32(&o.ST2CW019.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW019_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW019.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW119: Screening Type 2 Compare Word 1 Register (index = 19)
func (o *GMAC_Type) SetST2CW119_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW119.Reg, volatile.LoadUint32(&o.ST2CW119.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW119_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW119.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW119_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW119.Reg, volatile.LoadUint32(&o.ST2CW119.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW119_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW119.Reg) & 0x180) >> 7
}

// GMAC.ST2CW020: Screening Type 2 Compare Word 0 Register (index = 20)
func (o *GMAC_Type) SetST2CW020_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW020.Reg, volatile.LoadUint32(&o.ST2CW020.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW020_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW020.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW020_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW020.Reg, volatile.LoadUint32(&o.ST2CW020.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW020_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW020.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW120: Screening Type 2 Compare Word 1 Register (index = 20)
func (o *GMAC_Type) SetST2CW120_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW120.Reg, volatile.LoadUint32(&o.ST2CW120.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW120_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW120.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW120_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW120.Reg, volatile.LoadUint32(&o.ST2CW120.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW120_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW120.Reg) & 0x180) >> 7
}

// GMAC.ST2CW021: Screening Type 2 Compare Word 0 Register (index = 21)
func (o *GMAC_Type) SetST2CW021_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW021.Reg, volatile.LoadUint32(&o.ST2CW021.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW021_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW021.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW021_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW021.Reg, volatile.LoadUint32(&o.ST2CW021.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW021_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW021.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW121: Screening Type 2 Compare Word 1 Register (index = 21)
func (o *GMAC_Type) SetST2CW121_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW121.Reg, volatile.LoadUint32(&o.ST2CW121.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW121_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW121.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW121_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW121.Reg, volatile.LoadUint32(&o.ST2CW121.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW121_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW121.Reg) & 0x180) >> 7
}

// GMAC.ST2CW022: Screening Type 2 Compare Word 0 Register (index = 22)
func (o *GMAC_Type) SetST2CW022_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW022.Reg, volatile.LoadUint32(&o.ST2CW022.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW022_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW022.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW022_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW022.Reg, volatile.LoadUint32(&o.ST2CW022.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW022_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW022.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW122: Screening Type 2 Compare Word 1 Register (index = 22)
func (o *GMAC_Type) SetST2CW122_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW122.Reg, volatile.LoadUint32(&o.ST2CW122.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW122_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW122.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW122_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW122.Reg, volatile.LoadUint32(&o.ST2CW122.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW122_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW122.Reg) & 0x180) >> 7
}

// GMAC.ST2CW023: Screening Type 2 Compare Word 0 Register (index = 23)
func (o *GMAC_Type) SetST2CW023_MASKVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW023.Reg, volatile.LoadUint32(&o.ST2CW023.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetST2CW023_MASKVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW023.Reg) & 0xffff
}
func (o *GMAC_Type) SetST2CW023_COMPVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW023.Reg, volatile.LoadUint32(&o.ST2CW023.Reg)&^(0xffff0000)|value<<16)
}
func (o *GMAC_Type) GetST2CW023_COMPVAL() uint32 {
	return (volatile.LoadUint32(&o.ST2CW023.Reg) & 0xffff0000) >> 16
}

// GMAC.ST2CW123: Screening Type 2 Compare Word 1 Register (index = 23)
func (o *GMAC_Type) SetST2CW123_OFFSVAL(value uint32) {
	volatile.StoreUint32(&o.ST2CW123.Reg, volatile.LoadUint32(&o.ST2CW123.Reg)&^(0x7f)|value)
}
func (o *GMAC_Type) GetST2CW123_OFFSVAL() uint32 {
	return volatile.LoadUint32(&o.ST2CW123.Reg) & 0x7f
}
func (o *GMAC_Type) SetST2CW123_OFFSSTRT(value uint32) {
	volatile.StoreUint32(&o.ST2CW123.Reg, volatile.LoadUint32(&o.ST2CW123.Reg)&^(0x180)|value<<7)
}
func (o *GMAC_Type) GetST2CW123_OFFSSTRT() uint32 {
	return (volatile.LoadUint32(&o.ST2CW123.Reg) & 0x180) >> 7
}

// Specific Address 1 Bottom Register
type GMAC_GMAC_SA_Type struct {
	SAB volatile.Register32 // 0x88
	SAT volatile.Register32 // 0x8C
}

// GMAC_GMAC_SA.SAB: Specific Address 1 Bottom Register
func (o *GMAC_GMAC_SA_Type) SetSAB(value uint32) {
	volatile.StoreUint32(&o.SAB.Reg, value)
}
func (o *GMAC_GMAC_SA_Type) GetSAB() uint32 {
	return volatile.LoadUint32(&o.SAB.Reg)
}

// GMAC_GMAC_SA.SAT: Specific Address 1 Top Register
func (o *GMAC_GMAC_SA_Type) SetSAT_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT.Reg, volatile.LoadUint32(&o.SAT.Reg)&^(0xffff)|value)
}
func (o *GMAC_GMAC_SA_Type) GetSAT_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT.Reg) & 0xffff
}

// General Purpose Backup Registers
type GPBR_Type struct {
	SYS_GPBR [8]volatile.Register32 // 0x0
}

// GPBR.SYS_GPBR: General Purpose Backup Register 0
func (o *GPBR_Type) SetSYS_GPBR(idx int, value uint32) {
	volatile.StoreUint32(&o.SYS_GPBR[idx].Reg, value)
}
func (o *GPBR_Type) GetSYS_GPBR(idx int) uint32 {
	return volatile.LoadUint32(&o.SYS_GPBR[idx].Reg)
}

// Integrity Check Monitor
type ICM_Type struct {
	CFG    volatile.Register32 // 0x0
	CTRL   volatile.Register32 // 0x4
	SR     volatile.Register32 // 0x8
	_      [4]byte
	IER    volatile.Register32 // 0x10
	IDR    volatile.Register32 // 0x14
	IMR    volatile.Register32 // 0x18
	ISR    volatile.Register32 // 0x1C
	UASR   volatile.Register32 // 0x20
	_      [12]byte
	DSCR   volatile.Register32    // 0x30
	HASH   volatile.Register32    // 0x34
	UIHVAL [8]volatile.Register32 // 0x38
}

// ICM.CFG: Configuration Register
func (o *ICM_Type) SetCFG_WBDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetCFG_WBDIS() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *ICM_Type) SetCFG_EOMDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2)|value<<1)
}
func (o *ICM_Type) GetCFG_EOMDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2) >> 1
}
func (o *ICM_Type) SetCFG_SLBDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4)|value<<2)
}
func (o *ICM_Type) GetCFG_SLBDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4) >> 2
}
func (o *ICM_Type) SetCFG_BBC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetCFG_BBC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetCFG_ASCD(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *ICM_Type) GetCFG_ASCD() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *ICM_Type) SetCFG_DUALBUFF(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x200)|value<<9)
}
func (o *ICM_Type) GetCFG_DUALBUFF() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x200) >> 9
}
func (o *ICM_Type) SetCFG_UIHASH(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *ICM_Type) GetCFG_UIHASH() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}
func (o *ICM_Type) SetCFG_UALGO(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xe000)|value<<13)
}
func (o *ICM_Type) GetCFG_UALGO() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xe000) >> 13
}

// ICM.CTRL: Control Register
func (o *ICM_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *ICM_Type) SetCTRL_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ICM_Type) GetCTRL_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *ICM_Type) SetCTRL_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ICM_Type) GetCTRL_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *ICM_Type) SetCTRL_REHASH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetCTRL_REHASH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetCTRL_RMDIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetCTRL_RMDIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetCTRL_RMEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetCTRL_RMEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf000) >> 12
}

// ICM.SR: Status Register
func (o *ICM_Type) SetSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *ICM_Type) SetSR_RAWRMDIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetSR_RAWRMDIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetSR_RMDIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetSR_RMDIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf000) >> 12
}

// ICM.IER: Interrupt Enable Register
func (o *ICM_Type) SetIER_RHC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIER_RHC() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0xf
}
func (o *ICM_Type) SetIER_RDM(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIER_RDM() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIER_RBE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIER_RBE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIER_RWC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIER_RWC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIER_REC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIER_REC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIER_RSU(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIER_RSU() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}

// ICM.IDR: Interrupt Disable Register
func (o *ICM_Type) SetIDR_RHC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIDR_RHC() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0xf
}
func (o *ICM_Type) SetIDR_RDM(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIDR_RDM() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIDR_RBE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIDR_RBE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIDR_RWC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIDR_RWC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIDR_REC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIDR_REC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIDR_RSU(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIDR_RSU() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}

// ICM.IMR: Interrupt Mask Register
func (o *ICM_Type) SetIMR_RHC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIMR_RHC() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0xf
}
func (o *ICM_Type) SetIMR_RDM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIMR_RDM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIMR_RBE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIMR_RBE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIMR_RWC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIMR_RWC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIMR_REC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIMR_REC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIMR_RSU(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIMR_RSU() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}

// ICM.ISR: Interrupt Status Register
func (o *ICM_Type) SetISR_RHC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetISR_RHC() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0xf
}
func (o *ICM_Type) SetISR_RDM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetISR_RDM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetISR_RBE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetISR_RBE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetISR_RWC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetISR_RWC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetISR_REC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetISR_REC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetISR_RSU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetISR_RSU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}

// ICM.UASR: Undefined Access Status Register
func (o *ICM_Type) SetUASR_URAT(value uint32) {
	volatile.StoreUint32(&o.UASR.Reg, volatile.LoadUint32(&o.UASR.Reg)&^(0x7)|value)
}
func (o *ICM_Type) GetUASR_URAT() uint32 {
	return volatile.LoadUint32(&o.UASR.Reg) & 0x7
}

// ICM.DSCR: Region Descriptor Area Start Address Register
func (o *ICM_Type) SetDSCR_DASA(value uint32) {
	volatile.StoreUint32(&o.DSCR.Reg, volatile.LoadUint32(&o.DSCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *ICM_Type) GetDSCR_DASA() uint32 {
	return (volatile.LoadUint32(&o.DSCR.Reg) & 0xffffffc0) >> 6
}

// ICM.HASH: Region Hash Area Start Address Register
func (o *ICM_Type) SetHASH_HASA(value uint32) {
	volatile.StoreUint32(&o.HASH.Reg, volatile.LoadUint32(&o.HASH.Reg)&^(0xffffff80)|value<<7)
}
func (o *ICM_Type) GetHASH_HASA() uint32 {
	return (volatile.LoadUint32(&o.HASH.Reg) & 0xffffff80) >> 7
}

// ICM.UIHVAL: User Initial Hash Value 0 Register 0
func (o *ICM_Type) SetUIHVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.UIHVAL[idx].Reg, value)
}
func (o *ICM_Type) GetUIHVAL(idx int) uint32 {
	return volatile.LoadUint32(&o.UIHVAL[idx].Reg)
}

// Image Sensor Interface
type ISI_Type struct {
	CFG1       volatile.Register32 // 0x0
	CFG2       volatile.Register32 // 0x4
	PSIZE      volatile.Register32 // 0x8
	PDECF      volatile.Register32 // 0xC
	Y2R_SET0   volatile.Register32 // 0x10
	Y2R_SET1   volatile.Register32 // 0x14
	R2Y_SET0   volatile.Register32 // 0x18
	R2Y_SET1   volatile.Register32 // 0x1C
	R2Y_SET2   volatile.Register32 // 0x20
	CR         volatile.Register32 // 0x24
	SR         volatile.Register32 // 0x28
	IER        volatile.Register32 // 0x2C
	IDR        volatile.Register32 // 0x30
	IMR        volatile.Register32 // 0x34
	DMA_CHER   volatile.Register32 // 0x38
	DMA_CHDR   volatile.Register32 // 0x3C
	DMA_CHSR   volatile.Register32 // 0x40
	DMA_P_ADDR volatile.Register32 // 0x44
	DMA_P_CTRL volatile.Register32 // 0x48
	DMA_P_DSCR volatile.Register32 // 0x4C
	DMA_C_ADDR volatile.Register32 // 0x50
	DMA_C_CTRL volatile.Register32 // 0x54
	DMA_C_DSCR volatile.Register32 // 0x58
	_          [136]byte
	WPMR       volatile.Register32 // 0xE4
	WPSR       volatile.Register32 // 0xE8
}

// ISI.CFG1: ISI Configuration 1 Register
func (o *ISI_Type) SetCFG1_HSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCFG1_HSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCFG1_VSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetCFG1_VSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x8) >> 3
}
func (o *ISI_Type) SetCFG1_PIXCLK_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ISI_Type) GetCFG1_PIXCLK_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10) >> 4
}
func (o *ISI_Type) SetCFG1_EMB_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x40)|value<<6)
}
func (o *ISI_Type) GetCFG1_EMB_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x40) >> 6
}
func (o *ISI_Type) SetCFG1_CRC_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ISI_Type) GetCFG1_CRC_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80) >> 7
}
func (o *ISI_Type) SetCFG1_FRATE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x700)|value<<8)
}
func (o *ISI_Type) GetCFG1_FRATE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x700) >> 8
}
func (o *ISI_Type) SetCFG1_DISCR(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG1_DISCR() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG1_FULL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG1_FULL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG1_THMASK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x6000)|value<<13)
}
func (o *ISI_Type) GetCFG1_THMASK() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x6000) >> 13
}
func (o *ISI_Type) SetCFG1_SLD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetCFG1_SLD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetCFG1_SFD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetCFG1_SFD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff000000) >> 24
}

// ISI.CFG2: ISI Configuration 2 Register
func (o *ISI_Type) SetCFG2_IM_VSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff)|value)
}
func (o *ISI_Type) GetCFG2_IM_VSIZE() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff
}
func (o *ISI_Type) SetCFG2_GS_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG2_GS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG2_RGB_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG2_RGB_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG2_GRAYSCALE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetCFG2_GRAYSCALE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetCFG2_RGB_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetCFG2_RGB_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4000) >> 14
}
func (o *ISI_Type) SetCFG2_COL_SPACE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8000)|value<<15)
}
func (o *ISI_Type) GetCFG2_COL_SPACE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8000) >> 15
}
func (o *ISI_Type) SetCFG2_IM_HSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *ISI_Type) GetCFG2_IM_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff0000) >> 16
}
func (o *ISI_Type) SetCFG2_YCC_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *ISI_Type) GetCFG2_YCC_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}
func (o *ISI_Type) SetCFG2_RGB_CFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ISI_Type) GetCFG2_RGB_CFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc0000000) >> 30
}

// ISI.PSIZE: ISI Preview Size Register
func (o *ISI_Type) SetPSIZE_PREV_VSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff)|value)
}
func (o *ISI_Type) GetPSIZE_PREV_VSIZE() uint32 {
	return volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff
}
func (o *ISI_Type) SetPSIZE_PREV_HSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff0000)|value<<16)
}
func (o *ISI_Type) GetPSIZE_PREV_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff0000) >> 16
}

// ISI.PDECF: ISI Preview Decimation Factor Register
func (o *ISI_Type) SetPDECF_DEC_FACTOR(value uint32) {
	volatile.StoreUint32(&o.PDECF.Reg, volatile.LoadUint32(&o.PDECF.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetPDECF_DEC_FACTOR() uint32 {
	return volatile.LoadUint32(&o.PDECF.Reg) & 0xff
}

// ISI.Y2R_SET0: ISI Color Space Conversion YCrCb To RGB Set 0 Register
func (o *ISI_Type) SetY2R_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetY2R_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff
}
func (o *ISI_Type) SetY2R_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetY2R_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetY2R_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetY2R_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetY2R_SET0_C3(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetY2R_SET0_C3() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff000000) >> 24
}

// ISI.Y2R_SET1: ISI Color Space Conversion YCrCb To RGB Set 1 Register
func (o *ISI_Type) SetY2R_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1ff)|value)
}
func (o *ISI_Type) GetY2R_SET1_C4() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1ff
}
func (o *ISI_Type) SetY2R_SET1_Yoff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetY2R_SET1_Yoff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetY2R_SET1_Croff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetY2R_SET1_Croff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetY2R_SET1_Cboff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetY2R_SET1_Cboff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x4000) >> 14
}

// ISI.R2Y_SET0: ISI Color Space Conversion RGB To YCrCb Set 0 Register
func (o *ISI_Type) SetR2Y_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET0_Roff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET0_Roff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET1: ISI Color Space Conversion RGB To YCrCb Set 1 Register
func (o *ISI_Type) SetR2Y_SET1_C3(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET1_C3() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET1_C4() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET1_C5(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET1_C5() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET1_Goff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET1_Goff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET2: ISI Color Space Conversion RGB To YCrCb Set 2 Register
func (o *ISI_Type) SetR2Y_SET2_C6(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET2_C6() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET2_C7(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET2_C7() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET2_C8(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET2_C8() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET2_Boff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET2_Boff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x1000000) >> 24
}

// ISI.CR: ISI Control Register
func (o *ISI_Type) SetCR_ISI_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetCR_ISI_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ISI_Type) SetCR_ISI_DIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetCR_ISI_DIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetCR_ISI_SRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCR_ISI_SRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCR_ISI_CDC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetCR_ISI_CDC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// ISI.SR: ISI Status Register
func (o *ISI_Type) SetSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *ISI_Type) SetSR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetSR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetSR_SRST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetSR_SRST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetSR_CDC_PND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetSR_CDC_PND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *ISI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetSR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetSR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetSR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetSR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetSR_SIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *ISI_Type) GetSR_SIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *ISI_Type) SetSR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetSR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetSR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetSR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetSR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetSR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetSR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetSR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}

// ISI.IER: ISI Interrupt Enable Register
func (o *ISI_Type) SetIER_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIER_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIER_SRST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIER_SRST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIER_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIER_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIER_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIER_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIER_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIER_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIER_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIER_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIER_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIER_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIER_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIER_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIER_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIER_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}

// ISI.IDR: ISI Interrupt Disable Register
func (o *ISI_Type) SetIDR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIDR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIDR_SRST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIDR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIDR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIDR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIDR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIDR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIDR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIDR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIDR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIDR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIDR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIDR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIDR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIDR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIDR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIDR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}

// ISI.IMR: ISI Interrupt Mask Register
func (o *ISI_Type) SetIMR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIMR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIMR_SRST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIMR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIMR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIMR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIMR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIMR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIMR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIMR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIMR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIMR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIMR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIMR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIMR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIMR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIMR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIMR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}

// ISI.DMA_CHER: DMA Channel Enable Register
func (o *ISI_Type) SetDMA_CHER_P_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHER_P_CH_EN() uint32 {
	return volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHER_C_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHER_C_CH_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x2) >> 1
}

// ISI.DMA_CHDR: DMA Channel Disable Register
func (o *ISI_Type) SetDMA_CHDR_P_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHDR_P_CH_DIS() uint32 {
	return volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHDR_C_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHDR_C_CH_DIS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x2) >> 1
}

// ISI.DMA_CHSR: DMA Channel Status Register
func (o *ISI_Type) SetDMA_CHSR_P_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHSR_P_CH_S() uint32 {
	return volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHSR_C_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHSR_C_CH_S() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x2) >> 1
}

// ISI.DMA_P_ADDR: DMA Preview Base Address Register
func (o *ISI_Type) SetDMA_P_ADDR_P_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_ADDR.Reg, volatile.LoadUint32(&o.DMA_P_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_ADDR_P_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_P_CTRL: DMA Preview Control Register
func (o *ISI_Type) SetDMA_P_CTRL_P_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_P_CTRL_P_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_P_DSCR: DMA Preview Descriptor Address Register
func (o *ISI_Type) SetDMA_P_DSCR_P_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_DSCR.Reg, volatile.LoadUint32(&o.DMA_P_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_DSCR_P_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_ADDR: DMA Codec Base Address Register
func (o *ISI_Type) SetDMA_C_ADDR_C_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_ADDR.Reg, volatile.LoadUint32(&o.DMA_C_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_ADDR_C_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_CTRL: DMA Codec Control Register
func (o *ISI_Type) SetDMA_C_CTRL_C_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_C_CTRL_C_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_C_DSCR: DMA Codec Descriptor Address Register
func (o *ISI_Type) SetDMA_C_DSCR_C_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_DSCR.Reg, volatile.LoadUint32(&o.DMA_C_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_DSCR_C_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.WPMR: Write Protection Mode Register
func (o *ISI_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *ISI_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ISI_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// ISI.WPSR: Write Protection Status Register
func (o *ISI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *ISI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ISI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Bus Matrix
type MATRIX_Type struct {
	MCFG         [12]volatile.Register32 // 0x0
	_            [16]byte
	SCFG         [9]volatile.Register32 // 0x40
	_            [28]byte
	MATRIX_PR    [9]MATRIX_MATRIX_PR_Type // 0x80
	_            [56]byte
	MRCR         volatile.Register32 // 0x100
	_            [12]byte
	CCFG_CAN0    volatile.Register32 // 0x110
	CCFG_SYSIO   volatile.Register32 // 0x114
	_            [12]byte
	CCFG_SMCNFCS volatile.Register32 // 0x124
	_            [188]byte
	WPMR         volatile.Register32 // 0x1E4
	WPSR         volatile.Register32 // 0x1E8
}

// MATRIX.MCFG: Master Configuration Register 0
func (o *MATRIX_Type) SetMCFG_ULBT(idx int, value uint32) {
	volatile.StoreUint32(&o.MCFG[idx].Reg, volatile.LoadUint32(&o.MCFG[idx].Reg)&^(0x7)|value)
}
func (o *MATRIX_Type) GetMCFG_ULBT(idx int) uint32 {
	return volatile.LoadUint32(&o.MCFG[idx].Reg) & 0x7
}

// MATRIX.SCFG: Slave Configuration Register 0
func (o *MATRIX_Type) SetSCFG_SLOT_CYCLE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x1ff)|value)
}
func (o *MATRIX_Type) GetSCFG_SLOT_CYCLE(idx int) uint32 {
	return volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x1ff
}
func (o *MATRIX_Type) SetSCFG_DEFMSTR_TYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetSCFG_DEFMSTR_TYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetSCFG_FIXED_DEFMSTR(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x3c0000)|value<<18)
}
func (o *MATRIX_Type) GetSCFG_FIXED_DEFMSTR(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x3c0000) >> 18
}

// MATRIX.MRCR: Master Remap Control Register
func (o *MATRIX_Type) SetMRCR_RCB0(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetMRCR_RCB0() uint32 {
	return volatile.LoadUint32(&o.MRCR.Reg) & 0x1
}
func (o *MATRIX_Type) SetMRCR_RCB1(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2)|value<<1)
}
func (o *MATRIX_Type) GetMRCR_RCB1() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2) >> 1
}
func (o *MATRIX_Type) SetMRCR_RCB2(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4)|value<<2)
}
func (o *MATRIX_Type) GetMRCR_RCB2() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4) >> 2
}
func (o *MATRIX_Type) SetMRCR_RCB3(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8)|value<<3)
}
func (o *MATRIX_Type) GetMRCR_RCB3() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8) >> 3
}
func (o *MATRIX_Type) SetMRCR_RCB4(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetMRCR_RCB4() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x10) >> 4
}
func (o *MATRIX_Type) SetMRCR_RCB5(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x20)|value<<5)
}
func (o *MATRIX_Type) GetMRCR_RCB5() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x20) >> 5
}
func (o *MATRIX_Type) SetMRCR_RCB6(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x40)|value<<6)
}
func (o *MATRIX_Type) GetMRCR_RCB6() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x40) >> 6
}
func (o *MATRIX_Type) SetMRCR_RCB8(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x100)|value<<8)
}
func (o *MATRIX_Type) GetMRCR_RCB8() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x100) >> 8
}
func (o *MATRIX_Type) SetMRCR_RCB9(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x200)|value<<9)
}
func (o *MATRIX_Type) GetMRCR_RCB9() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x200) >> 9
}
func (o *MATRIX_Type) SetMRCR_RCB10(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x400)|value<<10)
}
func (o *MATRIX_Type) GetMRCR_RCB10() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x400) >> 10
}
func (o *MATRIX_Type) SetMRCR_RCB11(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x800)|value<<11)
}
func (o *MATRIX_Type) GetMRCR_RCB11() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x800) >> 11
}

// MATRIX.CCFG_CAN0: CAN0 Configuration Register
func (o *MATRIX_Type) SetCCFG_CAN0_CAN0DMABA(value uint32) {
	volatile.StoreUint32(&o.CCFG_CAN0.Reg, volatile.LoadUint32(&o.CCFG_CAN0.Reg)&^(0xffff0000)|value<<16)
}
func (o *MATRIX_Type) GetCCFG_CAN0_CAN0DMABA() uint32 {
	return (volatile.LoadUint32(&o.CCFG_CAN0.Reg) & 0xffff0000) >> 16
}

// MATRIX.CCFG_SYSIO: System I/O Configuration Register
func (o *MATRIX_Type) SetCCFG_SYSIO_SYSIO4(value uint32) {
	volatile.StoreUint32(&o.CCFG_SYSIO.Reg, volatile.LoadUint32(&o.CCFG_SYSIO.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetCCFG_SYSIO_SYSIO4() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SYSIO.Reg) & 0x10) >> 4
}
func (o *MATRIX_Type) SetCCFG_SYSIO_SYSIO5(value uint32) {
	volatile.StoreUint32(&o.CCFG_SYSIO.Reg, volatile.LoadUint32(&o.CCFG_SYSIO.Reg)&^(0x20)|value<<5)
}
func (o *MATRIX_Type) GetCCFG_SYSIO_SYSIO5() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SYSIO.Reg) & 0x20) >> 5
}
func (o *MATRIX_Type) SetCCFG_SYSIO_SYSIO6(value uint32) {
	volatile.StoreUint32(&o.CCFG_SYSIO.Reg, volatile.LoadUint32(&o.CCFG_SYSIO.Reg)&^(0x40)|value<<6)
}
func (o *MATRIX_Type) GetCCFG_SYSIO_SYSIO6() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SYSIO.Reg) & 0x40) >> 6
}
func (o *MATRIX_Type) SetCCFG_SYSIO_SYSIO7(value uint32) {
	volatile.StoreUint32(&o.CCFG_SYSIO.Reg, volatile.LoadUint32(&o.CCFG_SYSIO.Reg)&^(0x80)|value<<7)
}
func (o *MATRIX_Type) GetCCFG_SYSIO_SYSIO7() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SYSIO.Reg) & 0x80) >> 7
}
func (o *MATRIX_Type) SetCCFG_SYSIO_SYSIO12(value uint32) {
	volatile.StoreUint32(&o.CCFG_SYSIO.Reg, volatile.LoadUint32(&o.CCFG_SYSIO.Reg)&^(0x1000)|value<<12)
}
func (o *MATRIX_Type) GetCCFG_SYSIO_SYSIO12() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SYSIO.Reg) & 0x1000) >> 12
}

// MATRIX.CCFG_SMCNFCS: SMC NAND Flash Chip Select Configuration Register
func (o *MATRIX_Type) SetCCFG_SMCNFCS_SMC_NFCS0(value uint32) {
	volatile.StoreUint32(&o.CCFG_SMCNFCS.Reg, volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetCCFG_SMCNFCS_SMC_NFCS0() uint32 {
	return volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg) & 0x1
}
func (o *MATRIX_Type) SetCCFG_SMCNFCS_SMC_NFCS1(value uint32) {
	volatile.StoreUint32(&o.CCFG_SMCNFCS.Reg, volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg)&^(0x2)|value<<1)
}
func (o *MATRIX_Type) GetCCFG_SMCNFCS_SMC_NFCS1() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg) & 0x2) >> 1
}
func (o *MATRIX_Type) SetCCFG_SMCNFCS_SMC_NFCS2(value uint32) {
	volatile.StoreUint32(&o.CCFG_SMCNFCS.Reg, volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg)&^(0x4)|value<<2)
}
func (o *MATRIX_Type) GetCCFG_SMCNFCS_SMC_NFCS2() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg) & 0x4) >> 2
}
func (o *MATRIX_Type) SetCCFG_SMCNFCS_SMC_NFCS3(value uint32) {
	volatile.StoreUint32(&o.CCFG_SMCNFCS.Reg, volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg)&^(0x8)|value<<3)
}
func (o *MATRIX_Type) GetCCFG_SMCNFCS_SMC_NFCS3() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg) & 0x8) >> 3
}
func (o *MATRIX_Type) SetCCFG_SMCNFCS_SDRAMEN(value uint32) {
	volatile.StoreUint32(&o.CCFG_SMCNFCS.Reg, volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetCCFG_SMCNFCS_SDRAMEN() uint32 {
	return (volatile.LoadUint32(&o.CCFG_SMCNFCS.Reg) & 0x10) >> 4
}

// MATRIX.WPMR: Write Protection Mode Register
func (o *MATRIX_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// MATRIX.WPSR: Write Protection Status Register
func (o *MATRIX_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Priority Register A for Slave 0
type MATRIX_MATRIX_PR_Type struct {
	PRAS volatile.Register32 // 0x80
	PRBS volatile.Register32 // 0x84
}

// MATRIX_MATRIX_PR.PRAS: Priority Register A for Slave 0
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x3)|value)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS.Reg) & 0x3
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x30) >> 4
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x300) >> 8
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x3000) >> 12
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x30000) >> 16
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x300000) >> 20
}
func (o *MATRIX_MATRIX_PR_Type) SetPRAS_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS.Reg, volatile.LoadUint32(&o.PRAS.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRAS_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS.Reg) & 0x3000000) >> 24
}

// MATRIX_MATRIX_PR.PRBS: Priority Register B for Slave 0
func (o *MATRIX_MATRIX_PR_Type) SetPRBS_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS.Reg, volatile.LoadUint32(&o.PRBS.Reg)&^(0x3)|value)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRBS_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS.Reg) & 0x3
}
func (o *MATRIX_MATRIX_PR_Type) SetPRBS_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS.Reg, volatile.LoadUint32(&o.PRBS.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRBS_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS.Reg) & 0x30) >> 4
}
func (o *MATRIX_MATRIX_PR_Type) SetPRBS_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS.Reg, volatile.LoadUint32(&o.PRBS.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRBS_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS.Reg) & 0x300) >> 8
}
func (o *MATRIX_MATRIX_PR_Type) SetPRBS_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS.Reg, volatile.LoadUint32(&o.PRBS.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_MATRIX_PR_Type) GetPRBS_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS.Reg) & 0x3000) >> 12
}

// Controller Area Network
type MCAN_Type struct {
	_      [8]byte
	CUST   volatile.Register32 // 0x8
	FBTP   volatile.Register32 // 0xC
	TEST   volatile.Register32 // 0x10
	RWD    volatile.Register32 // 0x14
	CCCR   volatile.Register32 // 0x18
	BTP    volatile.Register32 // 0x1C
	TSCC   volatile.Register32 // 0x20
	TSCV   volatile.Register32 // 0x24
	TOCC   volatile.Register32 // 0x28
	TOCV   volatile.Register32 // 0x2C
	_      [16]byte
	ECR    volatile.Register32 // 0x40
	PSR    volatile.Register32 // 0x44
	_      [8]byte
	IR     volatile.Register32 // 0x50
	IE     volatile.Register32 // 0x54
	ILS    volatile.Register32 // 0x58
	ILE    volatile.Register32 // 0x5C
	_      [32]byte
	GFC    volatile.Register32 // 0x80
	SIDFC  volatile.Register32 // 0x84
	XIDFC  volatile.Register32 // 0x88
	_      [4]byte
	XIDAM  volatile.Register32 // 0x90
	HPMS   volatile.Register32 // 0x94
	NDAT1  volatile.Register32 // 0x98
	NDAT2  volatile.Register32 // 0x9C
	RXF0C  volatile.Register32 // 0xA0
	RXF0S  volatile.Register32 // 0xA4
	RXF0A  volatile.Register32 // 0xA8
	RXBC   volatile.Register32 // 0xAC
	RXF1C  volatile.Register32 // 0xB0
	RXF1S  volatile.Register32 // 0xB4
	RXF1A  volatile.Register32 // 0xB8
	RXESC  volatile.Register32 // 0xBC
	TXBC   volatile.Register32 // 0xC0
	TXFQS  volatile.Register32 // 0xC4
	TXESC  volatile.Register32 // 0xC8
	TXBRP  volatile.Register32 // 0xCC
	TXBAR  volatile.Register32 // 0xD0
	TXBCR  volatile.Register32 // 0xD4
	TXBTO  volatile.Register32 // 0xD8
	TXBCF  volatile.Register32 // 0xDC
	TXBTIE volatile.Register32 // 0xE0
	TXBCIE volatile.Register32 // 0xE4
	_      [8]byte
	TXEFC  volatile.Register32 // 0xF0
	TXEFS  volatile.Register32 // 0xF4
	TXEFA  volatile.Register32 // 0xF8
}

// MCAN.CUST: Customer Register
func (o *MCAN_Type) SetCUST(value uint32) {
	volatile.StoreUint32(&o.CUST.Reg, value)
}
func (o *MCAN_Type) GetCUST() uint32 {
	return volatile.LoadUint32(&o.CUST.Reg)
}

// MCAN.FBTP: Fast Bit Timing and Prescaler Register
func (o *MCAN_Type) SetFBTP_FSJW(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0x3)|value)
}
func (o *MCAN_Type) GetFBTP_FSJW() uint32 {
	return volatile.LoadUint32(&o.FBTP.Reg) & 0x3
}
func (o *MCAN_Type) SetFBTP_FTSEG2(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0x70)|value<<4)
}
func (o *MCAN_Type) GetFBTP_FTSEG2() uint32 {
	return (volatile.LoadUint32(&o.FBTP.Reg) & 0x70) >> 4
}
func (o *MCAN_Type) SetFBTP_FTSEG1(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0xf00)|value<<8)
}
func (o *MCAN_Type) GetFBTP_FTSEG1() uint32 {
	return (volatile.LoadUint32(&o.FBTP.Reg) & 0xf00) >> 8
}
func (o *MCAN_Type) SetFBTP_FBRP(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0x1f0000)|value<<16)
}
func (o *MCAN_Type) GetFBTP_FBRP() uint32 {
	return (volatile.LoadUint32(&o.FBTP.Reg) & 0x1f0000) >> 16
}
func (o *MCAN_Type) SetFBTP_TDC(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetFBTP_TDC() uint32 {
	return (volatile.LoadUint32(&o.FBTP.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetFBTP_TDCO(value uint32) {
	volatile.StoreUint32(&o.FBTP.Reg, volatile.LoadUint32(&o.FBTP.Reg)&^(0x1f000000)|value<<24)
}
func (o *MCAN_Type) GetFBTP_TDCO() uint32 {
	return (volatile.LoadUint32(&o.FBTP.Reg) & 0x1f000000) >> 24
}

// MCAN.TEST: Test Register
func (o *MCAN_Type) SetTEST_LBCK(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTEST_LBCK() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTEST_TX(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x60)|value<<5)
}
func (o *MCAN_Type) GetTEST_TX() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x60) >> 5
}
func (o *MCAN_Type) SetTEST_RX(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTEST_RX() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTEST_TDCV(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x3f00)|value<<8)
}
func (o *MCAN_Type) GetTEST_TDCV() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x3f00) >> 8
}

// MCAN.RWD: RAM Watchdog Register
func (o *MCAN_Type) SetRWD_WDC(value uint32) {
	volatile.StoreUint32(&o.RWD.Reg, volatile.LoadUint32(&o.RWD.Reg)&^(0xff)|value)
}
func (o *MCAN_Type) GetRWD_WDC() uint32 {
	return volatile.LoadUint32(&o.RWD.Reg) & 0xff
}
func (o *MCAN_Type) SetRWD_WDV(value uint32) {
	volatile.StoreUint32(&o.RWD.Reg, volatile.LoadUint32(&o.RWD.Reg)&^(0xff00)|value<<8)
}
func (o *MCAN_Type) GetRWD_WDV() uint32 {
	return (volatile.LoadUint32(&o.RWD.Reg) & 0xff00) >> 8
}

// MCAN.CCCR: CC Control Register
func (o *MCAN_Type) SetCCCR_INIT(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetCCCR_INIT() uint32 {
	return volatile.LoadUint32(&o.CCCR.Reg) & 0x1
}
func (o *MCAN_Type) SetCCCR_CCE(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetCCCR_CCE() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetCCCR_ASM(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetCCCR_ASM() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetCCCR_CSA(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetCCCR_CSA() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetCCCR_CSR(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetCCCR_CSR() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetCCCR_MON(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetCCCR_MON() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetCCCR_DAR(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetCCCR_DAR() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetCCCR_TEST(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetCCCR_TEST() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetCCCR_CME(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x300)|value<<8)
}
func (o *MCAN_Type) GetCCCR_CME() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x300) >> 8
}
func (o *MCAN_Type) SetCCCR_CMR(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0xc00)|value<<10)
}
func (o *MCAN_Type) GetCCCR_CMR() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0xc00) >> 10
}
func (o *MCAN_Type) SetCCCR_FDO(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetCCCR_FDO() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetCCCR_FDBS(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetCCCR_FDBS() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetCCCR_TXP(value uint32) {
	volatile.StoreUint32(&o.CCCR.Reg, volatile.LoadUint32(&o.CCCR.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetCCCR_TXP() uint32 {
	return (volatile.LoadUint32(&o.CCCR.Reg) & 0x4000) >> 14
}

// MCAN.BTP: Bit Timing and Prescaler Register
func (o *MCAN_Type) SetBTP_SJW(value uint32) {
	volatile.StoreUint32(&o.BTP.Reg, volatile.LoadUint32(&o.BTP.Reg)&^(0xf)|value)
}
func (o *MCAN_Type) GetBTP_SJW() uint32 {
	return volatile.LoadUint32(&o.BTP.Reg) & 0xf
}
func (o *MCAN_Type) SetBTP_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BTP.Reg, volatile.LoadUint32(&o.BTP.Reg)&^(0xf0)|value<<4)
}
func (o *MCAN_Type) GetBTP_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BTP.Reg) & 0xf0) >> 4
}
func (o *MCAN_Type) SetBTP_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BTP.Reg, volatile.LoadUint32(&o.BTP.Reg)&^(0x3f00)|value<<8)
}
func (o *MCAN_Type) GetBTP_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BTP.Reg) & 0x3f00) >> 8
}
func (o *MCAN_Type) SetBTP_BRP(value uint32) {
	volatile.StoreUint32(&o.BTP.Reg, volatile.LoadUint32(&o.BTP.Reg)&^(0x3ff0000)|value<<16)
}
func (o *MCAN_Type) GetBTP_BRP() uint32 {
	return (volatile.LoadUint32(&o.BTP.Reg) & 0x3ff0000) >> 16
}

// MCAN.TSCC: Timestamp Counter Configuration Register
func (o *MCAN_Type) SetTSCC_TSS(value uint32) {
	volatile.StoreUint32(&o.TSCC.Reg, volatile.LoadUint32(&o.TSCC.Reg)&^(0x3)|value)
}
func (o *MCAN_Type) GetTSCC_TSS() uint32 {
	return volatile.LoadUint32(&o.TSCC.Reg) & 0x3
}
func (o *MCAN_Type) SetTSCC_TCP(value uint32) {
	volatile.StoreUint32(&o.TSCC.Reg, volatile.LoadUint32(&o.TSCC.Reg)&^(0xf0000)|value<<16)
}
func (o *MCAN_Type) GetTSCC_TCP() uint32 {
	return (volatile.LoadUint32(&o.TSCC.Reg) & 0xf0000) >> 16
}

// MCAN.TSCV: Timestamp Counter Value Register
func (o *MCAN_Type) SetTSCV_TSC(value uint32) {
	volatile.StoreUint32(&o.TSCV.Reg, volatile.LoadUint32(&o.TSCV.Reg)&^(0xffff)|value)
}
func (o *MCAN_Type) GetTSCV_TSC() uint32 {
	return volatile.LoadUint32(&o.TSCV.Reg) & 0xffff
}

// MCAN.TOCC: Timeout Counter Configuration Register
func (o *MCAN_Type) SetTOCC_ETOC(value uint32) {
	volatile.StoreUint32(&o.TOCC.Reg, volatile.LoadUint32(&o.TOCC.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTOCC_ETOC() uint32 {
	return volatile.LoadUint32(&o.TOCC.Reg) & 0x1
}
func (o *MCAN_Type) SetTOCC_TOS(value uint32) {
	volatile.StoreUint32(&o.TOCC.Reg, volatile.LoadUint32(&o.TOCC.Reg)&^(0x6)|value<<1)
}
func (o *MCAN_Type) GetTOCC_TOS() uint32 {
	return (volatile.LoadUint32(&o.TOCC.Reg) & 0x6) >> 1
}
func (o *MCAN_Type) SetTOCC_TOP(value uint32) {
	volatile.StoreUint32(&o.TOCC.Reg, volatile.LoadUint32(&o.TOCC.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCAN_Type) GetTOCC_TOP() uint32 {
	return (volatile.LoadUint32(&o.TOCC.Reg) & 0xffff0000) >> 16
}

// MCAN.TOCV: Timeout Counter Value Register
func (o *MCAN_Type) SetTOCV_TOC(value uint32) {
	volatile.StoreUint32(&o.TOCV.Reg, volatile.LoadUint32(&o.TOCV.Reg)&^(0xffff)|value)
}
func (o *MCAN_Type) GetTOCV_TOC() uint32 {
	return volatile.LoadUint32(&o.TOCV.Reg) & 0xffff
}

// MCAN.ECR: Error Counter Register
func (o *MCAN_Type) SetECR_TEC(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff)|value)
}
func (o *MCAN_Type) GetECR_TEC() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0xff
}
func (o *MCAN_Type) SetECR_REC(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x7f00)|value<<8)
}
func (o *MCAN_Type) GetECR_REC() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x7f00) >> 8
}
func (o *MCAN_Type) SetECR_RP(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetECR_RP() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetECR_CEL(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff0000)|value<<16)
}
func (o *MCAN_Type) GetECR_CEL() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0xff0000) >> 16
}

// MCAN.PSR: Protocol Status Register
func (o *MCAN_Type) SetPSR_LEC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x7)|value)
}
func (o *MCAN_Type) GetPSR_LEC() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x7
}
func (o *MCAN_Type) SetPSR_ACT(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x18)|value<<3)
}
func (o *MCAN_Type) GetPSR_ACT() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x18) >> 3
}
func (o *MCAN_Type) SetPSR_EP(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetPSR_EP() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetPSR_EW(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetPSR_EW() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetPSR_BO(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetPSR_BO() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetPSR_FLEC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x700)|value<<8)
}
func (o *MCAN_Type) GetPSR_FLEC() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x700) >> 8
}
func (o *MCAN_Type) SetPSR_RESI(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetPSR_RESI() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetPSR_RBRS(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetPSR_RBRS() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetPSR_REDL(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetPSR_REDL() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000) >> 13
}

// MCAN.IR: Interrupt Register
func (o *MCAN_Type) SetIR_RF0N(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetIR_RF0N() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *MCAN_Type) SetIR_RF0W(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetIR_RF0W() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetIR_RF0F(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetIR_RF0F() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetIR_RF0L(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetIR_RF0L() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetIR_RF1N(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetIR_RF1N() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetIR_RF1W(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetIR_RF1W() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetIR_RF1F(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetIR_RF1F() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetIR_RF1L(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetIR_RF1L() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetIR_HPM(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetIR_HPM() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetIR_TC(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetIR_TC() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetIR_TCF(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetIR_TCF() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetIR_TFE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetIR_TFE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetIR_TEFN(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetIR_TEFN() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetIR_TEFW(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetIR_TEFW() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetIR_TEFF(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetIR_TEFF() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetIR_TEFL(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetIR_TEFL() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetIR_TSW(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetIR_TSW() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetIR_MRAF(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetIR_MRAF() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetIR_TOO(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetIR_TOO() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetIR_DRX(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetIR_DRX() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetIR_ELO(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetIR_ELO() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetIR_EP(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetIR_EP() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetIR_EW(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetIR_EW() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetIR_BO(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetIR_BO() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetIR_WDI(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetIR_WDI() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetIR_CRCE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetIR_CRCE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetIR_BE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetIR_BE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetIR_ACKE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetIR_ACKE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetIR_FOE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetIR_FOE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetIR_STE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetIR_STE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x80000000) >> 31
}

// MCAN.IE: Interrupt Enable Register
func (o *MCAN_Type) SetIE_RF0NE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetIE_RF0NE() uint32 {
	return volatile.LoadUint32(&o.IE.Reg) & 0x1
}
func (o *MCAN_Type) SetIE_RF0WE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetIE_RF0WE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetIE_RF0FE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetIE_RF0FE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetIE_RF0LE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetIE_RF0LE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetIE_RF1NE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetIE_RF1NE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetIE_RF1WE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetIE_RF1WE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetIE_RF1FE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetIE_RF1FE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetIE_RF1LE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetIE_RF1LE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetIE_HPME(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetIE_HPME() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetIE_TCE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetIE_TCE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetIE_TCFE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetIE_TCFE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetIE_TFEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetIE_TFEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetIE_TEFNE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetIE_TEFNE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetIE_TEFWE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetIE_TEFWE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetIE_TEFFE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetIE_TEFFE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetIE_TEFLE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetIE_TEFLE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetIE_TSWE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetIE_TSWE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetIE_MRAFE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetIE_MRAFE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetIE_TOOE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetIE_TOOE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetIE_DRXE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetIE_DRXE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetIE_ELOE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetIE_ELOE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetIE_EPE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetIE_EPE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetIE_EWE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetIE_EWE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetIE_BOE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetIE_BOE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetIE_WDIE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetIE_WDIE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetIE_CRCEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetIE_CRCEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetIE_BEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetIE_BEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetIE_ACKEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetIE_ACKEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetIE_FOEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetIE_FOEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetIE_STEE(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetIE_STEE() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80000000) >> 31
}

// MCAN.ILS: Interrupt Line Select Register
func (o *MCAN_Type) SetILS_RF0NL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetILS_RF0NL() uint32 {
	return volatile.LoadUint32(&o.ILS.Reg) & 0x1
}
func (o *MCAN_Type) SetILS_RF0WL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetILS_RF0WL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetILS_RF0FL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetILS_RF0FL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetILS_RF0LL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetILS_RF0LL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetILS_RF1NL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetILS_RF1NL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetILS_RF1WL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetILS_RF1WL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetILS_RF1FL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetILS_RF1FL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetILS_RF1LL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetILS_RF1LL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetILS_HPML(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetILS_HPML() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetILS_TCL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetILS_TCL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetILS_TCFL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetILS_TCFL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetILS_TFEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetILS_TFEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetILS_TEFNL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetILS_TEFNL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetILS_TEFWL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetILS_TEFWL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetILS_TEFFL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetILS_TEFFL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetILS_TEFLL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetILS_TEFLL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetILS_TSWL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetILS_TSWL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetILS_MRAFL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetILS_MRAFL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetILS_TOOL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetILS_TOOL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetILS_DRXL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetILS_DRXL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetILS_ELOL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetILS_ELOL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetILS_EPL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetILS_EPL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetILS_EWL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetILS_EWL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetILS_BOL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetILS_BOL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetILS_WDIL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetILS_WDIL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetILS_CRCEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetILS_CRCEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetILS_BEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetILS_BEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetILS_ACKEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetILS_ACKEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetILS_FOEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetILS_FOEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetILS_STEL(value uint32) {
	volatile.StoreUint32(&o.ILS.Reg, volatile.LoadUint32(&o.ILS.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetILS_STEL() uint32 {
	return (volatile.LoadUint32(&o.ILS.Reg) & 0x80000000) >> 31
}

// MCAN.ILE: Interrupt Line Enable Register
func (o *MCAN_Type) SetILE_EINT0(value uint32) {
	volatile.StoreUint32(&o.ILE.Reg, volatile.LoadUint32(&o.ILE.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetILE_EINT0() uint32 {
	return volatile.LoadUint32(&o.ILE.Reg) & 0x1
}
func (o *MCAN_Type) SetILE_EINT1(value uint32) {
	volatile.StoreUint32(&o.ILE.Reg, volatile.LoadUint32(&o.ILE.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetILE_EINT1() uint32 {
	return (volatile.LoadUint32(&o.ILE.Reg) & 0x2) >> 1
}

// MCAN.GFC: Global Filter Configuration Register
func (o *MCAN_Type) SetGFC_RRFE(value uint32) {
	volatile.StoreUint32(&o.GFC.Reg, volatile.LoadUint32(&o.GFC.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetGFC_RRFE() uint32 {
	return volatile.LoadUint32(&o.GFC.Reg) & 0x1
}
func (o *MCAN_Type) SetGFC_RRFS(value uint32) {
	volatile.StoreUint32(&o.GFC.Reg, volatile.LoadUint32(&o.GFC.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetGFC_RRFS() uint32 {
	return (volatile.LoadUint32(&o.GFC.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetGFC_ANFE(value uint32) {
	volatile.StoreUint32(&o.GFC.Reg, volatile.LoadUint32(&o.GFC.Reg)&^(0xc)|value<<2)
}
func (o *MCAN_Type) GetGFC_ANFE() uint32 {
	return (volatile.LoadUint32(&o.GFC.Reg) & 0xc) >> 2
}
func (o *MCAN_Type) SetGFC_ANFS(value uint32) {
	volatile.StoreUint32(&o.GFC.Reg, volatile.LoadUint32(&o.GFC.Reg)&^(0x30)|value<<4)
}
func (o *MCAN_Type) GetGFC_ANFS() uint32 {
	return (volatile.LoadUint32(&o.GFC.Reg) & 0x30) >> 4
}

// MCAN.SIDFC: Standard ID Filter Configuration Register
func (o *MCAN_Type) SetSIDFC_FLSSA(value uint32) {
	volatile.StoreUint32(&o.SIDFC.Reg, volatile.LoadUint32(&o.SIDFC.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetSIDFC_FLSSA() uint32 {
	return (volatile.LoadUint32(&o.SIDFC.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetSIDFC_LSS(value uint32) {
	volatile.StoreUint32(&o.SIDFC.Reg, volatile.LoadUint32(&o.SIDFC.Reg)&^(0xff0000)|value<<16)
}
func (o *MCAN_Type) GetSIDFC_LSS() uint32 {
	return (volatile.LoadUint32(&o.SIDFC.Reg) & 0xff0000) >> 16
}

// MCAN.XIDFC: Extended ID Filter Configuration Register
func (o *MCAN_Type) SetXIDFC_FLESA(value uint32) {
	volatile.StoreUint32(&o.XIDFC.Reg, volatile.LoadUint32(&o.XIDFC.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetXIDFC_FLESA() uint32 {
	return (volatile.LoadUint32(&o.XIDFC.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetXIDFC_LSE(value uint32) {
	volatile.StoreUint32(&o.XIDFC.Reg, volatile.LoadUint32(&o.XIDFC.Reg)&^(0x7f0000)|value<<16)
}
func (o *MCAN_Type) GetXIDFC_LSE() uint32 {
	return (volatile.LoadUint32(&o.XIDFC.Reg) & 0x7f0000) >> 16
}

// MCAN.XIDAM: Extended ID AND Mask Register
func (o *MCAN_Type) SetXIDAM_EIDM(value uint32) {
	volatile.StoreUint32(&o.XIDAM.Reg, volatile.LoadUint32(&o.XIDAM.Reg)&^(0x1fffffff)|value)
}
func (o *MCAN_Type) GetXIDAM_EIDM() uint32 {
	return volatile.LoadUint32(&o.XIDAM.Reg) & 0x1fffffff
}

// MCAN.HPMS: High Priority Message Status Register
func (o *MCAN_Type) SetHPMS_BIDX(value uint32) {
	volatile.StoreUint32(&o.HPMS.Reg, volatile.LoadUint32(&o.HPMS.Reg)&^(0x3f)|value)
}
func (o *MCAN_Type) GetHPMS_BIDX() uint32 {
	return volatile.LoadUint32(&o.HPMS.Reg) & 0x3f
}
func (o *MCAN_Type) SetHPMS_MSI(value uint32) {
	volatile.StoreUint32(&o.HPMS.Reg, volatile.LoadUint32(&o.HPMS.Reg)&^(0xc0)|value<<6)
}
func (o *MCAN_Type) GetHPMS_MSI() uint32 {
	return (volatile.LoadUint32(&o.HPMS.Reg) & 0xc0) >> 6
}
func (o *MCAN_Type) SetHPMS_FIDX(value uint32) {
	volatile.StoreUint32(&o.HPMS.Reg, volatile.LoadUint32(&o.HPMS.Reg)&^(0x7f00)|value<<8)
}
func (o *MCAN_Type) GetHPMS_FIDX() uint32 {
	return (volatile.LoadUint32(&o.HPMS.Reg) & 0x7f00) >> 8
}
func (o *MCAN_Type) SetHPMS_FLST(value uint32) {
	volatile.StoreUint32(&o.HPMS.Reg, volatile.LoadUint32(&o.HPMS.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetHPMS_FLST() uint32 {
	return (volatile.LoadUint32(&o.HPMS.Reg) & 0x8000) >> 15
}

// MCAN.NDAT1: New Data 1 Register
func (o *MCAN_Type) SetNDAT1_ND0(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetNDAT1_ND0() uint32 {
	return volatile.LoadUint32(&o.NDAT1.Reg) & 0x1
}
func (o *MCAN_Type) SetNDAT1_ND1(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetNDAT1_ND1() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetNDAT1_ND2(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetNDAT1_ND2() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetNDAT1_ND3(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetNDAT1_ND3() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetNDAT1_ND4(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetNDAT1_ND4() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetNDAT1_ND5(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetNDAT1_ND5() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetNDAT1_ND6(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetNDAT1_ND6() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetNDAT1_ND7(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetNDAT1_ND7() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetNDAT1_ND8(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetNDAT1_ND8() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetNDAT1_ND9(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetNDAT1_ND9() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetNDAT1_ND10(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetNDAT1_ND10() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetNDAT1_ND11(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetNDAT1_ND11() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetNDAT1_ND12(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetNDAT1_ND12() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetNDAT1_ND13(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetNDAT1_ND13() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetNDAT1_ND14(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetNDAT1_ND14() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetNDAT1_ND15(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetNDAT1_ND15() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetNDAT1_ND16(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetNDAT1_ND16() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetNDAT1_ND17(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetNDAT1_ND17() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetNDAT1_ND18(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetNDAT1_ND18() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetNDAT1_ND19(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetNDAT1_ND19() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetNDAT1_ND20(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetNDAT1_ND20() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetNDAT1_ND21(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetNDAT1_ND21() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetNDAT1_ND22(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetNDAT1_ND22() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetNDAT1_ND23(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetNDAT1_ND23() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetNDAT1_ND24(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetNDAT1_ND24() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetNDAT1_ND25(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetNDAT1_ND25() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetNDAT1_ND26(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetNDAT1_ND26() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetNDAT1_ND27(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetNDAT1_ND27() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetNDAT1_ND28(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetNDAT1_ND28() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetNDAT1_ND29(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetNDAT1_ND29() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetNDAT1_ND30(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetNDAT1_ND30() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetNDAT1_ND31(value uint32) {
	volatile.StoreUint32(&o.NDAT1.Reg, volatile.LoadUint32(&o.NDAT1.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetNDAT1_ND31() uint32 {
	return (volatile.LoadUint32(&o.NDAT1.Reg) & 0x80000000) >> 31
}

// MCAN.NDAT2: New Data 2 Register
func (o *MCAN_Type) SetNDAT2_ND32(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetNDAT2_ND32() uint32 {
	return volatile.LoadUint32(&o.NDAT2.Reg) & 0x1
}
func (o *MCAN_Type) SetNDAT2_ND33(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetNDAT2_ND33() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetNDAT2_ND34(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetNDAT2_ND34() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetNDAT2_ND35(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetNDAT2_ND35() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetNDAT2_ND36(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetNDAT2_ND36() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetNDAT2_ND37(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetNDAT2_ND37() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetNDAT2_ND38(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetNDAT2_ND38() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetNDAT2_ND39(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetNDAT2_ND39() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetNDAT2_ND40(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetNDAT2_ND40() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetNDAT2_ND41(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetNDAT2_ND41() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetNDAT2_ND42(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetNDAT2_ND42() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetNDAT2_ND43(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetNDAT2_ND43() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetNDAT2_ND44(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetNDAT2_ND44() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetNDAT2_ND45(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetNDAT2_ND45() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetNDAT2_ND46(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetNDAT2_ND46() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetNDAT2_ND47(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetNDAT2_ND47() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetNDAT2_ND48(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetNDAT2_ND48() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetNDAT2_ND49(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetNDAT2_ND49() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetNDAT2_ND50(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetNDAT2_ND50() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetNDAT2_ND51(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetNDAT2_ND51() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetNDAT2_ND52(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetNDAT2_ND52() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetNDAT2_ND53(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetNDAT2_ND53() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetNDAT2_ND54(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetNDAT2_ND54() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetNDAT2_ND55(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetNDAT2_ND55() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetNDAT2_ND56(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetNDAT2_ND56() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetNDAT2_ND57(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetNDAT2_ND57() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetNDAT2_ND58(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetNDAT2_ND58() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetNDAT2_ND59(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetNDAT2_ND59() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetNDAT2_ND60(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetNDAT2_ND60() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetNDAT2_ND61(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetNDAT2_ND61() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetNDAT2_ND62(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetNDAT2_ND62() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetNDAT2_ND63(value uint32) {
	volatile.StoreUint32(&o.NDAT2.Reg, volatile.LoadUint32(&o.NDAT2.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetNDAT2_ND63() uint32 {
	return (volatile.LoadUint32(&o.NDAT2.Reg) & 0x80000000) >> 31
}

// MCAN.RXF0C: Receive FIFO 0 Configuration Register
func (o *MCAN_Type) SetRXF0C_F0SA(value uint32) {
	volatile.StoreUint32(&o.RXF0C.Reg, volatile.LoadUint32(&o.RXF0C.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetRXF0C_F0SA() uint32 {
	return (volatile.LoadUint32(&o.RXF0C.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetRXF0C_F0S(value uint32) {
	volatile.StoreUint32(&o.RXF0C.Reg, volatile.LoadUint32(&o.RXF0C.Reg)&^(0x7f0000)|value<<16)
}
func (o *MCAN_Type) GetRXF0C_F0S() uint32 {
	return (volatile.LoadUint32(&o.RXF0C.Reg) & 0x7f0000) >> 16
}
func (o *MCAN_Type) SetRXF0C_F0WM(value uint32) {
	volatile.StoreUint32(&o.RXF0C.Reg, volatile.LoadUint32(&o.RXF0C.Reg)&^(0x7f000000)|value<<24)
}
func (o *MCAN_Type) GetRXF0C_F0WM() uint32 {
	return (volatile.LoadUint32(&o.RXF0C.Reg) & 0x7f000000) >> 24
}
func (o *MCAN_Type) SetRXF0C_F0OM(value uint32) {
	volatile.StoreUint32(&o.RXF0C.Reg, volatile.LoadUint32(&o.RXF0C.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetRXF0C_F0OM() uint32 {
	return (volatile.LoadUint32(&o.RXF0C.Reg) & 0x80000000) >> 31
}

// MCAN.RXF0S: Receive FIFO 0 Status Register
func (o *MCAN_Type) SetRXF0S_F0FL(value uint32) {
	volatile.StoreUint32(&o.RXF0S.Reg, volatile.LoadUint32(&o.RXF0S.Reg)&^(0x7f)|value)
}
func (o *MCAN_Type) GetRXF0S_F0FL() uint32 {
	return volatile.LoadUint32(&o.RXF0S.Reg) & 0x7f
}
func (o *MCAN_Type) SetRXF0S_F0GI(value uint32) {
	volatile.StoreUint32(&o.RXF0S.Reg, volatile.LoadUint32(&o.RXF0S.Reg)&^(0x3f00)|value<<8)
}
func (o *MCAN_Type) GetRXF0S_F0GI() uint32 {
	return (volatile.LoadUint32(&o.RXF0S.Reg) & 0x3f00) >> 8
}
func (o *MCAN_Type) SetRXF0S_F0PI(value uint32) {
	volatile.StoreUint32(&o.RXF0S.Reg, volatile.LoadUint32(&o.RXF0S.Reg)&^(0x3f0000)|value<<16)
}
func (o *MCAN_Type) GetRXF0S_F0PI() uint32 {
	return (volatile.LoadUint32(&o.RXF0S.Reg) & 0x3f0000) >> 16
}
func (o *MCAN_Type) SetRXF0S_F0F(value uint32) {
	volatile.StoreUint32(&o.RXF0S.Reg, volatile.LoadUint32(&o.RXF0S.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetRXF0S_F0F() uint32 {
	return (volatile.LoadUint32(&o.RXF0S.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetRXF0S_RF0L(value uint32) {
	volatile.StoreUint32(&o.RXF0S.Reg, volatile.LoadUint32(&o.RXF0S.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetRXF0S_RF0L() uint32 {
	return (volatile.LoadUint32(&o.RXF0S.Reg) & 0x2000000) >> 25
}

// MCAN.RXF0A: Receive FIFO 0 Acknowledge Register
func (o *MCAN_Type) SetRXF0A_F0AI(value uint32) {
	volatile.StoreUint32(&o.RXF0A.Reg, volatile.LoadUint32(&o.RXF0A.Reg)&^(0x3f)|value)
}
func (o *MCAN_Type) GetRXF0A_F0AI() uint32 {
	return volatile.LoadUint32(&o.RXF0A.Reg) & 0x3f
}

// MCAN.RXBC: Receive Rx Buffer Configuration Register
func (o *MCAN_Type) SetRXBC_RBSA(value uint32) {
	volatile.StoreUint32(&o.RXBC.Reg, volatile.LoadUint32(&o.RXBC.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetRXBC_RBSA() uint32 {
	return (volatile.LoadUint32(&o.RXBC.Reg) & 0xfffc) >> 2
}

// MCAN.RXF1C: Receive FIFO 1 Configuration Register
func (o *MCAN_Type) SetRXF1C_F1SA(value uint32) {
	volatile.StoreUint32(&o.RXF1C.Reg, volatile.LoadUint32(&o.RXF1C.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetRXF1C_F1SA() uint32 {
	return (volatile.LoadUint32(&o.RXF1C.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetRXF1C_F1S(value uint32) {
	volatile.StoreUint32(&o.RXF1C.Reg, volatile.LoadUint32(&o.RXF1C.Reg)&^(0x7f0000)|value<<16)
}
func (o *MCAN_Type) GetRXF1C_F1S() uint32 {
	return (volatile.LoadUint32(&o.RXF1C.Reg) & 0x7f0000) >> 16
}
func (o *MCAN_Type) SetRXF1C_F1WM(value uint32) {
	volatile.StoreUint32(&o.RXF1C.Reg, volatile.LoadUint32(&o.RXF1C.Reg)&^(0x7f000000)|value<<24)
}
func (o *MCAN_Type) GetRXF1C_F1WM() uint32 {
	return (volatile.LoadUint32(&o.RXF1C.Reg) & 0x7f000000) >> 24
}
func (o *MCAN_Type) SetRXF1C_F1OM(value uint32) {
	volatile.StoreUint32(&o.RXF1C.Reg, volatile.LoadUint32(&o.RXF1C.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetRXF1C_F1OM() uint32 {
	return (volatile.LoadUint32(&o.RXF1C.Reg) & 0x80000000) >> 31
}

// MCAN.RXF1S: Receive FIFO 1 Status Register
func (o *MCAN_Type) SetRXF1S_F1FL(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0x7f)|value)
}
func (o *MCAN_Type) GetRXF1S_F1FL() uint32 {
	return volatile.LoadUint32(&o.RXF1S.Reg) & 0x7f
}
func (o *MCAN_Type) SetRXF1S_F1GI(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0x3f00)|value<<8)
}
func (o *MCAN_Type) GetRXF1S_F1GI() uint32 {
	return (volatile.LoadUint32(&o.RXF1S.Reg) & 0x3f00) >> 8
}
func (o *MCAN_Type) SetRXF1S_F1PI(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0x3f0000)|value<<16)
}
func (o *MCAN_Type) GetRXF1S_F1PI() uint32 {
	return (volatile.LoadUint32(&o.RXF1S.Reg) & 0x3f0000) >> 16
}
func (o *MCAN_Type) SetRXF1S_F1F(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetRXF1S_F1F() uint32 {
	return (volatile.LoadUint32(&o.RXF1S.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetRXF1S_RF1L(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetRXF1S_RF1L() uint32 {
	return (volatile.LoadUint32(&o.RXF1S.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetRXF1S_DMS(value uint32) {
	volatile.StoreUint32(&o.RXF1S.Reg, volatile.LoadUint32(&o.RXF1S.Reg)&^(0xc0000000)|value<<30)
}
func (o *MCAN_Type) GetRXF1S_DMS() uint32 {
	return (volatile.LoadUint32(&o.RXF1S.Reg) & 0xc0000000) >> 30
}

// MCAN.RXF1A: Receive FIFO 1 Acknowledge Register
func (o *MCAN_Type) SetRXF1A_F1AI(value uint32) {
	volatile.StoreUint32(&o.RXF1A.Reg, volatile.LoadUint32(&o.RXF1A.Reg)&^(0x3f)|value)
}
func (o *MCAN_Type) GetRXF1A_F1AI() uint32 {
	return volatile.LoadUint32(&o.RXF1A.Reg) & 0x3f
}

// MCAN.RXESC: Receive Buffer / FIFO Element Size Configuration Register
func (o *MCAN_Type) SetRXESC_F0DS(value uint32) {
	volatile.StoreUint32(&o.RXESC.Reg, volatile.LoadUint32(&o.RXESC.Reg)&^(0x7)|value)
}
func (o *MCAN_Type) GetRXESC_F0DS() uint32 {
	return volatile.LoadUint32(&o.RXESC.Reg) & 0x7
}
func (o *MCAN_Type) SetRXESC_F1DS(value uint32) {
	volatile.StoreUint32(&o.RXESC.Reg, volatile.LoadUint32(&o.RXESC.Reg)&^(0x70)|value<<4)
}
func (o *MCAN_Type) GetRXESC_F1DS() uint32 {
	return (volatile.LoadUint32(&o.RXESC.Reg) & 0x70) >> 4
}
func (o *MCAN_Type) SetRXESC_RBDS(value uint32) {
	volatile.StoreUint32(&o.RXESC.Reg, volatile.LoadUint32(&o.RXESC.Reg)&^(0x700)|value<<8)
}
func (o *MCAN_Type) GetRXESC_RBDS() uint32 {
	return (volatile.LoadUint32(&o.RXESC.Reg) & 0x700) >> 8
}

// MCAN.TXBC: Transmit Buffer Configuration Register
func (o *MCAN_Type) SetTXBC_TBSA(value uint32) {
	volatile.StoreUint32(&o.TXBC.Reg, volatile.LoadUint32(&o.TXBC.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetTXBC_TBSA() uint32 {
	return (volatile.LoadUint32(&o.TXBC.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetTXBC_NDTB(value uint32) {
	volatile.StoreUint32(&o.TXBC.Reg, volatile.LoadUint32(&o.TXBC.Reg)&^(0x3f0000)|value<<16)
}
func (o *MCAN_Type) GetTXBC_NDTB() uint32 {
	return (volatile.LoadUint32(&o.TXBC.Reg) & 0x3f0000) >> 16
}
func (o *MCAN_Type) SetTXBC_TFQS(value uint32) {
	volatile.StoreUint32(&o.TXBC.Reg, volatile.LoadUint32(&o.TXBC.Reg)&^(0x3f000000)|value<<24)
}
func (o *MCAN_Type) GetTXBC_TFQS() uint32 {
	return (volatile.LoadUint32(&o.TXBC.Reg) & 0x3f000000) >> 24
}
func (o *MCAN_Type) SetTXBC_TFQM(value uint32) {
	volatile.StoreUint32(&o.TXBC.Reg, volatile.LoadUint32(&o.TXBC.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBC_TFQM() uint32 {
	return (volatile.LoadUint32(&o.TXBC.Reg) & 0x40000000) >> 30
}

// MCAN.TXFQS: Transmit FIFO/Queue Status Register
func (o *MCAN_Type) SetTXFQS_TFFL(value uint32) {
	volatile.StoreUint32(&o.TXFQS.Reg, volatile.LoadUint32(&o.TXFQS.Reg)&^(0x3f)|value)
}
func (o *MCAN_Type) GetTXFQS_TFFL() uint32 {
	return volatile.LoadUint32(&o.TXFQS.Reg) & 0x3f
}
func (o *MCAN_Type) SetTXFQS_TFGI(value uint32) {
	volatile.StoreUint32(&o.TXFQS.Reg, volatile.LoadUint32(&o.TXFQS.Reg)&^(0x1f00)|value<<8)
}
func (o *MCAN_Type) GetTXFQS_TFGI() uint32 {
	return (volatile.LoadUint32(&o.TXFQS.Reg) & 0x1f00) >> 8
}
func (o *MCAN_Type) SetTXFQS_TFQPI(value uint32) {
	volatile.StoreUint32(&o.TXFQS.Reg, volatile.LoadUint32(&o.TXFQS.Reg)&^(0x1f0000)|value<<16)
}
func (o *MCAN_Type) GetTXFQS_TFQPI() uint32 {
	return (volatile.LoadUint32(&o.TXFQS.Reg) & 0x1f0000) >> 16
}
func (o *MCAN_Type) SetTXFQS_TFQF(value uint32) {
	volatile.StoreUint32(&o.TXFQS.Reg, volatile.LoadUint32(&o.TXFQS.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXFQS_TFQF() uint32 {
	return (volatile.LoadUint32(&o.TXFQS.Reg) & 0x200000) >> 21
}

// MCAN.TXESC: Transmit Buffer Element Size Configuration Register
func (o *MCAN_Type) SetTXESC_TBDS(value uint32) {
	volatile.StoreUint32(&o.TXESC.Reg, volatile.LoadUint32(&o.TXESC.Reg)&^(0x7)|value)
}
func (o *MCAN_Type) GetTXESC_TBDS() uint32 {
	return volatile.LoadUint32(&o.TXESC.Reg) & 0x7
}

// MCAN.TXBRP: Transmit Buffer Request Pending Register
func (o *MCAN_Type) SetTXBRP_TRP0(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBRP_TRP0() uint32 {
	return volatile.LoadUint32(&o.TXBRP.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBRP_TRP1(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBRP_TRP1() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBRP_TRP2(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBRP_TRP2() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBRP_TRP3(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBRP_TRP3() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBRP_TRP4(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBRP_TRP4() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBRP_TRP5(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBRP_TRP5() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBRP_TRP6(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBRP_TRP6() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBRP_TRP7(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBRP_TRP7() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBRP_TRP8(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBRP_TRP8() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBRP_TRP9(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBRP_TRP9() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBRP_TRP10(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBRP_TRP10() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBRP_TRP11(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBRP_TRP11() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBRP_TRP12(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBRP_TRP12() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBRP_TRP13(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBRP_TRP13() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBRP_TRP14(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBRP_TRP14() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBRP_TRP15(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBRP_TRP15() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBRP_TRP16(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBRP_TRP16() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBRP_TRP17(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBRP_TRP17() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBRP_TRP18(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBRP_TRP18() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBRP_TRP19(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBRP_TRP19() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBRP_TRP20(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBRP_TRP20() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBRP_TRP21(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBRP_TRP21() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBRP_TRP22(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBRP_TRP22() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBRP_TRP23(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBRP_TRP23() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBRP_TRP24(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBRP_TRP24() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBRP_TRP25(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBRP_TRP25() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBRP_TRP26(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBRP_TRP26() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBRP_TRP27(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBRP_TRP27() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBRP_TRP28(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBRP_TRP28() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBRP_TRP29(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBRP_TRP29() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBRP_TRP30(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBRP_TRP30() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBRP_TRP31(value uint32) {
	volatile.StoreUint32(&o.TXBRP.Reg, volatile.LoadUint32(&o.TXBRP.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBRP_TRP31() uint32 {
	return (volatile.LoadUint32(&o.TXBRP.Reg) & 0x80000000) >> 31
}

// MCAN.TXBAR: Transmit Buffer Add Request Register
func (o *MCAN_Type) SetTXBAR_AR0(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBAR_AR0() uint32 {
	return volatile.LoadUint32(&o.TXBAR.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBAR_AR1(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBAR_AR1() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBAR_AR2(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBAR_AR2() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBAR_AR3(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBAR_AR3() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBAR_AR4(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBAR_AR4() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBAR_AR5(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBAR_AR5() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBAR_AR6(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBAR_AR6() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBAR_AR7(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBAR_AR7() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBAR_AR8(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBAR_AR8() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBAR_AR9(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBAR_AR9() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBAR_AR10(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBAR_AR10() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBAR_AR11(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBAR_AR11() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBAR_AR12(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBAR_AR12() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBAR_AR13(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBAR_AR13() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBAR_AR14(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBAR_AR14() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBAR_AR15(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBAR_AR15() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBAR_AR16(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBAR_AR16() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBAR_AR17(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBAR_AR17() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBAR_AR18(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBAR_AR18() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBAR_AR19(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBAR_AR19() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBAR_AR20(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBAR_AR20() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBAR_AR21(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBAR_AR21() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBAR_AR22(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBAR_AR22() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBAR_AR23(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBAR_AR23() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBAR_AR24(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBAR_AR24() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBAR_AR25(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBAR_AR25() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBAR_AR26(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBAR_AR26() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBAR_AR27(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBAR_AR27() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBAR_AR28(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBAR_AR28() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBAR_AR29(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBAR_AR29() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBAR_AR30(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBAR_AR30() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBAR_AR31(value uint32) {
	volatile.StoreUint32(&o.TXBAR.Reg, volatile.LoadUint32(&o.TXBAR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBAR_AR31() uint32 {
	return (volatile.LoadUint32(&o.TXBAR.Reg) & 0x80000000) >> 31
}

// MCAN.TXBCR: Transmit Buffer Cancellation Request Register
func (o *MCAN_Type) SetTXBCR_CR0(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBCR_CR0() uint32 {
	return volatile.LoadUint32(&o.TXBCR.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBCR_CR1(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBCR_CR1() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBCR_CR2(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBCR_CR2() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBCR_CR3(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBCR_CR3() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBCR_CR4(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBCR_CR4() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBCR_CR5(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBCR_CR5() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBCR_CR6(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBCR_CR6() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBCR_CR7(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBCR_CR7() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBCR_CR8(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBCR_CR8() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBCR_CR9(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBCR_CR9() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBCR_CR10(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBCR_CR10() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBCR_CR11(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBCR_CR11() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBCR_CR12(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBCR_CR12() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBCR_CR13(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBCR_CR13() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBCR_CR14(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBCR_CR14() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBCR_CR15(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBCR_CR15() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBCR_CR16(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBCR_CR16() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBCR_CR17(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBCR_CR17() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBCR_CR18(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBCR_CR18() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBCR_CR19(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBCR_CR19() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBCR_CR20(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBCR_CR20() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBCR_CR21(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBCR_CR21() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBCR_CR22(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBCR_CR22() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBCR_CR23(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBCR_CR23() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBCR_CR24(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBCR_CR24() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBCR_CR25(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBCR_CR25() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBCR_CR26(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBCR_CR26() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBCR_CR27(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBCR_CR27() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBCR_CR28(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBCR_CR28() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBCR_CR29(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBCR_CR29() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBCR_CR30(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBCR_CR30() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBCR_CR31(value uint32) {
	volatile.StoreUint32(&o.TXBCR.Reg, volatile.LoadUint32(&o.TXBCR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBCR_CR31() uint32 {
	return (volatile.LoadUint32(&o.TXBCR.Reg) & 0x80000000) >> 31
}

// MCAN.TXBTO: Transmit Buffer Transmission Occurred Register
func (o *MCAN_Type) SetTXBTO_TO0(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBTO_TO0() uint32 {
	return volatile.LoadUint32(&o.TXBTO.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBTO_TO1(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBTO_TO1() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBTO_TO2(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBTO_TO2() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBTO_TO3(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBTO_TO3() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBTO_TO4(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBTO_TO4() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBTO_TO5(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBTO_TO5() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBTO_TO6(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBTO_TO6() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBTO_TO7(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBTO_TO7() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBTO_TO8(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBTO_TO8() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBTO_TO9(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBTO_TO9() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBTO_TO10(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBTO_TO10() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBTO_TO11(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBTO_TO11() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBTO_TO12(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBTO_TO12() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBTO_TO13(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBTO_TO13() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBTO_TO14(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBTO_TO14() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBTO_TO15(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBTO_TO15() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBTO_TO16(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBTO_TO16() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBTO_TO17(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBTO_TO17() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBTO_TO18(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBTO_TO18() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBTO_TO19(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBTO_TO19() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBTO_TO20(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBTO_TO20() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBTO_TO21(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBTO_TO21() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBTO_TO22(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBTO_TO22() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBTO_TO23(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBTO_TO23() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBTO_TO24(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBTO_TO24() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBTO_TO25(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBTO_TO25() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBTO_TO26(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBTO_TO26() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBTO_TO27(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBTO_TO27() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBTO_TO28(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBTO_TO28() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBTO_TO29(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBTO_TO29() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBTO_TO30(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBTO_TO30() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBTO_TO31(value uint32) {
	volatile.StoreUint32(&o.TXBTO.Reg, volatile.LoadUint32(&o.TXBTO.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBTO_TO31() uint32 {
	return (volatile.LoadUint32(&o.TXBTO.Reg) & 0x80000000) >> 31
}

// MCAN.TXBCF: Transmit Buffer Cancellation Finished Register
func (o *MCAN_Type) SetTXBCF_CF0(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBCF_CF0() uint32 {
	return volatile.LoadUint32(&o.TXBCF.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBCF_CF1(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBCF_CF1() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBCF_CF2(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBCF_CF2() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBCF_CF3(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBCF_CF3() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBCF_CF4(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBCF_CF4() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBCF_CF5(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBCF_CF5() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBCF_CF6(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBCF_CF6() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBCF_CF7(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBCF_CF7() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBCF_CF8(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBCF_CF8() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBCF_CF9(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBCF_CF9() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBCF_CF10(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBCF_CF10() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBCF_CF11(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBCF_CF11() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBCF_CF12(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBCF_CF12() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBCF_CF13(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBCF_CF13() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBCF_CF14(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBCF_CF14() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBCF_CF15(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBCF_CF15() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBCF_CF16(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBCF_CF16() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBCF_CF17(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBCF_CF17() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBCF_CF18(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBCF_CF18() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBCF_CF19(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBCF_CF19() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBCF_CF20(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBCF_CF20() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBCF_CF21(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBCF_CF21() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBCF_CF22(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBCF_CF22() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBCF_CF23(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBCF_CF23() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBCF_CF24(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBCF_CF24() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBCF_CF25(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBCF_CF25() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBCF_CF26(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBCF_CF26() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBCF_CF27(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBCF_CF27() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBCF_CF28(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBCF_CF28() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBCF_CF29(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBCF_CF29() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBCF_CF30(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBCF_CF30() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBCF_CF31(value uint32) {
	volatile.StoreUint32(&o.TXBCF.Reg, volatile.LoadUint32(&o.TXBCF.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBCF_CF31() uint32 {
	return (volatile.LoadUint32(&o.TXBCF.Reg) & 0x80000000) >> 31
}

// MCAN.TXBTIE: Transmit Buffer Transmission Interrupt Enable Register
func (o *MCAN_Type) SetTXBTIE_TIE0(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBTIE_TIE0() uint32 {
	return volatile.LoadUint32(&o.TXBTIE.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBTIE_TIE1(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBTIE_TIE1() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBTIE_TIE2(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBTIE_TIE2() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBTIE_TIE3(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBTIE_TIE3() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBTIE_TIE4(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBTIE_TIE4() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBTIE_TIE5(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBTIE_TIE5() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBTIE_TIE6(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBTIE_TIE6() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBTIE_TIE7(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBTIE_TIE7() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBTIE_TIE8(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBTIE_TIE8() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBTIE_TIE9(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBTIE_TIE9() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBTIE_TIE10(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBTIE_TIE10() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBTIE_TIE11(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBTIE_TIE11() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBTIE_TIE12(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBTIE_TIE12() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBTIE_TIE13(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBTIE_TIE13() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBTIE_TIE14(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBTIE_TIE14() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBTIE_TIE15(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBTIE_TIE15() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBTIE_TIE16(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBTIE_TIE16() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBTIE_TIE17(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBTIE_TIE17() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBTIE_TIE18(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBTIE_TIE18() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBTIE_TIE19(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBTIE_TIE19() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBTIE_TIE20(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBTIE_TIE20() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBTIE_TIE21(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBTIE_TIE21() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBTIE_TIE22(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBTIE_TIE22() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBTIE_TIE23(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBTIE_TIE23() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBTIE_TIE24(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBTIE_TIE24() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBTIE_TIE25(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBTIE_TIE25() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBTIE_TIE26(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBTIE_TIE26() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBTIE_TIE27(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBTIE_TIE27() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBTIE_TIE28(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBTIE_TIE28() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBTIE_TIE29(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBTIE_TIE29() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBTIE_TIE30(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBTIE_TIE30() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBTIE_TIE31(value uint32) {
	volatile.StoreUint32(&o.TXBTIE.Reg, volatile.LoadUint32(&o.TXBTIE.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBTIE_TIE31() uint32 {
	return (volatile.LoadUint32(&o.TXBTIE.Reg) & 0x80000000) >> 31
}

// MCAN.TXBCIE: Transmit Buffer Cancellation Finished Interrupt Enable Register
func (o *MCAN_Type) SetTXBCIE_CFIE0(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x1)|value)
}
func (o *MCAN_Type) GetTXBCIE_CFIE0() uint32 {
	return volatile.LoadUint32(&o.TXBCIE.Reg) & 0x1
}
func (o *MCAN_Type) SetTXBCIE_CFIE1(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x2)|value<<1)
}
func (o *MCAN_Type) GetTXBCIE_CFIE1() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x2) >> 1
}
func (o *MCAN_Type) SetTXBCIE_CFIE2(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x4)|value<<2)
}
func (o *MCAN_Type) GetTXBCIE_CFIE2() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x4) >> 2
}
func (o *MCAN_Type) SetTXBCIE_CFIE3(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x8)|value<<3)
}
func (o *MCAN_Type) GetTXBCIE_CFIE3() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x8) >> 3
}
func (o *MCAN_Type) SetTXBCIE_CFIE4(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x10)|value<<4)
}
func (o *MCAN_Type) GetTXBCIE_CFIE4() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x10) >> 4
}
func (o *MCAN_Type) SetTXBCIE_CFIE5(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x20)|value<<5)
}
func (o *MCAN_Type) GetTXBCIE_CFIE5() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x20) >> 5
}
func (o *MCAN_Type) SetTXBCIE_CFIE6(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x40)|value<<6)
}
func (o *MCAN_Type) GetTXBCIE_CFIE6() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x40) >> 6
}
func (o *MCAN_Type) SetTXBCIE_CFIE7(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x80)|value<<7)
}
func (o *MCAN_Type) GetTXBCIE_CFIE7() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x80) >> 7
}
func (o *MCAN_Type) SetTXBCIE_CFIE8(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x100)|value<<8)
}
func (o *MCAN_Type) GetTXBCIE_CFIE8() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x100) >> 8
}
func (o *MCAN_Type) SetTXBCIE_CFIE9(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x200)|value<<9)
}
func (o *MCAN_Type) GetTXBCIE_CFIE9() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x200) >> 9
}
func (o *MCAN_Type) SetTXBCIE_CFIE10(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x400)|value<<10)
}
func (o *MCAN_Type) GetTXBCIE_CFIE10() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x400) >> 10
}
func (o *MCAN_Type) SetTXBCIE_CFIE11(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x800)|value<<11)
}
func (o *MCAN_Type) GetTXBCIE_CFIE11() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x800) >> 11
}
func (o *MCAN_Type) SetTXBCIE_CFIE12(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x1000)|value<<12)
}
func (o *MCAN_Type) GetTXBCIE_CFIE12() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x1000) >> 12
}
func (o *MCAN_Type) SetTXBCIE_CFIE13(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x2000)|value<<13)
}
func (o *MCAN_Type) GetTXBCIE_CFIE13() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x2000) >> 13
}
func (o *MCAN_Type) SetTXBCIE_CFIE14(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x4000)|value<<14)
}
func (o *MCAN_Type) GetTXBCIE_CFIE14() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x4000) >> 14
}
func (o *MCAN_Type) SetTXBCIE_CFIE15(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x8000)|value<<15)
}
func (o *MCAN_Type) GetTXBCIE_CFIE15() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x8000) >> 15
}
func (o *MCAN_Type) SetTXBCIE_CFIE16(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x10000)|value<<16)
}
func (o *MCAN_Type) GetTXBCIE_CFIE16() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x10000) >> 16
}
func (o *MCAN_Type) SetTXBCIE_CFIE17(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x20000)|value<<17)
}
func (o *MCAN_Type) GetTXBCIE_CFIE17() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x20000) >> 17
}
func (o *MCAN_Type) SetTXBCIE_CFIE18(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x40000)|value<<18)
}
func (o *MCAN_Type) GetTXBCIE_CFIE18() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x40000) >> 18
}
func (o *MCAN_Type) SetTXBCIE_CFIE19(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x80000)|value<<19)
}
func (o *MCAN_Type) GetTXBCIE_CFIE19() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x80000) >> 19
}
func (o *MCAN_Type) SetTXBCIE_CFIE20(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x100000)|value<<20)
}
func (o *MCAN_Type) GetTXBCIE_CFIE20() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x100000) >> 20
}
func (o *MCAN_Type) SetTXBCIE_CFIE21(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x200000)|value<<21)
}
func (o *MCAN_Type) GetTXBCIE_CFIE21() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x200000) >> 21
}
func (o *MCAN_Type) SetTXBCIE_CFIE22(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x400000)|value<<22)
}
func (o *MCAN_Type) GetTXBCIE_CFIE22() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x400000) >> 22
}
func (o *MCAN_Type) SetTXBCIE_CFIE23(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x800000)|value<<23)
}
func (o *MCAN_Type) GetTXBCIE_CFIE23() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x800000) >> 23
}
func (o *MCAN_Type) SetTXBCIE_CFIE24(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXBCIE_CFIE24() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXBCIE_CFIE25(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXBCIE_CFIE25() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x2000000) >> 25
}
func (o *MCAN_Type) SetTXBCIE_CFIE26(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x4000000)|value<<26)
}
func (o *MCAN_Type) GetTXBCIE_CFIE26() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x4000000) >> 26
}
func (o *MCAN_Type) SetTXBCIE_CFIE27(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x8000000)|value<<27)
}
func (o *MCAN_Type) GetTXBCIE_CFIE27() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x8000000) >> 27
}
func (o *MCAN_Type) SetTXBCIE_CFIE28(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x10000000)|value<<28)
}
func (o *MCAN_Type) GetTXBCIE_CFIE28() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x10000000) >> 28
}
func (o *MCAN_Type) SetTXBCIE_CFIE29(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x20000000)|value<<29)
}
func (o *MCAN_Type) GetTXBCIE_CFIE29() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x20000000) >> 29
}
func (o *MCAN_Type) SetTXBCIE_CFIE30(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x40000000)|value<<30)
}
func (o *MCAN_Type) GetTXBCIE_CFIE30() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x40000000) >> 30
}
func (o *MCAN_Type) SetTXBCIE_CFIE31(value uint32) {
	volatile.StoreUint32(&o.TXBCIE.Reg, volatile.LoadUint32(&o.TXBCIE.Reg)&^(0x80000000)|value<<31)
}
func (o *MCAN_Type) GetTXBCIE_CFIE31() uint32 {
	return (volatile.LoadUint32(&o.TXBCIE.Reg) & 0x80000000) >> 31
}

// MCAN.TXEFC: Transmit Event FIFO Configuration Register
func (o *MCAN_Type) SetTXEFC_EFSA(value uint32) {
	volatile.StoreUint32(&o.TXEFC.Reg, volatile.LoadUint32(&o.TXEFC.Reg)&^(0xfffc)|value<<2)
}
func (o *MCAN_Type) GetTXEFC_EFSA() uint32 {
	return (volatile.LoadUint32(&o.TXEFC.Reg) & 0xfffc) >> 2
}
func (o *MCAN_Type) SetTXEFC_EFS(value uint32) {
	volatile.StoreUint32(&o.TXEFC.Reg, volatile.LoadUint32(&o.TXEFC.Reg)&^(0x3f0000)|value<<16)
}
func (o *MCAN_Type) GetTXEFC_EFS() uint32 {
	return (volatile.LoadUint32(&o.TXEFC.Reg) & 0x3f0000) >> 16
}
func (o *MCAN_Type) SetTXEFC_EFWM(value uint32) {
	volatile.StoreUint32(&o.TXEFC.Reg, volatile.LoadUint32(&o.TXEFC.Reg)&^(0x3f000000)|value<<24)
}
func (o *MCAN_Type) GetTXEFC_EFWM() uint32 {
	return (volatile.LoadUint32(&o.TXEFC.Reg) & 0x3f000000) >> 24
}

// MCAN.TXEFS: Transmit Event FIFO Status Register
func (o *MCAN_Type) SetTXEFS_EFFL(value uint32) {
	volatile.StoreUint32(&o.TXEFS.Reg, volatile.LoadUint32(&o.TXEFS.Reg)&^(0x3f)|value)
}
func (o *MCAN_Type) GetTXEFS_EFFL() uint32 {
	return volatile.LoadUint32(&o.TXEFS.Reg) & 0x3f
}
func (o *MCAN_Type) SetTXEFS_EFGI(value uint32) {
	volatile.StoreUint32(&o.TXEFS.Reg, volatile.LoadUint32(&o.TXEFS.Reg)&^(0x1f00)|value<<8)
}
func (o *MCAN_Type) GetTXEFS_EFGI() uint32 {
	return (volatile.LoadUint32(&o.TXEFS.Reg) & 0x1f00) >> 8
}
func (o *MCAN_Type) SetTXEFS_EFPI(value uint32) {
	volatile.StoreUint32(&o.TXEFS.Reg, volatile.LoadUint32(&o.TXEFS.Reg)&^(0x1f0000)|value<<16)
}
func (o *MCAN_Type) GetTXEFS_EFPI() uint32 {
	return (volatile.LoadUint32(&o.TXEFS.Reg) & 0x1f0000) >> 16
}
func (o *MCAN_Type) SetTXEFS_EFF(value uint32) {
	volatile.StoreUint32(&o.TXEFS.Reg, volatile.LoadUint32(&o.TXEFS.Reg)&^(0x1000000)|value<<24)
}
func (o *MCAN_Type) GetTXEFS_EFF() uint32 {
	return (volatile.LoadUint32(&o.TXEFS.Reg) & 0x1000000) >> 24
}
func (o *MCAN_Type) SetTXEFS_TEFL(value uint32) {
	volatile.StoreUint32(&o.TXEFS.Reg, volatile.LoadUint32(&o.TXEFS.Reg)&^(0x2000000)|value<<25)
}
func (o *MCAN_Type) GetTXEFS_TEFL() uint32 {
	return (volatile.LoadUint32(&o.TXEFS.Reg) & 0x2000000) >> 25
}

// MCAN.TXEFA: Transmit Event FIFO Acknowledge Register
func (o *MCAN_Type) SetTXEFA_EFAI(value uint32) {
	volatile.StoreUint32(&o.TXEFA.Reg, volatile.LoadUint32(&o.TXEFA.Reg)&^(0x1f)|value)
}
func (o *MCAN_Type) GetTXEFA_EFAI() uint32 {
	return volatile.LoadUint32(&o.TXEFA.Reg) & 0x1f
}

// Parallel Input/Output Controller
type PIO_Type struct {
	PER     volatile.Register32 // 0x0
	PDR     volatile.Register32 // 0x4
	PSR     volatile.Register32 // 0x8
	_       [4]byte
	OER     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	OSR     volatile.Register32 // 0x18
	_       [4]byte
	IFER    volatile.Register32 // 0x20
	IFDR    volatile.Register32 // 0x24
	IFSR    volatile.Register32 // 0x28
	_       [4]byte
	SODR    volatile.Register32 // 0x30
	CODR    volatile.Register32 // 0x34
	ODSR    volatile.Register32 // 0x38
	PDSR    volatile.Register32 // 0x3C
	IER     volatile.Register32 // 0x40
	IDR     volatile.Register32 // 0x44
	IMR     volatile.Register32 // 0x48
	ISR     volatile.Register32 // 0x4C
	MDER    volatile.Register32 // 0x50
	MDDR    volatile.Register32 // 0x54
	MDSR    volatile.Register32 // 0x58
	_       [4]byte
	PUDR    volatile.Register32 // 0x60
	PUER    volatile.Register32 // 0x64
	PUSR    volatile.Register32 // 0x68
	_       [4]byte
	ABCDSR  [2]volatile.Register32 // 0x70
	_       [8]byte
	IFSCDR  volatile.Register32 // 0x80
	IFSCER  volatile.Register32 // 0x84
	IFSCSR  volatile.Register32 // 0x88
	SCDR    volatile.Register32 // 0x8C
	PPDDR   volatile.Register32 // 0x90
	PPDER   volatile.Register32 // 0x94
	PPDSR   volatile.Register32 // 0x98
	_       [4]byte
	OWER    volatile.Register32 // 0xA0
	OWDR    volatile.Register32 // 0xA4
	OWSR    volatile.Register32 // 0xA8
	_       [4]byte
	AIMER   volatile.Register32 // 0xB0
	AIMDR   volatile.Register32 // 0xB4
	AIMMR   volatile.Register32 // 0xB8
	_       [4]byte
	ESR     volatile.Register32 // 0xC0
	LSR     volatile.Register32 // 0xC4
	ELSR    volatile.Register32 // 0xC8
	_       [4]byte
	FELLSR  volatile.Register32 // 0xD0
	REHLSR  volatile.Register32 // 0xD4
	FRLHSR  volatile.Register32 // 0xD8
	_       [4]byte
	LOCKSR  volatile.Register32 // 0xE0
	WPMR    volatile.Register32 // 0xE4
	WPSR    volatile.Register32 // 0xE8
	_       [20]byte
	SCHMITT volatile.Register32 // 0x100
	_       [20]byte
	DRIVER  volatile.Register32 // 0x118
	_       [52]byte
	PCMR    volatile.Register32 // 0x150
	PCIER   volatile.Register32 // 0x154
	PCIDR   volatile.Register32 // 0x158
	PCIMR   volatile.Register32 // 0x15C
	PCISR   volatile.Register32 // 0x160
	PCRHR   volatile.Register32 // 0x164
}

// PIO.PER: PIO Enable Register
func (o *PIO_Type) SetPER_P0(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPER_P0() uint32 {
	return volatile.LoadUint32(&o.PER.Reg) & 0x1
}
func (o *PIO_Type) SetPER_P1(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPER_P1() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPER_P2(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPER_P2() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPER_P3(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPER_P3() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPER_P4(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPER_P4() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPER_P5(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPER_P5() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPER_P6(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPER_P6() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPER_P7(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPER_P7() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPER_P8(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPER_P8() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPER_P9(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPER_P9() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPER_P10(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPER_P10() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPER_P11(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPER_P11() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPER_P12(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPER_P12() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPER_P13(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPER_P13() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPER_P14(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPER_P14() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPER_P15(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPER_P15() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPER_P16(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPER_P16() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPER_P17(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPER_P17() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPER_P18(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPER_P18() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPER_P19(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPER_P19() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPER_P20(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPER_P20() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPER_P21(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPER_P21() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPER_P22(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPER_P22() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPER_P23(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPER_P23() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPER_P24(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPER_P24() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPER_P25(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPER_P25() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPER_P26(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPER_P26() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPER_P27(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPER_P27() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPER_P28(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPER_P28() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPER_P29(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPER_P29() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPER_P30(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPER_P30() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPER_P31(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPER_P31() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000000) >> 31
}

// PIO.PDR: PIO Disable Register
func (o *PIO_Type) SetPDR_P0(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDR_P0() uint32 {
	return volatile.LoadUint32(&o.PDR.Reg) & 0x1
}
func (o *PIO_Type) SetPDR_P1(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDR_P2(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDR_P3(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDR_P4(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDR_P5(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDR_P6(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDR_P7(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDR_P8(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDR_P9(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDR_P10(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDR_P11(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDR_P12(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDR_P13(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDR_P14(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDR_P15(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDR_P16(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDR_P17(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDR_P18(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDR_P19(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDR_P20(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDR_P21(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDR_P22(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDR_P23(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDR_P24(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDR_P25(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDR_P26(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDR_P27(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDR_P28(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDR_P29(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDR_P30(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDR_P31(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000000) >> 31
}

// PIO.PSR: PIO Status Register
func (o *PIO_Type) SetPSR_P0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPSR_P0() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}
func (o *PIO_Type) SetPSR_P1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPSR_P2(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPSR_P3(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPSR_P4(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPSR_P5(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPSR_P6(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPSR_P7(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPSR_P8(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPSR_P9(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPSR_P10(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPSR_P11(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPSR_P12(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPSR_P13(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPSR_P14(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPSR_P15(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPSR_P16(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPSR_P17(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPSR_P18(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPSR_P19(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPSR_P20(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPSR_P21(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPSR_P22(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPSR_P23(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPSR_P24(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPSR_P25(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPSR_P26(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPSR_P27(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPSR_P28(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPSR_P29(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPSR_P30(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPSR_P31(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000000) >> 31
}

// PIO.OER: Output Enable Register
func (o *PIO_Type) SetOER_P0(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOER_P0() uint32 {
	return volatile.LoadUint32(&o.OER.Reg) & 0x1
}
func (o *PIO_Type) SetOER_P1(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOER_P1() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOER_P2(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOER_P2() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOER_P3(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOER_P3() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOER_P4(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOER_P4() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOER_P5(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOER_P5() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOER_P6(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOER_P6() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOER_P7(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOER_P7() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOER_P8(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOER_P8() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOER_P9(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOER_P9() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOER_P10(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOER_P10() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOER_P11(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOER_P11() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOER_P12(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOER_P12() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOER_P13(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOER_P13() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOER_P14(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOER_P14() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOER_P15(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOER_P15() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOER_P16(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOER_P16() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOER_P17(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOER_P17() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOER_P18(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOER_P18() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOER_P19(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOER_P19() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOER_P20(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOER_P20() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOER_P21(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOER_P21() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOER_P22(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOER_P22() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOER_P23(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOER_P23() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOER_P24(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOER_P24() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOER_P25(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOER_P25() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOER_P26(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOER_P26() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOER_P27(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOER_P27() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOER_P28(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOER_P28() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOER_P29(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOER_P29() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOER_P30(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOER_P30() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOER_P31(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOER_P31() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000000) >> 31
}

// PIO.ODR: Output Disable Register
func (o *PIO_Type) SetODR_P0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODR_P0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}
func (o *PIO_Type) SetODR_P1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODR_P2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODR_P3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODR_P4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODR_P5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODR_P6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODR_P7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODR_P8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODR_P9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODR_P10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODR_P11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODR_P12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODR_P13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODR_P14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODR_P15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODR_P16(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODR_P17(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODR_P18(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODR_P19(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODR_P20(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODR_P21(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODR_P22(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODR_P23(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODR_P24(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODR_P25(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODR_P26(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODR_P27(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODR_P28(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODR_P29(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODR_P30(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODR_P31(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000000) >> 31
}

// PIO.OSR: Output Status Register
func (o *PIO_Type) SetOSR_P0(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOSR_P0() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *PIO_Type) SetOSR_P1(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOSR_P2(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOSR_P3(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOSR_P4(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOSR_P5(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOSR_P6(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOSR_P7(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOSR_P8(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOSR_P9(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOSR_P10(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOSR_P11(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOSR_P12(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOSR_P13(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOSR_P14(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOSR_P15(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOSR_P16(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOSR_P17(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOSR_P18(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOSR_P19(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOSR_P20(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOSR_P21(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOSR_P22(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOSR_P23(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOSR_P24(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOSR_P25(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOSR_P26(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOSR_P27(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOSR_P28(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOSR_P29(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOSR_P30(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOSR_P31(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000000) >> 31
}

// PIO.IFER: Glitch Input Filter Enable Register
func (o *PIO_Type) SetIFER_P0(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFER_P0() uint32 {
	return volatile.LoadUint32(&o.IFER.Reg) & 0x1
}
func (o *PIO_Type) SetIFER_P1(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFER_P2(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFER_P3(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFER_P4(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFER_P5(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFER_P6(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFER_P7(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFER_P8(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFER_P9(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFER_P10(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFER_P11(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFER_P12(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFER_P13(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFER_P14(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFER_P15(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFER_P16(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFER_P17(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFER_P18(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFER_P19(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFER_P20(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFER_P21(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFER_P22(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFER_P23(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFER_P24(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFER_P25(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFER_P26(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFER_P27(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFER_P28(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFER_P29(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFER_P30(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFER_P31(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000000) >> 31
}

// PIO.IFDR: Glitch Input Filter Disable Register
func (o *PIO_Type) SetIFDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSR: Glitch Input Filter Status Register
func (o *PIO_Type) SetIFSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000000) >> 31
}

// PIO.SODR: Set Output Data Register
func (o *PIO_Type) SetSODR_P0(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSODR_P0() uint32 {
	return volatile.LoadUint32(&o.SODR.Reg) & 0x1
}
func (o *PIO_Type) SetSODR_P1(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSODR_P1() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSODR_P2(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSODR_P2() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSODR_P3(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSODR_P3() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSODR_P4(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSODR_P4() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSODR_P5(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSODR_P5() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSODR_P6(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSODR_P6() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSODR_P7(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSODR_P7() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSODR_P8(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSODR_P8() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSODR_P9(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSODR_P9() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSODR_P10(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSODR_P10() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSODR_P11(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSODR_P11() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSODR_P12(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSODR_P12() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSODR_P13(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSODR_P13() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSODR_P14(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSODR_P14() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSODR_P15(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSODR_P15() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSODR_P16(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSODR_P16() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSODR_P17(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSODR_P17() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSODR_P18(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSODR_P18() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSODR_P19(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSODR_P19() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSODR_P20(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSODR_P20() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSODR_P21(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSODR_P21() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSODR_P22(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSODR_P22() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSODR_P23(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSODR_P23() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSODR_P24(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSODR_P24() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSODR_P25(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSODR_P25() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSODR_P26(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSODR_P26() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSODR_P27(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSODR_P27() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSODR_P28(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSODR_P28() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSODR_P29(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSODR_P29() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSODR_P30(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSODR_P30() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSODR_P31(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSODR_P31() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000000) >> 31
}

// PIO.CODR: Clear Output Data Register
func (o *PIO_Type) SetCODR_P0(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetCODR_P0() uint32 {
	return volatile.LoadUint32(&o.CODR.Reg) & 0x1
}
func (o *PIO_Type) SetCODR_P1(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetCODR_P1() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetCODR_P2(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetCODR_P2() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetCODR_P3(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetCODR_P3() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetCODR_P4(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetCODR_P4() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetCODR_P5(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetCODR_P5() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetCODR_P6(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetCODR_P6() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetCODR_P7(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetCODR_P7() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetCODR_P8(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetCODR_P8() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetCODR_P9(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetCODR_P9() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetCODR_P10(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetCODR_P10() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetCODR_P11(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetCODR_P11() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetCODR_P12(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetCODR_P12() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetCODR_P13(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetCODR_P13() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetCODR_P14(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetCODR_P14() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetCODR_P15(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetCODR_P15() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetCODR_P16(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetCODR_P16() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetCODR_P17(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetCODR_P17() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetCODR_P18(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetCODR_P18() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetCODR_P19(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetCODR_P19() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetCODR_P20(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetCODR_P20() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetCODR_P21(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetCODR_P21() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetCODR_P22(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetCODR_P22() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetCODR_P23(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetCODR_P23() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetCODR_P24(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetCODR_P24() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetCODR_P25(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetCODR_P25() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetCODR_P26(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetCODR_P26() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetCODR_P27(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetCODR_P27() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetCODR_P28(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetCODR_P28() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetCODR_P29(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetCODR_P29() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetCODR_P30(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetCODR_P30() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetCODR_P31(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetCODR_P31() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000000) >> 31
}

// PIO.ODSR: Output Data Status Register
func (o *PIO_Type) SetODSR_P0(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODSR_P0() uint32 {
	return volatile.LoadUint32(&o.ODSR.Reg) & 0x1
}
func (o *PIO_Type) SetODSR_P1(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODSR_P2(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODSR_P3(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODSR_P4(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODSR_P5(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODSR_P6(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODSR_P7(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODSR_P8(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODSR_P9(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODSR_P10(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODSR_P11(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODSR_P12(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODSR_P13(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODSR_P14(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODSR_P15(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODSR_P16(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODSR_P17(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODSR_P18(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODSR_P19(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODSR_P20(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODSR_P21(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODSR_P22(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODSR_P23(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODSR_P24(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODSR_P25(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODSR_P26(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODSR_P27(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODSR_P28(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODSR_P29(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODSR_P30(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODSR_P31(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000000) >> 31
}

// PIO.PDSR: Pin Data Status Register
func (o *PIO_Type) SetPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000000) >> 31
}

// PIO.IER: Interrupt Enable Register
func (o *PIO_Type) SetIER_P0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIER_P0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PIO_Type) SetIER_P1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIER_P1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIER_P2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIER_P2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIER_P3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIER_P3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIER_P4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIER_P4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIER_P5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIER_P5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIER_P6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIER_P6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIER_P7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIER_P7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIER_P8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIER_P8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIER_P9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIER_P9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIER_P10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIER_P10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIER_P11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIER_P11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIER_P12(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIER_P12() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIER_P13(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIER_P13() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIER_P14(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIER_P14() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIER_P15(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIER_P15() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIER_P16(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIER_P16() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIER_P17(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIER_P17() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIER_P18(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIER_P18() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIER_P19(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIER_P19() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIER_P20(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIER_P20() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIER_P21(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIER_P21() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIER_P22(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIER_P22() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIER_P23(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIER_P23() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIER_P24(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIER_P24() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIER_P25(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIER_P25() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIER_P26(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIER_P26() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIER_P27(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIER_P27() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIER_P28(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIER_P28() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIER_P29(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIER_P29() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIER_P30(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIER_P30() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIER_P31(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIER_P31() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// PIO.IDR: Interrupt Disable Register
func (o *PIO_Type) SetIDR_P0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIDR_P0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PIO_Type) SetIDR_P1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIDR_P2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIDR_P3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIDR_P4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIDR_P5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIDR_P6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIDR_P7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIDR_P8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIDR_P9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIDR_P10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIDR_P11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIDR_P12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIDR_P13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIDR_P14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIDR_P15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIDR_P16(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIDR_P17(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIDR_P18(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIDR_P19(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIDR_P20(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIDR_P21(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIDR_P22(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIDR_P23(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIDR_P24(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIDR_P25(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIDR_P26(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIDR_P27(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIDR_P28(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIDR_P29(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIDR_P30(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIDR_P31(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// PIO.IMR: Interrupt Mask Register
func (o *PIO_Type) SetIMR_P0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIMR_P0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PIO_Type) SetIMR_P1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIMR_P1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIMR_P2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIMR_P2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIMR_P3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIMR_P3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIMR_P4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIMR_P4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIMR_P5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIMR_P5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIMR_P6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIMR_P6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIMR_P7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIMR_P7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIMR_P8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIMR_P8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIMR_P9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIMR_P9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIMR_P10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIMR_P10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIMR_P11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIMR_P11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIMR_P12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIMR_P12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIMR_P13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIMR_P13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIMR_P14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIMR_P14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIMR_P15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIMR_P15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIMR_P16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIMR_P16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIMR_P17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIMR_P17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIMR_P18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIMR_P18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIMR_P19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIMR_P19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIMR_P20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIMR_P20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIMR_P21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIMR_P21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIMR_P22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIMR_P22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIMR_P23(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIMR_P23() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIMR_P24(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIMR_P24() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIMR_P25(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIMR_P25() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIMR_P26(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIMR_P26() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIMR_P27(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIMR_P27() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIMR_P28(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIMR_P28() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIMR_P29(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIMR_P29() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIMR_P30(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIMR_P30() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIMR_P31(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIMR_P31() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// PIO.ISR: Interrupt Status Register
func (o *PIO_Type) SetISR_P0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetISR_P0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PIO_Type) SetISR_P1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetISR_P1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetISR_P2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetISR_P2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetISR_P3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetISR_P3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetISR_P4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetISR_P4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetISR_P5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetISR_P5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetISR_P6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetISR_P6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetISR_P7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetISR_P7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetISR_P8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetISR_P8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetISR_P9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetISR_P9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetISR_P10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetISR_P10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetISR_P11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetISR_P11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetISR_P12(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetISR_P12() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetISR_P13(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetISR_P13() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetISR_P14(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetISR_P14() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetISR_P15(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetISR_P15() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetISR_P16(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetISR_P16() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetISR_P17(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetISR_P17() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetISR_P18(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetISR_P18() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetISR_P19(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetISR_P19() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetISR_P20(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetISR_P20() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetISR_P21(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetISR_P21() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetISR_P22(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetISR_P22() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetISR_P23(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetISR_P23() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetISR_P24(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetISR_P24() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetISR_P25(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetISR_P25() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetISR_P26(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetISR_P26() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetISR_P27(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetISR_P27() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetISR_P28(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetISR_P28() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetISR_P29(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetISR_P29() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetISR_P30(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetISR_P30() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetISR_P31(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetISR_P31() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// PIO.MDER: Multi-driver Enable Register
func (o *PIO_Type) SetMDER_P0(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDER_P0() uint32 {
	return volatile.LoadUint32(&o.MDER.Reg) & 0x1
}
func (o *PIO_Type) SetMDER_P1(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDER_P1() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDER_P2(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDER_P2() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDER_P3(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDER_P3() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDER_P4(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDER_P4() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDER_P5(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDER_P5() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDER_P6(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDER_P6() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDER_P7(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDER_P7() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDER_P8(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDER_P8() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDER_P9(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDER_P9() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDER_P10(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDER_P10() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDER_P11(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDER_P11() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDER_P12(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDER_P12() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDER_P13(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDER_P13() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDER_P14(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDER_P14() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDER_P15(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDER_P15() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDER_P16(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDER_P16() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDER_P17(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDER_P17() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDER_P18(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDER_P18() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDER_P19(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDER_P19() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDER_P20(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDER_P20() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDER_P21(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDER_P21() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDER_P22(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDER_P22() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDER_P23(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDER_P23() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDER_P24(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDER_P24() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDER_P25(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDER_P25() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDER_P26(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDER_P26() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDER_P27(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDER_P27() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDER_P28(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDER_P28() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDER_P29(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDER_P29() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDER_P30(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDER_P30() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDER_P31(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDER_P31() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000000) >> 31
}

// PIO.MDDR: Multi-driver Disable Register
func (o *PIO_Type) SetMDDR_P0(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDDR_P0() uint32 {
	return volatile.LoadUint32(&o.MDDR.Reg) & 0x1
}
func (o *PIO_Type) SetMDDR_P1(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDDR_P2(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDDR_P3(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDDR_P4(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDDR_P5(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDDR_P6(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDDR_P7(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDDR_P8(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDDR_P9(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDDR_P10(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDDR_P11(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDDR_P12(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDDR_P13(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDDR_P14(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDDR_P15(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDDR_P16(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDDR_P17(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDDR_P18(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDDR_P19(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDDR_P20(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDDR_P21(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDDR_P22(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDDR_P23(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDDR_P24(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDDR_P25(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDDR_P26(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDDR_P27(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDDR_P28(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDDR_P29(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDDR_P30(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDDR_P31(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000000) >> 31
}

// PIO.MDSR: Multi-driver Status Register
func (o *PIO_Type) SetMDSR_P0(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDSR_P0() uint32 {
	return volatile.LoadUint32(&o.MDSR.Reg) & 0x1
}
func (o *PIO_Type) SetMDSR_P1(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDSR_P2(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDSR_P3(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDSR_P4(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDSR_P5(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDSR_P6(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDSR_P7(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDSR_P8(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDSR_P9(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDSR_P10(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDSR_P11(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDSR_P12(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDSR_P13(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDSR_P14(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDSR_P15(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDSR_P16(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDSR_P17(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDSR_P18(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDSR_P19(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDSR_P20(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDSR_P21(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDSR_P22(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDSR_P23(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDSR_P24(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDSR_P25(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDSR_P26(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDSR_P27(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDSR_P28(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDSR_P29(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDSR_P30(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDSR_P31(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000000) >> 31
}

// PIO.PUDR: Pull-up Disable Register
func (o *PIO_Type) SetPUDR_P0(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUDR_P0() uint32 {
	return volatile.LoadUint32(&o.PUDR.Reg) & 0x1
}
func (o *PIO_Type) SetPUDR_P1(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUDR_P2(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUDR_P3(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUDR_P4(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUDR_P5(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUDR_P6(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUDR_P7(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUDR_P8(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUDR_P9(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUDR_P10(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUDR_P11(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUDR_P12(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUDR_P13(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUDR_P14(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUDR_P15(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUDR_P16(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUDR_P17(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUDR_P18(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUDR_P19(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUDR_P20(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUDR_P21(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUDR_P22(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUDR_P23(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUDR_P24(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUDR_P25(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUDR_P26(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUDR_P27(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUDR_P28(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUDR_P29(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUDR_P30(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUDR_P31(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000000) >> 31
}

// PIO.PUER: Pull-up Enable Register
func (o *PIO_Type) SetPUER_P0(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUER_P0() uint32 {
	return volatile.LoadUint32(&o.PUER.Reg) & 0x1
}
func (o *PIO_Type) SetPUER_P1(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUER_P1() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUER_P2(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUER_P2() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUER_P3(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUER_P3() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUER_P4(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUER_P4() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUER_P5(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUER_P5() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUER_P6(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUER_P6() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUER_P7(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUER_P7() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUER_P8(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUER_P8() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUER_P9(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUER_P9() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUER_P10(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUER_P10() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUER_P11(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUER_P11() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUER_P12(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUER_P12() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUER_P13(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUER_P13() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUER_P14(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUER_P14() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUER_P15(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUER_P15() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUER_P16(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUER_P16() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUER_P17(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUER_P17() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUER_P18(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUER_P18() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUER_P19(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUER_P19() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUER_P20(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUER_P20() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUER_P21(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUER_P21() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUER_P22(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUER_P22() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUER_P23(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUER_P23() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUER_P24(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUER_P24() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUER_P25(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUER_P25() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUER_P26(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUER_P26() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUER_P27(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUER_P27() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUER_P28(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUER_P28() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUER_P29(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUER_P29() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUER_P30(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUER_P30() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUER_P31(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUER_P31() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000000) >> 31
}

// PIO.PUSR: Pad Pull-up Status Register
func (o *PIO_Type) SetPUSR_P0(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUSR_P0() uint32 {
	return volatile.LoadUint32(&o.PUSR.Reg) & 0x1
}
func (o *PIO_Type) SetPUSR_P1(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUSR_P2(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUSR_P3(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUSR_P4(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUSR_P5(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUSR_P6(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUSR_P7(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUSR_P8(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUSR_P9(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUSR_P10(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUSR_P11(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUSR_P12(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUSR_P13(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUSR_P14(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUSR_P15(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUSR_P16(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUSR_P17(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUSR_P18(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUSR_P19(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUSR_P20(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUSR_P21(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUSR_P22(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUSR_P23(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUSR_P24(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUSR_P25(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUSR_P26(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUSR_P27(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUSR_P28(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUSR_P29(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUSR_P30(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUSR_P31(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000000) >> 31
}

// PIO.ABCDSR: Peripheral ABCD Select Register 0
func (o *PIO_Type) SetABCDSR_P0(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetABCDSR_P0(idx int) uint32 {
	return volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1
}
func (o *PIO_Type) SetABCDSR_P1(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetABCDSR_P1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetABCDSR_P2(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetABCDSR_P2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetABCDSR_P3(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetABCDSR_P3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetABCDSR_P4(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetABCDSR_P4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetABCDSR_P5(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetABCDSR_P5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetABCDSR_P6(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetABCDSR_P6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetABCDSR_P7(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetABCDSR_P7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetABCDSR_P8(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetABCDSR_P8(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetABCDSR_P9(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetABCDSR_P9(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetABCDSR_P10(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetABCDSR_P10(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetABCDSR_P11(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetABCDSR_P11(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetABCDSR_P12(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetABCDSR_P12(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetABCDSR_P13(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetABCDSR_P13(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetABCDSR_P14(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetABCDSR_P14(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetABCDSR_P15(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetABCDSR_P15(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetABCDSR_P16(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetABCDSR_P16(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetABCDSR_P17(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetABCDSR_P17(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetABCDSR_P18(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetABCDSR_P18(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetABCDSR_P19(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetABCDSR_P19(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetABCDSR_P20(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetABCDSR_P20(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetABCDSR_P21(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetABCDSR_P21(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetABCDSR_P22(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetABCDSR_P22(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetABCDSR_P23(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetABCDSR_P23(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetABCDSR_P24(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetABCDSR_P24(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetABCDSR_P25(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetABCDSR_P25(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetABCDSR_P26(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetABCDSR_P26(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetABCDSR_P27(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetABCDSR_P27(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetABCDSR_P28(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetABCDSR_P28(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetABCDSR_P29(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetABCDSR_P29(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetABCDSR_P30(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetABCDSR_P30(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetABCDSR_P31(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetABCDSR_P31(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000000) >> 31
}

// PIO.IFSCDR: Input Filter Slow Clock Disable Register
func (o *PIO_Type) SetIFSCDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSCER: Input Filter Slow Clock Enable Register
func (o *PIO_Type) SetIFSCER_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCER_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCER.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCER_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCER_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCER_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCER_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCER_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCER_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCER_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCER_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCER_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCER_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCER_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCER_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCER_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCER_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCER_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCER_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCER_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCER_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCER_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCER_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCER_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCER_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCER_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCER_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCER_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCER_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCER_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCER_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCER_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCER_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCER_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000000) >> 31
}

// PIO.IFSCSR: Input Filter Slow Clock Status Register
func (o *PIO_Type) SetIFSCSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000000) >> 31
}

// PIO.SCDR: Slow Clock Divider Debouncing Register
func (o *PIO_Type) SetSCDR_DIV(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x3fff)|value)
}
func (o *PIO_Type) GetSCDR_DIV() uint32 {
	return volatile.LoadUint32(&o.SCDR.Reg) & 0x3fff
}

// PIO.PPDDR: Pad Pull-down Disable Register
func (o *PIO_Type) SetPPDDR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDDR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDDR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDDR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDDR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDDR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDDR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDDR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDDR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDDR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDDR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDDR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDDR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDDR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDDR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDDR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDDR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDDR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDDR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDDR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDDR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDDR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDDR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDDR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDDR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDDR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDDR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDDR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDDR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDDR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDDR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDDR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDDR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDDR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000000) >> 31
}

// PIO.PPDER: Pad Pull-down Enable Register
func (o *PIO_Type) SetPPDER_P0(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDER_P0() uint32 {
	return volatile.LoadUint32(&o.PPDER.Reg) & 0x1
}
func (o *PIO_Type) SetPPDER_P1(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDER_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDER_P2(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDER_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDER_P3(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDER_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDER_P4(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDER_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDER_P5(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDER_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDER_P6(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDER_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDER_P7(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDER_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDER_P8(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDER_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDER_P9(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDER_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDER_P10(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDER_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDER_P11(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDER_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDER_P12(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDER_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDER_P13(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDER_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDER_P14(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDER_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDER_P15(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDER_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDER_P16(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDER_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDER_P17(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDER_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDER_P18(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDER_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDER_P19(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDER_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDER_P20(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDER_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDER_P21(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDER_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDER_P22(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDER_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDER_P23(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDER_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDER_P24(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDER_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDER_P25(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDER_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDER_P26(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDER_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDER_P27(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDER_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDER_P28(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDER_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDER_P29(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDER_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDER_P30(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDER_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDER_P31(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDER_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000000) >> 31
}

// PIO.PPDSR: Pad Pull-down Status Register
func (o *PIO_Type) SetPPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000000) >> 31
}

// PIO.OWER: Output Write Enable
func (o *PIO_Type) SetOWER_P0(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWER_P0() uint32 {
	return volatile.LoadUint32(&o.OWER.Reg) & 0x1
}
func (o *PIO_Type) SetOWER_P1(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWER_P1() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWER_P2(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWER_P2() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWER_P3(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWER_P3() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWER_P4(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWER_P4() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWER_P5(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWER_P5() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWER_P6(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWER_P6() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWER_P7(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWER_P7() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWER_P8(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWER_P8() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWER_P9(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWER_P9() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWER_P10(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWER_P10() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWER_P11(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWER_P11() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWER_P12(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWER_P12() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWER_P13(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWER_P13() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWER_P14(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWER_P14() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWER_P15(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWER_P15() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWER_P16(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWER_P16() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWER_P17(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWER_P17() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWER_P18(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWER_P18() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWER_P19(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWER_P19() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWER_P20(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWER_P20() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWER_P21(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWER_P21() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWER_P22(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWER_P22() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWER_P23(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWER_P23() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWER_P24(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWER_P24() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWER_P25(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWER_P25() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWER_P26(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWER_P26() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWER_P27(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWER_P27() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWER_P28(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWER_P28() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWER_P29(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWER_P29() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWER_P30(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWER_P30() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWER_P31(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWER_P31() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000000) >> 31
}

// PIO.OWDR: Output Write Disable
func (o *PIO_Type) SetOWDR_P0(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWDR_P0() uint32 {
	return volatile.LoadUint32(&o.OWDR.Reg) & 0x1
}
func (o *PIO_Type) SetOWDR_P1(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWDR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWDR_P2(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWDR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWDR_P3(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWDR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWDR_P4(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWDR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWDR_P5(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWDR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWDR_P6(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWDR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWDR_P7(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWDR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWDR_P8(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWDR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWDR_P9(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWDR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWDR_P10(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWDR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWDR_P11(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWDR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWDR_P12(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWDR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWDR_P13(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWDR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWDR_P14(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWDR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWDR_P15(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWDR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWDR_P16(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWDR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWDR_P17(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWDR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWDR_P18(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWDR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWDR_P19(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWDR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWDR_P20(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWDR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWDR_P21(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWDR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWDR_P22(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWDR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWDR_P23(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWDR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWDR_P24(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWDR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWDR_P25(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWDR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWDR_P26(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWDR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWDR_P27(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWDR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWDR_P28(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWDR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWDR_P29(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWDR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWDR_P30(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWDR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWDR_P31(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWDR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000000) >> 31
}

// PIO.OWSR: Output Write Status Register
func (o *PIO_Type) SetOWSR_P0(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWSR_P0() uint32 {
	return volatile.LoadUint32(&o.OWSR.Reg) & 0x1
}
func (o *PIO_Type) SetOWSR_P1(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWSR_P2(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWSR_P3(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWSR_P4(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWSR_P5(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWSR_P6(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWSR_P7(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWSR_P8(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWSR_P9(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWSR_P10(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWSR_P11(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWSR_P12(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWSR_P13(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWSR_P14(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWSR_P15(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWSR_P16(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWSR_P17(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWSR_P18(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWSR_P19(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWSR_P20(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWSR_P21(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWSR_P22(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWSR_P23(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWSR_P24(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWSR_P25(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWSR_P26(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWSR_P27(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWSR_P28(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWSR_P29(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWSR_P30(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWSR_P31(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000000) >> 31
}

// PIO.AIMER: Additional Interrupt Modes Enable Register
func (o *PIO_Type) SetAIMER_P0(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMER_P0() uint32 {
	return volatile.LoadUint32(&o.AIMER.Reg) & 0x1
}
func (o *PIO_Type) SetAIMER_P1(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMER_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMER_P2(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMER_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMER_P3(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMER_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMER_P4(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMER_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMER_P5(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMER_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMER_P6(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMER_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMER_P7(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMER_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMER_P8(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMER_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMER_P9(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMER_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMER_P10(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMER_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMER_P11(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMER_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMER_P12(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMER_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMER_P13(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMER_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMER_P14(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMER_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMER_P15(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMER_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMER_P16(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMER_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMER_P17(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMER_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMER_P18(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMER_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMER_P19(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMER_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMER_P20(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMER_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMER_P21(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMER_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMER_P22(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMER_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMER_P23(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMER_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMER_P24(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMER_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMER_P25(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMER_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMER_P26(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMER_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMER_P27(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMER_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMER_P28(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMER_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMER_P29(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMER_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMER_P30(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMER_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMER_P31(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMER_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000000) >> 31
}

// PIO.AIMDR: Additional Interrupt Modes Disable Register
func (o *PIO_Type) SetAIMDR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMDR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMDR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMDR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMDR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMDR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMDR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMDR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMDR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMDR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMDR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMDR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMDR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMDR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMDR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMDR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMDR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMDR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMDR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMDR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMDR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMDR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMDR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMDR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMDR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMDR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMDR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMDR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMDR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMDR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMDR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMDR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMDR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMDR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMDR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMDR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMDR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMDR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMDR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMDR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMDR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMDR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMDR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMDR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMDR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMDR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMDR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMDR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMDR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMDR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMDR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMDR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMDR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMDR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMDR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMDR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMDR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMDR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMDR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMDR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMDR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMDR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMDR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMDR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMDR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000000) >> 31
}

// PIO.AIMMR: Additional Interrupt Modes Mask Register
func (o *PIO_Type) SetAIMMR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMMR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMMR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMMR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMMR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMMR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMMR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMMR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMMR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMMR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMMR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMMR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMMR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMMR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMMR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMMR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMMR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMMR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMMR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMMR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMMR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMMR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMMR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMMR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMMR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMMR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMMR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMMR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMMR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMMR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMMR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMMR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMMR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMMR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMMR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMMR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMMR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMMR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMMR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMMR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMMR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMMR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMMR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMMR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMMR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMMR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMMR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMMR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMMR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMMR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMMR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMMR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMMR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMMR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMMR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMMR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMMR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMMR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMMR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMMR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMMR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMMR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMMR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMMR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMMR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000000) >> 31
}

// PIO.ESR: Edge Select Register
func (o *PIO_Type) SetESR_P0(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetESR_P0() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x1
}
func (o *PIO_Type) SetESR_P1(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetESR_P1() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetESR_P2(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetESR_P2() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetESR_P3(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetESR_P3() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetESR_P4(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetESR_P4() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetESR_P5(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetESR_P5() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetESR_P6(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetESR_P6() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetESR_P7(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetESR_P7() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetESR_P8(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetESR_P8() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetESR_P9(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetESR_P9() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetESR_P10(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetESR_P10() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetESR_P11(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetESR_P11() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetESR_P12(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetESR_P12() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetESR_P13(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetESR_P13() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetESR_P14(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetESR_P14() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetESR_P15(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetESR_P15() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetESR_P16(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetESR_P16() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetESR_P17(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetESR_P17() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetESR_P18(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetESR_P18() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetESR_P19(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetESR_P19() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetESR_P20(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetESR_P20() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetESR_P21(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetESR_P21() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetESR_P22(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetESR_P22() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetESR_P23(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetESR_P23() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetESR_P24(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetESR_P24() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetESR_P25(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetESR_P25() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetESR_P26(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetESR_P26() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetESR_P27(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetESR_P27() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetESR_P28(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetESR_P28() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetESR_P29(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetESR_P29() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetESR_P30(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetESR_P30() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetESR_P31(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetESR_P31() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000000) >> 31
}

// PIO.LSR: Level Select Register
func (o *PIO_Type) SetLSR_P0(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLSR_P0() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *PIO_Type) SetLSR_P1(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLSR_P2(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLSR_P3(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLSR_P4(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLSR_P5(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLSR_P6(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLSR_P7(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLSR_P8(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLSR_P9(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLSR_P10(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLSR_P11(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLSR_P12(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLSR_P13(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLSR_P14(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLSR_P15(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLSR_P16(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLSR_P17(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLSR_P18(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLSR_P19(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLSR_P20(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLSR_P21(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLSR_P22(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLSR_P23(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLSR_P24(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLSR_P25(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLSR_P26(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLSR_P27(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLSR_P28(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLSR_P29(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLSR_P30(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLSR_P31(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000000) >> 31
}

// PIO.ELSR: Edge/Level Status Register
func (o *PIO_Type) SetELSR_P0(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetELSR_P0() uint32 {
	return volatile.LoadUint32(&o.ELSR.Reg) & 0x1
}
func (o *PIO_Type) SetELSR_P1(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetELSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetELSR_P2(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetELSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetELSR_P3(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetELSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetELSR_P4(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetELSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetELSR_P5(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetELSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetELSR_P6(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetELSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetELSR_P7(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetELSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetELSR_P8(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetELSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetELSR_P9(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetELSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetELSR_P10(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetELSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetELSR_P11(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetELSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetELSR_P12(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetELSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetELSR_P13(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetELSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetELSR_P14(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetELSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetELSR_P15(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetELSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetELSR_P16(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetELSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetELSR_P17(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetELSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetELSR_P18(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetELSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetELSR_P19(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetELSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetELSR_P20(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetELSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetELSR_P21(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetELSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetELSR_P22(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetELSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetELSR_P23(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetELSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetELSR_P24(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetELSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetELSR_P25(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetELSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetELSR_P26(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetELSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetELSR_P27(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetELSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetELSR_P28(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetELSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetELSR_P29(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetELSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetELSR_P30(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetELSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetELSR_P31(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetELSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000000) >> 31
}

// PIO.FELLSR: Falling Edge/Low-Level Select Register
func (o *PIO_Type) SetFELLSR_P0(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFELLSR_P0() uint32 {
	return volatile.LoadUint32(&o.FELLSR.Reg) & 0x1
}
func (o *PIO_Type) SetFELLSR_P1(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFELLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFELLSR_P2(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFELLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFELLSR_P3(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFELLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFELLSR_P4(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFELLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFELLSR_P5(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFELLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFELLSR_P6(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFELLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFELLSR_P7(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFELLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFELLSR_P8(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFELLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFELLSR_P9(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFELLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFELLSR_P10(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFELLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFELLSR_P11(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFELLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFELLSR_P12(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFELLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFELLSR_P13(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFELLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFELLSR_P14(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFELLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFELLSR_P15(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFELLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFELLSR_P16(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFELLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFELLSR_P17(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFELLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFELLSR_P18(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFELLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFELLSR_P19(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFELLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFELLSR_P20(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFELLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFELLSR_P21(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFELLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFELLSR_P22(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFELLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFELLSR_P23(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFELLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFELLSR_P24(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFELLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFELLSR_P25(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFELLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFELLSR_P26(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFELLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFELLSR_P27(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFELLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFELLSR_P28(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFELLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFELLSR_P29(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFELLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFELLSR_P30(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFELLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFELLSR_P31(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFELLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000000) >> 31
}

// PIO.REHLSR: Rising Edge/High-Level Select Register
func (o *PIO_Type) SetREHLSR_P0(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetREHLSR_P0() uint32 {
	return volatile.LoadUint32(&o.REHLSR.Reg) & 0x1
}
func (o *PIO_Type) SetREHLSR_P1(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetREHLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetREHLSR_P2(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetREHLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetREHLSR_P3(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetREHLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetREHLSR_P4(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetREHLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetREHLSR_P5(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetREHLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetREHLSR_P6(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetREHLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetREHLSR_P7(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetREHLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetREHLSR_P8(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetREHLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetREHLSR_P9(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetREHLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetREHLSR_P10(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetREHLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetREHLSR_P11(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetREHLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetREHLSR_P12(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetREHLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetREHLSR_P13(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetREHLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetREHLSR_P14(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetREHLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetREHLSR_P15(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetREHLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetREHLSR_P16(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetREHLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetREHLSR_P17(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetREHLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetREHLSR_P18(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetREHLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetREHLSR_P19(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetREHLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetREHLSR_P20(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetREHLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetREHLSR_P21(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetREHLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetREHLSR_P22(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetREHLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetREHLSR_P23(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetREHLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetREHLSR_P24(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetREHLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetREHLSR_P25(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetREHLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetREHLSR_P26(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetREHLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetREHLSR_P27(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetREHLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetREHLSR_P28(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetREHLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetREHLSR_P29(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetREHLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetREHLSR_P30(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetREHLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetREHLSR_P31(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetREHLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000000) >> 31
}

// PIO.FRLHSR: Fall/Rise - Low/High Status Register
func (o *PIO_Type) SetFRLHSR_P0(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFRLHSR_P0() uint32 {
	return volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1
}
func (o *PIO_Type) SetFRLHSR_P1(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFRLHSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFRLHSR_P2(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFRLHSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFRLHSR_P3(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFRLHSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFRLHSR_P4(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFRLHSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFRLHSR_P5(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFRLHSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFRLHSR_P6(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFRLHSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFRLHSR_P7(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFRLHSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFRLHSR_P8(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFRLHSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFRLHSR_P9(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFRLHSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFRLHSR_P10(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFRLHSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFRLHSR_P11(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFRLHSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFRLHSR_P12(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFRLHSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFRLHSR_P13(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFRLHSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFRLHSR_P14(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFRLHSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFRLHSR_P15(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFRLHSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFRLHSR_P16(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFRLHSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFRLHSR_P17(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFRLHSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFRLHSR_P18(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFRLHSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFRLHSR_P19(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFRLHSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFRLHSR_P20(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFRLHSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFRLHSR_P21(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFRLHSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFRLHSR_P22(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFRLHSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFRLHSR_P23(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFRLHSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFRLHSR_P24(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFRLHSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFRLHSR_P25(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFRLHSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFRLHSR_P26(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFRLHSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFRLHSR_P27(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFRLHSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFRLHSR_P28(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFRLHSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFRLHSR_P29(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFRLHSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFRLHSR_P30(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFRLHSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFRLHSR_P31(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFRLHSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000000) >> 31
}

// PIO.LOCKSR: Lock Status
func (o *PIO_Type) SetLOCKSR_P0(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLOCKSR_P0() uint32 {
	return volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1
}
func (o *PIO_Type) SetLOCKSR_P1(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLOCKSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLOCKSR_P2(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLOCKSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLOCKSR_P3(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLOCKSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLOCKSR_P4(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLOCKSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLOCKSR_P5(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLOCKSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLOCKSR_P6(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLOCKSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLOCKSR_P7(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLOCKSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLOCKSR_P8(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLOCKSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLOCKSR_P9(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLOCKSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLOCKSR_P10(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLOCKSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLOCKSR_P11(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLOCKSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLOCKSR_P12(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLOCKSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLOCKSR_P13(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLOCKSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLOCKSR_P14(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLOCKSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLOCKSR_P15(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLOCKSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLOCKSR_P16(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLOCKSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLOCKSR_P17(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLOCKSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLOCKSR_P18(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLOCKSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLOCKSR_P19(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLOCKSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLOCKSR_P20(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLOCKSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLOCKSR_P21(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLOCKSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLOCKSR_P22(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLOCKSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLOCKSR_P23(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLOCKSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLOCKSR_P24(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLOCKSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLOCKSR_P25(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLOCKSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLOCKSR_P26(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLOCKSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLOCKSR_P27(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLOCKSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLOCKSR_P28(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLOCKSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLOCKSR_P29(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLOCKSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLOCKSR_P30(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLOCKSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLOCKSR_P31(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLOCKSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000000) >> 31
}

// PIO.WPMR: Write Protection Mode Register
func (o *PIO_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PIO_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PIO_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PIO.WPSR: Write Protection Status Register
func (o *PIO_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PIO_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PIO_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// PIO.SCHMITT: Schmitt Trigger Register
func (o *PIO_Type) SetSCHMITT_SCHMITT0(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT0() uint32 {
	return volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT1(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT1() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT2(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT2() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSCHMITT_SCHMITT3(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT3() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSCHMITT_SCHMITT4(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT4() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSCHMITT_SCHMITT5(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT5() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSCHMITT_SCHMITT6(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT6() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSCHMITT_SCHMITT7(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT7() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSCHMITT_SCHMITT8(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT8() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSCHMITT_SCHMITT9(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT9() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSCHMITT_SCHMITT10(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT10() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSCHMITT_SCHMITT11(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT11() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSCHMITT_SCHMITT12(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT12() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSCHMITT_SCHMITT13(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT13() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSCHMITT_SCHMITT14(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT14() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSCHMITT_SCHMITT15(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT15() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSCHMITT_SCHMITT16(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT16() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSCHMITT_SCHMITT17(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT17() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSCHMITT_SCHMITT18(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT18() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSCHMITT_SCHMITT19(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT19() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSCHMITT_SCHMITT20(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT20() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSCHMITT_SCHMITT21(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT21() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSCHMITT_SCHMITT22(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT22() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSCHMITT_SCHMITT23(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT23() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSCHMITT_SCHMITT24(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT24() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSCHMITT_SCHMITT25(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT25() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSCHMITT_SCHMITT26(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT26() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSCHMITT_SCHMITT27(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT27() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSCHMITT_SCHMITT28(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT28() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSCHMITT_SCHMITT29(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT29() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSCHMITT_SCHMITT30(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT30() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSCHMITT_SCHMITT31(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT31() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000000) >> 31
}

// PIO.DRIVER: I/O Drive Register
func (o *PIO_Type) SetDRIVER_LINE0(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetDRIVER_LINE0() uint32 {
	return volatile.LoadUint32(&o.DRIVER.Reg) & 0x1
}
func (o *PIO_Type) SetDRIVER_LINE1(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetDRIVER_LINE1() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetDRIVER_LINE2(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetDRIVER_LINE2() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetDRIVER_LINE3(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetDRIVER_LINE3() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetDRIVER_LINE4(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetDRIVER_LINE4() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetDRIVER_LINE5(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetDRIVER_LINE5() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetDRIVER_LINE6(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetDRIVER_LINE6() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetDRIVER_LINE7(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetDRIVER_LINE7() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetDRIVER_LINE8(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetDRIVER_LINE8() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetDRIVER_LINE9(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetDRIVER_LINE9() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetDRIVER_LINE10(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetDRIVER_LINE10() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetDRIVER_LINE11(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetDRIVER_LINE11() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetDRIVER_LINE12(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetDRIVER_LINE12() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetDRIVER_LINE13(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetDRIVER_LINE13() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetDRIVER_LINE14(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetDRIVER_LINE14() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetDRIVER_LINE15(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetDRIVER_LINE15() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetDRIVER_LINE16(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetDRIVER_LINE16() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetDRIVER_LINE17(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetDRIVER_LINE17() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetDRIVER_LINE18(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetDRIVER_LINE18() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetDRIVER_LINE19(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetDRIVER_LINE19() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetDRIVER_LINE20(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetDRIVER_LINE20() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetDRIVER_LINE21(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetDRIVER_LINE21() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetDRIVER_LINE22(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetDRIVER_LINE22() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetDRIVER_LINE23(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetDRIVER_LINE23() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetDRIVER_LINE24(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetDRIVER_LINE24() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetDRIVER_LINE25(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetDRIVER_LINE25() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetDRIVER_LINE26(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetDRIVER_LINE26() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetDRIVER_LINE27(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetDRIVER_LINE27() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetDRIVER_LINE28(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetDRIVER_LINE28() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetDRIVER_LINE29(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetDRIVER_LINE29() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetDRIVER_LINE30(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetDRIVER_LINE30() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetDRIVER_LINE31(value uint32) {
	volatile.StoreUint32(&o.DRIVER.Reg, volatile.LoadUint32(&o.DRIVER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetDRIVER_LINE31() uint32 {
	return (volatile.LoadUint32(&o.DRIVER.Reg) & 0x80000000) >> 31
}

// PIO.PCMR: Parallel Capture Mode Register
func (o *PIO_Type) SetPCMR_PCEN(value uint32) {
	volatile.StoreUint32(&o.PCMR.Reg, volatile.LoadUint32(&o.PCMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPCMR_PCEN() uint32 {
	return volatile.LoadUint32(&o.PCMR.Reg) & 0x1
}
func (o *PIO_Type) SetPCMR_DSIZE(value uint32) {
	volatile.StoreUint32(&o.PCMR.Reg, volatile.LoadUint32(&o.PCMR.Reg)&^(0x30)|value<<4)
}
func (o *PIO_Type) GetPCMR_DSIZE() uint32 {
	return (volatile.LoadUint32(&o.PCMR.Reg) & 0x30) >> 4
}
func (o *PIO_Type) SetPCMR_ALWYS(value uint32) {
	volatile.StoreUint32(&o.PCMR.Reg, volatile.LoadUint32(&o.PCMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPCMR_ALWYS() uint32 {
	return (volatile.LoadUint32(&o.PCMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPCMR_HALFS(value uint32) {
	volatile.StoreUint32(&o.PCMR.Reg, volatile.LoadUint32(&o.PCMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPCMR_HALFS() uint32 {
	return (volatile.LoadUint32(&o.PCMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPCMR_FRSTS(value uint32) {
	volatile.StoreUint32(&o.PCMR.Reg, volatile.LoadUint32(&o.PCMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPCMR_FRSTS() uint32 {
	return (volatile.LoadUint32(&o.PCMR.Reg) & 0x800) >> 11
}

// PIO.PCIER: Parallel Capture Interrupt Enable Register
func (o *PIO_Type) SetPCIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.PCIER.Reg, volatile.LoadUint32(&o.PCIER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPCIER_DRDY() uint32 {
	return volatile.LoadUint32(&o.PCIER.Reg) & 0x1
}
func (o *PIO_Type) SetPCIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.PCIER.Reg, volatile.LoadUint32(&o.PCIER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPCIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.PCIER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPCIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.PCIER.Reg, volatile.LoadUint32(&o.PCIER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPCIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.PCIER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPCIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.PCIER.Reg, volatile.LoadUint32(&o.PCIER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPCIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.PCIER.Reg) & 0x8) >> 3
}

// PIO.PCIDR: Parallel Capture Interrupt Disable Register
func (o *PIO_Type) SetPCIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.PCIDR.Reg, volatile.LoadUint32(&o.PCIDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPCIDR_DRDY() uint32 {
	return volatile.LoadUint32(&o.PCIDR.Reg) & 0x1
}
func (o *PIO_Type) SetPCIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.PCIDR.Reg, volatile.LoadUint32(&o.PCIDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPCIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.PCIDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPCIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.PCIDR.Reg, volatile.LoadUint32(&o.PCIDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPCIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.PCIDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPCIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.PCIDR.Reg, volatile.LoadUint32(&o.PCIDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPCIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.PCIDR.Reg) & 0x8) >> 3
}

// PIO.PCIMR: Parallel Capture Interrupt Mask Register
func (o *PIO_Type) SetPCIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.PCIMR.Reg, volatile.LoadUint32(&o.PCIMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPCIMR_DRDY() uint32 {
	return volatile.LoadUint32(&o.PCIMR.Reg) & 0x1
}
func (o *PIO_Type) SetPCIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.PCIMR.Reg, volatile.LoadUint32(&o.PCIMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPCIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.PCIMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPCIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.PCIMR.Reg, volatile.LoadUint32(&o.PCIMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPCIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.PCIMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPCIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.PCIMR.Reg, volatile.LoadUint32(&o.PCIMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPCIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.PCIMR.Reg) & 0x8) >> 3
}

// PIO.PCISR: Parallel Capture Interrupt Status Register
func (o *PIO_Type) SetPCISR_DRDY(value uint32) {
	volatile.StoreUint32(&o.PCISR.Reg, volatile.LoadUint32(&o.PCISR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPCISR_DRDY() uint32 {
	return volatile.LoadUint32(&o.PCISR.Reg) & 0x1
}
func (o *PIO_Type) SetPCISR_OVRE(value uint32) {
	volatile.StoreUint32(&o.PCISR.Reg, volatile.LoadUint32(&o.PCISR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPCISR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.PCISR.Reg) & 0x2) >> 1
}

// PIO.PCRHR: Parallel Capture Reception Holding Register
func (o *PIO_Type) SetPCRHR(value uint32) {
	volatile.StoreUint32(&o.PCRHR.Reg, value)
}
func (o *PIO_Type) GetPCRHR() uint32 {
	return volatile.LoadUint32(&o.PCRHR.Reg)
}

// Power Management Controller
type PMC_Type struct {
	SCER       volatile.Register32 // 0x0
	SCDR       volatile.Register32 // 0x4
	SCSR       volatile.Register32 // 0x8
	_          [4]byte
	PCER0      volatile.Register32 // 0x10
	PCDR0      volatile.Register32 // 0x14
	PCSR0      volatile.Register32 // 0x18
	CKGR_UCKR  volatile.Register32 // 0x1C
	CKGR_MOR   volatile.Register32 // 0x20
	CKGR_MCFR  volatile.Register32 // 0x24
	CKGR_PLLAR volatile.Register32 // 0x28
	_          [4]byte
	MCKR       volatile.Register32 // 0x30
	_          [4]byte
	USB        volatile.Register32 // 0x38
	_          [4]byte
	PCK        [8]volatile.Register32 // 0x40
	IER        volatile.Register32    // 0x60
	IDR        volatile.Register32    // 0x64
	SR         volatile.Register32    // 0x68
	IMR        volatile.Register32    // 0x6C
	FSMR       volatile.Register32    // 0x70
	FSPR       volatile.Register32    // 0x74
	FOCR       volatile.Register32    // 0x78
	_          [104]byte
	WPMR       volatile.Register32 // 0xE4
	WPSR       volatile.Register32 // 0xE8
	_          [20]byte
	PCER1      volatile.Register32 // 0x100
	PCDR1      volatile.Register32 // 0x104
	PCSR1      volatile.Register32 // 0x108
	PCR        volatile.Register32 // 0x10C
	OCR        volatile.Register32 // 0x110
	SLPWK_ER0  volatile.Register32 // 0x114
	SLPWK_DR0  volatile.Register32 // 0x118
	SLPWK_SR0  volatile.Register32 // 0x11C
	SLPWK_ASR0 volatile.Register32 // 0x120
	_          [12]byte
	PMMR       volatile.Register32 // 0x130
	SLPWK_ER1  volatile.Register32 // 0x134
	SLPWK_DR1  volatile.Register32 // 0x138
	SLPWK_SR1  volatile.Register32 // 0x13C
	SLPWK_ASR1 volatile.Register32 // 0x140
	SLPWK_AIPR volatile.Register32 // 0x144
}

// PMC.SCER: System Clock Enable Register
func (o *PMC_Type) SetSCER_USBCLK(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSCER_USBCLK() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSCER_PCK0(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSCER_PCK0() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSCER_PCK1(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSCER_PCK1() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSCER_PCK2(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSCER_PCK2() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSCER_PCK3(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSCER_PCK3() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSCER_PCK4(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSCER_PCK4() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSCER_PCK5(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSCER_PCK5() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSCER_PCK6(value uint32) {
	volatile.StoreUint32(&o.SCER.Reg, volatile.LoadUint32(&o.SCER.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSCER_PCK6() uint32 {
	return (volatile.LoadUint32(&o.SCER.Reg) & 0x4000) >> 14
}

// PMC.SCDR: System Clock Disable Register
func (o *PMC_Type) SetSCDR_USBCLK(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSCDR_USBCLK() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSCDR_PCK0(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSCDR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSCDR_PCK1(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSCDR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSCDR_PCK2(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSCDR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSCDR_PCK3(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSCDR_PCK3() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSCDR_PCK4(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSCDR_PCK4() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSCDR_PCK5(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSCDR_PCK5() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSCDR_PCK6(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSCDR_PCK6() uint32 {
	return (volatile.LoadUint32(&o.SCDR.Reg) & 0x4000) >> 14
}

// PMC.SCSR: System Clock Status Register
func (o *PMC_Type) SetSCSR_HCLKS(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSCSR_HCLKS() uint32 {
	return volatile.LoadUint32(&o.SCSR.Reg) & 0x1
}
func (o *PMC_Type) SetSCSR_USBCLK(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSCSR_USBCLK() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSCSR_PCK0(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSCSR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSCSR_PCK1(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSCSR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSCSR_PCK2(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSCSR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSCSR_PCK3(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSCSR_PCK3() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSCSR_PCK4(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSCSR_PCK4() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSCSR_PCK5(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSCSR_PCK5() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSCSR_PCK6(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSCSR_PCK6() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x4000) >> 14
}

// PMC.PCER0: Peripheral Clock Enable Register 0
func (o *PMC_Type) SetPCER0_PID7(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCER0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCER0_PID8(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCER0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCER0_PID9(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCER0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCER0_PID10(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCER0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCER0_PID11(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCER0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCER0_PID12(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCER0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCER0_PID13(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCER0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCER0_PID14(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCER0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCER0_PID15(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCER0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCER0_PID16(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCER0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCER0_PID17(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCER0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCER0_PID18(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCER0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCER0_PID19(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCER0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCER0_PID20(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCER0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCER0_PID21(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCER0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCER0_PID22(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPCER0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPCER0_PID23(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPCER0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPCER0_PID24(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCER0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCER0_PID25(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCER0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCER0_PID26(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCER0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCER0_PID27(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCER0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCER0_PID28(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCER0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPCER0_PID29(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPCER0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPCER0_PID30(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPCER0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPCER0_PID31(value uint32) {
	volatile.StoreUint32(&o.PCER0.Reg, volatile.LoadUint32(&o.PCER0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPCER0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PCER0.Reg) & 0x80000000) >> 31
}

// PMC.PCDR0: Peripheral Clock Disable Register 0
func (o *PMC_Type) SetPCDR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCDR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCDR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCDR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCDR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCDR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCDR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCDR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCDR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCDR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCDR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCDR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCDR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCDR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCDR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCDR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCDR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCDR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCDR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCDR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCDR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCDR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCDR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCDR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCDR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCDR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCDR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCDR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCDR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCDR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCDR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPCDR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPCDR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPCDR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPCDR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCDR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCDR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCDR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCDR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCDR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCDR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCDR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCDR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCDR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPCDR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPCDR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPCDR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPCDR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPCDR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PCDR0.Reg, volatile.LoadUint32(&o.PCDR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPCDR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PCDR0.Reg) & 0x80000000) >> 31
}

// PMC.PCSR0: Peripheral Clock Status Register 0
func (o *PMC_Type) SetPCSR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCSR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCSR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCSR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCSR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCSR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCSR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCSR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCSR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCSR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCSR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCSR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCSR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCSR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCSR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCSR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCSR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCSR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCSR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCSR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCSR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCSR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCSR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCSR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCSR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCSR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCSR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCSR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCSR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCSR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCSR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPCSR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPCSR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPCSR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPCSR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCSR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCSR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCSR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCSR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCSR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCSR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCSR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCSR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCSR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPCSR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPCSR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPCSR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPCSR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPCSR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PCSR0.Reg, volatile.LoadUint32(&o.PCSR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPCSR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PCSR0.Reg) & 0x80000000) >> 31
}

// PMC.CKGR_UCKR: UTMI Clock Register
func (o *PMC_Type) SetCKGR_UCKR_UPLLEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetCKGR_UCKR_UPLLCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf00000)|value<<20)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf00000) >> 20
}

// PMC.CKGR_MOR: Main Oscillator Register
func (o *PMC_Type) SetCKGR_MOR_MOSCXTEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTEN() uint32 {
	return volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTBY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTBY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetCKGR_MOR_WAITMODE(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetCKGR_MOR_WAITMODE() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetCKGR_MOR_MOSCRCEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCRCEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetCKGR_MOR_MOSCRCF(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCRCF() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x70) >> 4
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTST(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff00)|value<<8)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTST() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff00) >> 8
}
func (o *PMC_Type) SetCKGR_MOR_KEY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MOR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff0000) >> 16
}
func (o *PMC_Type) SetCKGR_MOR_MOSCSEL(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCSEL() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_MOR_CFDEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetCKGR_MOR_CFDEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetCKGR_MOR_XT32KFME(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetCKGR_MOR_XT32KFME() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x4000000) >> 26
}

// PMC.CKGR_MCFR: Main Clock Frequency Register
func (o *PMC_Type) SetCKGR_MCFR_MAINF(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0xffff)|value)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINF() uint32 {
	return volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0xffff
}
func (o *PMC_Type) SetCKGR_MCFR_MAINFRDY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINFRDY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetCKGR_MCFR_RCMEAS(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetCKGR_MCFR_RCMEAS() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetCKGR_MCFR_CCSS(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_MCFR_CCSS() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x1000000) >> 24
}

// PMC.CKGR_PLLAR: PLLA Register
func (o *PMC_Type) SetCKGR_PLLAR_DIVA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xff)|value)
}
func (o *PMC_Type) GetCKGR_PLLAR_DIVA() uint32 {
	return volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xff
}
func (o *PMC_Type) SetCKGR_PLLAR_PLLACOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x3f00)|value<<8)
}
func (o *PMC_Type) GetCKGR_PLLAR_PLLACOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x3f00) >> 8
}
func (o *PMC_Type) SetCKGR_PLLAR_MULA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_PLLAR_MULA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x7ff0000) >> 16
}
func (o *PMC_Type) SetCKGR_PLLAR_ONE(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetCKGR_PLLAR_ONE() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x20000000) >> 29
}

// PMC.MCKR: Master Clock Register
func (o *PMC_Type) SetMCKR_CSS(value uint32) {
	volatile.StoreUint32(&o.MCKR.Reg, volatile.LoadUint32(&o.MCKR.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetMCKR_CSS() uint32 {
	return volatile.LoadUint32(&o.MCKR.Reg) & 0x3
}
func (o *PMC_Type) SetMCKR_PRES(value uint32) {
	volatile.StoreUint32(&o.MCKR.Reg, volatile.LoadUint32(&o.MCKR.Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetMCKR_PRES() uint32 {
	return (volatile.LoadUint32(&o.MCKR.Reg) & 0x70) >> 4
}
func (o *PMC_Type) SetMCKR_MDIV(value uint32) {
	volatile.StoreUint32(&o.MCKR.Reg, volatile.LoadUint32(&o.MCKR.Reg)&^(0x300)|value<<8)
}
func (o *PMC_Type) GetMCKR_MDIV() uint32 {
	return (volatile.LoadUint32(&o.MCKR.Reg) & 0x300) >> 8
}
func (o *PMC_Type) SetMCKR_UPLLDIV2(value uint32) {
	volatile.StoreUint32(&o.MCKR.Reg, volatile.LoadUint32(&o.MCKR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetMCKR_UPLLDIV2() uint32 {
	return (volatile.LoadUint32(&o.MCKR.Reg) & 0x2000) >> 13
}

// PMC.USB: USB Clock Register
func (o *PMC_Type) SetUSB_USBS(value uint32) {
	volatile.StoreUint32(&o.USB.Reg, volatile.LoadUint32(&o.USB.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetUSB_USBS() uint32 {
	return volatile.LoadUint32(&o.USB.Reg) & 0x1
}
func (o *PMC_Type) SetUSB_USBDIV(value uint32) {
	volatile.StoreUint32(&o.USB.Reg, volatile.LoadUint32(&o.USB.Reg)&^(0xf00)|value<<8)
}
func (o *PMC_Type) GetUSB_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.USB.Reg) & 0xf00) >> 8
}

// PMC.PCK: Programmable Clock Register
func (o *PMC_Type) SetPCK_CSS(idx int, value uint32) {
	volatile.StoreUint32(&o.PCK[idx].Reg, volatile.LoadUint32(&o.PCK[idx].Reg)&^(0x7)|value)
}
func (o *PMC_Type) GetPCK_CSS(idx int) uint32 {
	return volatile.LoadUint32(&o.PCK[idx].Reg) & 0x7
}
func (o *PMC_Type) SetPCK_PRES(idx int, value uint32) {
	volatile.StoreUint32(&o.PCK[idx].Reg, volatile.LoadUint32(&o.PCK[idx].Reg)&^(0xff0)|value<<4)
}
func (o *PMC_Type) GetPCK_PRES(idx int) uint32 {
	return (volatile.LoadUint32(&o.PCK[idx].Reg) & 0xff0) >> 4
}

// PMC.IER: Interrupt Enable Register
func (o *PMC_Type) SetIER_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetIER_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PMC_Type) SetIER_LOCKA(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetIER_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetIER_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetIER_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetIER_LOCKU(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetIER_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetIER_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetIER_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetIER_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetIER_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetIER_PCKRDY2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetIER_PCKRDY2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetIER_PCKRDY3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetIER_PCKRDY3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetIER_PCKRDY4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetIER_PCKRDY4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetIER_PCKRDY5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetIER_PCKRDY5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetIER_PCKRDY6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetIER_PCKRDY6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetIER_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetIER_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetIER_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetIER_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetIER_CFDEV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetIER_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetIER_XT32KERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetIER_XT32KERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}

// PMC.IDR: Interrupt Disable Register
func (o *PMC_Type) SetIDR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetIDR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PMC_Type) SetIDR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetIDR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetIDR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetIDR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetIDR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetIDR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetIDR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetIDR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetIDR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetIDR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetIDR_PCKRDY2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetIDR_PCKRDY2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetIDR_PCKRDY3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetIDR_PCKRDY3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetIDR_PCKRDY4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetIDR_PCKRDY4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetIDR_PCKRDY5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetIDR_PCKRDY5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetIDR_PCKRDY6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetIDR_PCKRDY6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetIDR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetIDR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetIDR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetIDR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetIDR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetIDR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetIDR_XT32KERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetIDR_XT32KERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}

// PMC.SR: Status Register
func (o *PMC_Type) SetSR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *PMC_Type) SetSR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetSR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetSR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetSR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetSR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetSR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetSR_OSCSELS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSR_OSCSELS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSR_PCKRDY2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSR_PCKRDY2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSR_PCKRDY3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSR_PCKRDY3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSR_PCKRDY4(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSR_PCKRDY4() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSR_PCKRDY5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSR_PCKRDY5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSR_PCKRDY6(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSR_PCKRDY6() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSR_CFDS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSR_CFDS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSR_FOS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSR_FOS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSR_XT32KERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSR_XT32KERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}

// PMC.IMR: Interrupt Mask Register
func (o *PMC_Type) SetIMR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetIMR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PMC_Type) SetIMR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetIMR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetIMR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetIMR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetIMR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetIMR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetIMR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetIMR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetIMR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetIMR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetIMR_PCKRDY2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetIMR_PCKRDY2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetIMR_PCKRDY3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetIMR_PCKRDY3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetIMR_PCKRDY4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetIMR_PCKRDY4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetIMR_PCKRDY5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetIMR_PCKRDY5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetIMR_PCKRDY6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetIMR_PCKRDY6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetIMR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetIMR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetIMR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetIMR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetIMR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetIMR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetIMR_XT32KERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetIMR_XT32KERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}

// PMC.FSMR: Fast Startup Mode Register
func (o *PMC_Type) SetFSMR_FSTT0(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetFSMR_FSTT0() uint32 {
	return volatile.LoadUint32(&o.FSMR.Reg) & 0x1
}
func (o *PMC_Type) SetFSMR_FSTT1(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetFSMR_FSTT1() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetFSMR_FSTT2(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetFSMR_FSTT2() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetFSMR_FSTT3(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetFSMR_FSTT3() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetFSMR_FSTT4(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetFSMR_FSTT4() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetFSMR_FSTT5(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetFSMR_FSTT5() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetFSMR_FSTT6(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetFSMR_FSTT6() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetFSMR_FSTT7(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetFSMR_FSTT7() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetFSMR_FSTT8(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetFSMR_FSTT8() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetFSMR_FSTT9(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetFSMR_FSTT9() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetFSMR_FSTT10(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetFSMR_FSTT10() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetFSMR_FSTT11(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetFSMR_FSTT11() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetFSMR_FSTT12(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetFSMR_FSTT12() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetFSMR_FSTT13(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetFSMR_FSTT13() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetFSMR_FSTT14(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetFSMR_FSTT14() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetFSMR_FSTT15(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetFSMR_FSTT15() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetFSMR_RTTAL(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetFSMR_RTTAL() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetFSMR_RTCAL(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetFSMR_RTCAL() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetFSMR_USBAL(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetFSMR_USBAL() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetFSMR_LPM(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetFSMR_LPM() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetFSMR_FLPM(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x600000)|value<<21)
}
func (o *PMC_Type) GetFSMR_FLPM() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x600000) >> 21
}
func (o *PMC_Type) SetFSMR_FFLPM(value uint32) {
	volatile.StoreUint32(&o.FSMR.Reg, volatile.LoadUint32(&o.FSMR.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetFSMR_FFLPM() uint32 {
	return (volatile.LoadUint32(&o.FSMR.Reg) & 0x800000) >> 23
}

// PMC.FSPR: Fast Startup Polarity Register
func (o *PMC_Type) SetFSPR_FSTP0(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetFSPR_FSTP0() uint32 {
	return volatile.LoadUint32(&o.FSPR.Reg) & 0x1
}
func (o *PMC_Type) SetFSPR_FSTP1(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetFSPR_FSTP1() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetFSPR_FSTP2(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetFSPR_FSTP2() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetFSPR_FSTP3(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetFSPR_FSTP3() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetFSPR_FSTP4(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetFSPR_FSTP4() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetFSPR_FSTP5(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetFSPR_FSTP5() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetFSPR_FSTP6(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetFSPR_FSTP6() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetFSPR_FSTP7(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetFSPR_FSTP7() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetFSPR_FSTP8(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetFSPR_FSTP8() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetFSPR_FSTP9(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetFSPR_FSTP9() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetFSPR_FSTP10(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetFSPR_FSTP10() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetFSPR_FSTP11(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetFSPR_FSTP11() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetFSPR_FSTP12(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetFSPR_FSTP12() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetFSPR_FSTP13(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetFSPR_FSTP13() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetFSPR_FSTP14(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetFSPR_FSTP14() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetFSPR_FSTP15(value uint32) {
	volatile.StoreUint32(&o.FSPR.Reg, volatile.LoadUint32(&o.FSPR.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetFSPR_FSTP15() uint32 {
	return (volatile.LoadUint32(&o.FSPR.Reg) & 0x8000) >> 15
}

// PMC.FOCR: Fault Output Clear Register
func (o *PMC_Type) SetFOCR_FOCLR(value uint32) {
	volatile.StoreUint32(&o.FOCR.Reg, volatile.LoadUint32(&o.FOCR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetFOCR_FOCLR() uint32 {
	return volatile.LoadUint32(&o.FOCR.Reg) & 0x1
}

// PMC.WPMR: Write Protection Mode Register
func (o *PMC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PMC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PMC.WPSR: Write Protection Status Register
func (o *PMC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PMC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PMC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// PMC.PCER1: Peripheral Clock Enable Register 1
func (o *PMC_Type) SetPCER1_PID32(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPCER1_PID32() uint32 {
	return volatile.LoadUint32(&o.PCER1.Reg) & 0x1
}
func (o *PMC_Type) SetPCER1_PID33(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPCER1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPCER1_PID34(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPCER1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPCER1_PID35(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPCER1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPCER1_PID37(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPCER1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPCER1_PID39(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCER1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCER1_PID40(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCER1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCER1_PID41(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCER1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCER1_PID42(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCER1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCER1_PID43(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCER1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCER1_PID44(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCER1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCER1_PID45(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCER1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCER1_PID46(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCER1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCER1_PID47(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCER1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCER1_PID48(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCER1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCER1_PID49(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCER1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCER1_PID50(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCER1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCER1_PID51(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCER1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCER1_PID52(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCER1_PID52() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCER1_PID53(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCER1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCER1_PID56(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCER1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCER1_PID57(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCER1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCER1_PID58(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCER1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCER1_PID59(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCER1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCER1_PID60(value uint32) {
	volatile.StoreUint32(&o.PCER1.Reg, volatile.LoadUint32(&o.PCER1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCER1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PCER1.Reg) & 0x10000000) >> 28
}

// PMC.PCDR1: Peripheral Clock Disable Register 1
func (o *PMC_Type) SetPCDR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPCDR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PCDR1.Reg) & 0x1
}
func (o *PMC_Type) SetPCDR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPCDR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPCDR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPCDR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPCDR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPCDR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPCDR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPCDR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPCDR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCDR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCDR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCDR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCDR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCDR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCDR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCDR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCDR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCDR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCDR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCDR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCDR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCDR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCDR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCDR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCDR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCDR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCDR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCDR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCDR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCDR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCDR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCDR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCDR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCDR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCDR1_PID52(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCDR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCDR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCDR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCDR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCDR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCDR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCDR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCDR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCDR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCDR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCDR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCDR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PCDR1.Reg, volatile.LoadUint32(&o.PCDR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCDR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PCDR1.Reg) & 0x10000000) >> 28
}

// PMC.PCSR1: Peripheral Clock Status Register 1
func (o *PMC_Type) SetPCSR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPCSR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PCSR1.Reg) & 0x1
}
func (o *PMC_Type) SetPCSR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPCSR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPCSR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPCSR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPCSR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPCSR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPCSR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPCSR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPCSR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPCSR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPCSR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPCSR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPCSR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPCSR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPCSR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPCSR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPCSR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPCSR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPCSR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCSR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCSR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPCSR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPCSR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPCSR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPCSR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPCSR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPCSR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPCSR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPCSR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPCSR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPCSR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPCSR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPCSR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPCSR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPCSR1_PID52(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPCSR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPCSR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPCSR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPCSR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPCSR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPCSR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPCSR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPCSR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPCSR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPCSR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPCSR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPCSR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PCSR1.Reg, volatile.LoadUint32(&o.PCSR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCSR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PCSR1.Reg) & 0x10000000) >> 28
}

// PMC.PCR: Peripheral Control Register
func (o *PMC_Type) SetPCR_PID(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x7f)|value)
}
func (o *PMC_Type) GetPCR_PID() uint32 {
	return volatile.LoadUint32(&o.PCR.Reg) & 0x7f
}
func (o *PMC_Type) SetPCR_GCLKCSS(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x700)|value<<8)
}
func (o *PMC_Type) GetPCR_GCLKCSS() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x700) >> 8
}
func (o *PMC_Type) SetPCR_CMD(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPCR_CMD() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPCR_GCLKDIV(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0xff00000)|value<<20)
}
func (o *PMC_Type) GetPCR_GCLKDIV() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0xff00000) >> 20
}
func (o *PMC_Type) SetPCR_EN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPCR_EN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPCR_GCLKEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPCR_GCLKEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x20000000) >> 29
}

// PMC.OCR: Oscillator Calibration Register
func (o *PMC_Type) SetOCR_CAL4(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x7f)|value)
}
func (o *PMC_Type) GetOCR_CAL4() uint32 {
	return volatile.LoadUint32(&o.OCR.Reg) & 0x7f
}
func (o *PMC_Type) SetOCR_SEL4(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetOCR_SEL4() uint32 {
	return (volatile.LoadUint32(&o.OCR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetOCR_CAL8(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x7f00)|value<<8)
}
func (o *PMC_Type) GetOCR_CAL8() uint32 {
	return (volatile.LoadUint32(&o.OCR.Reg) & 0x7f00) >> 8
}
func (o *PMC_Type) SetOCR_SEL8(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetOCR_SEL8() uint32 {
	return (volatile.LoadUint32(&o.OCR.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetOCR_CAL12(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x7f0000)|value<<16)
}
func (o *PMC_Type) GetOCR_CAL12() uint32 {
	return (volatile.LoadUint32(&o.OCR.Reg) & 0x7f0000) >> 16
}
func (o *PMC_Type) SetOCR_SEL12(value uint32) {
	volatile.StoreUint32(&o.OCR.Reg, volatile.LoadUint32(&o.OCR.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetOCR_SEL12() uint32 {
	return (volatile.LoadUint32(&o.OCR.Reg) & 0x800000) >> 23
}

// PMC.SLPWK_ER0: SleepWalking Enable Register 0
func (o *PMC_Type) SetSLPWK_ER0_PID7(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_ER0_PID7() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_ER0_PID8(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_ER0_PID8() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_ER0_PID9(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_ER0_PID9() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_ER0_PID10(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_ER0_PID10() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_ER0_PID11(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_ER0_PID11() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_ER0_PID12(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_ER0_PID12() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_ER0_PID13(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_ER0_PID13() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_ER0_PID14(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_ER0_PID14() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_ER0_PID15(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_ER0_PID15() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_ER0_PID16(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_ER0_PID16() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_ER0_PID17(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_ER0_PID17() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_ER0_PID18(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_ER0_PID18() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_ER0_PID19(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_ER0_PID19() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_ER0_PID20(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_ER0_PID20() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_ER0_PID21(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_ER0_PID21() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_ER0_PID22(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetSLPWK_ER0_PID22() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetSLPWK_ER0_PID23(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetSLPWK_ER0_PID23() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetSLPWK_ER0_PID24(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_ER0_PID24() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_ER0_PID25(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_ER0_PID25() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_ER0_PID26(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_ER0_PID26() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_ER0_PID27(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_ER0_PID27() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_ER0_PID28(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_ER0_PID28() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetSLPWK_ER0_PID29(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetSLPWK_ER0_PID29() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetSLPWK_ER0_PID30(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetSLPWK_ER0_PID30() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetSLPWK_ER0_PID31(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER0.Reg, volatile.LoadUint32(&o.SLPWK_ER0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetSLPWK_ER0_PID31() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER0.Reg) & 0x80000000) >> 31
}

// PMC.SLPWK_DR0: SleepWalking Disable Register 0
func (o *PMC_Type) SetSLPWK_DR0_PID7(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_DR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_DR0_PID8(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_DR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_DR0_PID9(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_DR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_DR0_PID10(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_DR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_DR0_PID11(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_DR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_DR0_PID12(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_DR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_DR0_PID13(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_DR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_DR0_PID14(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_DR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_DR0_PID15(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_DR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_DR0_PID16(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_DR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_DR0_PID17(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_DR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_DR0_PID18(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_DR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_DR0_PID19(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_DR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_DR0_PID20(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_DR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_DR0_PID21(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_DR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_DR0_PID22(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetSLPWK_DR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetSLPWK_DR0_PID23(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetSLPWK_DR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetSLPWK_DR0_PID24(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_DR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_DR0_PID25(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_DR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_DR0_PID26(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_DR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_DR0_PID27(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_DR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_DR0_PID28(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_DR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetSLPWK_DR0_PID29(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetSLPWK_DR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetSLPWK_DR0_PID30(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetSLPWK_DR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetSLPWK_DR0_PID31(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR0.Reg, volatile.LoadUint32(&o.SLPWK_DR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetSLPWK_DR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR0.Reg) & 0x80000000) >> 31
}

// PMC.SLPWK_SR0: SleepWalking Status Register 0
func (o *PMC_Type) SetSLPWK_SR0_PID7(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_SR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_SR0_PID8(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_SR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_SR0_PID9(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_SR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_SR0_PID10(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_SR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_SR0_PID11(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_SR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_SR0_PID12(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_SR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_SR0_PID13(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_SR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_SR0_PID14(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_SR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_SR0_PID15(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_SR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_SR0_PID16(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_SR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_SR0_PID17(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_SR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_SR0_PID18(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_SR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_SR0_PID19(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_SR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_SR0_PID20(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_SR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_SR0_PID21(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_SR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_SR0_PID22(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetSLPWK_SR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetSLPWK_SR0_PID23(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetSLPWK_SR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetSLPWK_SR0_PID24(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_SR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_SR0_PID25(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_SR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_SR0_PID26(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_SR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_SR0_PID27(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_SR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_SR0_PID28(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_SR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetSLPWK_SR0_PID29(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetSLPWK_SR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetSLPWK_SR0_PID30(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetSLPWK_SR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetSLPWK_SR0_PID31(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR0.Reg, volatile.LoadUint32(&o.SLPWK_SR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetSLPWK_SR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR0.Reg) & 0x80000000) >> 31
}

// PMC.SLPWK_ASR0: SleepWalking Activity Status Register 0
func (o *PMC_Type) SetSLPWK_ASR0_PID7(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_ASR0_PID8(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_ASR0_PID9(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_ASR0_PID10(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_ASR0_PID11(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_ASR0_PID12(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_ASR0_PID13(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_ASR0_PID14(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_ASR0_PID15(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_ASR0_PID16(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_ASR0_PID17(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_ASR0_PID18(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_ASR0_PID19(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_ASR0_PID20(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_ASR0_PID21(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_ASR0_PID22(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetSLPWK_ASR0_PID23(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetSLPWK_ASR0_PID24(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_ASR0_PID25(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_ASR0_PID26(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_ASR0_PID27(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_ASR0_PID28(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetSLPWK_ASR0_PID29(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetSLPWK_ASR0_PID30(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetSLPWK_ASR0_PID31(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR0.Reg, volatile.LoadUint32(&o.SLPWK_ASR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetSLPWK_ASR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR0.Reg) & 0x80000000) >> 31
}

// PMC.PMMR: PLL Maximum Multiplier Value Register
func (o *PMC_Type) SetPMMR_PLLA_MMAX(value uint32) {
	volatile.StoreUint32(&o.PMMR.Reg, volatile.LoadUint32(&o.PMMR.Reg)&^(0x7ff)|value)
}
func (o *PMC_Type) GetPMMR_PLLA_MMAX() uint32 {
	return volatile.LoadUint32(&o.PMMR.Reg) & 0x7ff
}

// PMC.SLPWK_ER1: SleepWalking Enable Register 1
func (o *PMC_Type) SetSLPWK_ER1_PID32(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSLPWK_ER1_PID32() uint32 {
	return volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x1
}
func (o *PMC_Type) SetSLPWK_ER1_PID33(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetSLPWK_ER1_PID33() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetSLPWK_ER1_PID34(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetSLPWK_ER1_PID34() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetSLPWK_ER1_PID35(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetSLPWK_ER1_PID35() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetSLPWK_ER1_PID37(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSLPWK_ER1_PID37() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSLPWK_ER1_PID39(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_ER1_PID39() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_ER1_PID40(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_ER1_PID40() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_ER1_PID41(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_ER1_PID41() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_ER1_PID42(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_ER1_PID42() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_ER1_PID43(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_ER1_PID43() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_ER1_PID44(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_ER1_PID44() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_ER1_PID45(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_ER1_PID45() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_ER1_PID46(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_ER1_PID46() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_ER1_PID47(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_ER1_PID47() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_ER1_PID48(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_ER1_PID48() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_ER1_PID49(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_ER1_PID49() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_ER1_PID50(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_ER1_PID50() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_ER1_PID51(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_ER1_PID51() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_ER1_PID52(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_ER1_PID52() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_ER1_PID53(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_ER1_PID53() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_ER1_PID56(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_ER1_PID56() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_ER1_PID57(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_ER1_PID57() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_ER1_PID58(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_ER1_PID58() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_ER1_PID59(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_ER1_PID59() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_ER1_PID60(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ER1.Reg, volatile.LoadUint32(&o.SLPWK_ER1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_ER1_PID60() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ER1.Reg) & 0x10000000) >> 28
}

// PMC.SLPWK_DR1: SleepWalking Disable Register 1
func (o *PMC_Type) SetSLPWK_DR1_PID32(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSLPWK_DR1_PID32() uint32 {
	return volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x1
}
func (o *PMC_Type) SetSLPWK_DR1_PID33(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetSLPWK_DR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetSLPWK_DR1_PID34(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetSLPWK_DR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetSLPWK_DR1_PID35(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetSLPWK_DR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetSLPWK_DR1_PID37(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSLPWK_DR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSLPWK_DR1_PID39(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_DR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_DR1_PID40(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_DR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_DR1_PID41(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_DR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_DR1_PID42(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_DR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_DR1_PID43(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_DR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_DR1_PID44(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_DR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_DR1_PID45(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_DR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_DR1_PID46(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_DR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_DR1_PID47(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_DR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_DR1_PID48(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_DR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_DR1_PID49(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_DR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_DR1_PID50(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_DR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_DR1_PID51(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_DR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_DR1_PID52(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_DR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_DR1_PID53(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_DR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_DR1_PID56(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_DR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_DR1_PID57(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_DR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_DR1_PID58(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_DR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_DR1_PID59(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_DR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_DR1_PID60(value uint32) {
	volatile.StoreUint32(&o.SLPWK_DR1.Reg, volatile.LoadUint32(&o.SLPWK_DR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_DR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_DR1.Reg) & 0x10000000) >> 28
}

// PMC.SLPWK_SR1: SleepWalking Status Register 1
func (o *PMC_Type) SetSLPWK_SR1_PID32(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSLPWK_SR1_PID32() uint32 {
	return volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x1
}
func (o *PMC_Type) SetSLPWK_SR1_PID33(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetSLPWK_SR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetSLPWK_SR1_PID34(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetSLPWK_SR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetSLPWK_SR1_PID35(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetSLPWK_SR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetSLPWK_SR1_PID37(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSLPWK_SR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSLPWK_SR1_PID39(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_SR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_SR1_PID40(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_SR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_SR1_PID41(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_SR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_SR1_PID42(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_SR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_SR1_PID43(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_SR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_SR1_PID44(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_SR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_SR1_PID45(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_SR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_SR1_PID46(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_SR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_SR1_PID47(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_SR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_SR1_PID48(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_SR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_SR1_PID49(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_SR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_SR1_PID50(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_SR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_SR1_PID51(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_SR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_SR1_PID52(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_SR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_SR1_PID53(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_SR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_SR1_PID56(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_SR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_SR1_PID57(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_SR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_SR1_PID58(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_SR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_SR1_PID59(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_SR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_SR1_PID60(value uint32) {
	volatile.StoreUint32(&o.SLPWK_SR1.Reg, volatile.LoadUint32(&o.SLPWK_SR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_SR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_SR1.Reg) & 0x10000000) >> 28
}

// PMC.SLPWK_ASR1: SleepWalking Activity Status Register 1
func (o *PMC_Type) SetSLPWK_ASR1_PID32(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID32() uint32 {
	return volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x1
}
func (o *PMC_Type) SetSLPWK_ASR1_PID33(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetSLPWK_ASR1_PID34(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetSLPWK_ASR1_PID35(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetSLPWK_ASR1_PID37(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetSLPWK_ASR1_PID39(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetSLPWK_ASR1_PID40(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetSLPWK_ASR1_PID41(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetSLPWK_ASR1_PID42(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetSLPWK_ASR1_PID43(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetSLPWK_ASR1_PID44(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetSLPWK_ASR1_PID45(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetSLPWK_ASR1_PID46(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetSLPWK_ASR1_PID47(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetSLPWK_ASR1_PID48(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetSLPWK_ASR1_PID49(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetSLPWK_ASR1_PID50(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetSLPWK_ASR1_PID51(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetSLPWK_ASR1_PID52(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetSLPWK_ASR1_PID53(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetSLPWK_ASR1_PID56(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetSLPWK_ASR1_PID57(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetSLPWK_ASR1_PID58(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetSLPWK_ASR1_PID59(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetSLPWK_ASR1_PID60(value uint32) {
	volatile.StoreUint32(&o.SLPWK_ASR1.Reg, volatile.LoadUint32(&o.SLPWK_ASR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetSLPWK_ASR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.SLPWK_ASR1.Reg) & 0x10000000) >> 28
}

// PMC.SLPWK_AIPR: SleepWalking Activity In Progress Register
func (o *PMC_Type) SetSLPWK_AIPR_AIP(value uint32) {
	volatile.StoreUint32(&o.SLPWK_AIPR.Reg, volatile.LoadUint32(&o.SLPWK_AIPR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetSLPWK_AIPR_AIP() uint32 {
	return volatile.LoadUint32(&o.SLPWK_AIPR.Reg) & 0x1
}

// Pulse Width Modulation Controller
type PWM_Type struct {
	CLK        volatile.Register32 // 0x0
	ENA        volatile.Register32 // 0x4
	DIS        volatile.Register32 // 0x8
	SR         volatile.Register32 // 0xC
	IER1       volatile.Register32 // 0x10
	IDR1       volatile.Register32 // 0x14
	IMR1       volatile.Register32 // 0x18
	ISR1       volatile.Register32 // 0x1C
	SCM        volatile.Register32 // 0x20
	DMAR       volatile.Register32 // 0x24
	SCUC       volatile.Register32 // 0x28
	SCUP       volatile.Register32 // 0x2C
	SCUPUPD    volatile.Register32 // 0x30
	IER2       volatile.Register32 // 0x34
	IDR2       volatile.Register32 // 0x38
	IMR2       volatile.Register32 // 0x3C
	ISR2       volatile.Register32 // 0x40
	OOV        volatile.Register32 // 0x44
	OS         volatile.Register32 // 0x48
	OSS        volatile.Register32 // 0x4C
	OSC        volatile.Register32 // 0x50
	OSSUPD     volatile.Register32 // 0x54
	OSCUPD     volatile.Register32 // 0x58
	FMR        volatile.Register32 // 0x5C
	FSR        volatile.Register32 // 0x60
	FCR        volatile.Register32 // 0x64
	FPV1       volatile.Register32 // 0x68
	FPE        volatile.Register32 // 0x6C
	_          [12]byte
	ELMR       [2]volatile.Register32 // 0x7C
	_          [28]byte
	SSPR       volatile.Register32 // 0xA0
	SSPUP      volatile.Register32 // 0xA4
	_          [8]byte
	SMMR       volatile.Register32 // 0xB0
	_          [12]byte
	FPV2       volatile.Register32 // 0xC0
	_          [32]byte
	WPCR       volatile.Register32 // 0xE4
	WPSR       volatile.Register32 // 0xE8
	_          [68]byte
	PWM_CMP    [8]PWM_PWM_CMP_Type // 0x130
	_          [80]byte
	PWM_CH_NUM [4]PWM_PWM_CH_NUM_Type // 0x200
	_          [384]byte
	CMUPD0     volatile.Register32 // 0x400
	_          [28]byte
	CMUPD1     volatile.Register32 // 0x420
	_          [8]byte
	ETRG1      volatile.Register32 // 0x42C
	LEBR1      volatile.Register32 // 0x430
	_          [12]byte
	CMUPD2     volatile.Register32 // 0x440
	_          [8]byte
	ETRG2      volatile.Register32 // 0x44C
	LEBR2      volatile.Register32 // 0x450
	_          [12]byte
	CMUPD3     volatile.Register32 // 0x460
}

// PWM.CLK: PWM Clock Register
func (o *PWM_Type) SetCLK_DIVA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetCLK_DIVA() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0xff
}
func (o *PWM_Type) SetCLK_PREA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCLK_PREA() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCLK_DIVB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetCLK_DIVB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetCLK_PREB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf000000)|value<<24)
}
func (o *PWM_Type) GetCLK_PREB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf000000) >> 24
}

// PWM.ENA: PWM Enable Register
func (o *PWM_Type) SetENA_CHID0(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENA_CHID0() uint32 {
	return volatile.LoadUint32(&o.ENA.Reg) & 0x1
}
func (o *PWM_Type) SetENA_CHID1(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetENA_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetENA_CHID2(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetENA_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetENA_CHID3(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetENA_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x8) >> 3
}

// PWM.DIS: PWM Disable Register
func (o *PWM_Type) SetDIS_CHID0(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetDIS_CHID0() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}
func (o *PWM_Type) SetDIS_CHID1(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetDIS_CHID1() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetDIS_CHID2(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetDIS_CHID2() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetDIS_CHID3(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetDIS_CHID3() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x8) >> 3
}

// PWM.SR: PWM Status Register
func (o *PWM_Type) SetSR_CHID0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSR_CHID0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *PWM_Type) SetSR_CHID1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSR_CHID2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSR_CHID3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}

// PWM.IER1: PWM Interrupt Enable Register 1
func (o *PWM_Type) SetIER1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *PWM_Type) SetIER1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIER1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIER1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIER1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIER1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80000) >> 19
}

// PWM.IDR1: PWM Interrupt Disable Register 1
func (o *PWM_Type) SetIDR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *PWM_Type) SetIDR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIDR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIDR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIDR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIDR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80000) >> 19
}

// PWM.IMR1: PWM Interrupt Mask Register 1
func (o *PWM_Type) SetIMR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *PWM_Type) SetIMR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIMR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIMR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIMR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIMR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000) >> 19
}

// PWM.ISR1: PWM Interrupt Status Register 1
func (o *PWM_Type) SetISR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg) & 0x1
}
func (o *PWM_Type) SetISR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetISR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetISR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetISR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetISR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x80000) >> 19
}

// PWM.SCM: PWM Sync Channels Mode Register
func (o *PWM_Type) SetSCM_SYNC0(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCM_SYNC0() uint32 {
	return volatile.LoadUint32(&o.SCM.Reg) & 0x1
}
func (o *PWM_Type) SetSCM_SYNC1(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSCM_SYNC1() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSCM_SYNC2(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSCM_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSCM_SYNC3(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSCM_SYNC3() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSCM_UPDM(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x30000)|value<<16)
}
func (o *PWM_Type) GetSCM_UPDM() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x30000) >> 16
}
func (o *PWM_Type) SetSCM_PTRM(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetSCM_PTRM() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetSCM_PTRCS(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0xe00000)|value<<21)
}
func (o *PWM_Type) GetSCM_PTRCS() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0xe00000) >> 21
}

// PWM.DMAR: PWM DMA Register
func (o *PWM_Type) SetDMAR_DMADUTY(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetDMAR_DMADUTY() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffffff
}

// PWM.SCUC: PWM Sync Channels Update Control Register
func (o *PWM_Type) SetSCUC_UPDULOCK(value uint32) {
	volatile.StoreUint32(&o.SCUC.Reg, volatile.LoadUint32(&o.SCUC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCUC_UPDULOCK() uint32 {
	return volatile.LoadUint32(&o.SCUC.Reg) & 0x1
}

// PWM.SCUP: PWM Sync Channels Update Period Register
func (o *PWM_Type) SetSCUP_UPR(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUP_UPR() uint32 {
	return volatile.LoadUint32(&o.SCUP.Reg) & 0xf
}
func (o *PWM_Type) SetSCUP_UPRCNT(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSCUP_UPRCNT() uint32 {
	return (volatile.LoadUint32(&o.SCUP.Reg) & 0xf0) >> 4
}

// PWM.SCUPUPD: PWM Sync Channels Update Period Update Register
func (o *PWM_Type) SetSCUPUPD_UPRUPD(value uint32) {
	volatile.StoreUint32(&o.SCUPUPD.Reg, volatile.LoadUint32(&o.SCUPUPD.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUPUPD_UPRUPD() uint32 {
	return volatile.LoadUint32(&o.SCUPUPD.Reg) & 0xf
}

// PWM.IER2: PWM Interrupt Enable Register 2
func (o *PWM_Type) SetIER2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *PWM_Type) SetIER2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIER2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIER2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIER2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIER2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIER2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIER2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIER2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIER2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIER2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIER2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIER2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIER2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIER2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIER2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIER2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIER2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIER2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIER2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIER2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIER2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIER2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIER2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIER2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIER2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800000) >> 23
}

// PWM.IDR2: PWM Interrupt Disable Register 2
func (o *PWM_Type) SetIDR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *PWM_Type) SetIDR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIDR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIDR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIDR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIDR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIDR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIDR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIDR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIDR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIDR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIDR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIDR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIDR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIDR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIDR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIDR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIDR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIDR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIDR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIDR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIDR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIDR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIDR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIDR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIDR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800000) >> 23
}

// PWM.IMR2: PWM Interrupt Mask Register 2
func (o *PWM_Type) SetIMR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *PWM_Type) SetIMR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIMR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIMR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIMR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIMR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIMR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIMR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIMR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIMR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIMR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIMR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIMR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIMR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIMR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIMR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIMR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIMR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIMR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIMR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIMR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIMR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIMR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIMR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIMR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIMR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800000) >> 23
}

// PWM.ISR2: PWM Interrupt Status Register 2
func (o *PWM_Type) SetISR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.ISR2.Reg) & 0x1
}
func (o *PWM_Type) SetISR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetISR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetISR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetISR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetISR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetISR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetISR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetISR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetISR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetISR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetISR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetISR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetISR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetISR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetISR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetISR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetISR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetISR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetISR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetISR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetISR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetISR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetISR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetISR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetISR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800000) >> 23
}

// PWM.OOV: PWM Output Override Value Register
func (o *PWM_Type) SetOOV_OOVH0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOOV_OOVH0() uint32 {
	return volatile.LoadUint32(&o.OOV.Reg) & 0x1
}
func (o *PWM_Type) SetOOV_OOVH1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOOV_OOVH1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOOV_OOVH2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOOV_OOVH2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOOV_OOVH3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOOV_OOVH3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOOV_OOVL0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOOV_OOVL0() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOOV_OOVL1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOOV_OOVL1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOOV_OOVL2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOOV_OOVL2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOOV_OOVL3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOOV_OOVL3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x80000) >> 19
}

// PWM.OS: PWM Output Selection Register
func (o *PWM_Type) SetOS_OSH0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOS_OSH0() uint32 {
	return volatile.LoadUint32(&o.OS.Reg) & 0x1
}
func (o *PWM_Type) SetOS_OSH1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOS_OSH1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOS_OSH2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOS_OSH2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOS_OSH3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOS_OSH3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOS_OSL0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOS_OSL0() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOS_OSL1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOS_OSL1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOS_OSL2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOS_OSL2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOS_OSL3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOS_OSL3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x80000) >> 19
}

// PWM.OSS: PWM Output Selection Set Register
func (o *PWM_Type) SetOSS_OSSH0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSS_OSSH0() uint32 {
	return volatile.LoadUint32(&o.OSS.Reg) & 0x1
}
func (o *PWM_Type) SetOSS_OSSH1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSS_OSSH1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSS_OSSH2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSS_OSSH2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSS_OSSH3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSS_OSSH3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSS_OSSL0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSS_OSSL0() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSS_OSSL1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSS_OSSL1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSS_OSSL2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSS_OSSL2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSS_OSSL3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSS_OSSL3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x80000) >> 19
}

// PWM.OSC: PWM Output Selection Clear Register
func (o *PWM_Type) SetOSC_OSCH0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSC_OSCH0() uint32 {
	return volatile.LoadUint32(&o.OSC.Reg) & 0x1
}
func (o *PWM_Type) SetOSC_OSCH1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSC_OSCH1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSC_OSCH2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSC_OSCH2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSC_OSCH3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSC_OSCH3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSC_OSCL0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSC_OSCL0() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSC_OSCL1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSC_OSCL1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSC_OSCL2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSC_OSCL2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSC_OSCL3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSC_OSCL3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x80000) >> 19
}

// PWM.OSSUPD: PWM Output Selection Set Update Register
func (o *PWM_Type) SetOSSUPD_OSSUPH0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH0() uint32 {
	return volatile.LoadUint32(&o.OSSUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSSUPD_OSSUPH3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSSUPD_OSSUPL0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSSUPD_OSSUPL1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSSUPD_OSSUPL2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSSUPD_OSSUPL3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x80000) >> 19
}

// PWM.OSCUPD: PWM Output Selection Clear Update Register
func (o *PWM_Type) SetOSCUPD_OSCUPH0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH0() uint32 {
	return volatile.LoadUint32(&o.OSCUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSCUPD_OSCUPH3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSCUPD_OSCUPL0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSCUPD_OSCUPL1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSCUPD_OSCUPL2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSCUPD_OSCUPL3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x80000) >> 19
}

// PWM.FMR: PWM Fault Mode Register
func (o *PWM_Type) SetFMR_FPOL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFMR_FPOL() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0xff
}
func (o *PWM_Type) SetFMR_FMOD(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFMR_FMOD() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFMR_FFIL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFMR_FFIL() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff0000) >> 16
}

// PWM.FSR: PWM Fault Status Register
func (o *PWM_Type) SetFSR_FIV(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFSR_FIV() uint32 {
	return volatile.LoadUint32(&o.FSR.Reg) & 0xff
}
func (o *PWM_Type) SetFSR_FS(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFSR_FS() uint32 {
	return (volatile.LoadUint32(&o.FSR.Reg) & 0xff00) >> 8
}

// PWM.FCR: PWM Fault Clear Register
func (o *PWM_Type) SetFCR_FCLR(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFCR_FCLR() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0xff
}

// PWM.FPV1: PWM Fault Protection Value Register 1
func (o *PWM_Type) SetFPV1_FPVH0(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetFPV1_FPVH0() uint32 {
	return volatile.LoadUint32(&o.FPV1.Reg) & 0x1
}
func (o *PWM_Type) SetFPV1_FPVH1(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetFPV1_FPVH1() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetFPV1_FPVH2(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetFPV1_FPVH2() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetFPV1_FPVH3(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetFPV1_FPVH3() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetFPV1_FPVL0(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetFPV1_FPVL0() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetFPV1_FPVL1(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetFPV1_FPVL1() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetFPV1_FPVL2(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetFPV1_FPVL2() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetFPV1_FPVL3(value uint32) {
	volatile.StoreUint32(&o.FPV1.Reg, volatile.LoadUint32(&o.FPV1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetFPV1_FPVL3() uint32 {
	return (volatile.LoadUint32(&o.FPV1.Reg) & 0x80000) >> 19
}

// PWM.FPE: PWM Fault Protection Enable Register
func (o *PWM_Type) SetFPE_FPE0(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFPE_FPE0() uint32 {
	return volatile.LoadUint32(&o.FPE.Reg) & 0xff
}
func (o *PWM_Type) SetFPE_FPE1(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFPE_FPE1() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFPE_FPE2(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFPE_FPE2() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetFPE_FPE3(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff000000)|value<<24)
}
func (o *PWM_Type) GetFPE_FPE3() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff000000) >> 24
}

// PWM.ELMR: PWM Event Line 0 Mode Register 0
func (o *PWM_Type) SetELMR_CSEL0(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetELMR_CSEL0(idx int) uint32 {
	return volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x1
}
func (o *PWM_Type) SetELMR_CSEL1(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetELMR_CSEL1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetELMR_CSEL2(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetELMR_CSEL2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetELMR_CSEL3(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetELMR_CSEL3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetELMR_CSEL4(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetELMR_CSEL4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetELMR_CSEL5(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetELMR_CSEL5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetELMR_CSEL6(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetELMR_CSEL6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetELMR_CSEL7(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetELMR_CSEL7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x80) >> 7
}

// PWM.SSPR: PWM Spread Spectrum Register
func (o *PWM_Type) SetSSPR_SPRD(value uint32) {
	volatile.StoreUint32(&o.SSPR.Reg, volatile.LoadUint32(&o.SSPR.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetSSPR_SPRD() uint32 {
	return volatile.LoadUint32(&o.SSPR.Reg) & 0xffffff
}
func (o *PWM_Type) SetSSPR_SPRDM(value uint32) {
	volatile.StoreUint32(&o.SSPR.Reg, volatile.LoadUint32(&o.SSPR.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetSSPR_SPRDM() uint32 {
	return (volatile.LoadUint32(&o.SSPR.Reg) & 0x1000000) >> 24
}

// PWM.SSPUP: PWM Spread Spectrum Update Register
func (o *PWM_Type) SetSSPUP_SPRDUP(value uint32) {
	volatile.StoreUint32(&o.SSPUP.Reg, volatile.LoadUint32(&o.SSPUP.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetSSPUP_SPRDUP() uint32 {
	return volatile.LoadUint32(&o.SSPUP.Reg) & 0xffffff
}

// PWM.SMMR: PWM Stepper Motor Mode Register
func (o *PWM_Type) SetSMMR_GCEN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSMMR_GCEN0() uint32 {
	return volatile.LoadUint32(&o.SMMR.Reg) & 0x1
}
func (o *PWM_Type) SetSMMR_GCEN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSMMR_GCEN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSMMR_DOWN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetSMMR_DOWN0() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetSMMR_DOWN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetSMMR_DOWN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x20000) >> 17
}

// PWM.FPV2: PWM Fault Protection Value 2 Register
func (o *PWM_Type) SetFPV2_FPZH0(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetFPV2_FPZH0() uint32 {
	return volatile.LoadUint32(&o.FPV2.Reg) & 0x1
}
func (o *PWM_Type) SetFPV2_FPZH1(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetFPV2_FPZH1() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetFPV2_FPZH2(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetFPV2_FPZH2() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetFPV2_FPZH3(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetFPV2_FPZH3() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetFPV2_FPZL0(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetFPV2_FPZL0() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetFPV2_FPZL1(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetFPV2_FPZL1() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetFPV2_FPZL2(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetFPV2_FPZL2() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetFPV2_FPZL3(value uint32) {
	volatile.StoreUint32(&o.FPV2.Reg, volatile.LoadUint32(&o.FPV2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetFPV2_FPZL3() uint32 {
	return (volatile.LoadUint32(&o.FPV2.Reg) & 0x80000) >> 19
}

// PWM.WPCR: PWM Write Protection Control Register
func (o *PWM_Type) SetWPCR_WPCMD(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetWPCR_WPCMD() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x3
}
func (o *PWM_Type) SetWPCR_WPRG0(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPCR_WPRG0() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPCR_WPRG1(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPCR_WPRG1() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPCR_WPRG2(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPCR_WPRG2() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPCR_WPRG3(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPCR_WPRG3() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPCR_WPRG4(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetWPCR_WPRG4() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetWPCR_WPRG5(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPCR_WPRG5() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPCR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PWM_Type) GetWPCR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// PWM.WPSR: PWM Write Protection Status Register
func (o *PWM_Type) SetWPSR_WPSWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetWPSR_WPSWS0() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PWM_Type) SetWPSR_WPSWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetWPSR_WPSWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetWPSR_WPSWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPSR_WPSWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPSR_WPSWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPSR_WPSWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPSR_WPSWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPSR_WPSWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPSR_WPSWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPSR_WPSWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPSR_WPVS() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPSR_WPHWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetWPSR_WPHWS0() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetWPSR_WPHWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetWPSR_WPHWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetWPSR_WPHWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetWPSR_WPHWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetWPSR_WPHWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetWPSR_WPHWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetWPSR_WPHWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetWPSR_WPHWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetWPSR_WPHWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetWPSR_WPHWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff0000) >> 16
}

// PWM.CMUPD0: PWM Channel Mode Update Register (ch_num = 0)
func (o *PWM_Type) SetCMUPD0_CPOLUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD0.Reg, volatile.LoadUint32(&o.CMUPD0.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMUPD0_CPOLUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD0.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMUPD0_CPOLINVUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD0.Reg, volatile.LoadUint32(&o.CMUPD0.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetCMUPD0_CPOLINVUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD0.Reg) & 0x2000) >> 13
}

// PWM.CMUPD1: PWM Channel Mode Update Register (ch_num = 1)
func (o *PWM_Type) SetCMUPD1_CPOLUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD1.Reg, volatile.LoadUint32(&o.CMUPD1.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMUPD1_CPOLUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD1.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMUPD1_CPOLINVUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD1.Reg, volatile.LoadUint32(&o.CMUPD1.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetCMUPD1_CPOLINVUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD1.Reg) & 0x2000) >> 13
}

// PWM.ETRG1: PWM External Trigger Register (trg_num = 1)
func (o *PWM_Type) SetETRG1_MAXCNT(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetETRG1_MAXCNT() uint32 {
	return volatile.LoadUint32(&o.ETRG1.Reg) & 0xffffff
}
func (o *PWM_Type) SetETRG1_TRGMODE(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0x3000000)|value<<24)
}
func (o *PWM_Type) GetETRG1_TRGMODE() uint32 {
	return (volatile.LoadUint32(&o.ETRG1.Reg) & 0x3000000) >> 24
}
func (o *PWM_Type) SetETRG1_TRGEDGE(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0x10000000)|value<<28)
}
func (o *PWM_Type) GetETRG1_TRGEDGE() uint32 {
	return (volatile.LoadUint32(&o.ETRG1.Reg) & 0x10000000) >> 28
}
func (o *PWM_Type) SetETRG1_TRGFILT(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0x20000000)|value<<29)
}
func (o *PWM_Type) GetETRG1_TRGFILT() uint32 {
	return (volatile.LoadUint32(&o.ETRG1.Reg) & 0x20000000) >> 29
}
func (o *PWM_Type) SetETRG1_TRGSRC(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0x40000000)|value<<30)
}
func (o *PWM_Type) GetETRG1_TRGSRC() uint32 {
	return (volatile.LoadUint32(&o.ETRG1.Reg) & 0x40000000) >> 30
}
func (o *PWM_Type) SetETRG1_RFEN(value uint32) {
	volatile.StoreUint32(&o.ETRG1.Reg, volatile.LoadUint32(&o.ETRG1.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetETRG1_RFEN() uint32 {
	return (volatile.LoadUint32(&o.ETRG1.Reg) & 0x80000000) >> 31
}

// PWM.LEBR1: PWM Leading-Edge Blanking Register (trg_num = 1)
func (o *PWM_Type) SetLEBR1_LEBDELAY(value uint32) {
	volatile.StoreUint32(&o.LEBR1.Reg, volatile.LoadUint32(&o.LEBR1.Reg)&^(0x7f)|value)
}
func (o *PWM_Type) GetLEBR1_LEBDELAY() uint32 {
	return volatile.LoadUint32(&o.LEBR1.Reg) & 0x7f
}
func (o *PWM_Type) SetLEBR1_PWMLFEN(value uint32) {
	volatile.StoreUint32(&o.LEBR1.Reg, volatile.LoadUint32(&o.LEBR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetLEBR1_PWMLFEN() uint32 {
	return (volatile.LoadUint32(&o.LEBR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetLEBR1_PWMLREN(value uint32) {
	volatile.StoreUint32(&o.LEBR1.Reg, volatile.LoadUint32(&o.LEBR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetLEBR1_PWMLREN() uint32 {
	return (volatile.LoadUint32(&o.LEBR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetLEBR1_PWMHFEN(value uint32) {
	volatile.StoreUint32(&o.LEBR1.Reg, volatile.LoadUint32(&o.LEBR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetLEBR1_PWMHFEN() uint32 {
	return (volatile.LoadUint32(&o.LEBR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetLEBR1_PWMHREN(value uint32) {
	volatile.StoreUint32(&o.LEBR1.Reg, volatile.LoadUint32(&o.LEBR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetLEBR1_PWMHREN() uint32 {
	return (volatile.LoadUint32(&o.LEBR1.Reg) & 0x80000) >> 19
}

// PWM.CMUPD2: PWM Channel Mode Update Register (ch_num = 2)
func (o *PWM_Type) SetCMUPD2_CPOLUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD2.Reg, volatile.LoadUint32(&o.CMUPD2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMUPD2_CPOLUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMUPD2_CPOLINVUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD2.Reg, volatile.LoadUint32(&o.CMUPD2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetCMUPD2_CPOLINVUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD2.Reg) & 0x2000) >> 13
}

// PWM.ETRG2: PWM External Trigger Register (trg_num = 2)
func (o *PWM_Type) SetETRG2_MAXCNT(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetETRG2_MAXCNT() uint32 {
	return volatile.LoadUint32(&o.ETRG2.Reg) & 0xffffff
}
func (o *PWM_Type) SetETRG2_TRGMODE(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0x3000000)|value<<24)
}
func (o *PWM_Type) GetETRG2_TRGMODE() uint32 {
	return (volatile.LoadUint32(&o.ETRG2.Reg) & 0x3000000) >> 24
}
func (o *PWM_Type) SetETRG2_TRGEDGE(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0x10000000)|value<<28)
}
func (o *PWM_Type) GetETRG2_TRGEDGE() uint32 {
	return (volatile.LoadUint32(&o.ETRG2.Reg) & 0x10000000) >> 28
}
func (o *PWM_Type) SetETRG2_TRGFILT(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0x20000000)|value<<29)
}
func (o *PWM_Type) GetETRG2_TRGFILT() uint32 {
	return (volatile.LoadUint32(&o.ETRG2.Reg) & 0x20000000) >> 29
}
func (o *PWM_Type) SetETRG2_TRGSRC(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0x40000000)|value<<30)
}
func (o *PWM_Type) GetETRG2_TRGSRC() uint32 {
	return (volatile.LoadUint32(&o.ETRG2.Reg) & 0x40000000) >> 30
}
func (o *PWM_Type) SetETRG2_RFEN(value uint32) {
	volatile.StoreUint32(&o.ETRG2.Reg, volatile.LoadUint32(&o.ETRG2.Reg)&^(0x80000000)|value<<31)
}
func (o *PWM_Type) GetETRG2_RFEN() uint32 {
	return (volatile.LoadUint32(&o.ETRG2.Reg) & 0x80000000) >> 31
}

// PWM.LEBR2: PWM Leading-Edge Blanking Register (trg_num = 2)
func (o *PWM_Type) SetLEBR2_LEBDELAY(value uint32) {
	volatile.StoreUint32(&o.LEBR2.Reg, volatile.LoadUint32(&o.LEBR2.Reg)&^(0x7f)|value)
}
func (o *PWM_Type) GetLEBR2_LEBDELAY() uint32 {
	return volatile.LoadUint32(&o.LEBR2.Reg) & 0x7f
}
func (o *PWM_Type) SetLEBR2_PWMLFEN(value uint32) {
	volatile.StoreUint32(&o.LEBR2.Reg, volatile.LoadUint32(&o.LEBR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetLEBR2_PWMLFEN() uint32 {
	return (volatile.LoadUint32(&o.LEBR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetLEBR2_PWMLREN(value uint32) {
	volatile.StoreUint32(&o.LEBR2.Reg, volatile.LoadUint32(&o.LEBR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetLEBR2_PWMLREN() uint32 {
	return (volatile.LoadUint32(&o.LEBR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetLEBR2_PWMHFEN(value uint32) {
	volatile.StoreUint32(&o.LEBR2.Reg, volatile.LoadUint32(&o.LEBR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetLEBR2_PWMHFEN() uint32 {
	return (volatile.LoadUint32(&o.LEBR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetLEBR2_PWMHREN(value uint32) {
	volatile.StoreUint32(&o.LEBR2.Reg, volatile.LoadUint32(&o.LEBR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetLEBR2_PWMHREN() uint32 {
	return (volatile.LoadUint32(&o.LEBR2.Reg) & 0x80000) >> 19
}

// PWM.CMUPD3: PWM Channel Mode Update Register (ch_num = 3)
func (o *PWM_Type) SetCMUPD3_CPOLUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD3.Reg, volatile.LoadUint32(&o.CMUPD3.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMUPD3_CPOLUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD3.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMUPD3_CPOLINVUP(value uint32) {
	volatile.StoreUint32(&o.CMUPD3.Reg, volatile.LoadUint32(&o.CMUPD3.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetCMUPD3_CPOLINVUP() uint32 {
	return (volatile.LoadUint32(&o.CMUPD3.Reg) & 0x2000) >> 13
}

// PWM Comparison 0 Value Register
type PWM_PWM_CMP_Type struct {
	CMPV    volatile.Register32 // 0x130
	CMPVUPD volatile.Register32 // 0x134
	CMPM    volatile.Register32 // 0x138
	CMPMUPD volatile.Register32 // 0x13C
}

// PWM_PWM_CMP.CMPV: PWM Comparison 0 Value Register
func (o *PWM_PWM_CMP_Type) SetCMPV_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV.Reg, volatile.LoadUint32(&o.CMPV.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CMP_Type) GetCMPV_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV.Reg) & 0xffffff
}
func (o *PWM_PWM_CMP_Type) SetCMPV_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV.Reg, volatile.LoadUint32(&o.CMPV.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_PWM_CMP_Type) GetCMPV_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV.Reg) & 0x1000000) >> 24
}

// PWM_PWM_CMP.CMPVUPD: PWM Comparison 0 Value Update Register
func (o *PWM_PWM_CMP_Type) SetCMPVUPD_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD.Reg, volatile.LoadUint32(&o.CMPVUPD.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CMP_Type) GetCMPVUPD_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD.Reg) & 0xffffff
}
func (o *PWM_PWM_CMP_Type) SetCMPVUPD_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD.Reg, volatile.LoadUint32(&o.CMPVUPD.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_PWM_CMP_Type) GetCMPVUPD_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD.Reg) & 0x1000000) >> 24
}

// PWM_PWM_CMP.CMPM: PWM Comparison 0 Mode Register
func (o *PWM_PWM_CMP_Type) SetCMPM_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0x1)|value)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM.Reg) & 0x1
}
func (o *PWM_PWM_CMP_Type) SetCMPM_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM.Reg) & 0xf0) >> 4
}
func (o *PWM_PWM_CMP_Type) SetCMPM_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM.Reg) & 0xf00) >> 8
}
func (o *PWM_PWM_CMP_Type) SetCMPM_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM.Reg) & 0xf000) >> 12
}
func (o *PWM_PWM_CMP_Type) SetCMPM_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM.Reg) & 0xf0000) >> 16
}
func (o *PWM_PWM_CMP_Type) SetCMPM_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM.Reg, volatile.LoadUint32(&o.CMPM.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_PWM_CMP_Type) GetCMPM_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM.Reg) & 0xf00000) >> 20
}

// PWM_PWM_CMP.CMPMUPD: PWM Comparison 0 Mode Update Register
func (o *PWM_PWM_CMP_Type) SetCMPMUPD_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD.Reg, volatile.LoadUint32(&o.CMPMUPD.Reg)&^(0x1)|value)
}
func (o *PWM_PWM_CMP_Type) GetCMPMUPD_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD.Reg) & 0x1
}
func (o *PWM_PWM_CMP_Type) SetCMPMUPD_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD.Reg, volatile.LoadUint32(&o.CMPMUPD.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_PWM_CMP_Type) GetCMPMUPD_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD.Reg) & 0xf0) >> 4
}
func (o *PWM_PWM_CMP_Type) SetCMPMUPD_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD.Reg, volatile.LoadUint32(&o.CMPMUPD.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_PWM_CMP_Type) GetCMPMUPD_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD.Reg) & 0xf00) >> 8
}
func (o *PWM_PWM_CMP_Type) SetCMPMUPD_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD.Reg, volatile.LoadUint32(&o.CMPMUPD.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_PWM_CMP_Type) GetCMPMUPD_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD.Reg) & 0xf0000) >> 16
}

// PWM Channel Mode Register (ch_num = 0)
type PWM_PWM_CH_NUM_Type struct {
	CMR     volatile.Register32 // 0x200
	CDTY    volatile.Register32 // 0x204
	CDTYUPD volatile.Register32 // 0x208
	CPRD    volatile.Register32 // 0x20C
	CPRDUPD volatile.Register32 // 0x210
	CCNT    volatile.Register32 // 0x214
	DT      volatile.Register32 // 0x218
	DTUPD   volatile.Register32 // 0x21C
}

// PWM_PWM_CH_NUM.CMR: PWM Channel Mode Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCMR_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xf)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xf
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x100) >> 8
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x200) >> 9
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_CES(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x400) >> 10
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_UPDS(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_UPDS() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x800) >> 11
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_DPOLI(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_DPOLI() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x1000) >> 12
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_TCTS(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_TCTS() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x2000) >> 13
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x10000) >> 16
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x20000) >> 17
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x40000) >> 18
}
func (o *PWM_PWM_CH_NUM_Type) SetCMR_PPM(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_PWM_CH_NUM_Type) GetCMR_PPM() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x80000) >> 19
}

// PWM_PWM_CH_NUM.CDTY: PWM Channel Duty Cycle Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY.Reg, volatile.LoadUint32(&o.CDTY.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY.Reg) & 0xffffff
}

// PWM_PWM_CH_NUM.CDTYUPD: PWM Channel Duty Cycle Update Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD.Reg, volatile.LoadUint32(&o.CDTYUPD.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD.Reg) & 0xffffff
}

// PWM_PWM_CH_NUM.CPRD: PWM Channel Period Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD.Reg, volatile.LoadUint32(&o.CPRD.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD.Reg) & 0xffffff
}

// PWM_PWM_CH_NUM.CPRDUPD: PWM Channel Period Update Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD.Reg, volatile.LoadUint32(&o.CPRDUPD.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD.Reg) & 0xffffff
}

// PWM_PWM_CH_NUM.CCNT: PWM Channel Counter Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetCCNT_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT.Reg, volatile.LoadUint32(&o.CCNT.Reg)&^(0xffffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetCCNT_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT.Reg) & 0xffffff
}

// PWM_PWM_CH_NUM.DT: PWM Channel Dead Time Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetDT_DTH(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetDT_DTH() uint32 {
	return volatile.LoadUint32(&o.DT.Reg) & 0xffff
}
func (o *PWM_PWM_CH_NUM_Type) SetDT_DTL(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_PWM_CH_NUM_Type) GetDT_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0xffff0000) >> 16
}

// PWM_PWM_CH_NUM.DTUPD: PWM Channel Dead Time Update Register (ch_num = 0)
func (o *PWM_PWM_CH_NUM_Type) SetDTUPD_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD.Reg, volatile.LoadUint32(&o.DTUPD.Reg)&^(0xffff)|value)
}
func (o *PWM_PWM_CH_NUM_Type) GetDTUPD_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD.Reg) & 0xffff
}
func (o *PWM_PWM_CH_NUM_Type) SetDTUPD_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD.Reg, volatile.LoadUint32(&o.DTUPD.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_PWM_CH_NUM_Type) GetDTUPD_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD.Reg) & 0xffff0000) >> 16
}

// Quad Serial Peripheral Interface
type QSPI_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	RDR  volatile.Register32 // 0x8
	TDR  volatile.Register32 // 0xC
	SR   volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
	IDR  volatile.Register32 // 0x18
	IMR  volatile.Register32 // 0x1C
	SCR  volatile.Register32 // 0x20
	_    [12]byte
	IAR  volatile.Register32 // 0x30
	ICR  volatile.Register32 // 0x34
	IFR  volatile.Register32 // 0x38
	_    [4]byte
	SMR  volatile.Register32 // 0x40
	SKR  volatile.Register32 // 0x44
	_    [156]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// QSPI.CR: Control Register
func (o *QSPI_Type) SetCR_QSPIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetCR_QSPIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *QSPI_Type) SetCR_QSPIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetCR_QSPIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetCR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *QSPI_Type) GetCR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// QSPI.MR: Mode Register
func (o *QSPI_Type) SetMR_SMM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetMR_SMM() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *QSPI_Type) SetMR_LLB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetMR_LLB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetMR_WDRBT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetMR_WDRBT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetMR_CSMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30)|value<<4)
}
func (o *QSPI_Type) GetMR_CSMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30) >> 4
}
func (o *QSPI_Type) SetMR_NBBITS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *QSPI_Type) GetMR_NBBITS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *QSPI_Type) SetMR_DLYBCT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetMR_DLYBCT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff0000) >> 16
}
func (o *QSPI_Type) SetMR_DLYCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *QSPI_Type) GetMR_DLYCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// QSPI.RDR: Receive Data Register
func (o *QSPI_Type) SetRDR_RD(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xffff)|value)
}
func (o *QSPI_Type) GetRDR_RD() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0xffff
}

// QSPI.TDR: Transmit Data Register
func (o *QSPI_Type) SetTDR_TD(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xffff)|value)
}
func (o *QSPI_Type) GetTDR_TD() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0xffff
}

// QSPI.SR: Status Register
func (o *QSPI_Type) SetSR_RDRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSR_RDRF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *QSPI_Type) SetSR_TDRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetSR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetSR_OVRES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetSR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetSR_CSR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetSR_CSR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetSR_CSS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetSR_CSS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetSR_INSTRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetSR_INSTRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *QSPI_Type) SetSR_QSPIENS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *QSPI_Type) GetSR_QSPIENS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}

// QSPI.IER: Interrupt Enable Register
func (o *QSPI_Type) SetIER_RDRF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetIER_RDRF() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *QSPI_Type) SetIER_TDRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetIER_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetIER_OVRES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetIER_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetIER_CSR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetIER_CSR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetIER_CSS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetIER_CSS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetIER_INSTRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetIER_INSTRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}

// QSPI.IDR: Interrupt Disable Register
func (o *QSPI_Type) SetIDR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetIDR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *QSPI_Type) SetIDR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetIDR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetIDR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetIDR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetIDR_CSR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetIDR_CSR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetIDR_CSS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetIDR_CSS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetIDR_INSTRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetIDR_INSTRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}

// QSPI.IMR: Interrupt Mask Register
func (o *QSPI_Type) SetIMR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetIMR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *QSPI_Type) SetIMR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetIMR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetIMR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetIMR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetIMR_CSR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetIMR_CSR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetIMR_CSS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetIMR_CSS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetIMR_INSTRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetIMR_INSTRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}

// QSPI.SCR: Serial Clock Register
func (o *QSPI_Type) SetSCR_CPOL(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSCR_CPOL() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}
func (o *QSPI_Type) SetSCR_CPHA(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetSCR_CPHA() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetSCR_SCBR(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetSCR_SCBR() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetSCR_DLYBS(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetSCR_DLYBS() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xff0000) >> 16
}

// QSPI.IAR: Instruction Address Register
func (o *QSPI_Type) SetIAR(value uint32) {
	volatile.StoreUint32(&o.IAR.Reg, value)
}
func (o *QSPI_Type) GetIAR() uint32 {
	return volatile.LoadUint32(&o.IAR.Reg)
}

// QSPI.ICR: Instruction Code Register
func (o *QSPI_Type) SetICR_INST(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetICR_INST() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0xff
}
func (o *QSPI_Type) SetICR_OPT(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetICR_OPT() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xff0000) >> 16
}

// QSPI.IFR: Instruction Frame Register
func (o *QSPI_Type) SetIFR_WIDTH(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x7)|value)
}
func (o *QSPI_Type) GetIFR_WIDTH() uint32 {
	return volatile.LoadUint32(&o.IFR.Reg) & 0x7
}
func (o *QSPI_Type) SetIFR_INSTEN(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetIFR_INSTEN() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetIFR_ADDREN(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetIFR_ADDREN() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x20) >> 5
}
func (o *QSPI_Type) SetIFR_OPTEN(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetIFR_OPTEN() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetIFR_DATAEN(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetIFR_DATAEN() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetIFR_OPTL(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x300)|value<<8)
}
func (o *QSPI_Type) GetIFR_OPTL() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x300) >> 8
}
func (o *QSPI_Type) SetIFR_ADDRL(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetIFR_ADDRL() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x400) >> 10
}
func (o *QSPI_Type) SetIFR_TFRTYP(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x3000)|value<<12)
}
func (o *QSPI_Type) GetIFR_TFRTYP() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x3000) >> 12
}
func (o *QSPI_Type) SetIFR_CRM(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x4000)|value<<14)
}
func (o *QSPI_Type) GetIFR_CRM() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x4000) >> 14
}
func (o *QSPI_Type) SetIFR_NBDUM(value uint32) {
	volatile.StoreUint32(&o.IFR.Reg, volatile.LoadUint32(&o.IFR.Reg)&^(0x1f0000)|value<<16)
}
func (o *QSPI_Type) GetIFR_NBDUM() uint32 {
	return (volatile.LoadUint32(&o.IFR.Reg) & 0x1f0000) >> 16
}

// QSPI.SMR: Scrambling Mode Register
func (o *QSPI_Type) SetSMR_SCREN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSMR_SCREN() uint32 {
	return volatile.LoadUint32(&o.SMR.Reg) & 0x1
}
func (o *QSPI_Type) SetSMR_RVDIS(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetSMR_RVDIS() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x2) >> 1
}

// QSPI.SKR: Scrambling Key Register
func (o *QSPI_Type) SetSKR(value uint32) {
	volatile.StoreUint32(&o.SKR.Reg, value)
}
func (o *QSPI_Type) GetSKR() uint32 {
	return volatile.LoadUint32(&o.SKR.Reg)
}

// QSPI.WPMR: Write Protection Mode Register
func (o *QSPI_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *QSPI_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *QSPI_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// QSPI.WPSR: Write Protection Status Register
func (o *QSPI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *QSPI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xff00) >> 8
}

// Reset Controller
type RSTC_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	MR volatile.Register32 // 0x8
}

// RSTC.CR: Control Register
func (o *RSTC_Type) SetCR_PROCRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RSTC_Type) GetCR_PROCRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RSTC_Type) SetCR_EXTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RSTC_Type) GetCR_EXTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RSTC_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *RSTC_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// RSTC.SR: Status Register
func (o *RSTC_Type) SetSR_URSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RSTC_Type) GetSR_URSTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RSTC_Type) SetSR_RSTTYP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x700)|value<<8)
}
func (o *RSTC_Type) GetSR_RSTTYP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x700) >> 8
}
func (o *RSTC_Type) SetSR_NRSTL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *RSTC_Type) GetSR_NRSTL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *RSTC_Type) SetSR_SRCMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *RSTC_Type) GetSR_SRCMP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// RSTC.MR: Mode Register
func (o *RSTC_Type) SetMR_URSTEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *RSTC_Type) GetMR_URSTEN() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *RSTC_Type) SetMR_URSTIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *RSTC_Type) GetMR_URSTIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *RSTC_Type) SetMR_ERSTL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *RSTC_Type) GetMR_ERSTL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *RSTC_Type) SetMR_KEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *RSTC_Type) GetMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// Reinforced Safety Watchdog Timer
type RSWDT_Type struct {
	CR volatile.Register32 // 0x0
	MR volatile.Register32 // 0x4
	SR volatile.Register32 // 0x8
}

// RSWDT.CR: Control Register
func (o *RSWDT_Type) SetCR_WDRSTT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RSWDT_Type) GetCR_WDRSTT() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RSWDT_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *RSWDT_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// RSWDT.MR: Mode Register
func (o *RSWDT_Type) SetMR_WDV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xfff)|value)
}
func (o *RSWDT_Type) GetMR_WDV() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xfff
}
func (o *RSWDT_Type) SetMR_WDFIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *RSWDT_Type) GetMR_WDFIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *RSWDT_Type) SetMR_WDRSTEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *RSWDT_Type) GetMR_WDRSTEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *RSWDT_Type) SetMR_WDDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *RSWDT_Type) GetMR_WDDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *RSWDT_Type) SetMR_ALLONES(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xfff0000)|value<<16)
}
func (o *RSWDT_Type) GetMR_ALLONES() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xfff0000) >> 16
}
func (o *RSWDT_Type) SetMR_WDDBGHLT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *RSWDT_Type) GetMR_WDDBGHLT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}
func (o *RSWDT_Type) SetMR_WDIDLEHLT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000000)|value<<29)
}
func (o *RSWDT_Type) GetMR_WDIDLEHLT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000000) >> 29
}

// RSWDT.SR: Status Register
func (o *RSWDT_Type) SetSR_WDUNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RSWDT_Type) GetSR_WDUNF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Real-time Clock
type RTC_Type struct {
	CR     volatile.Register32 // 0x0
	MR     volatile.Register32 // 0x4
	TIMR   volatile.Register32 // 0x8
	CALR   volatile.Register32 // 0xC
	TIMALR volatile.Register32 // 0x10
	CALALR volatile.Register32 // 0x14
	SR     volatile.Register32 // 0x18
	SCCR   volatile.Register32 // 0x1C
	IER    volatile.Register32 // 0x20
	IDR    volatile.Register32 // 0x24
	IMR    volatile.Register32 // 0x28
	VER    volatile.Register32 // 0x2C
}

// RTC.CR: Control Register
func (o *RTC_Type) SetCR_UPDTIM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCR_UPDTIM() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RTC_Type) SetCR_UPDCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCR_UPDCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCR_TIMEVSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *RTC_Type) GetCR_TIMEVSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *RTC_Type) SetCR_CALEVSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *RTC_Type) GetCR_CALEVSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}

// RTC.MR: Mode Register
func (o *RTC_Type) SetMR_HRMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetMR_HRMOD() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *RTC_Type) SetMR_PERSIAN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetMR_PERSIAN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetMR_NEGPPM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetMR_NEGPPM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetMR_CORRECTION(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7f00)|value<<8)
}
func (o *RTC_Type) GetMR_CORRECTION() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7f00) >> 8
}
func (o *RTC_Type) SetMR_HIGHPPM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetMR_HIGHPPM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetMR_OUT0(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_Type) GetMR_OUT0() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x70000) >> 16
}
func (o *RTC_Type) SetMR_OUT1(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x700000)|value<<20)
}
func (o *RTC_Type) GetMR_OUT1() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x700000) >> 20
}
func (o *RTC_Type) SetMR_THIGH(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetMR_THIGH() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetMR_TPERIOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetMR_TPERIOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30000000) >> 28
}

// RTC.TIMR: Time Register
func (o *RTC_Type) SetTIMR_SEC(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetTIMR_SEC() uint32 {
	return volatile.LoadUint32(&o.TIMR.Reg) & 0x7f
}
func (o *RTC_Type) SetTIMR_MIN(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x7f00)|value<<8)
}
func (o *RTC_Type) GetTIMR_MIN() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x7f00) >> 8
}
func (o *RTC_Type) SetTIMR_HOUR(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x3f0000)|value<<16)
}
func (o *RTC_Type) GetTIMR_HOUR() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x3f0000) >> 16
}
func (o *RTC_Type) SetTIMR_AMPM(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTIMR_AMPM() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x400000) >> 22
}

// RTC.CALR: Calendar Register
func (o *RTC_Type) SetCALR_CENT(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetCALR_CENT() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x7f
}
func (o *RTC_Type) SetCALR_YEAR(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetCALR_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetCALR_MONTH(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCALR_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCALR_DAY(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0xe00000)|value<<21)
}
func (o *RTC_Type) GetCALR_DAY() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0xe00000) >> 21
}
func (o *RTC_Type) SetCALR_DATE(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetCALR_DATE() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x3f000000) >> 24
}

// RTC.TIMALR: Time Alarm Register
func (o *RTC_Type) SetTIMALR_SEC(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetTIMALR_SEC() uint32 {
	return volatile.LoadUint32(&o.TIMALR.Reg) & 0x7f
}
func (o *RTC_Type) SetTIMALR_SECEN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetTIMALR_SECEN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetTIMALR_MIN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x7f00)|value<<8)
}
func (o *RTC_Type) GetTIMALR_MIN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x7f00) >> 8
}
func (o *RTC_Type) SetTIMALR_MINEN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetTIMALR_MINEN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetTIMALR_HOUR(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x3f0000)|value<<16)
}
func (o *RTC_Type) GetTIMALR_HOUR() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x3f0000) >> 16
}
func (o *RTC_Type) SetTIMALR_AMPM(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTIMALR_AMPM() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTIMALR_HOUREN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetTIMALR_HOUREN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x800000) >> 23
}

// RTC.CALALR: Calendar Alarm Register
func (o *RTC_Type) SetCALALR_MONTH(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCALALR_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCALALR_MTHEN(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCALALR_MTHEN() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCALALR_DATE(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetCALALR_DATE() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetCALALR_DATEEN(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetCALALR_DATEEN() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x80000000) >> 31
}

// RTC.SR: Status Register
func (o *RTC_Type) SetSR_ACKUPD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_ACKUPD() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTC_Type) SetSR_ALARM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_ALARM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_SEC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_SEC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_TIMEV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSR_TIMEV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSR_CALEV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_CALEV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSR_TDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSR_TDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}

// RTC.SCCR: Status Clear Command Register
func (o *RTC_Type) SetSCCR_ACKCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSCCR_ACKCLR() uint32 {
	return volatile.LoadUint32(&o.SCCR.Reg) & 0x1
}
func (o *RTC_Type) SetSCCR_ALRCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSCCR_ALRCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSCCR_SECCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSCCR_SECCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSCCR_TIMCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSCCR_TIMCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSCCR_CALCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSCCR_CALCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSCCR_TDERRCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSCCR_TDERRCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x20) >> 5
}

// RTC.IER: Interrupt Enable Register
func (o *RTC_Type) SetIER_ACKEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIER_ACKEN() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *RTC_Type) SetIER_ALREN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIER_ALREN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIER_SECEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIER_SECEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIER_TIMEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIER_TIMEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIER_CALEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIER_CALEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetIER_TDERREN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetIER_TDERREN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}

// RTC.IDR: Interrupt Disable Register
func (o *RTC_Type) SetIDR_ACKDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIDR_ACKDIS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *RTC_Type) SetIDR_ALRDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIDR_ALRDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIDR_SECDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIDR_SECDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIDR_TIMDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIDR_TIMDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIDR_CALDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIDR_CALDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetIDR_TDERRDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetIDR_TDERRDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}

// RTC.IMR: Interrupt Mask Register
func (o *RTC_Type) SetIMR_ACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIMR_ACK() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *RTC_Type) SetIMR_ALR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIMR_ALR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIMR_SEC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIMR_SEC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIMR_TIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIMR_TIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIMR_CAL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIMR_CAL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetIMR_TDERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetIMR_TDERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}

// RTC.VER: Valid Entry Register
func (o *RTC_Type) SetVER_NVTIM(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetVER_NVTIM() uint32 {
	return volatile.LoadUint32(&o.VER.Reg) & 0x1
}
func (o *RTC_Type) SetVER_NVCAL(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetVER_NVCAL() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetVER_NVTIMALR(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetVER_NVTIMALR() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetVER_NVCALALR(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetVER_NVCALALR() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x8) >> 3
}

// Real-time Timer
type RTT_Type struct {
	MR volatile.Register32 // 0x0
	AR volatile.Register32 // 0x4
	VR volatile.Register32 // 0x8
	SR volatile.Register32 // 0xC
}

// RTT.MR: Mode Register
func (o *RTT_Type) SetMR_RTPRES(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xffff)|value)
}
func (o *RTT_Type) GetMR_RTPRES() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xffff
}
func (o *RTT_Type) SetMR_ALMIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *RTT_Type) GetMR_ALMIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}
func (o *RTT_Type) SetMR_RTTINCIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000)|value<<17)
}
func (o *RTT_Type) GetMR_RTTINCIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000) >> 17
}
func (o *RTT_Type) SetMR_RTTRST(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000)|value<<18)
}
func (o *RTT_Type) GetMR_RTTRST() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000) >> 18
}
func (o *RTT_Type) SetMR_RTTDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100000)|value<<20)
}
func (o *RTT_Type) GetMR_RTTDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100000) >> 20
}
func (o *RTT_Type) SetMR_RTC1HZ(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTT_Type) GetMR_RTC1HZ() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000000) >> 24
}

// RTT.AR: Alarm Register
func (o *RTT_Type) SetAR(value uint32) {
	volatile.StoreUint32(&o.AR.Reg, value)
}
func (o *RTT_Type) GetAR() uint32 {
	return volatile.LoadUint32(&o.AR.Reg)
}

// RTT.VR: Value Register
func (o *RTT_Type) SetVR(value uint32) {
	volatile.StoreUint32(&o.VR.Reg, value)
}
func (o *RTT_Type) GetVR() uint32 {
	return volatile.LoadUint32(&o.VR.Reg)
}

// RTT.SR: Status Register
func (o *RTT_Type) SetSR_ALMS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTT_Type) GetSR_ALMS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTT_Type) SetSR_RTTINC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTT_Type) GetSR_RTTINC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}

// Synchronous Serial Controller
type SSC_Type struct {
	CR   volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	_    [8]byte
	RCMR volatile.Register32 // 0x10
	RFMR volatile.Register32 // 0x14
	TCMR volatile.Register32 // 0x18
	TFMR volatile.Register32 // 0x1C
	RHR  volatile.Register32 // 0x20
	THR  volatile.Register32 // 0x24
	_    [8]byte
	RSHR volatile.Register32 // 0x30
	TSHR volatile.Register32 // 0x34
	RC0R volatile.Register32 // 0x38
	RC1R volatile.Register32 // 0x3C
	SR   volatile.Register32 // 0x40
	IER  volatile.Register32 // 0x44
	IDR  volatile.Register32 // 0x48
	IMR  volatile.Register32 // 0x4C
	_    [148]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// SSC.CR: Control Register
func (o *SSC_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetCR_RXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SSC_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *SSC_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}

// SSC.CMR: Clock Mode Register
func (o *SSC_Type) SetCMR_DIV(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xfff)|value)
}
func (o *SSC_Type) GetCMR_DIV() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xfff
}

// SSC.RCMR: Receive Clock Mode Register
func (o *SSC_Type) SetRCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetRCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.RCMR.Reg) & 0x3
}
func (o *SSC_Type) SetRCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetRCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetRCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetRCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetRCMR_START(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRCMR_START() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRCMR_STOP(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1000)|value<<12)
}
func (o *SSC_Type) GetRCMR_STOP() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1000) >> 12
}
func (o *SSC_Type) SetRCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetRCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetRCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetRCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff000000) >> 24
}

// SSC.RFMR: Receive Frame Mode Register
func (o *SSC_Type) SetRFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetRFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.RFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetRFMR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRFMR_LOOP() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetRFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetRFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetRFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetRFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetRFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetRFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetRFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetRFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetRFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000000) >> 28
}

// SSC.TCMR: Transmit Clock Mode Register
func (o *SSC_Type) SetTCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetTCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.TCMR.Reg) & 0x3
}
func (o *SSC_Type) SetTCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetTCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetTCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetTCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetTCMR_START(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTCMR_START() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetTCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetTCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetTCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff000000) >> 24
}

// SSC.TFMR: Transmit Frame Mode Register
func (o *SSC_Type) SetTFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetTFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.TFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetTFMR_DATDEF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTFMR_DATDEF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetTFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetTFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetTFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetTFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetTFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetTFMR_FSDEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x800000)|value<<23)
}
func (o *SSC_Type) GetTFMR_FSDEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x800000) >> 23
}
func (o *SSC_Type) SetTFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetTFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetTFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetTFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000000) >> 28
}

// SSC.RHR: Receive Holding Register
func (o *SSC_Type) SetRHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, value)
}
func (o *SSC_Type) GetRHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg)
}

// SSC.THR: Transmit Holding Register
func (o *SSC_Type) SetTHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, value)
}
func (o *SSC_Type) GetTHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg)
}

// SSC.RSHR: Receive Sync. Holding Register
func (o *SSC_Type) SetRSHR_RSDAT(value uint32) {
	volatile.StoreUint32(&o.RSHR.Reg, volatile.LoadUint32(&o.RSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRSHR_RSDAT() uint32 {
	return volatile.LoadUint32(&o.RSHR.Reg) & 0xffff
}

// SSC.TSHR: Transmit Sync. Holding Register
func (o *SSC_Type) SetTSHR_TSDAT(value uint32) {
	volatile.StoreUint32(&o.TSHR.Reg, volatile.LoadUint32(&o.TSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTSHR_TSDAT() uint32 {
	return volatile.LoadUint32(&o.TSHR.Reg) & 0xffff
}

// SSC.RC0R: Receive Compare 0 Register
func (o *SSC_Type) SetRC0R_CP0(value uint32) {
	volatile.StoreUint32(&o.RC0R.Reg, volatile.LoadUint32(&o.RC0R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC0R_CP0() uint32 {
	return volatile.LoadUint32(&o.RC0R.Reg) & 0xffff
}

// SSC.RC1R: Receive Compare 1 Register
func (o *SSC_Type) SetRC1R_CP1(value uint32) {
	volatile.StoreUint32(&o.RC1R.Reg, volatile.LoadUint32(&o.RC1R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC1R_CP1() uint32 {
	return volatile.LoadUint32(&o.RC1R.Reg) & 0xffff
}

// SSC.SR: Status Register
func (o *SSC_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSC_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetSR_CP0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetSR_CP0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetSR_CP1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetSR_CP1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetSR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetSR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetSR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetSR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *SSC_Type) SetSR_TXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SSC_Type) GetSR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SSC_Type) SetSR_RXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SSC_Type) GetSR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SSC.IER: Interrupt Enable Register
func (o *SSC_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIER_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SSC_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIER_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIER_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIER_CP0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIER_CP0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIER_CP1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIER_CP1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIER_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIER_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIER_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIER_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// SSC.IDR: Interrupt Disable Register
func (o *SSC_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIDR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SSC_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIDR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIDR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIDR_CP0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIDR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIDR_CP1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIDR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIDR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIDR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIDR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIDR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// SSC.IMR: Interrupt Mask Register
func (o *SSC_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SSC_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIMR_CP0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIMR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIMR_CP1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIMR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIMR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIMR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIMR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIMR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// SSC.WPMR: Write Protection Mode Register
func (o *SSC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *SSC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SSC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// SSC.WPSR: Write Protection Status Register
func (o *SSC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *SSC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *SSC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Supply Controller
type SUPC_Type struct {
	CR   volatile.Register32 // 0x0
	SMMR volatile.Register32 // 0x4
	MR   volatile.Register32 // 0x8
	WUMR volatile.Register32 // 0xC
	WUIR volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
}

// SUPC.CR: Supply Controller Control Register
func (o *SUPC_Type) SetCR_VROFF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetCR_VROFF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetCR_XTALSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SUPC_Type) GetCR_XTALSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SUPC_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *SUPC_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// SUPC.SMMR: Supply Controller Supply Monitor Mode Register
func (o *SUPC_Type) SetSMMR_SMTH(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0xf)|value)
}
func (o *SUPC_Type) GetSMMR_SMTH() uint32 {
	return volatile.LoadUint32(&o.SMMR.Reg) & 0xf
}
func (o *SUPC_Type) SetSMMR_SMSMPL(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x700)|value<<8)
}
func (o *SUPC_Type) GetSMMR_SMSMPL() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x700) >> 8
}
func (o *SUPC_Type) SetSMMR_SMRSTEN(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x1000)|value<<12)
}
func (o *SUPC_Type) GetSMMR_SMRSTEN() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x1000) >> 12
}
func (o *SUPC_Type) SetSMMR_SMIEN(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x2000)|value<<13)
}
func (o *SUPC_Type) GetSMMR_SMIEN() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x2000) >> 13
}

// SUPC.MR: Supply Controller Mode Register
func (o *SUPC_Type) SetMR_BODRSTEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *SUPC_Type) GetMR_BODRSTEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *SUPC_Type) SetMR_BODDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *SUPC_Type) GetMR_BODDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *SUPC_Type) SetMR_ONREG(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000)|value<<14)
}
func (o *SUPC_Type) GetMR_ONREG() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000) >> 14
}
func (o *SUPC_Type) SetMR_BKUPRETON(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000)|value<<17)
}
func (o *SUPC_Type) GetMR_BKUPRETON() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000) >> 17
}
func (o *SUPC_Type) SetMR_OSCBYPASS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100000)|value<<20)
}
func (o *SUPC_Type) GetMR_OSCBYPASS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100000) >> 20
}
func (o *SUPC_Type) SetMR_KEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SUPC_Type) GetMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// SUPC.WUMR: Supply Controller Wake-up Mode Register
func (o *SUPC_Type) SetWUMR_SMEN(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetWUMR_SMEN() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetWUMR_RTTEN(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetWUMR_RTTEN() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetWUMR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x8)|value<<3)
}
func (o *SUPC_Type) GetWUMR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x8) >> 3
}
func (o *SUPC_Type) SetWUMR_LPDBCEN0(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x20)|value<<5)
}
func (o *SUPC_Type) GetWUMR_LPDBCEN0() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x20) >> 5
}
func (o *SUPC_Type) SetWUMR_LPDBCEN1(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x40)|value<<6)
}
func (o *SUPC_Type) GetWUMR_LPDBCEN1() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x40) >> 6
}
func (o *SUPC_Type) SetWUMR_LPDBCCLR(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetWUMR_LPDBCCLR() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetWUMR_WKUPDBC(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x7000)|value<<12)
}
func (o *SUPC_Type) GetWUMR_WKUPDBC() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x7000) >> 12
}
func (o *SUPC_Type) SetWUMR_LPDBC(value uint32) {
	volatile.StoreUint32(&o.WUMR.Reg, volatile.LoadUint32(&o.WUMR.Reg)&^(0x70000)|value<<16)
}
func (o *SUPC_Type) GetWUMR_LPDBC() uint32 {
	return (volatile.LoadUint32(&o.WUMR.Reg) & 0x70000) >> 16
}

// SUPC.WUIR: Supply Controller Wake-up Inputs Register
func (o *SUPC_Type) SetWUIR_WKUPEN0(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetWUIR_WKUPEN0() uint32 {
	return volatile.LoadUint32(&o.WUIR.Reg) & 0x1
}
func (o *SUPC_Type) SetWUIR_WKUPEN1(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetWUIR_WKUPEN1() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetWUIR_WKUPEN2(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetWUIR_WKUPEN2() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetWUIR_WKUPEN3(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x8)|value<<3)
}
func (o *SUPC_Type) GetWUIR_WKUPEN3() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x8) >> 3
}
func (o *SUPC_Type) SetWUIR_WKUPEN4(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x10)|value<<4)
}
func (o *SUPC_Type) GetWUIR_WKUPEN4() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x10) >> 4
}
func (o *SUPC_Type) SetWUIR_WKUPEN5(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x20)|value<<5)
}
func (o *SUPC_Type) GetWUIR_WKUPEN5() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x20) >> 5
}
func (o *SUPC_Type) SetWUIR_WKUPEN6(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x40)|value<<6)
}
func (o *SUPC_Type) GetWUIR_WKUPEN6() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x40) >> 6
}
func (o *SUPC_Type) SetWUIR_WKUPEN7(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetWUIR_WKUPEN7() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetWUIR_WKUPEN8(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetWUIR_WKUPEN8() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetWUIR_WKUPEN9(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x200)|value<<9)
}
func (o *SUPC_Type) GetWUIR_WKUPEN9() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x200) >> 9
}
func (o *SUPC_Type) SetWUIR_WKUPEN10(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x400)|value<<10)
}
func (o *SUPC_Type) GetWUIR_WKUPEN10() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x400) >> 10
}
func (o *SUPC_Type) SetWUIR_WKUPEN11(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x800)|value<<11)
}
func (o *SUPC_Type) GetWUIR_WKUPEN11() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x800) >> 11
}
func (o *SUPC_Type) SetWUIR_WKUPEN12(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x1000)|value<<12)
}
func (o *SUPC_Type) GetWUIR_WKUPEN12() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x1000) >> 12
}
func (o *SUPC_Type) SetWUIR_WKUPEN13(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x2000)|value<<13)
}
func (o *SUPC_Type) GetWUIR_WKUPEN13() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x2000) >> 13
}
func (o *SUPC_Type) SetWUIR_WKUPT0(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x10000)|value<<16)
}
func (o *SUPC_Type) GetWUIR_WKUPT0() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x10000) >> 16
}
func (o *SUPC_Type) SetWUIR_WKUPT1(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x20000)|value<<17)
}
func (o *SUPC_Type) GetWUIR_WKUPT1() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x20000) >> 17
}
func (o *SUPC_Type) SetWUIR_WKUPT2(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x40000)|value<<18)
}
func (o *SUPC_Type) GetWUIR_WKUPT2() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x40000) >> 18
}
func (o *SUPC_Type) SetWUIR_WKUPT3(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x80000)|value<<19)
}
func (o *SUPC_Type) GetWUIR_WKUPT3() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x80000) >> 19
}
func (o *SUPC_Type) SetWUIR_WKUPT4(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x100000)|value<<20)
}
func (o *SUPC_Type) GetWUIR_WKUPT4() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x100000) >> 20
}
func (o *SUPC_Type) SetWUIR_WKUPT5(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x200000)|value<<21)
}
func (o *SUPC_Type) GetWUIR_WKUPT5() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x200000) >> 21
}
func (o *SUPC_Type) SetWUIR_WKUPT6(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x400000)|value<<22)
}
func (o *SUPC_Type) GetWUIR_WKUPT6() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x400000) >> 22
}
func (o *SUPC_Type) SetWUIR_WKUPT7(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x800000)|value<<23)
}
func (o *SUPC_Type) GetWUIR_WKUPT7() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x800000) >> 23
}
func (o *SUPC_Type) SetWUIR_WKUPT8(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x1000000)|value<<24)
}
func (o *SUPC_Type) GetWUIR_WKUPT8() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x1000000) >> 24
}
func (o *SUPC_Type) SetWUIR_WKUPT9(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x2000000)|value<<25)
}
func (o *SUPC_Type) GetWUIR_WKUPT9() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x2000000) >> 25
}
func (o *SUPC_Type) SetWUIR_WKUPT10(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x4000000)|value<<26)
}
func (o *SUPC_Type) GetWUIR_WKUPT10() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x4000000) >> 26
}
func (o *SUPC_Type) SetWUIR_WKUPT11(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x8000000)|value<<27)
}
func (o *SUPC_Type) GetWUIR_WKUPT11() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x8000000) >> 27
}
func (o *SUPC_Type) SetWUIR_WKUPT12(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x10000000)|value<<28)
}
func (o *SUPC_Type) GetWUIR_WKUPT12() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x10000000) >> 28
}
func (o *SUPC_Type) SetWUIR_WKUPT13(value uint32) {
	volatile.StoreUint32(&o.WUIR.Reg, volatile.LoadUint32(&o.WUIR.Reg)&^(0x20000000)|value<<29)
}
func (o *SUPC_Type) GetWUIR_WKUPT13() uint32 {
	return (volatile.LoadUint32(&o.WUIR.Reg) & 0x20000000) >> 29
}

// SUPC.SR: Supply Controller Status Register
func (o *SUPC_Type) SetSR_WKUPS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetSR_WKUPS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetSR_SMWS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetSR_SMWS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetSR_BODRSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SUPC_Type) GetSR_BODRSTS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SUPC_Type) SetSR_SMRSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SUPC_Type) GetSR_SMRSTS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SUPC_Type) SetSR_SMS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SUPC_Type) GetSR_SMS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SUPC_Type) SetSR_SMOS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SUPC_Type) GetSR_SMOS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SUPC_Type) SetSR_OSCSEL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetSR_OSCSEL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetSR_LPDBCS0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *SUPC_Type) GetSR_LPDBCS0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *SUPC_Type) SetSR_LPDBCS1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *SUPC_Type) GetSR_LPDBCS1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *SUPC_Type) SetSR_WKUPIS0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SUPC_Type) GetSR_WKUPIS0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SUPC_Type) SetSR_WKUPIS1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SUPC_Type) GetSR_WKUPIS1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *SUPC_Type) SetSR_WKUPIS2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *SUPC_Type) GetSR_WKUPIS2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *SUPC_Type) SetSR_WKUPIS3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *SUPC_Type) GetSR_WKUPIS3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *SUPC_Type) SetSR_WKUPIS4(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *SUPC_Type) GetSR_WKUPIS4() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *SUPC_Type) SetSR_WKUPIS5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *SUPC_Type) GetSR_WKUPIS5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *SUPC_Type) SetSR_WKUPIS6(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *SUPC_Type) GetSR_WKUPIS6() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *SUPC_Type) SetSR_WKUPIS7(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *SUPC_Type) GetSR_WKUPIS7() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *SUPC_Type) SetSR_WKUPIS8(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *SUPC_Type) GetSR_WKUPIS8() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *SUPC_Type) SetSR_WKUPIS9(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *SUPC_Type) GetSR_WKUPIS9() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *SUPC_Type) SetSR_WKUPIS10(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *SUPC_Type) GetSR_WKUPIS10() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *SUPC_Type) SetSR_WKUPIS11(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *SUPC_Type) GetSR_WKUPIS11() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *SUPC_Type) SetSR_WKUPIS12(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *SUPC_Type) GetSR_WKUPIS12() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *SUPC_Type) SetSR_WKUPIS13(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *SUPC_Type) GetSR_WKUPIS13() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}

// Timer Counter
type TC_Type struct {
	TC_CHANNEL [3]TC_TC_CHANNEL_Type // 0x0
	BCR        volatile.Register32   // 0xC0
	BMR        volatile.Register32   // 0xC4
	QIER       volatile.Register32   // 0xC8
	QIDR       volatile.Register32   // 0xCC
	QIMR       volatile.Register32   // 0xD0
	QISR       volatile.Register32   // 0xD4
	FMR        volatile.Register32   // 0xD8
	_          [8]byte
	WPMR       volatile.Register32 // 0xE4
}

// TC.BCR: Block Control Register
func (o *TC_Type) SetBCR_SYNC(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetBCR_SYNC() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// TC.BMR: Block Mode Register
func (o *TC_Type) SetBMR_TC0XC0S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3)|value)
}
func (o *TC_Type) GetBMR_TC0XC0S() uint32 {
	return volatile.LoadUint32(&o.BMR.Reg) & 0x3
}
func (o *TC_Type) SetBMR_TC1XC1S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0xc)|value<<2)
}
func (o *TC_Type) GetBMR_TC1XC1S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0xc) >> 2
}
func (o *TC_Type) SetBMR_TC2XC2S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetBMR_TC2XC2S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetBMR_QDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetBMR_QDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x100) >> 8
}
func (o *TC_Type) SetBMR_POSEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x200)|value<<9)
}
func (o *TC_Type) GetBMR_POSEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x200) >> 9
}
func (o *TC_Type) SetBMR_SPEEDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetBMR_SPEEDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetBMR_QDTRANS(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x800)|value<<11)
}
func (o *TC_Type) GetBMR_QDTRANS() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x800) >> 11
}
func (o *TC_Type) SetBMR_EDGPHA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x1000)|value<<12)
}
func (o *TC_Type) GetBMR_EDGPHA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x1000) >> 12
}
func (o *TC_Type) SetBMR_INVA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x2000)|value<<13)
}
func (o *TC_Type) GetBMR_INVA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x2000) >> 13
}
func (o *TC_Type) SetBMR_INVB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetBMR_INVB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetBMR_INVIDX(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetBMR_INVIDX() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetBMR_SWAP(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetBMR_SWAP() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetBMR_IDXPHB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetBMR_IDXPHB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetBMR_MAXFILT(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3f00000)|value<<20)
}
func (o *TC_Type) GetBMR_MAXFILT() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x3f00000) >> 20
}

// TC.QIER: QDEC Interrupt Enable Register
func (o *TC_Type) SetQIER_IDX(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIER_IDX() uint32 {
	return volatile.LoadUint32(&o.QIER.Reg) & 0x1
}
func (o *TC_Type) SetQIER_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIER_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIER_QERR(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIER_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x4) >> 2
}

// TC.QIDR: QDEC Interrupt Disable Register
func (o *TC_Type) SetQIDR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIDR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIDR.Reg) & 0x1
}
func (o *TC_Type) SetQIDR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIDR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIDR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIDR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x4) >> 2
}

// TC.QIMR: QDEC Interrupt Mask Register
func (o *TC_Type) SetQIMR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIMR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIMR.Reg) & 0x1
}
func (o *TC_Type) SetQIMR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIMR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIMR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIMR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x4) >> 2
}

// TC.QISR: QDEC Interrupt Status Register
func (o *TC_Type) SetQISR_IDX(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQISR_IDX() uint32 {
	return volatile.LoadUint32(&o.QISR.Reg) & 0x1
}
func (o *TC_Type) SetQISR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQISR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQISR_QERR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQISR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetQISR_DIR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetQISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x100) >> 8
}

// TC.FMR: Fault Mode Register
func (o *TC_Type) SetFMR_ENCF0(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetFMR_ENCF0() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0x1
}
func (o *TC_Type) SetFMR_ENCF1(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetFMR_ENCF1() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0x2) >> 1
}

// TC.WPMR: Write Protection Mode Register
func (o *TC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *TC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Channel Control Register (channel = 0)
type TC_TC_CHANNEL_Type struct {
	CCR  volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	SMMR volatile.Register32 // 0x8
	RAB  volatile.Register32 // 0xC
	CV   volatile.Register32 // 0x10
	RA   volatile.Register32 // 0x14
	RB   volatile.Register32 // 0x18
	RC   volatile.Register32 // 0x1C
	SR   volatile.Register32 // 0x20
	IER  volatile.Register32 // 0x24
	IDR  volatile.Register32 // 0x28
	IMR  volatile.Register32 // 0x2C
	EMR  volatile.Register32 // 0x30
	_    [12]byte
}

// TC_TC_CHANNEL.CCR: Channel Control Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetCCR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetCCR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetCCR_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetCCR_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *TC_TC_CHANNEL_Type) SetCCR_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *TC_TC_CHANNEL_Type) GetCCR_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}

// TC_TC_CHANNEL.CMR: Channel Mode Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetCMR_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x7)|value)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0x7
}
func (o *TC_TC_CHANNEL_Type) SetCMR_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x8)|value<<3)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x8) >> 3
}
func (o *TC_TC_CHANNEL_Type) SetCMR_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x30) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetCMR_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x40)|value<<6)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x40) >> 6
}
func (o *TC_TC_CHANNEL_Type) SetCMR_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x80)|value<<7)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x80) >> 7
}
func (o *TC_TC_CHANNEL_Type) SetCMR_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x300)|value<<8)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x300) >> 8
}
func (o *TC_TC_CHANNEL_Type) SetCMR_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x400)|value<<10)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x400) >> 10
}
func (o *TC_TC_CHANNEL_Type) SetCMR_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x4000)|value<<14)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x4000) >> 14
}
func (o *TC_TC_CHANNEL_Type) SetCMR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x8000)|value<<15)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x8000) >> 15
}
func (o *TC_TC_CHANNEL_Type) SetCMR_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x30000)|value<<16)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x30000) >> 16
}
func (o *TC_TC_CHANNEL_Type) SetCMR_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0xc0000) >> 18
}
func (o *TC_TC_CHANNEL_Type) SetCMR_SBSMPLR(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x700000)|value<<20)
}
func (o *TC_TC_CHANNEL_Type) GetCMR_SBSMPLR() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x700000) >> 20
}

// TC_TC_CHANNEL.SMMR: Stepper Motor Mode Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetSMMR_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetSMMR_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetSMMR_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetSMMR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x2) >> 1
}

// TC_TC_CHANNEL.RAB: Register AB (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetRAB(value uint32) {
	volatile.StoreUint32(&o.RAB.Reg, value)
}
func (o *TC_TC_CHANNEL_Type) GetRAB() uint32 {
	return volatile.LoadUint32(&o.RAB.Reg)
}

// TC_TC_CHANNEL.CV: Counter Value (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetCV(value uint32) {
	volatile.StoreUint32(&o.CV.Reg, value)
}
func (o *TC_TC_CHANNEL_Type) GetCV() uint32 {
	return volatile.LoadUint32(&o.CV.Reg)
}

// TC_TC_CHANNEL.RA: Register A (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetRA(value uint32) {
	volatile.StoreUint32(&o.RA.Reg, value)
}
func (o *TC_TC_CHANNEL_Type) GetRA() uint32 {
	return volatile.LoadUint32(&o.RA.Reg)
}

// TC_TC_CHANNEL.RB: Register B (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetRB(value uint32) {
	volatile.StoreUint32(&o.RB.Reg, value)
}
func (o *TC_TC_CHANNEL_Type) GetRB() uint32 {
	return volatile.LoadUint32(&o.RB.Reg)
}

// TC_TC_CHANNEL.RC: Register C (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetRC(value uint32) {
	volatile.StoreUint32(&o.RC.Reg, value)
}
func (o *TC_TC_CHANNEL_Type) GetRC() uint32 {
	return volatile.LoadUint32(&o.RC.Reg)
}

// TC_TC_CHANNEL.SR: Status Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetSR_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetSR_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetSR_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetSR_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TC_TC_CHANNEL_Type) SetSR_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TC_TC_CHANNEL_Type) GetSR_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TC_TC_CHANNEL_Type) SetSR_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TC_TC_CHANNEL_Type) GetSR_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TC_TC_CHANNEL_Type) SetSR_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetSR_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetSR_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TC_TC_CHANNEL_Type) GetSR_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TC_TC_CHANNEL_Type) SetSR_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TC_TC_CHANNEL_Type) GetSR_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TC_TC_CHANNEL_Type) SetSR_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TC_TC_CHANNEL_Type) GetSR_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TC_TC_CHANNEL_Type) SetSR_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TC_TC_CHANNEL_Type) GetSR_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TC_TC_CHANNEL_Type) SetSR_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *TC_TC_CHANNEL_Type) GetSR_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *TC_TC_CHANNEL_Type) SetSR_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *TC_TC_CHANNEL_Type) GetSR_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}

// TC_TC_CHANNEL.IER: Interrupt Enable Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetIER_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetIER_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetIER_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetIER_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TC_TC_CHANNEL_Type) SetIER_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TC_TC_CHANNEL_Type) GetIER_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TC_TC_CHANNEL_Type) SetIER_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *TC_TC_CHANNEL_Type) GetIER_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *TC_TC_CHANNEL_Type) SetIER_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetIER_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetIER_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TC_TC_CHANNEL_Type) GetIER_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TC_TC_CHANNEL_Type) SetIER_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TC_TC_CHANNEL_Type) GetIER_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TC_TC_CHANNEL_Type) SetIER_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *TC_TC_CHANNEL_Type) GetIER_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}

// TC_TC_CHANNEL.IDR: Interrupt Disable Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetIDR_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetIDR_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TC_TC_CHANNEL_Type) SetIDR_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TC_TC_CHANNEL_Type) SetIDR_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *TC_TC_CHANNEL_Type) SetIDR_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetIDR_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TC_TC_CHANNEL_Type) SetIDR_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TC_TC_CHANNEL_Type) SetIDR_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *TC_TC_CHANNEL_Type) GetIDR_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}

// TC_TC_CHANNEL.IMR: Interrupt Mask Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetIMR_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TC_TC_CHANNEL_Type) SetIMR_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TC_TC_CHANNEL_Type) SetIMR_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TC_TC_CHANNEL_Type) SetIMR_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *TC_TC_CHANNEL_Type) SetIMR_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetIMR_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TC_TC_CHANNEL_Type) SetIMR_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TC_TC_CHANNEL_Type) SetIMR_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *TC_TC_CHANNEL_Type) GetIMR_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}

// TC_TC_CHANNEL.EMR: Extended Mode Register (channel = 0)
func (o *TC_TC_CHANNEL_Type) SetEMR_TRIGSRCA(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3)|value)
}
func (o *TC_TC_CHANNEL_Type) GetEMR_TRIGSRCA() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x3
}
func (o *TC_TC_CHANNEL_Type) SetEMR_TRIGSRCB(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_TC_CHANNEL_Type) GetEMR_TRIGSRCB() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *TC_TC_CHANNEL_Type) SetEMR_NODIVCLK(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x100)|value<<8)
}
func (o *TC_TC_CHANNEL_Type) GetEMR_NODIVCLK() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x100) >> 8
}

// True Random Number Generator
type TRNG_Type struct {
	CR    volatile.Register32 // 0x0
	_     [12]byte
	IER   volatile.Register32 // 0x10
	IDR   volatile.Register32 // 0x14
	IMR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	_     [48]byte
	ODATA volatile.Register32 // 0x50
}

// TRNG.CR: Control Register
func (o *TRNG_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TRNG_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TRNG_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffffff00) >> 8
}

// TRNG.IER: Interrupt Enable Register
func (o *TRNG_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// TRNG.IDR: Interrupt Disable Register
func (o *TRNG_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// TRNG.IMR: Interrupt Mask Register
func (o *TRNG_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// TRNG.ISR: Interrupt Status Register
func (o *TRNG_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// TRNG.ODATA: Output Data Register
func (o *TRNG_Type) SetODATA(value uint32) {
	volatile.StoreUint32(&o.ODATA.Reg, value)
}
func (o *TRNG_Type) GetODATA() uint32 {
	return volatile.LoadUint32(&o.ODATA.Reg)
}

// Two-wire Interface High Speed
type TWIHS_Type struct {
	CR    volatile.Register32 // 0x0
	MMR   volatile.Register32 // 0x4
	SMR   volatile.Register32 // 0x8
	IADR  volatile.Register32 // 0xC
	CWGR  volatile.Register32 // 0x10
	_     [12]byte
	SR    volatile.Register32 // 0x20
	IER   volatile.Register32 // 0x24
	IDR   volatile.Register32 // 0x28
	IMR   volatile.Register32 // 0x2C
	RHR   volatile.Register32 // 0x30
	THR   volatile.Register32 // 0x34
	SMBTR volatile.Register32 // 0x38
	_     [8]byte
	FILTR volatile.Register32 // 0x44
	_     [4]byte
	SWMR  volatile.Register32 // 0x4C
	_     [148]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// TWIHS.CR: Control Register
func (o *TWIHS_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TWIHS_Type) SetCR_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetCR_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetCR_MSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetCR_MSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetCR_MSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *TWIHS_Type) GetCR_MSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *TWIHS_Type) SetCR_SVEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *TWIHS_Type) GetCR_SVEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *TWIHS_Type) SetCR_SVDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *TWIHS_Type) GetCR_SVDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *TWIHS_Type) SetCR_QUICK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetCR_QUICK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *TWIHS_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *TWIHS_Type) SetCR_HSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *TWIHS_Type) GetCR_HSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *TWIHS_Type) SetCR_HSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *TWIHS_Type) GetCR_HSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *TWIHS_Type) SetCR_SMBEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *TWIHS_Type) GetCR_SMBEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *TWIHS_Type) SetCR_SMBDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *TWIHS_Type) GetCR_SMBDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *TWIHS_Type) SetCR_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *TWIHS_Type) GetCR_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *TWIHS_Type) SetCR_PECDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *TWIHS_Type) GetCR_PECDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *TWIHS_Type) SetCR_PECRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *TWIHS_Type) GetCR_PECRQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *TWIHS_Type) SetCR_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *TWIHS_Type) GetCR_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *TWIHS_Type) SetCR_ACMEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *TWIHS_Type) GetCR_ACMEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *TWIHS_Type) SetCR_ACMDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *TWIHS_Type) GetCR_ACMDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *TWIHS_Type) SetCR_THRCLR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIHS_Type) GetCR_THRCLR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *TWIHS_Type) SetCR_LOCKCLR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIHS_Type) GetCR_LOCKCLR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *TWIHS_Type) SetCR_FIFOEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *TWIHS_Type) GetCR_FIFOEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *TWIHS_Type) SetCR_FIFODIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *TWIHS_Type) GetCR_FIFODIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}

// TWIHS.MMR: Master Mode Register
func (o *TWIHS_Type) SetMMR_IADRSZ(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x300)|value<<8)
}
func (o *TWIHS_Type) GetMMR_IADRSZ() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x300) >> 8
}
func (o *TWIHS_Type) SetMMR_MREAD(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x1000)|value<<12)
}
func (o *TWIHS_Type) GetMMR_MREAD() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x1000) >> 12
}
func (o *TWIHS_Type) SetMMR_DADR(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWIHS_Type) GetMMR_DADR() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x7f0000) >> 16
}

// TWIHS.SMR: Slave Mode Register
func (o *TWIHS_Type) SetSMR_NACKEN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetSMR_NACKEN() uint32 {
	return volatile.LoadUint32(&o.SMR.Reg) & 0x1
}
func (o *TWIHS_Type) SetSMR_SMDA(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetSMR_SMDA() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetSMR_SMHH(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *TWIHS_Type) GetSMR_SMHH() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x8) >> 3
}
func (o *TWIHS_Type) SetSMR_SCLWSDIS(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetSMR_SCLWSDIS() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetSMR_MASK(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7f00)|value<<8)
}
func (o *TWIHS_Type) GetSMR_MASK() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x7f00) >> 8
}
func (o *TWIHS_Type) SetSMR_SADR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWIHS_Type) GetSMR_SADR() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x7f0000) >> 16
}
func (o *TWIHS_Type) SetSMR_SADR1EN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x10000000)|value<<28)
}
func (o *TWIHS_Type) GetSMR_SADR1EN() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x10000000) >> 28
}
func (o *TWIHS_Type) SetSMR_SADR2EN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x20000000)|value<<29)
}
func (o *TWIHS_Type) GetSMR_SADR2EN() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x20000000) >> 29
}
func (o *TWIHS_Type) SetSMR_SADR3EN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x40000000)|value<<30)
}
func (o *TWIHS_Type) GetSMR_SADR3EN() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x40000000) >> 30
}
func (o *TWIHS_Type) SetSMR_DATAMEN(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIHS_Type) GetSMR_DATAMEN() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x80000000) >> 31
}

// TWIHS.IADR: Internal Address Register
func (o *TWIHS_Type) SetIADR(value uint32) {
	volatile.StoreUint32(&o.IADR.Reg, volatile.LoadUint32(&o.IADR.Reg)&^(0xffffff)|value)
}
func (o *TWIHS_Type) GetIADR() uint32 {
	return volatile.LoadUint32(&o.IADR.Reg) & 0xffffff
}

// TWIHS.CWGR: Clock Waveform Generator Register
func (o *TWIHS_Type) SetCWGR_CLDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff)|value)
}
func (o *TWIHS_Type) GetCWGR_CLDIV() uint32 {
	return volatile.LoadUint32(&o.CWGR.Reg) & 0xff
}
func (o *TWIHS_Type) SetCWGR_CHDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff00)|value<<8)
}
func (o *TWIHS_Type) GetCWGR_CHDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0xff00) >> 8
}
func (o *TWIHS_Type) SetCWGR_CKDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0x70000)|value<<16)
}
func (o *TWIHS_Type) GetCWGR_CKDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0x70000) >> 16
}
func (o *TWIHS_Type) SetCWGR_HOLD(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0x3f000000)|value<<24)
}
func (o *TWIHS_Type) GetCWGR_HOLD() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0x3f000000) >> 24
}

// TWIHS.SR: Status Register
func (o *TWIHS_Type) SetSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetSR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TWIHS_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetSR_SVREAD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TWIHS_Type) GetSR_SVREAD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TWIHS_Type) SetSR_SVACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TWIHS_Type) GetSR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TWIHS_Type) SetSR_GACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TWIHS_Type) GetSR_GACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TWIHS_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetSR_UNRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TWIHS_Type) GetSR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TWIHS_Type) SetSR_NACK(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TWIHS_Type) GetSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TWIHS_Type) SetSR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TWIHS_Type) GetSR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TWIHS_Type) SetSR_SCLWS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TWIHS_Type) GetSR_SCLWS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TWIHS_Type) SetSR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TWIHS_Type) GetSR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TWIHS_Type) SetSR_MCACK(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TWIHS_Type) GetSR_MCACK() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TWIHS_Type) SetSR_TOUT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIHS_Type) GetSR_TOUT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *TWIHS_Type) SetSR_PECERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIHS_Type) GetSR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *TWIHS_Type) SetSR_SMBDAM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIHS_Type) GetSR_SMBDAM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *TWIHS_Type) SetSR_SMBHHM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *TWIHS_Type) GetSR_SMBHHM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *TWIHS_Type) SetSR_SCL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIHS_Type) GetSR_SCL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *TWIHS_Type) SetSR_SDA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIHS_Type) GetSR_SDA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}

// TWIHS.IER: Interrupt Enable Register
func (o *TWIHS_Type) SetIER_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetIER_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TWIHS_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetIER_SVACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TWIHS_Type) GetIER_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TWIHS_Type) SetIER_GACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TWIHS_Type) GetIER_GACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TWIHS_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetIER_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *TWIHS_Type) GetIER_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *TWIHS_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TWIHS_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *TWIHS_Type) SetIER_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *TWIHS_Type) GetIER_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *TWIHS_Type) SetIER_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *TWIHS_Type) GetIER_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *TWIHS_Type) SetIER_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *TWIHS_Type) GetIER_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *TWIHS_Type) SetIER_MCACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *TWIHS_Type) GetIER_MCACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *TWIHS_Type) SetIER_TOUT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *TWIHS_Type) GetIER_TOUT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *TWIHS_Type) SetIER_PECERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *TWIHS_Type) GetIER_PECERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *TWIHS_Type) SetIER_SMBDAM(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *TWIHS_Type) GetIER_SMBDAM() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *TWIHS_Type) SetIER_SMBHHM(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *TWIHS_Type) GetIER_SMBHHM() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}

// TWIHS.IDR: Interrupt Disable Register
func (o *TWIHS_Type) SetIDR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetIDR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TWIHS_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetIDR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TWIHS_Type) GetIDR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TWIHS_Type) SetIDR_GACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TWIHS_Type) GetIDR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TWIHS_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetIDR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *TWIHS_Type) GetIDR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *TWIHS_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TWIHS_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *TWIHS_Type) SetIDR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *TWIHS_Type) GetIDR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *TWIHS_Type) SetIDR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *TWIHS_Type) GetIDR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *TWIHS_Type) SetIDR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *TWIHS_Type) GetIDR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *TWIHS_Type) SetIDR_MCACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *TWIHS_Type) GetIDR_MCACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *TWIHS_Type) SetIDR_TOUT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIHS_Type) GetIDR_TOUT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *TWIHS_Type) SetIDR_PECERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIHS_Type) GetIDR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *TWIHS_Type) SetIDR_SMBDAM(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIHS_Type) GetIDR_SMBDAM() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *TWIHS_Type) SetIDR_SMBHHM(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *TWIHS_Type) GetIDR_SMBHHM() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}

// TWIHS.IMR: Interrupt Mask Register
func (o *TWIHS_Type) SetIMR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetIMR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TWIHS_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetIMR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TWIHS_Type) GetIMR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TWIHS_Type) SetIMR_GACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TWIHS_Type) GetIMR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TWIHS_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TWIHS_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TWIHS_Type) SetIMR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *TWIHS_Type) GetIMR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *TWIHS_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TWIHS_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *TWIHS_Type) SetIMR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *TWIHS_Type) GetIMR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *TWIHS_Type) SetIMR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *TWIHS_Type) GetIMR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *TWIHS_Type) SetIMR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *TWIHS_Type) GetIMR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *TWIHS_Type) SetIMR_MCACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *TWIHS_Type) GetIMR_MCACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *TWIHS_Type) SetIMR_TOUT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIHS_Type) GetIMR_TOUT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *TWIHS_Type) SetIMR_PECERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIHS_Type) GetIMR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *TWIHS_Type) SetIMR_SMBDAM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIHS_Type) GetIMR_SMBDAM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *TWIHS_Type) SetIMR_SMBHHM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *TWIHS_Type) GetIMR_SMBHHM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}

// TWIHS.RHR: Receive Holding Register
func (o *TWIHS_Type) SetRHR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *TWIHS_Type) GetRHR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// TWIHS.THR: Transmit Holding Register
func (o *TWIHS_Type) SetTHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *TWIHS_Type) GetTHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// TWIHS.SMBTR: SMBus Timing Register
func (o *TWIHS_Type) SetSMBTR_PRESC(value uint32) {
	volatile.StoreUint32(&o.SMBTR.Reg, volatile.LoadUint32(&o.SMBTR.Reg)&^(0xf)|value)
}
func (o *TWIHS_Type) GetSMBTR_PRESC() uint32 {
	return volatile.LoadUint32(&o.SMBTR.Reg) & 0xf
}
func (o *TWIHS_Type) SetSMBTR_TLOWS(value uint32) {
	volatile.StoreUint32(&o.SMBTR.Reg, volatile.LoadUint32(&o.SMBTR.Reg)&^(0xff00)|value<<8)
}
func (o *TWIHS_Type) GetSMBTR_TLOWS() uint32 {
	return (volatile.LoadUint32(&o.SMBTR.Reg) & 0xff00) >> 8
}
func (o *TWIHS_Type) SetSMBTR_TLOWM(value uint32) {
	volatile.StoreUint32(&o.SMBTR.Reg, volatile.LoadUint32(&o.SMBTR.Reg)&^(0xff0000)|value<<16)
}
func (o *TWIHS_Type) GetSMBTR_TLOWM() uint32 {
	return (volatile.LoadUint32(&o.SMBTR.Reg) & 0xff0000) >> 16
}
func (o *TWIHS_Type) SetSMBTR_THMAX(value uint32) {
	volatile.StoreUint32(&o.SMBTR.Reg, volatile.LoadUint32(&o.SMBTR.Reg)&^(0xff000000)|value<<24)
}
func (o *TWIHS_Type) GetSMBTR_THMAX() uint32 {
	return (volatile.LoadUint32(&o.SMBTR.Reg) & 0xff000000) >> 24
}

// TWIHS.FILTR: Filter Register
func (o *TWIHS_Type) SetFILTR_FILT(value uint32) {
	volatile.StoreUint32(&o.FILTR.Reg, volatile.LoadUint32(&o.FILTR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetFILTR_FILT() uint32 {
	return volatile.LoadUint32(&o.FILTR.Reg) & 0x1
}
func (o *TWIHS_Type) SetFILTR_PADFEN(value uint32) {
	volatile.StoreUint32(&o.FILTR.Reg, volatile.LoadUint32(&o.FILTR.Reg)&^(0x2)|value<<1)
}
func (o *TWIHS_Type) GetFILTR_PADFEN() uint32 {
	return (volatile.LoadUint32(&o.FILTR.Reg) & 0x2) >> 1
}
func (o *TWIHS_Type) SetFILTR_PADFCFG(value uint32) {
	volatile.StoreUint32(&o.FILTR.Reg, volatile.LoadUint32(&o.FILTR.Reg)&^(0x4)|value<<2)
}
func (o *TWIHS_Type) GetFILTR_PADFCFG() uint32 {
	return (volatile.LoadUint32(&o.FILTR.Reg) & 0x4) >> 2
}
func (o *TWIHS_Type) SetFILTR_THRES(value uint32) {
	volatile.StoreUint32(&o.FILTR.Reg, volatile.LoadUint32(&o.FILTR.Reg)&^(0x700)|value<<8)
}
func (o *TWIHS_Type) GetFILTR_THRES() uint32 {
	return (volatile.LoadUint32(&o.FILTR.Reg) & 0x700) >> 8
}

// TWIHS.SWMR: SleepWalking Matching Register
func (o *TWIHS_Type) SetSWMR_SADR1(value uint32) {
	volatile.StoreUint32(&o.SWMR.Reg, volatile.LoadUint32(&o.SWMR.Reg)&^(0x7f)|value)
}
func (o *TWIHS_Type) GetSWMR_SADR1() uint32 {
	return volatile.LoadUint32(&o.SWMR.Reg) & 0x7f
}
func (o *TWIHS_Type) SetSWMR_SADR2(value uint32) {
	volatile.StoreUint32(&o.SWMR.Reg, volatile.LoadUint32(&o.SWMR.Reg)&^(0x7f00)|value<<8)
}
func (o *TWIHS_Type) GetSWMR_SADR2() uint32 {
	return (volatile.LoadUint32(&o.SWMR.Reg) & 0x7f00) >> 8
}
func (o *TWIHS_Type) SetSWMR_SADR3(value uint32) {
	volatile.StoreUint32(&o.SWMR.Reg, volatile.LoadUint32(&o.SWMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWIHS_Type) GetSWMR_SADR3() uint32 {
	return (volatile.LoadUint32(&o.SWMR.Reg) & 0x7f0000) >> 16
}
func (o *TWIHS_Type) SetSWMR_DATAM(value uint32) {
	volatile.StoreUint32(&o.SWMR.Reg, volatile.LoadUint32(&o.SWMR.Reg)&^(0xff000000)|value<<24)
}
func (o *TWIHS_Type) GetSWMR_DATAM() uint32 {
	return (volatile.LoadUint32(&o.SWMR.Reg) & 0xff000000) >> 24
}

// TWIHS.WPMR: Write Protection Mode Register
func (o *TWIHS_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *TWIHS_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWIHS_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// TWIHS.WPSR: Write Protection Status Register
func (o *TWIHS_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *TWIHS_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *TWIHS_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWIHS_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffffff00) >> 8
}

// Universal Asynchronous Receiver Transmitter
type UART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	CMPR volatile.Register32 // 0x24
	_    [188]byte
	WPMR volatile.Register32 // 0xE4
}

// UART.CR: Control Register
func (o *UART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetCR_REQCLR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetCR_REQCLR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}

// UART.MR: Mode Register
func (o *UART_Type) SetMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *UART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *UART_Type) SetMR_BRSRCCK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetMR_BRSRCCK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *UART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// UART.IER: Interrupt Enable Register
func (o *UART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *UART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetIER_CMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetIER_CMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}

// UART.IDR: Interrupt Disable Register
func (o *UART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *UART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetIDR_CMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetIDR_CMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}

// UART.IMR: Interrupt Mask Register
func (o *UART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *UART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetIMR_CMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetIMR_CMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}

// UART.SR: Status Register
func (o *UART_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *UART_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetSR_CMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetSR_CMP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}

// UART.RHR: Receive Holding Register
func (o *UART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// UART.THR: Transmit Holding Register
func (o *UART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// UART.BRGR: Baud Rate Generator Register
func (o *UART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// UART.CMPR: Comparison Register
func (o *UART_Type) SetCMPR_VAL1(value uint32) {
	volatile.StoreUint32(&o.CMPR.Reg, volatile.LoadUint32(&o.CMPR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetCMPR_VAL1() uint32 {
	return volatile.LoadUint32(&o.CMPR.Reg) & 0xff
}
func (o *UART_Type) SetCMPR_CMPMODE(value uint32) {
	volatile.StoreUint32(&o.CMPR.Reg, volatile.LoadUint32(&o.CMPR.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetCMPR_CMPMODE() uint32 {
	return (volatile.LoadUint32(&o.CMPR.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetCMPR_CMPPAR(value uint32) {
	volatile.StoreUint32(&o.CMPR.Reg, volatile.LoadUint32(&o.CMPR.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetCMPR_CMPPAR() uint32 {
	return (volatile.LoadUint32(&o.CMPR.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetCMPR_VAL2(value uint32) {
	volatile.StoreUint32(&o.CMPR.Reg, volatile.LoadUint32(&o.CMPR.Reg)&^(0xff0000)|value<<16)
}
func (o *UART_Type) GetCMPR_VAL2() uint32 {
	return (volatile.LoadUint32(&o.CMPR.Reg) & 0xff0000) >> 16
}

// UART.WPMR: Write Protection Mode Register
func (o *UART_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *UART_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Universal Synchronous Asynchronous Receiver Transmitter
type USART_Type struct {
	US_CR       volatile.Register32 // 0x0
	US_MR       volatile.Register32 // 0x4
	US_IER      volatile.Register32 // 0x8
	US_IDR      volatile.Register32 // 0xC
	US_IMR      volatile.Register32 // 0x10
	US_CSR      volatile.Register32 // 0x14
	US_RHR      volatile.Register32 // 0x18
	US_THR      volatile.Register32 // 0x1C
	US_BRGR     volatile.Register32 // 0x20
	US_RTOR     volatile.Register32 // 0x24
	US_TTGR     volatile.Register32 // 0x28
	_           [20]byte
	US_FIDI     volatile.Register32 // 0x40
	US_NER      volatile.Register32 // 0x44
	_           [4]byte
	US_IF       volatile.Register32 // 0x4C
	US_MAN      volatile.Register32 // 0x50
	US_LINMR    volatile.Register32 // 0x54
	US_LINIR    volatile.Register32 // 0x58
	US_LINBRR   volatile.Register32 // 0x5C
	US_LONMR    volatile.Register32 // 0x60
	US_LONPR    volatile.Register32 // 0x64
	US_LONDL    volatile.Register32 // 0x68
	US_LONL2HDR volatile.Register32 // 0x6C
	US_LONBL    volatile.Register32 // 0x70
	US_LONB1TX  volatile.Register32 // 0x74
	US_LONB1RX  volatile.Register32 // 0x78
	US_LONPRIO  volatile.Register32 // 0x7C
	US_IDTTX    volatile.Register32 // 0x80
	US_IDTRX    volatile.Register32 // 0x84
	US_ICDIFF   volatile.Register32 // 0x88
	_           [88]byte
	US_WPMR     volatile.Register32 // 0xE4
	US_WPSR     volatile.Register32 // 0xE8
}

// USART.US_CR: Control Register
func (o *USART_Type) SetUS_CR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_CR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_CR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetUS_CR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetUS_CR_RXEN(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetUS_CR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetUS_CR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_CR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_CR_TXEN(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_CR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_CR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_CR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_CR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_CR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_CR_STTBRK(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetUS_CR_STTBRK() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetUS_CR_STPBRK(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetUS_CR_STPBRK() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetUS_CR_STTTO(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetUS_CR_STTTO() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetUS_CR_SENDA(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetUS_CR_SENDA() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetUS_CR_RSTIT(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetUS_CR_RSTIT() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetUS_CR_RSTNACK(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetUS_CR_RSTNACK() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetUS_CR_RETTO(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetUS_CR_RETTO() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetUS_CR_DTREN(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_CR_DTREN() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_CR_DTRDIS(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_CR_DTRDIS() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_CR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_CR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_CR_RTSDIS(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_CR_RTSDIS() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_CR_LINABT(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetUS_CR_LINABT() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetUS_CR_LINWKUP(value uint32) {
	volatile.StoreUint32(&o.US_CR.Reg, volatile.LoadUint32(&o.US_CR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetUS_CR_LINWKUP() uint32 {
	return (volatile.LoadUint32(&o.US_CR.Reg) & 0x200000) >> 21
}

// USART.US_MR: Mode Register
func (o *USART_Type) SetUS_MR_USART_MODE(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetUS_MR_USART_MODE() uint32 {
	return volatile.LoadUint32(&o.US_MR.Reg) & 0xf
}
func (o *USART_Type) SetUS_MR_USCLKS(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetUS_MR_USCLKS() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetUS_MR_CHRL(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0xc0)|value<<6)
}
func (o *USART_Type) GetUS_MR_CHRL() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0xc0) >> 6
}
func (o *USART_Type) SetUS_MR_SYNC(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_MR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_MR_PAR(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0xe00)|value<<9)
}
func (o *USART_Type) GetUS_MR_PAR() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0xe00) >> 9
}
func (o *USART_Type) SetUS_MR_NBSTOP(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetUS_MR_NBSTOP() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetUS_MR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0xc000)|value<<14)
}
func (o *USART_Type) GetUS_MR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0xc000) >> 14
}
func (o *USART_Type) SetUS_MR_MSBF(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_MR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_MR_MODE9(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_MR_MODE9() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_MR_CLKO(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_MR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_MR_OVER(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_MR_OVER() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_MR_INACK(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetUS_MR_INACK() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetUS_MR_DSNACK(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetUS_MR_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetUS_MR_VAR_SYNC(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetUS_MR_VAR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetUS_MR_INVDATA(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetUS_MR_INVDATA() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetUS_MR_MAX_ITERATION(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x7000000)|value<<24)
}
func (o *USART_Type) GetUS_MR_MAX_ITERATION() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x7000000) >> 24
}
func (o *USART_Type) SetUS_MR_FILTER(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetUS_MR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetUS_MR_MAN(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetUS_MR_MAN() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetUS_MR_MODSYNC(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetUS_MR_MODSYNC() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetUS_MR_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.US_MR.Reg, volatile.LoadUint32(&o.US_MR.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetUS_MR_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.US_MR.Reg) & 0x80000000) >> 31
}

// USART.US_IER: Interrupt Enable Register
func (o *USART_Type) SetUS_IER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_IER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.US_IER.Reg) & 0x1
}
func (o *USART_Type) SetUS_IER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetUS_IER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetUS_IER_RXBRK(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_IER_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_IER_OVRE(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_IER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_IER_FRAME(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_IER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_IER_PARE(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_IER_PARE() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_IER_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_IER_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_IER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetUS_IER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetUS_IER_ITER(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetUS_IER_ITER() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetUS_IER_NACK(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetUS_IER_NACK() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetUS_IER_RIIC(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_IER_RIIC() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_IER_DSRIC(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_IER_DSRIC() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_IER_DCDIC(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_IER_DCDIC() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_IER_CTSIC(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_IER_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_IER_MANE(value uint32) {
	volatile.StoreUint32(&o.US_IER.Reg, volatile.LoadUint32(&o.US_IER.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetUS_IER_MANE() uint32 {
	return (volatile.LoadUint32(&o.US_IER.Reg) & 0x1000000) >> 24
}

// USART.US_IDR: Interrupt Disable Register
func (o *USART_Type) SetUS_IDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_IDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.US_IDR.Reg) & 0x1
}
func (o *USART_Type) SetUS_IDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetUS_IDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetUS_IDR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_IDR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_IDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_IDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_IDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_IDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_IDR_PARE(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_IDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_IDR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_IDR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_IDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetUS_IDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetUS_IDR_ITER(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetUS_IDR_ITER() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetUS_IDR_NACK(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetUS_IDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetUS_IDR_RIIC(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_IDR_RIIC() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_IDR_DSRIC(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_IDR_DSRIC() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_IDR_DCDIC(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_IDR_DCDIC() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_IDR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_IDR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_IDR_MANE(value uint32) {
	volatile.StoreUint32(&o.US_IDR.Reg, volatile.LoadUint32(&o.US_IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetUS_IDR_MANE() uint32 {
	return (volatile.LoadUint32(&o.US_IDR.Reg) & 0x1000000) >> 24
}

// USART.US_IMR: Interrupt Mask Register
func (o *USART_Type) SetUS_IMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_IMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.US_IMR.Reg) & 0x1
}
func (o *USART_Type) SetUS_IMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetUS_IMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetUS_IMR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_IMR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_IMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_IMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_IMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_IMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_IMR_PARE(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_IMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_IMR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_IMR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_IMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetUS_IMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetUS_IMR_ITER(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetUS_IMR_ITER() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetUS_IMR_NACK(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetUS_IMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetUS_IMR_RIIC(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_IMR_RIIC() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_IMR_DSRIC(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_IMR_DSRIC() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_IMR_DCDIC(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_IMR_DCDIC() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_IMR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_IMR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_IMR_MANE(value uint32) {
	volatile.StoreUint32(&o.US_IMR.Reg, volatile.LoadUint32(&o.US_IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetUS_IMR_MANE() uint32 {
	return (volatile.LoadUint32(&o.US_IMR.Reg) & 0x1000000) >> 24
}

// USART.US_CSR: Channel Status Register
func (o *USART_Type) SetUS_CSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_CSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.US_CSR.Reg) & 0x1
}
func (o *USART_Type) SetUS_CSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetUS_CSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetUS_CSR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_CSR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_CSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_CSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_CSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_CSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_CSR_PARE(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_CSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_CSR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetUS_CSR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetUS_CSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetUS_CSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetUS_CSR_ITER(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetUS_CSR_ITER() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetUS_CSR_NACK(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetUS_CSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetUS_CSR_RIIC(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_CSR_RIIC() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_CSR_DSRIC(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_CSR_DSRIC() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetUS_CSR_DCDIC(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetUS_CSR_DCDIC() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetUS_CSR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetUS_CSR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetUS_CSR_RI(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetUS_CSR_RI() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetUS_CSR_DSR(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetUS_CSR_DSR() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetUS_CSR_DCD(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetUS_CSR_DCD() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetUS_CSR_CTS(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetUS_CSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetUS_CSR_MANERR(value uint32) {
	volatile.StoreUint32(&o.US_CSR.Reg, volatile.LoadUint32(&o.US_CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetUS_CSR_MANERR() uint32 {
	return (volatile.LoadUint32(&o.US_CSR.Reg) & 0x1000000) >> 24
}

// USART.US_RHR: Receive Holding Register
func (o *USART_Type) SetUS_RHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.US_RHR.Reg, volatile.LoadUint32(&o.US_RHR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetUS_RHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.US_RHR.Reg) & 0x1ff
}
func (o *USART_Type) SetUS_RHR_RXSYNH(value uint32) {
	volatile.StoreUint32(&o.US_RHR.Reg, volatile.LoadUint32(&o.US_RHR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetUS_RHR_RXSYNH() uint32 {
	return (volatile.LoadUint32(&o.US_RHR.Reg) & 0x8000) >> 15
}

// USART.US_THR: Transmit Holding Register
func (o *USART_Type) SetUS_THR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.US_THR.Reg, volatile.LoadUint32(&o.US_THR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetUS_THR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.US_THR.Reg) & 0x1ff
}
func (o *USART_Type) SetUS_THR_TXSYNH(value uint32) {
	volatile.StoreUint32(&o.US_THR.Reg, volatile.LoadUint32(&o.US_THR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetUS_THR_TXSYNH() uint32 {
	return (volatile.LoadUint32(&o.US_THR.Reg) & 0x8000) >> 15
}

// USART.US_BRGR: Baud Rate Generator Register
func (o *USART_Type) SetUS_BRGR_CD(value uint32) {
	volatile.StoreUint32(&o.US_BRGR.Reg, volatile.LoadUint32(&o.US_BRGR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetUS_BRGR_CD() uint32 {
	return volatile.LoadUint32(&o.US_BRGR.Reg) & 0xffff
}
func (o *USART_Type) SetUS_BRGR_FP(value uint32) {
	volatile.StoreUint32(&o.US_BRGR.Reg, volatile.LoadUint32(&o.US_BRGR.Reg)&^(0x70000)|value<<16)
}
func (o *USART_Type) GetUS_BRGR_FP() uint32 {
	return (volatile.LoadUint32(&o.US_BRGR.Reg) & 0x70000) >> 16
}

// USART.US_RTOR: Receiver Time-out Register
func (o *USART_Type) SetUS_RTOR_TO(value uint32) {
	volatile.StoreUint32(&o.US_RTOR.Reg, volatile.LoadUint32(&o.US_RTOR.Reg)&^(0x1ffff)|value)
}
func (o *USART_Type) GetUS_RTOR_TO() uint32 {
	return volatile.LoadUint32(&o.US_RTOR.Reg) & 0x1ffff
}

// USART.US_TTGR: Transmitter Timeguard Register
func (o *USART_Type) SetUS_TTGR_TG(value uint32) {
	volatile.StoreUint32(&o.US_TTGR.Reg, volatile.LoadUint32(&o.US_TTGR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetUS_TTGR_TG() uint32 {
	return volatile.LoadUint32(&o.US_TTGR.Reg) & 0xff
}

// USART.US_FIDI: FI DI Ratio Register
func (o *USART_Type) SetUS_FIDI_FI_DI_RATIO(value uint32) {
	volatile.StoreUint32(&o.US_FIDI.Reg, volatile.LoadUint32(&o.US_FIDI.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetUS_FIDI_FI_DI_RATIO() uint32 {
	return volatile.LoadUint32(&o.US_FIDI.Reg) & 0xffff
}

// USART.US_NER: Number of Errors Register
func (o *USART_Type) SetUS_NER_NB_ERRORS(value uint32) {
	volatile.StoreUint32(&o.US_NER.Reg, volatile.LoadUint32(&o.US_NER.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetUS_NER_NB_ERRORS() uint32 {
	return volatile.LoadUint32(&o.US_NER.Reg) & 0xff
}

// USART.US_IF: IrDA Filter Register
func (o *USART_Type) SetUS_IF_IRDA_FILTER(value uint32) {
	volatile.StoreUint32(&o.US_IF.Reg, volatile.LoadUint32(&o.US_IF.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetUS_IF_IRDA_FILTER() uint32 {
	return volatile.LoadUint32(&o.US_IF.Reg) & 0xff
}

// USART.US_MAN: Manchester Configuration Register
func (o *USART_Type) SetUS_MAN_TX_PL(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetUS_MAN_TX_PL() uint32 {
	return volatile.LoadUint32(&o.US_MAN.Reg) & 0xf
}
func (o *USART_Type) SetUS_MAN_TX_PP(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x300)|value<<8)
}
func (o *USART_Type) GetUS_MAN_TX_PP() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x300) >> 8
}
func (o *USART_Type) SetUS_MAN_TX_MPOL(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetUS_MAN_TX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetUS_MAN_RX_PL(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0xf0000)|value<<16)
}
func (o *USART_Type) GetUS_MAN_RX_PL() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0xf0000) >> 16
}
func (o *USART_Type) SetUS_MAN_RX_PP(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x3000000)|value<<24)
}
func (o *USART_Type) GetUS_MAN_RX_PP() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x3000000) >> 24
}
func (o *USART_Type) SetUS_MAN_RX_MPOL(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetUS_MAN_RX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetUS_MAN_ONE(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetUS_MAN_ONE() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetUS_MAN_DRIFT(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetUS_MAN_DRIFT() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetUS_MAN_RXIDLEV(value uint32) {
	volatile.StoreUint32(&o.US_MAN.Reg, volatile.LoadUint32(&o.US_MAN.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetUS_MAN_RXIDLEV() uint32 {
	return (volatile.LoadUint32(&o.US_MAN.Reg) & 0x80000000) >> 31
}

// USART.US_LINMR: LIN Mode Register
func (o *USART_Type) SetUS_LINMR_NACT(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x3)|value)
}
func (o *USART_Type) GetUS_LINMR_NACT() uint32 {
	return volatile.LoadUint32(&o.US_LINMR.Reg) & 0x3
}
func (o *USART_Type) SetUS_LINMR_PARDIS(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_LINMR_PARDIS() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_LINMR_CHKDIS(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetUS_LINMR_CHKDIS() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetUS_LINMR_CHKTYP(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetUS_LINMR_CHKTYP() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetUS_LINMR_DLM(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_LINMR_DLM() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_LINMR_FSDIS(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_LINMR_FSDIS() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_LINMR_WKUPTYP(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_LINMR_WKUPTYP() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetUS_LINMR_DLC(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetUS_LINMR_DLC() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetUS_LINMR_PDCM(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetUS_LINMR_PDCM() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetUS_LINMR_SYNCDIS(value uint32) {
	volatile.StoreUint32(&o.US_LINMR.Reg, volatile.LoadUint32(&o.US_LINMR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetUS_LINMR_SYNCDIS() uint32 {
	return (volatile.LoadUint32(&o.US_LINMR.Reg) & 0x20000) >> 17
}

// USART.US_LINIR: LIN Identifier Register
func (o *USART_Type) SetUS_LINIR_IDCHR(value uint32) {
	volatile.StoreUint32(&o.US_LINIR.Reg, volatile.LoadUint32(&o.US_LINIR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetUS_LINIR_IDCHR() uint32 {
	return volatile.LoadUint32(&o.US_LINIR.Reg) & 0xff
}

// USART.US_LINBRR: LIN Baud Rate Register
func (o *USART_Type) SetUS_LINBRR_LINCD(value uint32) {
	volatile.StoreUint32(&o.US_LINBRR.Reg, volatile.LoadUint32(&o.US_LINBRR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetUS_LINBRR_LINCD() uint32 {
	return volatile.LoadUint32(&o.US_LINBRR.Reg) & 0xffff
}
func (o *USART_Type) SetUS_LINBRR_LINFP(value uint32) {
	volatile.StoreUint32(&o.US_LINBRR.Reg, volatile.LoadUint32(&o.US_LINBRR.Reg)&^(0x70000)|value<<16)
}
func (o *USART_Type) GetUS_LINBRR_LINFP() uint32 {
	return (volatile.LoadUint32(&o.US_LINBRR.Reg) & 0x70000) >> 16
}

// USART.US_LONMR: LON Mode Register
func (o *USART_Type) SetUS_LONMR_COMMT(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_LONMR_COMMT() uint32 {
	return volatile.LoadUint32(&o.US_LONMR.Reg) & 0x1
}
func (o *USART_Type) SetUS_LONMR_COLDET(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetUS_LONMR_COLDET() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetUS_LONMR_TCOL(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetUS_LONMR_TCOL() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetUS_LONMR_CDTAIL(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetUS_LONMR_CDTAIL() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetUS_LONMR_DMAM(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetUS_LONMR_DMAM() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetUS_LONMR_LCDS(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetUS_LONMR_LCDS() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetUS_LONMR_EOFS(value uint32) {
	volatile.StoreUint32(&o.US_LONMR.Reg, volatile.LoadUint32(&o.US_LONMR.Reg)&^(0xff0000)|value<<16)
}
func (o *USART_Type) GetUS_LONMR_EOFS() uint32 {
	return (volatile.LoadUint32(&o.US_LONMR.Reg) & 0xff0000) >> 16
}

// USART.US_LONPR: LON Preamble Register
func (o *USART_Type) SetUS_LONPR_LONPL(value uint32) {
	volatile.StoreUint32(&o.US_LONPR.Reg, volatile.LoadUint32(&o.US_LONPR.Reg)&^(0x3fff)|value)
}
func (o *USART_Type) GetUS_LONPR_LONPL() uint32 {
	return volatile.LoadUint32(&o.US_LONPR.Reg) & 0x3fff
}

// USART.US_LONDL: LON Data Length Register
func (o *USART_Type) SetUS_LONDL_LONDL(value uint32) {
	volatile.StoreUint32(&o.US_LONDL.Reg, volatile.LoadUint32(&o.US_LONDL.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetUS_LONDL_LONDL() uint32 {
	return volatile.LoadUint32(&o.US_LONDL.Reg) & 0xff
}

// USART.US_LONL2HDR: LON L2HDR Register
func (o *USART_Type) SetUS_LONL2HDR_BLI(value uint32) {
	volatile.StoreUint32(&o.US_LONL2HDR.Reg, volatile.LoadUint32(&o.US_LONL2HDR.Reg)&^(0x3f)|value)
}
func (o *USART_Type) GetUS_LONL2HDR_BLI() uint32 {
	return volatile.LoadUint32(&o.US_LONL2HDR.Reg) & 0x3f
}
func (o *USART_Type) SetUS_LONL2HDR_ALTP(value uint32) {
	volatile.StoreUint32(&o.US_LONL2HDR.Reg, volatile.LoadUint32(&o.US_LONL2HDR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetUS_LONL2HDR_ALTP() uint32 {
	return (volatile.LoadUint32(&o.US_LONL2HDR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetUS_LONL2HDR_PB(value uint32) {
	volatile.StoreUint32(&o.US_LONL2HDR.Reg, volatile.LoadUint32(&o.US_LONL2HDR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetUS_LONL2HDR_PB() uint32 {
	return (volatile.LoadUint32(&o.US_LONL2HDR.Reg) & 0x80) >> 7
}

// USART.US_LONBL: LON Backlog Register
func (o *USART_Type) SetUS_LONBL_LONBL(value uint32) {
	volatile.StoreUint32(&o.US_LONBL.Reg, volatile.LoadUint32(&o.US_LONBL.Reg)&^(0x3f)|value)
}
func (o *USART_Type) GetUS_LONBL_LONBL() uint32 {
	return volatile.LoadUint32(&o.US_LONBL.Reg) & 0x3f
}

// USART.US_LONB1TX: LON Beta1 Tx Register
func (o *USART_Type) SetUS_LONB1TX_BETA1TX(value uint32) {
	volatile.StoreUint32(&o.US_LONB1TX.Reg, volatile.LoadUint32(&o.US_LONB1TX.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetUS_LONB1TX_BETA1TX() uint32 {
	return volatile.LoadUint32(&o.US_LONB1TX.Reg) & 0xffffff
}

// USART.US_LONB1RX: LON Beta1 Rx Register
func (o *USART_Type) SetUS_LONB1RX_BETA1RX(value uint32) {
	volatile.StoreUint32(&o.US_LONB1RX.Reg, volatile.LoadUint32(&o.US_LONB1RX.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetUS_LONB1RX_BETA1RX() uint32 {
	return volatile.LoadUint32(&o.US_LONB1RX.Reg) & 0xffffff
}

// USART.US_LONPRIO: LON Priority Register
func (o *USART_Type) SetUS_LONPRIO_PSNB(value uint32) {
	volatile.StoreUint32(&o.US_LONPRIO.Reg, volatile.LoadUint32(&o.US_LONPRIO.Reg)&^(0x7f)|value)
}
func (o *USART_Type) GetUS_LONPRIO_PSNB() uint32 {
	return volatile.LoadUint32(&o.US_LONPRIO.Reg) & 0x7f
}
func (o *USART_Type) SetUS_LONPRIO_NPS(value uint32) {
	volatile.StoreUint32(&o.US_LONPRIO.Reg, volatile.LoadUint32(&o.US_LONPRIO.Reg)&^(0x7f00)|value<<8)
}
func (o *USART_Type) GetUS_LONPRIO_NPS() uint32 {
	return (volatile.LoadUint32(&o.US_LONPRIO.Reg) & 0x7f00) >> 8
}

// USART.US_IDTTX: LON IDT Tx Register
func (o *USART_Type) SetUS_IDTTX_IDTTX(value uint32) {
	volatile.StoreUint32(&o.US_IDTTX.Reg, volatile.LoadUint32(&o.US_IDTTX.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetUS_IDTTX_IDTTX() uint32 {
	return volatile.LoadUint32(&o.US_IDTTX.Reg) & 0xffffff
}

// USART.US_IDTRX: LON IDT Rx Register
func (o *USART_Type) SetUS_IDTRX_IDTRX(value uint32) {
	volatile.StoreUint32(&o.US_IDTRX.Reg, volatile.LoadUint32(&o.US_IDTRX.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetUS_IDTRX_IDTRX() uint32 {
	return volatile.LoadUint32(&o.US_IDTRX.Reg) & 0xffffff
}

// USART.US_ICDIFF: IC DIFF Register
func (o *USART_Type) SetUS_ICDIFF_ICDIFF(value uint32) {
	volatile.StoreUint32(&o.US_ICDIFF.Reg, volatile.LoadUint32(&o.US_ICDIFF.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetUS_ICDIFF_ICDIFF() uint32 {
	return volatile.LoadUint32(&o.US_ICDIFF.Reg) & 0xf
}

// USART.US_WPMR: Write Protection Mode Register
func (o *USART_Type) SetUS_WPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.US_WPMR.Reg, volatile.LoadUint32(&o.US_WPMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_WPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.US_WPMR.Reg) & 0x1
}
func (o *USART_Type) SetUS_WPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.US_WPMR.Reg, volatile.LoadUint32(&o.US_WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetUS_WPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.US_WPMR.Reg) & 0xffffff00) >> 8
}

// USART.US_WPSR: Write Protection Status Register
func (o *USART_Type) SetUS_WPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.US_WPSR.Reg, volatile.LoadUint32(&o.US_WPSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetUS_WPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.US_WPSR.Reg) & 0x1
}
func (o *USART_Type) SetUS_WPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.US_WPSR.Reg, volatile.LoadUint32(&o.US_WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *USART_Type) GetUS_WPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.US_WPSR.Reg) & 0xffff00) >> 8
}

// USB High-Speed Interface
type USBHS_Type struct {
	DEVCTRL      volatile.Register32 // 0x0
	DEVISR       volatile.Register32 // 0x4
	DEVICR       volatile.Register32 // 0x8
	DEVIFR       volatile.Register32 // 0xC
	DEVIMR       volatile.Register32 // 0x10
	DEVIDR       volatile.Register32 // 0x14
	DEVIER       volatile.Register32 // 0x18
	DEVEPT       volatile.Register32 // 0x1C
	DEVFNUM      volatile.Register32 // 0x20
	_            [220]byte
	DEVEPTCFG    [10]volatile.Register32 // 0x100
	_            [8]byte
	DEVEPTISR    [10]volatile.Register32 // 0x130
	_            [8]byte
	DEVEPTICR    [10]volatile.Register32 // 0x160
	_            [8]byte
	DEVEPTIFR    [10]volatile.Register32 // 0x190
	_            [8]byte
	DEVEPTIMR    [10]volatile.Register32 // 0x1C0
	_            [8]byte
	DEVEPTIER    [10]volatile.Register32 // 0x1F0
	_            [8]byte
	DEVEPTIDR    [10]volatile.Register32 // 0x220
	_            [200]byte
	USBHS_DEVDMA [7]USBHS_USBHS_DEVDMA_Type // 0x310
	_            [128]byte
	HSTCTRL      volatile.Register32 // 0x400
	HSTISR       volatile.Register32 // 0x404
	HSTICR       volatile.Register32 // 0x408
	HSTIFR       volatile.Register32 // 0x40C
	HSTIMR       volatile.Register32 // 0x410
	HSTIDR       volatile.Register32 // 0x414
	HSTIER       volatile.Register32 // 0x418
	HSTPIP       volatile.Register32 // 0x41C
	HSTFNUM      volatile.Register32 // 0x420
	HSTADDR1     volatile.Register32 // 0x424
	HSTADDR2     volatile.Register32 // 0x428
	HSTADDR3     volatile.Register32 // 0x42C
	_            [208]byte
	HSTPIPCFG    [10]volatile.Register32 // 0x500
	_            [8]byte
	HSTPIPISR    [10]volatile.Register32 // 0x530
	_            [8]byte
	HSTPIPICR    [10]volatile.Register32 // 0x560
	_            [8]byte
	HSTPIPIFR    [10]volatile.Register32 // 0x590
	_            [8]byte
	HSTPIPIMR    [10]volatile.Register32 // 0x5C0
	_            [8]byte
	HSTPIPIER    [10]volatile.Register32 // 0x5F0
	_            [8]byte
	HSTPIPIDR    [10]volatile.Register32 // 0x620
	_            [8]byte
	HSTPIPINRQ   [10]volatile.Register32 // 0x650
	_            [8]byte
	HSTPIPERR    [10]volatile.Register32 // 0x680
	_            [104]byte
	USBHS_HSTDMA [7]USBHS_USBHS_HSTDMA_Type // 0x710
	_            [128]byte
	CTRL         volatile.Register32 // 0x800
	SR           volatile.Register32 // 0x804
	SCR          volatile.Register32 // 0x808
	SFR          volatile.Register32 // 0x80C
}

// USBHS.DEVCTRL: Device General Control Register
func (o *USBHS_Type) SetDEVCTRL_UADD(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetDEVCTRL_UADD() uint32 {
	return volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x7f
}
func (o *USBHS_Type) SetDEVCTRL_ADDEN(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVCTRL_ADDEN() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVCTRL_DETACH(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDEVCTRL_DETACH() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDEVCTRL_RMWKUP(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetDEVCTRL_RMWKUP() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetDEVCTRL_SPDCONF(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0xc00)|value<<10)
}
func (o *USBHS_Type) GetDEVCTRL_SPDCONF() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0xc00) >> 10
}
func (o *USBHS_Type) SetDEVCTRL_LS(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVCTRL_LS() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVCTRL_TSTJ(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVCTRL_TSTJ() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVCTRL_TSTK(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVCTRL_TSTK() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVCTRL_TSTPCKT(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVCTRL_TSTPCKT() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDEVCTRL_OPMODE2(value uint32) {
	volatile.StoreUint32(&o.DEVCTRL.Reg, volatile.LoadUint32(&o.DEVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVCTRL_OPMODE2() uint32 {
	return (volatile.LoadUint32(&o.DEVCTRL.Reg) & 0x10000) >> 16
}

// USBHS.DEVISR: Device Global Interrupt Status Register
func (o *USBHS_Type) SetDEVISR_SUSP(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVISR_SUSP() uint32 {
	return volatile.LoadUint32(&o.DEVISR.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVISR_MSOF(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVISR_MSOF() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVISR_SOF(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVISR_SOF() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVISR_EORST(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVISR_EORST() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVISR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVISR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVISR_EORSM(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVISR_EORSM() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVISR_UPRSM(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVISR_UPRSM() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVISR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVISR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVISR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVISR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVISR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVISR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVISR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVISR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDEVISR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVISR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVISR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVISR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVISR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVISR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVISR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVISR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetDEVISR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDEVISR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDEVISR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDEVISR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDEVISR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetDEVISR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetDEVISR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDEVISR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDEVISR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVISR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetDEVISR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetDEVISR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetDEVISR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetDEVISR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetDEVISR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetDEVISR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetDEVISR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetDEVISR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetDEVISR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetDEVISR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetDEVISR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.DEVISR.Reg, volatile.LoadUint32(&o.DEVISR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetDEVISR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.DEVISR.Reg) & 0x80000000) >> 31
}

// USBHS.DEVICR: Device Global Interrupt Clear Register
func (o *USBHS_Type) SetDEVICR_SUSPC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVICR_SUSPC() uint32 {
	return volatile.LoadUint32(&o.DEVICR.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVICR_MSOFC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVICR_MSOFC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVICR_SOFC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVICR_SOFC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVICR_EORSTC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVICR_EORSTC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVICR_WAKEUPC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVICR_WAKEUPC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVICR_EORSMC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVICR_EORSMC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVICR_UPRSMC(value uint32) {
	volatile.StoreUint32(&o.DEVICR.Reg, volatile.LoadUint32(&o.DEVICR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVICR_UPRSMC() uint32 {
	return (volatile.LoadUint32(&o.DEVICR.Reg) & 0x40) >> 6
}

// USBHS.DEVIFR: Device Global Interrupt Set Register
func (o *USBHS_Type) SetDEVIFR_SUSPS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVIFR_SUSPS() uint32 {
	return volatile.LoadUint32(&o.DEVIFR.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVIFR_MSOFS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVIFR_MSOFS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVIFR_SOFS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVIFR_SOFS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVIFR_EORSTS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVIFR_EORSTS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVIFR_WAKEUPS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVIFR_WAKEUPS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVIFR_EORSMS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVIFR_EORSMS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVIFR_UPRSMS(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVIFR_UPRSMS() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVIFR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVIFR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetDEVIFR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetDEVIFR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetDEVIFR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetDEVIFR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetDEVIFR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetDEVIFR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetDEVIFR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetDEVIFR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetDEVIFR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetDEVIFR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetDEVIFR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.DEVIFR.Reg, volatile.LoadUint32(&o.DEVIFR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetDEVIFR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIFR.Reg) & 0x80000000) >> 31
}

// USBHS.DEVIMR: Device Global Interrupt Mask Register
func (o *USBHS_Type) SetDEVIMR_SUSPE(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVIMR_SUSPE() uint32 {
	return volatile.LoadUint32(&o.DEVIMR.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVIMR_MSOFE(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVIMR_MSOFE() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVIMR_SOFE(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVIMR_SOFE() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVIMR_EORSTE(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVIMR_EORSTE() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVIMR_WAKEUPE(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVIMR_WAKEUPE() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVIMR_EORSME(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVIMR_EORSME() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVIMR_UPRSME(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVIMR_UPRSME() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVIMR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVIMR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVIMR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVIMR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVIMR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVIMR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVIMR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVIMR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDEVIMR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVIMR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVIMR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVIMR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVIMR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVIMR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVIMR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVIMR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetDEVIMR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDEVIMR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDEVIMR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDEVIMR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDEVIMR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetDEVIMR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetDEVIMR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDEVIMR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDEVIMR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVIMR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetDEVIMR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetDEVIMR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetDEVIMR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetDEVIMR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetDEVIMR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetDEVIMR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetDEVIMR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetDEVIMR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetDEVIMR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetDEVIMR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetDEVIMR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.DEVIMR.Reg, volatile.LoadUint32(&o.DEVIMR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetDEVIMR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIMR.Reg) & 0x80000000) >> 31
}

// USBHS.DEVIDR: Device Global Interrupt Disable Register
func (o *USBHS_Type) SetDEVIDR_SUSPEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVIDR_SUSPEC() uint32 {
	return volatile.LoadUint32(&o.DEVIDR.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVIDR_MSOFEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVIDR_MSOFEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVIDR_SOFEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVIDR_SOFEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVIDR_EORSTEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVIDR_EORSTEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVIDR_WAKEUPEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVIDR_WAKEUPEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVIDR_EORSMEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVIDR_EORSMEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVIDR_UPRSMEC(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVIDR_UPRSMEC() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVIDR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVIDR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVIDR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVIDR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVIDR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVIDR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVIDR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVIDR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDEVIDR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVIDR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVIDR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVIDR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVIDR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVIDR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVIDR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVIDR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetDEVIDR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDEVIDR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDEVIDR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDEVIDR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDEVIDR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetDEVIDR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetDEVIDR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDEVIDR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDEVIDR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVIDR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetDEVIDR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetDEVIDR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetDEVIDR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetDEVIDR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetDEVIDR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetDEVIDR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetDEVIDR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetDEVIDR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetDEVIDR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetDEVIDR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetDEVIDR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.DEVIDR.Reg, volatile.LoadUint32(&o.DEVIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetDEVIDR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIDR.Reg) & 0x80000000) >> 31
}

// USBHS.DEVIER: Device Global Interrupt Enable Register
func (o *USBHS_Type) SetDEVIER_SUSPES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVIER_SUSPES() uint32 {
	return volatile.LoadUint32(&o.DEVIER.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVIER_MSOFES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVIER_MSOFES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVIER_SOFES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVIER_SOFES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVIER_EORSTES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVIER_EORSTES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVIER_WAKEUPES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVIER_WAKEUPES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVIER_EORSMES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVIER_EORSMES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVIER_UPRSMES(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVIER_UPRSMES() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVIER_PEP_0(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVIER_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVIER_PEP_1(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVIER_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVIER_PEP_2(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVIER_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVIER_PEP_3(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVIER_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDEVIER_PEP_4(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVIER_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVIER_PEP_5(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVIER_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVIER_PEP_6(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVIER_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVIER_PEP_7(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVIER_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetDEVIER_PEP_8(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDEVIER_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDEVIER_PEP_9(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDEVIER_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDEVIER_PEP_10(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetDEVIER_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetDEVIER_PEP_11(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDEVIER_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDEVIER_DMA_1(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVIER_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetDEVIER_DMA_2(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetDEVIER_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetDEVIER_DMA_3(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetDEVIER_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetDEVIER_DMA_4(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetDEVIER_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetDEVIER_DMA_5(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetDEVIER_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetDEVIER_DMA_6(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetDEVIER_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetDEVIER_DMA_7(value uint32) {
	volatile.StoreUint32(&o.DEVIER.Reg, volatile.LoadUint32(&o.DEVIER.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetDEVIER_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.DEVIER.Reg) & 0x80000000) >> 31
}

// USBHS.DEVEPT: Device Endpoint Register
func (o *USBHS_Type) SetDEVEPT_EPEN0(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPT_EPEN0() uint32 {
	return volatile.LoadUint32(&o.DEVEPT.Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPT_EPEN1(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPT_EPEN1() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPT_EPEN2(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPT_EPEN2() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPT_EPEN3(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPT_EPEN3() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPT_EPEN4(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPT_EPEN4() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPT_EPEN5(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPT_EPEN5() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPT_EPEN6(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPT_EPEN6() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPT_EPEN7(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPT_EPEN7() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPT_EPEN8(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDEVEPT_EPEN8() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDEVEPT_EPEN9(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetDEVEPT_EPEN9() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetDEVEPT_EPRST0(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVEPT_EPRST0() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVEPT_EPRST1(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVEPT_EPRST1() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVEPT_EPRST2(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVEPT_EPRST2() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVEPT_EPRST3(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVEPT_EPRST3() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetDEVEPT_EPRST4(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDEVEPT_EPRST4() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDEVEPT_EPRST5(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDEVEPT_EPRST5() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDEVEPT_EPRST6(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetDEVEPT_EPRST6() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetDEVEPT_EPRST7(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDEVEPT_EPRST7() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDEVEPT_EPRST8(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetDEVEPT_EPRST8() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetDEVEPT_EPRST9(value uint32) {
	volatile.StoreUint32(&o.DEVEPT.Reg, volatile.LoadUint32(&o.DEVEPT.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetDEVEPT_EPRST9() uint32 {
	return (volatile.LoadUint32(&o.DEVEPT.Reg) & 0x2000000) >> 25
}

// USBHS.DEVFNUM: Device Frame Number Register
func (o *USBHS_Type) SetDEVFNUM_MFNUM(value uint32) {
	volatile.StoreUint32(&o.DEVFNUM.Reg, volatile.LoadUint32(&o.DEVFNUM.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetDEVFNUM_MFNUM() uint32 {
	return volatile.LoadUint32(&o.DEVFNUM.Reg) & 0x7
}
func (o *USBHS_Type) SetDEVFNUM_FNUM(value uint32) {
	volatile.StoreUint32(&o.DEVFNUM.Reg, volatile.LoadUint32(&o.DEVFNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *USBHS_Type) GetDEVFNUM_FNUM() uint32 {
	return (volatile.LoadUint32(&o.DEVFNUM.Reg) & 0x3ff8) >> 3
}
func (o *USBHS_Type) SetDEVFNUM_FNCERR(value uint32) {
	volatile.StoreUint32(&o.DEVFNUM.Reg, volatile.LoadUint32(&o.DEVFNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDEVFNUM_FNCERR() uint32 {
	return (volatile.LoadUint32(&o.DEVFNUM.Reg) & 0x8000) >> 15
}

// USBHS.DEVEPTCFG: Device Endpoint Configuration Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTCFG_ALLOC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTCFG_ALLOC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTCFG_EPBK(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTCFG_EPBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetDEVEPTCFG_EPSIZE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x70)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTCFG_EPSIZE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x70) >> 4
}
func (o *USBHS_Type) SetDEVEPTCFG_EPDIR(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDEVEPTCFG_EPDIR(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDEVEPTCFG_AUTOSW(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetDEVEPTCFG_AUTOSW(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetDEVEPTCFG_EPTYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x1800)|value<<11)
}
func (o *USBHS_Type) GetDEVEPTCFG_EPTYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x1800) >> 11
}
func (o *USBHS_Type) SetDEVEPTCFG_NBTRANS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTCFG[idx].Reg, volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg)&^(0x6000)|value<<13)
}
func (o *USBHS_Type) GetDEVEPTCFG_NBTRANS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTCFG[idx].Reg) & 0x6000) >> 13
}

// USBHS.DEVEPTISR: Device Endpoint Status Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTISR_TXINI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTISR_TXINI(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTISR_RXOUTI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTISR_RXOUTI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTISR_RXSTPI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTISR_RXSTPI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTISR_NAKOUTI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTISR_NAKOUTI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTISR_NAKINI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTISR_NAKINI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTISR_OVERFI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTISR_OVERFI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTISR_STALLEDI(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTISR_STALLEDI(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTISR_SHORTPACKET(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTISR_SHORTPACKET(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPTISR_DTSEQ(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x300)|value<<8)
}
func (o *USBHS_Type) GetDEVEPTISR_DTSEQ(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x300) >> 8
}
func (o *USBHS_Type) SetDEVEPTISR_NBUSYBK(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x3000)|value<<12)
}
func (o *USBHS_Type) GetDEVEPTISR_NBUSYBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x3000) >> 12
}
func (o *USBHS_Type) SetDEVEPTISR_CURRBK(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0xc000)|value<<14)
}
func (o *USBHS_Type) GetDEVEPTISR_CURRBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0xc000) >> 14
}
func (o *USBHS_Type) SetDEVEPTISR_RWALL(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVEPTISR_RWALL(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVEPTISR_CTRLDIR(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVEPTISR_CTRLDIR(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVEPTISR_CFGOK(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVEPTISR_CFGOK(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVEPTISR_BYCT(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTISR[idx].Reg, volatile.LoadUint32(&o.DEVEPTISR[idx].Reg)&^(0x7ff00000)|value<<20)
}
func (o *USBHS_Type) GetDEVEPTISR_BYCT(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTISR[idx].Reg) & 0x7ff00000) >> 20
}

// USBHS.DEVEPTICR: Device Endpoint Clear Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTICR_TXINIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTICR_TXINIC(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTICR_RXOUTIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTICR_RXOUTIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTICR_RXSTPIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTICR_RXSTPIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTICR_NAKOUTIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTICR_NAKOUTIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTICR_NAKINIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTICR_NAKINIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTICR_OVERFIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTICR_OVERFIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTICR_STALLEDIC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTICR_STALLEDIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTICR_SHORTPACKETC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTICR[idx].Reg, volatile.LoadUint32(&o.DEVEPTICR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTICR_SHORTPACKETC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTICR[idx].Reg) & 0x80) >> 7
}

// USBHS.DEVEPTIFR: Device Endpoint Set Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTIFR_TXINIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTIFR_TXINIS(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTIFR_RXOUTIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTIFR_RXOUTIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTIFR_RXSTPIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTIFR_RXSTPIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTIFR_NAKOUTIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTIFR_NAKOUTIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTIFR_NAKINIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTIFR_NAKINIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTIFR_OVERFIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTIFR_OVERFIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTIFR_STALLEDIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTIFR_STALLEDIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTIFR_SHORTPACKETS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTIFR_SHORTPACKETS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPTIFR_NBUSYBKS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIFR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVEPTIFR_NBUSYBKS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIFR[idx].Reg) & 0x1000) >> 12
}

// USBHS.DEVEPTIMR: Device Endpoint Mask Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTIMR_TXINE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTIMR_TXINE(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTIMR_RXOUTE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTIMR_RXOUTE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTIMR_RXSTPE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTIMR_RXSTPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTIMR_NAKOUTE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTIMR_NAKOUTE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTIMR_NAKINE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTIMR_NAKINE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTIMR_OVERFE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTIMR_OVERFE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTIMR_STALLEDE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTIMR_STALLEDE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTIMR_SHORTPACKETE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTIMR_SHORTPACKETE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPTIMR_NBUSYBKE(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVEPTIMR_NBUSYBKE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVEPTIMR_KILLBK(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVEPTIMR_KILLBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVEPTIMR_FIFOCON(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVEPTIMR_FIFOCON(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVEPTIMR_EPDISHDMA(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVEPTIMR_EPDISHDMA(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVEPTIMR_NYETDIS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVEPTIMR_NYETDIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVEPTIMR_RSTDT(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVEPTIMR_RSTDT(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVEPTIMR_STALLRQ(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIMR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVEPTIMR_STALLRQ(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIMR[idx].Reg) & 0x80000) >> 19
}

// USBHS.DEVEPTIER: Device Endpoint Enable Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTIER_TXINES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTIER_TXINES(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTIER_RXOUTES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTIER_RXOUTES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTIER_RXSTPES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTIER_RXSTPES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTIER_NAKOUTES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTIER_NAKOUTES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTIER_NAKINES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTIER_NAKINES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTIER_OVERFES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTIER_OVERFES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTIER_STALLEDES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTIER_STALLEDES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTIER_SHORTPACKETES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTIER_SHORTPACKETES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPTIER_NBUSYBKES(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVEPTIER_NBUSYBKES(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVEPTIER_KILLBKS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDEVEPTIER_KILLBKS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDEVEPTIER_FIFOCONS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVEPTIER_FIFOCONS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVEPTIER_EPDISHDMAS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVEPTIER_EPDISHDMAS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVEPTIER_NYETDISS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVEPTIER_NYETDISS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVEPTIER_RSTDTS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetDEVEPTIER_RSTDTS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetDEVEPTIER_STALLRQS(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIER[idx].Reg, volatile.LoadUint32(&o.DEVEPTIER[idx].Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVEPTIER_STALLRQS(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIER[idx].Reg) & 0x80000) >> 19
}

// USBHS.DEVEPTIDR: Device Endpoint Disable Register (n = 0) 0
func (o *USBHS_Type) SetDEVEPTIDR_TXINEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDEVEPTIDR_TXINEC(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetDEVEPTIDR_RXOUTEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDEVEPTIDR_RXOUTEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDEVEPTIDR_RXSTPEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDEVEPTIDR_RXSTPEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDEVEPTIDR_NAKOUTEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetDEVEPTIDR_NAKOUTEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetDEVEPTIDR_NAKINEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDEVEPTIDR_NAKINEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDEVEPTIDR_OVERFEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDEVEPTIDR_OVERFEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDEVEPTIDR_STALLEDEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDEVEPTIDR_STALLEDEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDEVEPTIDR_SHORTPACKETEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDEVEPTIDR_SHORTPACKETEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDEVEPTIDR_NBUSYBKEC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDEVEPTIDR_NBUSYBKEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDEVEPTIDR_FIFOCONC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDEVEPTIDR_FIFOCONC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDEVEPTIDR_EPDISHDMAC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetDEVEPTIDR_EPDISHDMAC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetDEVEPTIDR_NYETDISC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetDEVEPTIDR_NYETDISC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetDEVEPTIDR_STALLRQC(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVEPTIDR[idx].Reg, volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetDEVEPTIDR_STALLRQC(idx int) uint32 {
	return (volatile.LoadUint32(&o.DEVEPTIDR[idx].Reg) & 0x80000) >> 19
}

// USBHS.HSTCTRL: Host General Control Register
func (o *USBHS_Type) SetHSTCTRL_SOFE(value uint32) {
	volatile.StoreUint32(&o.HSTCTRL.Reg, volatile.LoadUint32(&o.HSTCTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTCTRL_SOFE() uint32 {
	return (volatile.LoadUint32(&o.HSTCTRL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTCTRL_RESET(value uint32) {
	volatile.StoreUint32(&o.HSTCTRL.Reg, volatile.LoadUint32(&o.HSTCTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetHSTCTRL_RESET() uint32 {
	return (volatile.LoadUint32(&o.HSTCTRL.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetHSTCTRL_RESUME(value uint32) {
	volatile.StoreUint32(&o.HSTCTRL.Reg, volatile.LoadUint32(&o.HSTCTRL.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTCTRL_RESUME() uint32 {
	return (volatile.LoadUint32(&o.HSTCTRL.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTCTRL_SPDCONF(value uint32) {
	volatile.StoreUint32(&o.HSTCTRL.Reg, volatile.LoadUint32(&o.HSTCTRL.Reg)&^(0x3000)|value<<12)
}
func (o *USBHS_Type) GetHSTCTRL_SPDCONF() uint32 {
	return (volatile.LoadUint32(&o.HSTCTRL.Reg) & 0x3000) >> 12
}

// USBHS.HSTISR: Host Global Interrupt Status Register
func (o *USBHS_Type) SetHSTISR_DCONNI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTISR_DCONNI() uint32 {
	return volatile.LoadUint32(&o.HSTISR.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTISR_DDISCI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTISR_DDISCI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTISR_RSTI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTISR_RSTI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTISR_RSMEDI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTISR_RSMEDI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTISR_RXRSMI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTISR_RXRSMI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTISR_HSOFI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTISR_HSOFI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTISR_HWUPI(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTISR_HWUPI() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTISR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTISR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTISR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetHSTISR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetHSTISR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTISR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTISR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetHSTISR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetHSTISR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTISR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTISR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetHSTISR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetHSTISR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTISR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTISR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetHSTISR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetHSTISR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTISR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTISR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTISR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTISR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTISR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTISR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetHSTISR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetHSTISR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetHSTISR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetHSTISR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetHSTISR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetHSTISR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetHSTISR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetHSTISR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetHSTISR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetHSTISR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetHSTISR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetHSTISR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetHSTISR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetHSTISR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.HSTISR.Reg, volatile.LoadUint32(&o.HSTISR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHSTISR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.HSTISR.Reg) & 0x80000000) >> 31
}

// USBHS.HSTICR: Host Global Interrupt Clear Register
func (o *USBHS_Type) SetHSTICR_DCONNIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTICR_DCONNIC() uint32 {
	return volatile.LoadUint32(&o.HSTICR.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTICR_DDISCIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTICR_DDISCIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTICR_RSTIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTICR_RSTIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTICR_RSMEDIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTICR_RSMEDIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTICR_RXRSMIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTICR_RXRSMIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTICR_HSOFIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTICR_HSOFIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTICR_HWUPIC(value uint32) {
	volatile.StoreUint32(&o.HSTICR.Reg, volatile.LoadUint32(&o.HSTICR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTICR_HWUPIC() uint32 {
	return (volatile.LoadUint32(&o.HSTICR.Reg) & 0x40) >> 6
}

// USBHS.HSTIFR: Host Global Interrupt Set Register
func (o *USBHS_Type) SetHSTIFR_DCONNIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTIFR_DCONNIS() uint32 {
	return volatile.LoadUint32(&o.HSTIFR.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTIFR_DDISCIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTIFR_DDISCIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTIFR_RSTIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTIFR_RSTIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTIFR_RSMEDIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTIFR_RSMEDIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTIFR_RXRSMIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTIFR_RXRSMIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTIFR_HSOFIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTIFR_HSOFIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTIFR_HWUPIS(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTIFR_HWUPIS() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTIFR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetHSTIFR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetHSTIFR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetHSTIFR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetHSTIFR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetHSTIFR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetHSTIFR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetHSTIFR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetHSTIFR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetHSTIFR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetHSTIFR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetHSTIFR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetHSTIFR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.HSTIFR.Reg, volatile.LoadUint32(&o.HSTIFR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHSTIFR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIFR.Reg) & 0x80000000) >> 31
}

// USBHS.HSTIMR: Host Global Interrupt Mask Register
func (o *USBHS_Type) SetHSTIMR_DCONNIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTIMR_DCONNIE() uint32 {
	return volatile.LoadUint32(&o.HSTIMR.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTIMR_DDISCIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTIMR_DDISCIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTIMR_RSTIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTIMR_RSTIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTIMR_RSMEDIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTIMR_RSMEDIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTIMR_RXRSMIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTIMR_RXRSMIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTIMR_HSOFIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTIMR_HSOFIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTIMR_HWUPIE(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTIMR_HWUPIE() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTIMR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTIMR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTIMR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetHSTIMR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetHSTIMR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTIMR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTIMR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetHSTIMR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetHSTIMR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTIMR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTIMR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetHSTIMR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetHSTIMR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTIMR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTIMR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetHSTIMR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetHSTIMR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTIMR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTIMR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTIMR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTIMR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTIMR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTIMR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetHSTIMR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetHSTIMR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetHSTIMR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetHSTIMR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetHSTIMR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetHSTIMR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetHSTIMR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetHSTIMR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetHSTIMR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetHSTIMR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetHSTIMR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetHSTIMR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetHSTIMR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetHSTIMR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.HSTIMR.Reg, volatile.LoadUint32(&o.HSTIMR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHSTIMR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIMR.Reg) & 0x80000000) >> 31
}

// USBHS.HSTIDR: Host Global Interrupt Disable Register
func (o *USBHS_Type) SetHSTIDR_DCONNIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTIDR_DCONNIEC() uint32 {
	return volatile.LoadUint32(&o.HSTIDR.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTIDR_DDISCIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTIDR_DDISCIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTIDR_RSTIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTIDR_RSTIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTIDR_RSMEDIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTIDR_RSMEDIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTIDR_RXRSMIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTIDR_RXRSMIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTIDR_HSOFIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTIDR_HSOFIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTIDR_HWUPIEC(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTIDR_HWUPIEC() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTIDR_PEP_0(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTIDR_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTIDR_PEP_1(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetHSTIDR_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetHSTIDR_PEP_2(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTIDR_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTIDR_PEP_3(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetHSTIDR_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetHSTIDR_PEP_4(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTIDR_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTIDR_PEP_5(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetHSTIDR_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetHSTIDR_PEP_6(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTIDR_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTIDR_PEP_7(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetHSTIDR_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetHSTIDR_PEP_8(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTIDR_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTIDR_PEP_9(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTIDR_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTIDR_PEP_10(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTIDR_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTIDR_PEP_11(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetHSTIDR_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetHSTIDR_DMA_1(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetHSTIDR_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetHSTIDR_DMA_2(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetHSTIDR_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetHSTIDR_DMA_3(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetHSTIDR_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetHSTIDR_DMA_4(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetHSTIDR_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetHSTIDR_DMA_5(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetHSTIDR_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetHSTIDR_DMA_6(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetHSTIDR_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetHSTIDR_DMA_7(value uint32) {
	volatile.StoreUint32(&o.HSTIDR.Reg, volatile.LoadUint32(&o.HSTIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHSTIDR_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIDR.Reg) & 0x80000000) >> 31
}

// USBHS.HSTIER: Host Global Interrupt Enable Register
func (o *USBHS_Type) SetHSTIER_DCONNIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTIER_DCONNIES() uint32 {
	return volatile.LoadUint32(&o.HSTIER.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTIER_DDISCIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTIER_DDISCIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTIER_RSTIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTIER_RSTIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTIER_RSMEDIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTIER_RSMEDIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTIER_RXRSMIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTIER_RXRSMIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTIER_HSOFIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTIER_HSOFIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTIER_HWUPIES(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTIER_HWUPIES() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTIER_PEP_0(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTIER_PEP_0() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTIER_PEP_1(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetHSTIER_PEP_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetHSTIER_PEP_2(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTIER_PEP_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTIER_PEP_3(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetHSTIER_PEP_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetHSTIER_PEP_4(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTIER_PEP_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTIER_PEP_5(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetHSTIER_PEP_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetHSTIER_PEP_6(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTIER_PEP_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTIER_PEP_7(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetHSTIER_PEP_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetHSTIER_PEP_8(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTIER_PEP_8() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTIER_PEP_9(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTIER_PEP_9() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTIER_PEP_10(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTIER_PEP_10() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTIER_PEP_11(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetHSTIER_PEP_11() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetHSTIER_DMA_1(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetHSTIER_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetHSTIER_DMA_2(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetHSTIER_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetHSTIER_DMA_3(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetHSTIER_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetHSTIER_DMA_4(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetHSTIER_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetHSTIER_DMA_5(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetHSTIER_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetHSTIER_DMA_6(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetHSTIER_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetHSTIER_DMA_7(value uint32) {
	volatile.StoreUint32(&o.HSTIER.Reg, volatile.LoadUint32(&o.HSTIER.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHSTIER_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.HSTIER.Reg) & 0x80000000) >> 31
}

// USBHS.HSTPIP: Host Pipe Register
func (o *USBHS_Type) SetHSTPIP_PEN0(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIP_PEN0() uint32 {
	return volatile.LoadUint32(&o.HSTPIP.Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIP_PEN1(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIP_PEN1() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIP_PEN2(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIP_PEN2() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIP_PEN3(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIP_PEN3() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIP_PEN4(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIP_PEN4() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIP_PEN5(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIP_PEN5() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIP_PEN6(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIP_PEN6() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIP_PEN7(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIP_PEN7() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIP_PEN8(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTPIP_PEN8() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetHSTPIP_PRST0(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIP_PRST0() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTPIP_PRST1(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTPIP_PRST1() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTPIP_PRST2(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTPIP_PRST2() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTPIP_PRST3(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetHSTPIP_PRST3() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetHSTPIP_PRST4(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetHSTPIP_PRST4() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetHSTPIP_PRST5(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetHSTPIP_PRST5() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetHSTPIP_PRST6(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetHSTPIP_PRST6() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetHSTPIP_PRST7(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetHSTPIP_PRST7() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetHSTPIP_PRST8(value uint32) {
	volatile.StoreUint32(&o.HSTPIP.Reg, volatile.LoadUint32(&o.HSTPIP.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetHSTPIP_PRST8() uint32 {
	return (volatile.LoadUint32(&o.HSTPIP.Reg) & 0x1000000) >> 24
}

// USBHS.HSTFNUM: Host Frame Number Register
func (o *USBHS_Type) SetHSTFNUM_MFNUM(value uint32) {
	volatile.StoreUint32(&o.HSTFNUM.Reg, volatile.LoadUint32(&o.HSTFNUM.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetHSTFNUM_MFNUM() uint32 {
	return volatile.LoadUint32(&o.HSTFNUM.Reg) & 0x7
}
func (o *USBHS_Type) SetHSTFNUM_FNUM(value uint32) {
	volatile.StoreUint32(&o.HSTFNUM.Reg, volatile.LoadUint32(&o.HSTFNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *USBHS_Type) GetHSTFNUM_FNUM() uint32 {
	return (volatile.LoadUint32(&o.HSTFNUM.Reg) & 0x3ff8) >> 3
}
func (o *USBHS_Type) SetHSTFNUM_FLENHIGH(value uint32) {
	volatile.StoreUint32(&o.HSTFNUM.Reg, volatile.LoadUint32(&o.HSTFNUM.Reg)&^(0xff0000)|value<<16)
}
func (o *USBHS_Type) GetHSTFNUM_FLENHIGH() uint32 {
	return (volatile.LoadUint32(&o.HSTFNUM.Reg) & 0xff0000) >> 16
}

// USBHS.HSTADDR1: Host Address 1 Register
func (o *USBHS_Type) SetHSTADDR1_HSTADDRP0(value uint32) {
	volatile.StoreUint32(&o.HSTADDR1.Reg, volatile.LoadUint32(&o.HSTADDR1.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetHSTADDR1_HSTADDRP0() uint32 {
	return volatile.LoadUint32(&o.HSTADDR1.Reg) & 0x7f
}
func (o *USBHS_Type) SetHSTADDR1_HSTADDRP1(value uint32) {
	volatile.StoreUint32(&o.HSTADDR1.Reg, volatile.LoadUint32(&o.HSTADDR1.Reg)&^(0x7f00)|value<<8)
}
func (o *USBHS_Type) GetHSTADDR1_HSTADDRP1() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR1.Reg) & 0x7f00) >> 8
}
func (o *USBHS_Type) SetHSTADDR1_HSTADDRP2(value uint32) {
	volatile.StoreUint32(&o.HSTADDR1.Reg, volatile.LoadUint32(&o.HSTADDR1.Reg)&^(0x7f0000)|value<<16)
}
func (o *USBHS_Type) GetHSTADDR1_HSTADDRP2() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR1.Reg) & 0x7f0000) >> 16
}
func (o *USBHS_Type) SetHSTADDR1_HSTADDRP3(value uint32) {
	volatile.StoreUint32(&o.HSTADDR1.Reg, volatile.LoadUint32(&o.HSTADDR1.Reg)&^(0x7f000000)|value<<24)
}
func (o *USBHS_Type) GetHSTADDR1_HSTADDRP3() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR1.Reg) & 0x7f000000) >> 24
}

// USBHS.HSTADDR2: Host Address 2 Register
func (o *USBHS_Type) SetHSTADDR2_HSTADDRP4(value uint32) {
	volatile.StoreUint32(&o.HSTADDR2.Reg, volatile.LoadUint32(&o.HSTADDR2.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetHSTADDR2_HSTADDRP4() uint32 {
	return volatile.LoadUint32(&o.HSTADDR2.Reg) & 0x7f
}
func (o *USBHS_Type) SetHSTADDR2_HSTADDRP5(value uint32) {
	volatile.StoreUint32(&o.HSTADDR2.Reg, volatile.LoadUint32(&o.HSTADDR2.Reg)&^(0x7f00)|value<<8)
}
func (o *USBHS_Type) GetHSTADDR2_HSTADDRP5() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR2.Reg) & 0x7f00) >> 8
}
func (o *USBHS_Type) SetHSTADDR2_HSTADDRP6(value uint32) {
	volatile.StoreUint32(&o.HSTADDR2.Reg, volatile.LoadUint32(&o.HSTADDR2.Reg)&^(0x7f0000)|value<<16)
}
func (o *USBHS_Type) GetHSTADDR2_HSTADDRP6() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR2.Reg) & 0x7f0000) >> 16
}
func (o *USBHS_Type) SetHSTADDR2_HSTADDRP7(value uint32) {
	volatile.StoreUint32(&o.HSTADDR2.Reg, volatile.LoadUint32(&o.HSTADDR2.Reg)&^(0x7f000000)|value<<24)
}
func (o *USBHS_Type) GetHSTADDR2_HSTADDRP7() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR2.Reg) & 0x7f000000) >> 24
}

// USBHS.HSTADDR3: Host Address 3 Register
func (o *USBHS_Type) SetHSTADDR3_HSTADDRP8(value uint32) {
	volatile.StoreUint32(&o.HSTADDR3.Reg, volatile.LoadUint32(&o.HSTADDR3.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetHSTADDR3_HSTADDRP8() uint32 {
	return volatile.LoadUint32(&o.HSTADDR3.Reg) & 0x7f
}
func (o *USBHS_Type) SetHSTADDR3_HSTADDRP9(value uint32) {
	volatile.StoreUint32(&o.HSTADDR3.Reg, volatile.LoadUint32(&o.HSTADDR3.Reg)&^(0x7f00)|value<<8)
}
func (o *USBHS_Type) GetHSTADDR3_HSTADDRP9() uint32 {
	return (volatile.LoadUint32(&o.HSTADDR3.Reg) & 0x7f00) >> 8
}

// USBHS.HSTPIPCFG: Host Pipe Configuration Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPCFG_ALLOC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPCFG_ALLOC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPCFG_PBK(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPCFG_PBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetHSTPIPCFG_PSIZE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0x70)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPCFG_PSIZE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0x70) >> 4
}
func (o *USBHS_Type) SetHSTPIPCFG_PTOKEN(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0x300)|value<<8)
}
func (o *USBHS_Type) GetHSTPIPCFG_PTOKEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0x300) >> 8
}
func (o *USBHS_Type) SetHSTPIPCFG_AUTOSW(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetHSTPIPCFG_AUTOSW(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetHSTPIPCFG_PTYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0x3000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPCFG_PTYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0x3000) >> 12
}
func (o *USBHS_Type) SetHSTPIPCFG_PEPNUM(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIPCFG_PEPNUM(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0xf0000) >> 16
}
func (o *USBHS_Type) SetHSTPIPCFG_INTFRQ(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPCFG[idx].Reg, volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *USBHS_Type) GetHSTPIPCFG_INTFRQ(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPCFG[idx].Reg) & 0xff000000) >> 24
}

// USBHS.HSTPIPISR: Host Pipe Status Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPISR_RXINI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPISR_RXINI(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPISR_TXOUTI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPISR_TXOUTI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPISR_TXSTPI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPISR_TXSTPI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPISR_PERRI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPISR_PERRI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPISR_NAKEDI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPISR_NAKEDI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPISR_OVERFI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPISR_OVERFI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPISR_RXSTALLDI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPISR_RXSTALLDI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPISR_SHORTPACKETI(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPISR_SHORTPACKETI(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIPISR_DTSEQ(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x300)|value<<8)
}
func (o *USBHS_Type) GetHSTPIPISR_DTSEQ(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x300) >> 8
}
func (o *USBHS_Type) SetHSTPIPISR_NBUSYBK(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x3000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPISR_NBUSYBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x3000) >> 12
}
func (o *USBHS_Type) SetHSTPIPISR_CURRBK(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0xc000)|value<<14)
}
func (o *USBHS_Type) GetHSTPIPISR_CURRBK(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0xc000) >> 14
}
func (o *USBHS_Type) SetHSTPIPISR_RWALL(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIPISR_RWALL(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTPIPISR_CFGOK(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTPIPISR_CFGOK(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetHSTPIPISR_PBYCT(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPISR[idx].Reg, volatile.LoadUint32(&o.HSTPIPISR[idx].Reg)&^(0x7ff00000)|value<<20)
}
func (o *USBHS_Type) GetHSTPIPISR_PBYCT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPISR[idx].Reg) & 0x7ff00000) >> 20
}

// USBHS.HSTPIPICR: Host Pipe Clear Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPICR_RXINIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPICR_RXINIC(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPICR_TXOUTIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPICR_TXOUTIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPICR_TXSTPIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPICR_TXSTPIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPICR_NAKEDIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPICR_NAKEDIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPICR_OVERFIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPICR_OVERFIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPICR_RXSTALLDIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPICR_RXSTALLDIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPICR_SHORTPACKETIC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPICR[idx].Reg, volatile.LoadUint32(&o.HSTPIPICR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPICR_SHORTPACKETIC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPICR[idx].Reg) & 0x80) >> 7
}

// USBHS.HSTPIPIFR: Host Pipe Set Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPIFR_RXINIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPIFR_RXINIS(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPIFR_TXOUTIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPIFR_TXOUTIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPIFR_TXSTPIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPIFR_TXSTPIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPIFR_PERRIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPIFR_PERRIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPIFR_NAKEDIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPIFR_NAKEDIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPIFR_OVERFIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPIFR_OVERFIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPIFR_RXSTALLDIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPIFR_RXSTALLDIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPIFR_SHORTPACKETIS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPIFR_SHORTPACKETIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIPIFR_NBUSYBKS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIFR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPIFR_NBUSYBKS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIFR[idx].Reg) & 0x1000) >> 12
}

// USBHS.HSTPIPIMR: Host Pipe Mask Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPIMR_RXINE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPIMR_RXINE(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPIMR_TXOUTE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPIMR_TXOUTE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPIMR_TXSTPE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPIMR_TXSTPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPIMR_PERRE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPIMR_PERRE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPIMR_NAKEDE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPIMR_NAKEDE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPIMR_OVERFIE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPIMR_OVERFIE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPIMR_RXSTALLDE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPIMR_RXSTALLDE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPIMR_SHORTPACKETIE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPIMR_SHORTPACKETIE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIPIMR_NBUSYBKE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPIMR_NBUSYBKE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTPIPIMR_FIFOCON(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTPIPIMR_FIFOCON(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTPIPIMR_PDISHDMA(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIPIMR_PDISHDMA(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTPIPIMR_PFREEZE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTPIPIMR_PFREEZE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTPIPIMR_RSTDT(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIMR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTPIPIMR_RSTDT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIMR[idx].Reg) & 0x40000) >> 18
}

// USBHS.HSTPIPIER: Host Pipe Enable Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPIER_RXINES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPIER_RXINES(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPIER_TXOUTES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPIER_TXOUTES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPIER_TXSTPES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPIER_TXSTPES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPIER_PERRES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPIER_PERRES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPIER_NAKEDES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPIER_NAKEDES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPIER_OVERFIES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPIER_OVERFIES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPIER_RXSTALLDES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPIER_RXSTALLDES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPIER_SHORTPACKETIES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPIER_SHORTPACKETIES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIPIER_NBUSYBKES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPIER_NBUSYBKES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTPIPIER_PDISHDMAS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIPIER_PDISHDMAS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTPIPIER_PFREEZES(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTPIPIER_PFREEZES(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetHSTPIPIER_RSTDTS(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIER[idx].Reg, volatile.LoadUint32(&o.HSTPIPIER[idx].Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetHSTPIPIER_RSTDTS(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIER[idx].Reg) & 0x40000) >> 18
}

// USBHS.HSTPIPIDR: Host Pipe Disable Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPIDR_RXINEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPIDR_RXINEC(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPIDR_TXOUTEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPIDR_TXOUTEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPIDR_TXSTPEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPIDR_TXSTPEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPIDR_PERREC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPIDR_PERREC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPIDR_NAKEDEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPIDR_NAKEDEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPIDR_OVERFIEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPIDR_OVERFIEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetHSTPIPIDR_RXSTALLDEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetHSTPIPIDR_RXSTALLDEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetHSTPIPIDR_SHORTPACKETIEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetHSTPIPIDR_SHORTPACKETIEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetHSTPIPIDR_NBUSYBKEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHSTPIPIDR_NBUSYBKEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHSTPIPIDR_FIFOCONC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetHSTPIPIDR_FIFOCONC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetHSTPIPIDR_PDISHDMAC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHSTPIPIDR_PDISHDMAC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHSTPIPIDR_PFREEZEC(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPIDR[idx].Reg, volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetHSTPIPIDR_PFREEZEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPIDR[idx].Reg) & 0x20000) >> 17
}

// USBHS.HSTPIPINRQ: Host Pipe IN Request Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPINRQ_INRQ(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPINRQ[idx].Reg, volatile.LoadUint32(&o.HSTPIPINRQ[idx].Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetHSTPIPINRQ_INRQ(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPINRQ[idx].Reg) & 0xff
}
func (o *USBHS_Type) SetHSTPIPINRQ_INMODE(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPINRQ[idx].Reg, volatile.LoadUint32(&o.HSTPIPINRQ[idx].Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetHSTPIPINRQ_INMODE(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPINRQ[idx].Reg) & 0x100) >> 8
}

// USBHS.HSTPIPERR: Host Pipe Error Register (n = 0) 0
func (o *USBHS_Type) SetHSTPIPERR_DATATGL(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHSTPIPERR_DATATGL(idx int) uint32 {
	return volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x1
}
func (o *USBHS_Type) SetHSTPIPERR_DATAPID(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHSTPIPERR_DATAPID(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHSTPIPERR_PID(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHSTPIPERR_PID(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHSTPIPERR_TIMEOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetHSTPIPERR_TIMEOUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetHSTPIPERR_CRC16(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHSTPIPERR_CRC16(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHSTPIPERR_COUNTER(idx int, value uint32) {
	volatile.StoreUint32(&o.HSTPIPERR[idx].Reg, volatile.LoadUint32(&o.HSTPIPERR[idx].Reg)&^(0x60)|value<<5)
}
func (o *USBHS_Type) GetHSTPIPERR_COUNTER(idx int) uint32 {
	return (volatile.LoadUint32(&o.HSTPIPERR[idx].Reg) & 0x60) >> 5
}

// USBHS.CTRL: General Control Register
func (o *USBHS_Type) SetCTRL_RDERRE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetCTRL_RDERRE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetCTRL_VBUSHWC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetCTRL_VBUSHWC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetCTRL_FRZCLK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetCTRL_FRZCLK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetCTRL_USBE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetCTRL_USBE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetCTRL_UIMOD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetCTRL_UIMOD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}

// USBHS.SR: General Status Register
func (o *USBHS_Type) SetSR_RDERRI(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetSR_RDERRI() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetSR_SPEED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3000)|value<<12)
}
func (o *USBHS_Type) GetSR_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3000) >> 12
}
func (o *USBHS_Type) SetSR_CLKUSABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetSR_CLKUSABLE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}

// USBHS.SCR: General Status Clear Register
func (o *USBHS_Type) SetSCR_RDERRIC(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetSCR_RDERRIC() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// USBHS.SFR: General Status Set Register
func (o *USBHS_Type) SetSFR_RDERRIS(value uint32) {
	volatile.StoreUint32(&o.SFR.Reg, volatile.LoadUint32(&o.SFR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetSFR_RDERRIS() uint32 {
	return (volatile.LoadUint32(&o.SFR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetSFR_VBUSRQS(value uint32) {
	volatile.StoreUint32(&o.SFR.Reg, volatile.LoadUint32(&o.SFR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetSFR_VBUSRQS() uint32 {
	return (volatile.LoadUint32(&o.SFR.Reg) & 0x200) >> 9
}

// Device DMA Channel Next Descriptor Address Register (n = 1)
type USBHS_USBHS_DEVDMA_Type struct {
	DEVDMANXTDSC  volatile.Register32 // 0x310
	DEVDMAADDRESS volatile.Register32 // 0x314
	DEVDMACONTROL volatile.Register32 // 0x318
	DEVDMASTATUS  volatile.Register32 // 0x31C
}

// USBHS_USBHS_DEVDMA.DEVDMANXTDSC: Device DMA Channel Next Descriptor Address Register (n = 1)
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMANXTDSC(value uint32) {
	volatile.StoreUint32(&o.DEVDMANXTDSC.Reg, value)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMANXTDSC() uint32 {
	return volatile.LoadUint32(&o.DEVDMANXTDSC.Reg)
}

// USBHS_USBHS_DEVDMA.DEVDMAADDRESS: Device DMA Channel Address Register (n = 1)
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMAADDRESS(value uint32) {
	volatile.StoreUint32(&o.DEVDMAADDRESS.Reg, value)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMAADDRESS() uint32 {
	return volatile.LoadUint32(&o.DEVDMAADDRESS.Reg)
}

// USBHS_USBHS_DEVDMA.DEVDMACONTROL: Device DMA Channel Control Register (n = 1)
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x1)|value)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x1
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x2) >> 1
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x4) >> 2
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x8) >> 3
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x10) >> 4
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x20) >> 5
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x40) >> 6
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0x80) >> 7
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMACONTROL_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DEVDMACONTROL.Reg, volatile.LoadUint32(&o.DEVDMACONTROL.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMACONTROL_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEVDMACONTROL.Reg) & 0xffff0000) >> 16
}

// USBHS_USBHS_DEVDMA.DEVDMASTATUS: Device DMA Channel Status Register (n = 1)
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0x1)|value)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0x1
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0x2) >> 1
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0x10) >> 4
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0x20) >> 5
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0x40) >> 6
}
func (o *USBHS_USBHS_DEVDMA_Type) SetDEVDMASTATUS_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEVDMASTATUS.Reg, volatile.LoadUint32(&o.DEVDMASTATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBHS_USBHS_DEVDMA_Type) GetDEVDMASTATUS_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DEVDMASTATUS.Reg) & 0xffff0000) >> 16
}

// Host DMA Channel Next Descriptor Address Register (n = 1)
type USBHS_USBHS_HSTDMA_Type struct {
	HSTDMANXTDSC  volatile.Register32 // 0x710
	HSTDMAADDRESS volatile.Register32 // 0x714
	HSTDMACONTROL volatile.Register32 // 0x718
	HSTDMASTATUS  volatile.Register32 // 0x71C
}

// USBHS_USBHS_HSTDMA.HSTDMANXTDSC: Host DMA Channel Next Descriptor Address Register (n = 1)
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMANXTDSC(value uint32) {
	volatile.StoreUint32(&o.HSTDMANXTDSC.Reg, value)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMANXTDSC() uint32 {
	return volatile.LoadUint32(&o.HSTDMANXTDSC.Reg)
}

// USBHS_USBHS_HSTDMA.HSTDMAADDRESS: Host DMA Channel Address Register (n = 1)
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMAADDRESS(value uint32) {
	volatile.StoreUint32(&o.HSTDMAADDRESS.Reg, value)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMAADDRESS() uint32 {
	return volatile.LoadUint32(&o.HSTDMAADDRESS.Reg)
}

// USBHS_USBHS_HSTDMA.HSTDMACONTROL: Host DMA Channel Control Register (n = 1)
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x1)|value)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x1
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x2) >> 1
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x4) >> 2
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x8) >> 3
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x10) >> 4
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x20) >> 5
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x40) >> 6
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0x80) >> 7
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMACONTROL_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.HSTDMACONTROL.Reg, volatile.LoadUint32(&o.HSTDMACONTROL.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMACONTROL_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.HSTDMACONTROL.Reg) & 0xffff0000) >> 16
}

// USBHS_USBHS_HSTDMA.HSTDMASTATUS: Host DMA Channel Status Register (n = 1)
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0x1)|value)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0x1
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0x2) >> 1
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0x10) >> 4
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0x20) >> 5
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0x40) >> 6
}
func (o *USBHS_USBHS_HSTDMA_Type) SetHSTDMASTATUS_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.HSTDMASTATUS.Reg, volatile.LoadUint32(&o.HSTDMASTATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBHS_USBHS_HSTDMA_Type) GetHSTDMASTATUS_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.HSTDMASTATUS.Reg) & 0xffff0000) >> 16
}

// USB Transmitter Interface Macrocell
type UTMI_Type struct {
	_       [16]byte
	OHCIICR volatile.Register32 // 0x10
	_       [28]byte
	CKTRIM  volatile.Register32 // 0x30
}

// UTMI.OHCIICR: OHCI Interrupt Configuration Register
func (o *UTMI_Type) SetOHCIICR_RES0(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x1)|value)
}
func (o *UTMI_Type) GetOHCIICR_RES0() uint32 {
	return volatile.LoadUint32(&o.OHCIICR.Reg) & 0x1
}
func (o *UTMI_Type) SetOHCIICR_ARIE(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x10)|value<<4)
}
func (o *UTMI_Type) GetOHCIICR_ARIE() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x10) >> 4
}
func (o *UTMI_Type) SetOHCIICR_APPSTART(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x20)|value<<5)
}
func (o *UTMI_Type) GetOHCIICR_APPSTART() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x20) >> 5
}
func (o *UTMI_Type) SetOHCIICR_UDPPUDIS(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x800000)|value<<23)
}
func (o *UTMI_Type) GetOHCIICR_UDPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x800000) >> 23
}

// UTMI.CKTRIM: UTMI Clock Trimming Register
func (o *UTMI_Type) SetCKTRIM_FREQ(value uint32) {
	volatile.StoreUint32(&o.CKTRIM.Reg, volatile.LoadUint32(&o.CKTRIM.Reg)&^(0x3)|value)
}
func (o *UTMI_Type) GetCKTRIM_FREQ() uint32 {
	return volatile.LoadUint32(&o.CKTRIM.Reg) & 0x3
}

// Watchdog Timer
type WDT_Type struct {
	CR volatile.Register32 // 0x0
	MR volatile.Register32 // 0x4
	SR volatile.Register32 // 0x8
}

// WDT.CR: Control Register
func (o *WDT_Type) SetCR_WDRSTT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetCR_WDRSTT() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *WDT_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *WDT_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// WDT.MR: Mode Register
func (o *WDT_Type) SetMR_WDV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xfff)|value)
}
func (o *WDT_Type) GetMR_WDV() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xfff
}
func (o *WDT_Type) SetMR_WDFIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *WDT_Type) GetMR_WDFIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *WDT_Type) SetMR_WDRSTEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *WDT_Type) GetMR_WDRSTEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *WDT_Type) SetMR_WDDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetMR_WDDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *WDT_Type) SetMR_WDD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xfff0000)|value<<16)
}
func (o *WDT_Type) GetMR_WDD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xfff0000) >> 16
}
func (o *WDT_Type) SetMR_WDDBGHLT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *WDT_Type) GetMR_WDDBGHLT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}
func (o *WDT_Type) SetMR_WDIDLEHLT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000000)|value<<29)
}
func (o *WDT_Type) GetMR_WDIDLEHLT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000000) >> 29
}

// WDT.SR: Status Register
func (o *WDT_Type) SetSR_WDUNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetSR_WDUNF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *WDT_Type) SetSR_WDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetSR_WDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}

// Extensible DMA Controller
type XDMAC_Type struct {
	GTYPE      volatile.Register32 // 0x0
	GCFG       volatile.Register32 // 0x4
	GWAC       volatile.Register32 // 0x8
	GIE        volatile.Register32 // 0xC
	GID        volatile.Register32 // 0x10
	GIM        volatile.Register32 // 0x14
	GIS        volatile.Register32 // 0x18
	GE         volatile.Register32 // 0x1C
	GD         volatile.Register32 // 0x20
	GS         volatile.Register32 // 0x24
	GRS        volatile.Register32 // 0x28
	GWS        volatile.Register32 // 0x2C
	GRWS       volatile.Register32 // 0x30
	GRWR       volatile.Register32 // 0x34
	GSWR       volatile.Register32 // 0x38
	GSWS       volatile.Register32 // 0x3C
	GSWF       volatile.Register32 // 0x40
	_          [12]byte
	XDMAC_CHID [24]XDMAC_XDMAC_CHID_Type // 0x50
}

// XDMAC.GTYPE: Global Type Register
func (o *XDMAC_Type) SetGTYPE_NB_CH(value uint32) {
	volatile.StoreUint32(&o.GTYPE.Reg, volatile.LoadUint32(&o.GTYPE.Reg)&^(0x1f)|value)
}
func (o *XDMAC_Type) GetGTYPE_NB_CH() uint32 {
	return volatile.LoadUint32(&o.GTYPE.Reg) & 0x1f
}
func (o *XDMAC_Type) SetGTYPE_FIFO_SZ(value uint32) {
	volatile.StoreUint32(&o.GTYPE.Reg, volatile.LoadUint32(&o.GTYPE.Reg)&^(0xffe0)|value<<5)
}
func (o *XDMAC_Type) GetGTYPE_FIFO_SZ() uint32 {
	return (volatile.LoadUint32(&o.GTYPE.Reg) & 0xffe0) >> 5
}
func (o *XDMAC_Type) SetGTYPE_NB_REQ(value uint32) {
	volatile.StoreUint32(&o.GTYPE.Reg, volatile.LoadUint32(&o.GTYPE.Reg)&^(0x7f0000)|value<<16)
}
func (o *XDMAC_Type) GetGTYPE_NB_REQ() uint32 {
	return (volatile.LoadUint32(&o.GTYPE.Reg) & 0x7f0000) >> 16
}

// XDMAC.GCFG: Global Configuration Register
func (o *XDMAC_Type) SetGCFG_CGDISREG(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGCFG_CGDISREG() uint32 {
	return volatile.LoadUint32(&o.GCFG.Reg) & 0x1
}
func (o *XDMAC_Type) SetGCFG_CGDISPIPE(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGCFG_CGDISPIPE() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGCFG_CGDISFIFO(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGCFG_CGDISFIFO() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGCFG_CGDISIF(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGCFG_CGDISIF() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGCFG_BXKBEN(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGCFG_BXKBEN() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x100) >> 8
}

// XDMAC.GWAC: Global Weighted Arbiter Configuration Register
func (o *XDMAC_Type) SetGWAC_PW0(value uint32) {
	volatile.StoreUint32(&o.GWAC.Reg, volatile.LoadUint32(&o.GWAC.Reg)&^(0xf)|value)
}
func (o *XDMAC_Type) GetGWAC_PW0() uint32 {
	return volatile.LoadUint32(&o.GWAC.Reg) & 0xf
}
func (o *XDMAC_Type) SetGWAC_PW1(value uint32) {
	volatile.StoreUint32(&o.GWAC.Reg, volatile.LoadUint32(&o.GWAC.Reg)&^(0xf0)|value<<4)
}
func (o *XDMAC_Type) GetGWAC_PW1() uint32 {
	return (volatile.LoadUint32(&o.GWAC.Reg) & 0xf0) >> 4
}
func (o *XDMAC_Type) SetGWAC_PW2(value uint32) {
	volatile.StoreUint32(&o.GWAC.Reg, volatile.LoadUint32(&o.GWAC.Reg)&^(0xf00)|value<<8)
}
func (o *XDMAC_Type) GetGWAC_PW2() uint32 {
	return (volatile.LoadUint32(&o.GWAC.Reg) & 0xf00) >> 8
}
func (o *XDMAC_Type) SetGWAC_PW3(value uint32) {
	volatile.StoreUint32(&o.GWAC.Reg, volatile.LoadUint32(&o.GWAC.Reg)&^(0xf000)|value<<12)
}
func (o *XDMAC_Type) GetGWAC_PW3() uint32 {
	return (volatile.LoadUint32(&o.GWAC.Reg) & 0xf000) >> 12
}

// XDMAC.GIE: Global Interrupt Enable Register
func (o *XDMAC_Type) SetGIE_IE0(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGIE_IE0() uint32 {
	return volatile.LoadUint32(&o.GIE.Reg) & 0x1
}
func (o *XDMAC_Type) SetGIE_IE1(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGIE_IE1() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGIE_IE2(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGIE_IE2() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGIE_IE3(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGIE_IE3() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGIE_IE4(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGIE_IE4() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGIE_IE5(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGIE_IE5() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGIE_IE6(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGIE_IE6() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGIE_IE7(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGIE_IE7() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGIE_IE8(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGIE_IE8() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGIE_IE9(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGIE_IE9() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGIE_IE10(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGIE_IE10() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGIE_IE11(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGIE_IE11() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGIE_IE12(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGIE_IE12() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGIE_IE13(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGIE_IE13() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGIE_IE14(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGIE_IE14() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGIE_IE15(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGIE_IE15() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGIE_IE16(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGIE_IE16() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGIE_IE17(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGIE_IE17() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGIE_IE18(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGIE_IE18() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGIE_IE19(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGIE_IE19() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGIE_IE20(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGIE_IE20() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGIE_IE21(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGIE_IE21() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGIE_IE22(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGIE_IE22() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGIE_IE23(value uint32) {
	volatile.StoreUint32(&o.GIE.Reg, volatile.LoadUint32(&o.GIE.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGIE_IE23() uint32 {
	return (volatile.LoadUint32(&o.GIE.Reg) & 0x800000) >> 23
}

// XDMAC.GID: Global Interrupt Disable Register
func (o *XDMAC_Type) SetGID_ID0(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGID_ID0() uint32 {
	return volatile.LoadUint32(&o.GID.Reg) & 0x1
}
func (o *XDMAC_Type) SetGID_ID1(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGID_ID1() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGID_ID2(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGID_ID2() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGID_ID3(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGID_ID3() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGID_ID4(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGID_ID4() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGID_ID5(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGID_ID5() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGID_ID6(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGID_ID6() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGID_ID7(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGID_ID7() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGID_ID8(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGID_ID8() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGID_ID9(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGID_ID9() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGID_ID10(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGID_ID10() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGID_ID11(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGID_ID11() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGID_ID12(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGID_ID12() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGID_ID13(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGID_ID13() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGID_ID14(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGID_ID14() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGID_ID15(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGID_ID15() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGID_ID16(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGID_ID16() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGID_ID17(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGID_ID17() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGID_ID18(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGID_ID18() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGID_ID19(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGID_ID19() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGID_ID20(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGID_ID20() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGID_ID21(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGID_ID21() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGID_ID22(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGID_ID22() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGID_ID23(value uint32) {
	volatile.StoreUint32(&o.GID.Reg, volatile.LoadUint32(&o.GID.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGID_ID23() uint32 {
	return (volatile.LoadUint32(&o.GID.Reg) & 0x800000) >> 23
}

// XDMAC.GIM: Global Interrupt Mask Register
func (o *XDMAC_Type) SetGIM_IM0(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGIM_IM0() uint32 {
	return volatile.LoadUint32(&o.GIM.Reg) & 0x1
}
func (o *XDMAC_Type) SetGIM_IM1(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGIM_IM1() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGIM_IM2(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGIM_IM2() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGIM_IM3(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGIM_IM3() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGIM_IM4(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGIM_IM4() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGIM_IM5(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGIM_IM5() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGIM_IM6(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGIM_IM6() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGIM_IM7(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGIM_IM7() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGIM_IM8(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGIM_IM8() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGIM_IM9(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGIM_IM9() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGIM_IM10(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGIM_IM10() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGIM_IM11(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGIM_IM11() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGIM_IM12(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGIM_IM12() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGIM_IM13(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGIM_IM13() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGIM_IM14(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGIM_IM14() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGIM_IM15(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGIM_IM15() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGIM_IM16(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGIM_IM16() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGIM_IM17(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGIM_IM17() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGIM_IM18(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGIM_IM18() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGIM_IM19(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGIM_IM19() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGIM_IM20(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGIM_IM20() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGIM_IM21(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGIM_IM21() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGIM_IM22(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGIM_IM22() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGIM_IM23(value uint32) {
	volatile.StoreUint32(&o.GIM.Reg, volatile.LoadUint32(&o.GIM.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGIM_IM23() uint32 {
	return (volatile.LoadUint32(&o.GIM.Reg) & 0x800000) >> 23
}

// XDMAC.GIS: Global Interrupt Status Register
func (o *XDMAC_Type) SetGIS_IS0(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGIS_IS0() uint32 {
	return volatile.LoadUint32(&o.GIS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGIS_IS1(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGIS_IS1() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGIS_IS2(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGIS_IS2() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGIS_IS3(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGIS_IS3() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGIS_IS4(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGIS_IS4() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGIS_IS5(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGIS_IS5() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGIS_IS6(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGIS_IS6() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGIS_IS7(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGIS_IS7() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGIS_IS8(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGIS_IS8() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGIS_IS9(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGIS_IS9() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGIS_IS10(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGIS_IS10() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGIS_IS11(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGIS_IS11() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGIS_IS12(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGIS_IS12() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGIS_IS13(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGIS_IS13() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGIS_IS14(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGIS_IS14() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGIS_IS15(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGIS_IS15() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGIS_IS16(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGIS_IS16() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGIS_IS17(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGIS_IS17() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGIS_IS18(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGIS_IS18() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGIS_IS19(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGIS_IS19() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGIS_IS20(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGIS_IS20() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGIS_IS21(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGIS_IS21() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGIS_IS22(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGIS_IS22() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGIS_IS23(value uint32) {
	volatile.StoreUint32(&o.GIS.Reg, volatile.LoadUint32(&o.GIS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGIS_IS23() uint32 {
	return (volatile.LoadUint32(&o.GIS.Reg) & 0x800000) >> 23
}

// XDMAC.GE: Global Channel Enable Register
func (o *XDMAC_Type) SetGE_EN0(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGE_EN0() uint32 {
	return volatile.LoadUint32(&o.GE.Reg) & 0x1
}
func (o *XDMAC_Type) SetGE_EN1(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGE_EN1() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGE_EN2(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGE_EN2() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGE_EN3(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGE_EN3() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGE_EN4(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGE_EN4() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGE_EN5(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGE_EN5() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGE_EN6(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGE_EN6() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGE_EN7(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGE_EN7() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGE_EN8(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGE_EN8() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGE_EN9(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGE_EN9() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGE_EN10(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGE_EN10() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGE_EN11(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGE_EN11() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGE_EN12(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGE_EN12() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGE_EN13(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGE_EN13() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGE_EN14(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGE_EN14() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGE_EN15(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGE_EN15() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGE_EN16(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGE_EN16() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGE_EN17(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGE_EN17() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGE_EN18(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGE_EN18() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGE_EN19(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGE_EN19() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGE_EN20(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGE_EN20() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGE_EN21(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGE_EN21() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGE_EN22(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGE_EN22() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGE_EN23(value uint32) {
	volatile.StoreUint32(&o.GE.Reg, volatile.LoadUint32(&o.GE.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGE_EN23() uint32 {
	return (volatile.LoadUint32(&o.GE.Reg) & 0x800000) >> 23
}

// XDMAC.GD: Global Channel Disable Register
func (o *XDMAC_Type) SetGD_DI0(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGD_DI0() uint32 {
	return volatile.LoadUint32(&o.GD.Reg) & 0x1
}
func (o *XDMAC_Type) SetGD_DI1(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGD_DI1() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGD_DI2(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGD_DI2() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGD_DI3(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGD_DI3() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGD_DI4(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGD_DI4() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGD_DI5(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGD_DI5() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGD_DI6(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGD_DI6() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGD_DI7(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGD_DI7() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGD_DI8(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGD_DI8() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGD_DI9(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGD_DI9() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGD_DI10(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGD_DI10() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGD_DI11(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGD_DI11() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGD_DI12(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGD_DI12() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGD_DI13(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGD_DI13() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGD_DI14(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGD_DI14() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGD_DI15(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGD_DI15() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGD_DI16(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGD_DI16() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGD_DI17(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGD_DI17() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGD_DI18(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGD_DI18() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGD_DI19(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGD_DI19() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGD_DI20(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGD_DI20() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGD_DI21(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGD_DI21() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGD_DI22(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGD_DI22() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGD_DI23(value uint32) {
	volatile.StoreUint32(&o.GD.Reg, volatile.LoadUint32(&o.GD.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGD_DI23() uint32 {
	return (volatile.LoadUint32(&o.GD.Reg) & 0x800000) >> 23
}

// XDMAC.GS: Global Channel Status Register
func (o *XDMAC_Type) SetGS_ST0(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGS_ST0() uint32 {
	return volatile.LoadUint32(&o.GS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGS_ST1(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGS_ST1() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGS_ST2(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGS_ST2() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGS_ST3(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGS_ST3() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGS_ST4(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGS_ST4() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGS_ST5(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGS_ST5() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGS_ST6(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGS_ST6() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGS_ST7(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGS_ST7() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGS_ST8(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGS_ST8() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGS_ST9(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGS_ST9() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGS_ST10(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGS_ST10() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGS_ST11(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGS_ST11() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGS_ST12(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGS_ST12() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGS_ST13(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGS_ST13() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGS_ST14(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGS_ST14() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGS_ST15(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGS_ST15() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGS_ST16(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGS_ST16() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGS_ST17(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGS_ST17() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGS_ST18(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGS_ST18() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGS_ST19(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGS_ST19() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGS_ST20(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGS_ST20() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGS_ST21(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGS_ST21() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGS_ST22(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGS_ST22() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGS_ST23(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGS_ST23() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x800000) >> 23
}

// XDMAC.GRS: Global Channel Read Suspend Register
func (o *XDMAC_Type) SetGRS_RS0(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGRS_RS0() uint32 {
	return volatile.LoadUint32(&o.GRS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGRS_RS1(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGRS_RS1() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGRS_RS2(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGRS_RS2() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGRS_RS3(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGRS_RS3() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGRS_RS4(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGRS_RS4() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGRS_RS5(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGRS_RS5() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGRS_RS6(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGRS_RS6() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGRS_RS7(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGRS_RS7() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGRS_RS8(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGRS_RS8() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGRS_RS9(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGRS_RS9() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGRS_RS10(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGRS_RS10() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGRS_RS11(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGRS_RS11() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGRS_RS12(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGRS_RS12() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGRS_RS13(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGRS_RS13() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGRS_RS14(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGRS_RS14() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGRS_RS15(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGRS_RS15() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGRS_RS16(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGRS_RS16() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGRS_RS17(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGRS_RS17() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGRS_RS18(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGRS_RS18() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGRS_RS19(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGRS_RS19() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGRS_RS20(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGRS_RS20() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGRS_RS21(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGRS_RS21() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGRS_RS22(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGRS_RS22() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGRS_RS23(value uint32) {
	volatile.StoreUint32(&o.GRS.Reg, volatile.LoadUint32(&o.GRS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGRS_RS23() uint32 {
	return (volatile.LoadUint32(&o.GRS.Reg) & 0x800000) >> 23
}

// XDMAC.GWS: Global Channel Write Suspend Register
func (o *XDMAC_Type) SetGWS_WS0(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGWS_WS0() uint32 {
	return volatile.LoadUint32(&o.GWS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGWS_WS1(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGWS_WS1() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGWS_WS2(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGWS_WS2() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGWS_WS3(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGWS_WS3() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGWS_WS4(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGWS_WS4() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGWS_WS5(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGWS_WS5() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGWS_WS6(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGWS_WS6() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGWS_WS7(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGWS_WS7() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGWS_WS8(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGWS_WS8() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGWS_WS9(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGWS_WS9() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGWS_WS10(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGWS_WS10() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGWS_WS11(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGWS_WS11() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGWS_WS12(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGWS_WS12() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGWS_WS13(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGWS_WS13() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGWS_WS14(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGWS_WS14() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGWS_WS15(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGWS_WS15() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGWS_WS16(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGWS_WS16() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGWS_WS17(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGWS_WS17() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGWS_WS18(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGWS_WS18() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGWS_WS19(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGWS_WS19() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGWS_WS20(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGWS_WS20() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGWS_WS21(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGWS_WS21() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGWS_WS22(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGWS_WS22() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGWS_WS23(value uint32) {
	volatile.StoreUint32(&o.GWS.Reg, volatile.LoadUint32(&o.GWS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGWS_WS23() uint32 {
	return (volatile.LoadUint32(&o.GWS.Reg) & 0x800000) >> 23
}

// XDMAC.GRWS: Global Channel Read Write Suspend Register
func (o *XDMAC_Type) SetGRWS_RWS0(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGRWS_RWS0() uint32 {
	return volatile.LoadUint32(&o.GRWS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGRWS_RWS1(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGRWS_RWS1() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGRWS_RWS2(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGRWS_RWS2() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGRWS_RWS3(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGRWS_RWS3() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGRWS_RWS4(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGRWS_RWS4() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGRWS_RWS5(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGRWS_RWS5() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGRWS_RWS6(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGRWS_RWS6() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGRWS_RWS7(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGRWS_RWS7() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGRWS_RWS8(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGRWS_RWS8() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGRWS_RWS9(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGRWS_RWS9() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGRWS_RWS10(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGRWS_RWS10() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGRWS_RWS11(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGRWS_RWS11() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGRWS_RWS12(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGRWS_RWS12() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGRWS_RWS13(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGRWS_RWS13() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGRWS_RWS14(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGRWS_RWS14() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGRWS_RWS15(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGRWS_RWS15() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGRWS_RWS16(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGRWS_RWS16() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGRWS_RWS17(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGRWS_RWS17() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGRWS_RWS18(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGRWS_RWS18() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGRWS_RWS19(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGRWS_RWS19() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGRWS_RWS20(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGRWS_RWS20() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGRWS_RWS21(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGRWS_RWS21() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGRWS_RWS22(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGRWS_RWS22() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGRWS_RWS23(value uint32) {
	volatile.StoreUint32(&o.GRWS.Reg, volatile.LoadUint32(&o.GRWS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGRWS_RWS23() uint32 {
	return (volatile.LoadUint32(&o.GRWS.Reg) & 0x800000) >> 23
}

// XDMAC.GRWR: Global Channel Read Write Resume Register
func (o *XDMAC_Type) SetGRWR_RWR0(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGRWR_RWR0() uint32 {
	return volatile.LoadUint32(&o.GRWR.Reg) & 0x1
}
func (o *XDMAC_Type) SetGRWR_RWR1(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGRWR_RWR1() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGRWR_RWR2(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGRWR_RWR2() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGRWR_RWR3(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGRWR_RWR3() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGRWR_RWR4(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGRWR_RWR4() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGRWR_RWR5(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGRWR_RWR5() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGRWR_RWR6(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGRWR_RWR6() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGRWR_RWR7(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGRWR_RWR7() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGRWR_RWR8(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGRWR_RWR8() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGRWR_RWR9(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGRWR_RWR9() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGRWR_RWR10(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGRWR_RWR10() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGRWR_RWR11(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGRWR_RWR11() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGRWR_RWR12(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGRWR_RWR12() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGRWR_RWR13(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGRWR_RWR13() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGRWR_RWR14(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGRWR_RWR14() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGRWR_RWR15(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGRWR_RWR15() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGRWR_RWR16(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGRWR_RWR16() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGRWR_RWR17(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGRWR_RWR17() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGRWR_RWR18(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGRWR_RWR18() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGRWR_RWR19(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGRWR_RWR19() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGRWR_RWR20(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGRWR_RWR20() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGRWR_RWR21(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGRWR_RWR21() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGRWR_RWR22(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGRWR_RWR22() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGRWR_RWR23(value uint32) {
	volatile.StoreUint32(&o.GRWR.Reg, volatile.LoadUint32(&o.GRWR.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGRWR_RWR23() uint32 {
	return (volatile.LoadUint32(&o.GRWR.Reg) & 0x800000) >> 23
}

// XDMAC.GSWR: Global Channel Software Request Register
func (o *XDMAC_Type) SetGSWR_SWREQ0(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGSWR_SWREQ0() uint32 {
	return volatile.LoadUint32(&o.GSWR.Reg) & 0x1
}
func (o *XDMAC_Type) SetGSWR_SWREQ1(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGSWR_SWREQ1() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGSWR_SWREQ2(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGSWR_SWREQ2() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGSWR_SWREQ3(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGSWR_SWREQ3() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGSWR_SWREQ4(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGSWR_SWREQ4() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGSWR_SWREQ5(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGSWR_SWREQ5() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGSWR_SWREQ6(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGSWR_SWREQ6() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGSWR_SWREQ7(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGSWR_SWREQ7() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGSWR_SWREQ8(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGSWR_SWREQ8() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGSWR_SWREQ9(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGSWR_SWREQ9() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGSWR_SWREQ10(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGSWR_SWREQ10() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGSWR_SWREQ11(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGSWR_SWREQ11() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGSWR_SWREQ12(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGSWR_SWREQ12() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGSWR_SWREQ13(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGSWR_SWREQ13() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGSWR_SWREQ14(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGSWR_SWREQ14() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGSWR_SWREQ15(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGSWR_SWREQ15() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGSWR_SWREQ16(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGSWR_SWREQ16() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGSWR_SWREQ17(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGSWR_SWREQ17() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGSWR_SWREQ18(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGSWR_SWREQ18() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGSWR_SWREQ19(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGSWR_SWREQ19() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGSWR_SWREQ20(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGSWR_SWREQ20() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGSWR_SWREQ21(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGSWR_SWREQ21() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGSWR_SWREQ22(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGSWR_SWREQ22() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGSWR_SWREQ23(value uint32) {
	volatile.StoreUint32(&o.GSWR.Reg, volatile.LoadUint32(&o.GSWR.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGSWR_SWREQ23() uint32 {
	return (volatile.LoadUint32(&o.GSWR.Reg) & 0x800000) >> 23
}

// XDMAC.GSWS: Global Channel Software Request Status Register
func (o *XDMAC_Type) SetGSWS_SWRS0(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGSWS_SWRS0() uint32 {
	return volatile.LoadUint32(&o.GSWS.Reg) & 0x1
}
func (o *XDMAC_Type) SetGSWS_SWRS1(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGSWS_SWRS1() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGSWS_SWRS2(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGSWS_SWRS2() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGSWS_SWRS3(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGSWS_SWRS3() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGSWS_SWRS4(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGSWS_SWRS4() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGSWS_SWRS5(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGSWS_SWRS5() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGSWS_SWRS6(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGSWS_SWRS6() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGSWS_SWRS7(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGSWS_SWRS7() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGSWS_SWRS8(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGSWS_SWRS8() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGSWS_SWRS9(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGSWS_SWRS9() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGSWS_SWRS10(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGSWS_SWRS10() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGSWS_SWRS11(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGSWS_SWRS11() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGSWS_SWRS12(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGSWS_SWRS12() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGSWS_SWRS13(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGSWS_SWRS13() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGSWS_SWRS14(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGSWS_SWRS14() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGSWS_SWRS15(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGSWS_SWRS15() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGSWS_SWRS16(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGSWS_SWRS16() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGSWS_SWRS17(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGSWS_SWRS17() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGSWS_SWRS18(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGSWS_SWRS18() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGSWS_SWRS19(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGSWS_SWRS19() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGSWS_SWRS20(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGSWS_SWRS20() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGSWS_SWRS21(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGSWS_SWRS21() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGSWS_SWRS22(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGSWS_SWRS22() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGSWS_SWRS23(value uint32) {
	volatile.StoreUint32(&o.GSWS.Reg, volatile.LoadUint32(&o.GSWS.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGSWS_SWRS23() uint32 {
	return (volatile.LoadUint32(&o.GSWS.Reg) & 0x800000) >> 23
}

// XDMAC.GSWF: Global Channel Software Flush Request Register
func (o *XDMAC_Type) SetGSWF_SWF0(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x1)|value)
}
func (o *XDMAC_Type) GetGSWF_SWF0() uint32 {
	return volatile.LoadUint32(&o.GSWF.Reg) & 0x1
}
func (o *XDMAC_Type) SetGSWF_SWF1(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_Type) GetGSWF_SWF1() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x2) >> 1
}
func (o *XDMAC_Type) SetGSWF_SWF2(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_Type) GetGSWF_SWF2() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x4) >> 2
}
func (o *XDMAC_Type) SetGSWF_SWF3(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_Type) GetGSWF_SWF3() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x8) >> 3
}
func (o *XDMAC_Type) SetGSWF_SWF4(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_Type) GetGSWF_SWF4() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x10) >> 4
}
func (o *XDMAC_Type) SetGSWF_SWF5(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_Type) GetGSWF_SWF5() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x20) >> 5
}
func (o *XDMAC_Type) SetGSWF_SWF6(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_Type) GetGSWF_SWF6() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x40) >> 6
}
func (o *XDMAC_Type) SetGSWF_SWF7(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_Type) GetGSWF_SWF7() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x80) >> 7
}
func (o *XDMAC_Type) SetGSWF_SWF8(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x100)|value<<8)
}
func (o *XDMAC_Type) GetGSWF_SWF8() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x100) >> 8
}
func (o *XDMAC_Type) SetGSWF_SWF9(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x200)|value<<9)
}
func (o *XDMAC_Type) GetGSWF_SWF9() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x200) >> 9
}
func (o *XDMAC_Type) SetGSWF_SWF10(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x400)|value<<10)
}
func (o *XDMAC_Type) GetGSWF_SWF10() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x400) >> 10
}
func (o *XDMAC_Type) SetGSWF_SWF11(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x800)|value<<11)
}
func (o *XDMAC_Type) GetGSWF_SWF11() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x800) >> 11
}
func (o *XDMAC_Type) SetGSWF_SWF12(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x1000)|value<<12)
}
func (o *XDMAC_Type) GetGSWF_SWF12() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x1000) >> 12
}
func (o *XDMAC_Type) SetGSWF_SWF13(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_Type) GetGSWF_SWF13() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x2000) >> 13
}
func (o *XDMAC_Type) SetGSWF_SWF14(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_Type) GetGSWF_SWF14() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x4000) >> 14
}
func (o *XDMAC_Type) SetGSWF_SWF15(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x8000)|value<<15)
}
func (o *XDMAC_Type) GetGSWF_SWF15() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x8000) >> 15
}
func (o *XDMAC_Type) SetGSWF_SWF16(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x10000)|value<<16)
}
func (o *XDMAC_Type) GetGSWF_SWF16() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x10000) >> 16
}
func (o *XDMAC_Type) SetGSWF_SWF17(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x20000)|value<<17)
}
func (o *XDMAC_Type) GetGSWF_SWF17() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x20000) >> 17
}
func (o *XDMAC_Type) SetGSWF_SWF18(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x40000)|value<<18)
}
func (o *XDMAC_Type) GetGSWF_SWF18() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x40000) >> 18
}
func (o *XDMAC_Type) SetGSWF_SWF19(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x80000)|value<<19)
}
func (o *XDMAC_Type) GetGSWF_SWF19() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x80000) >> 19
}
func (o *XDMAC_Type) SetGSWF_SWF20(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x100000)|value<<20)
}
func (o *XDMAC_Type) GetGSWF_SWF20() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x100000) >> 20
}
func (o *XDMAC_Type) SetGSWF_SWF21(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_Type) GetGSWF_SWF21() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x200000) >> 21
}
func (o *XDMAC_Type) SetGSWF_SWF22(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_Type) GetGSWF_SWF22() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x400000) >> 22
}
func (o *XDMAC_Type) SetGSWF_SWF23(value uint32) {
	volatile.StoreUint32(&o.GSWF.Reg, volatile.LoadUint32(&o.GSWF.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_Type) GetGSWF_SWF23() uint32 {
	return (volatile.LoadUint32(&o.GSWF.Reg) & 0x800000) >> 23
}

// Channel Interrupt Enable Register (chid = 0)
type XDMAC_XDMAC_CHID_Type struct {
	CIE     volatile.Register32 // 0x50
	CID     volatile.Register32 // 0x54
	CIM     volatile.Register32 // 0x58
	CIS     volatile.Register32 // 0x5C
	CSA     volatile.Register32 // 0x60
	CDA     volatile.Register32 // 0x64
	CNDA    volatile.Register32 // 0x68
	CNDC    volatile.Register32 // 0x6C
	CUBC    volatile.Register32 // 0x70
	CBC     volatile.Register32 // 0x74
	CC      volatile.Register32 // 0x78
	CDS_MSP volatile.Register32 // 0x7C
	CSUS    volatile.Register32 // 0x80
	CDUS    volatile.Register32 // 0x84
	_       [8]byte
}

// XDMAC_XDMAC_CHID.CIE: Channel Interrupt Enable Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_BIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_BIE() uint32 {
	return volatile.LoadUint32(&o.CIE.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_LIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_LIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x2) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_DIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_DIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x4) >> 2
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_FIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_FIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x8) >> 3
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_RBIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_RBIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x10) >> 4
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_WBIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_WBIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x20) >> 5
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIE_ROIE(value uint32) {
	volatile.StoreUint32(&o.CIE.Reg, volatile.LoadUint32(&o.CIE.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIE_ROIE() uint32 {
	return (volatile.LoadUint32(&o.CIE.Reg) & 0x40) >> 6
}

// XDMAC_XDMAC_CHID.CID: Channel Interrupt Disable Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCID_BID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_BID() uint32 {
	return volatile.LoadUint32(&o.CID.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_LID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_LID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x2) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_DID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_DID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x4) >> 2
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_FID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_FID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x8) >> 3
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_RBEID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_RBEID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x10) >> 4
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_WBEID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_WBEID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x20) >> 5
}
func (o *XDMAC_XDMAC_CHID_Type) SetCID_ROID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, volatile.LoadUint32(&o.CID.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCID_ROID() uint32 {
	return (volatile.LoadUint32(&o.CID.Reg) & 0x40) >> 6
}

// XDMAC_XDMAC_CHID.CIM: Channel Interrupt Mask Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_BIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_BIM() uint32 {
	return volatile.LoadUint32(&o.CIM.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_LIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_LIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x2) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_DIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_DIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x4) >> 2
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_FIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_FIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x8) >> 3
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_RBEIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_RBEIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x10) >> 4
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_WBEIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_WBEIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x20) >> 5
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIM_ROIM(value uint32) {
	volatile.StoreUint32(&o.CIM.Reg, volatile.LoadUint32(&o.CIM.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIM_ROIM() uint32 {
	return (volatile.LoadUint32(&o.CIM.Reg) & 0x40) >> 6
}

// XDMAC_XDMAC_CHID.CIS: Channel Interrupt Status Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_BIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_BIS() uint32 {
	return volatile.LoadUint32(&o.CIS.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_LIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_LIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x2) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_DIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_DIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x4) >> 2
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_FIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x8)|value<<3)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_FIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x8) >> 3
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_RBEIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_RBEIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x10) >> 4
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_WBEIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x20)|value<<5)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_WBEIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x20) >> 5
}
func (o *XDMAC_XDMAC_CHID_Type) SetCIS_ROIS(value uint32) {
	volatile.StoreUint32(&o.CIS.Reg, volatile.LoadUint32(&o.CIS.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCIS_ROIS() uint32 {
	return (volatile.LoadUint32(&o.CIS.Reg) & 0x40) >> 6
}

// XDMAC_XDMAC_CHID.CSA: Channel Source Address Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCSA(value uint32) {
	volatile.StoreUint32(&o.CSA.Reg, value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCSA() uint32 {
	return volatile.LoadUint32(&o.CSA.Reg)
}

// XDMAC_XDMAC_CHID.CDA: Channel Destination Address Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCDA(value uint32) {
	volatile.StoreUint32(&o.CDA.Reg, value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCDA() uint32 {
	return volatile.LoadUint32(&o.CDA.Reg)
}

// XDMAC_XDMAC_CHID.CNDA: Channel Next Descriptor Address Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCNDA_NDAIF(value uint32) {
	volatile.StoreUint32(&o.CNDA.Reg, volatile.LoadUint32(&o.CNDA.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDA_NDAIF() uint32 {
	return volatile.LoadUint32(&o.CNDA.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCNDA_NDA(value uint32) {
	volatile.StoreUint32(&o.CNDA.Reg, volatile.LoadUint32(&o.CNDA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDA_NDA() uint32 {
	return (volatile.LoadUint32(&o.CNDA.Reg) & 0xfffffffc) >> 2
}

// XDMAC_XDMAC_CHID.CNDC: Channel Next Descriptor Control Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCNDC_NDE(value uint32) {
	volatile.StoreUint32(&o.CNDC.Reg, volatile.LoadUint32(&o.CNDC.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDC_NDE() uint32 {
	return volatile.LoadUint32(&o.CNDC.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCNDC_NDSUP(value uint32) {
	volatile.StoreUint32(&o.CNDC.Reg, volatile.LoadUint32(&o.CNDC.Reg)&^(0x2)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDC_NDSUP() uint32 {
	return (volatile.LoadUint32(&o.CNDC.Reg) & 0x2) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCNDC_NDDUP(value uint32) {
	volatile.StoreUint32(&o.CNDC.Reg, volatile.LoadUint32(&o.CNDC.Reg)&^(0x4)|value<<2)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDC_NDDUP() uint32 {
	return (volatile.LoadUint32(&o.CNDC.Reg) & 0x4) >> 2
}
func (o *XDMAC_XDMAC_CHID_Type) SetCNDC_NDVIEW(value uint32) {
	volatile.StoreUint32(&o.CNDC.Reg, volatile.LoadUint32(&o.CNDC.Reg)&^(0x18)|value<<3)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCNDC_NDVIEW() uint32 {
	return (volatile.LoadUint32(&o.CNDC.Reg) & 0x18) >> 3
}

// XDMAC_XDMAC_CHID.CUBC: Channel Microblock Control Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCUBC_UBLEN(value uint32) {
	volatile.StoreUint32(&o.CUBC.Reg, volatile.LoadUint32(&o.CUBC.Reg)&^(0xffffff)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCUBC_UBLEN() uint32 {
	return volatile.LoadUint32(&o.CUBC.Reg) & 0xffffff
}

// XDMAC_XDMAC_CHID.CBC: Channel Block Control Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCBC_BLEN(value uint32) {
	volatile.StoreUint32(&o.CBC.Reg, volatile.LoadUint32(&o.CBC.Reg)&^(0xfff)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCBC_BLEN() uint32 {
	return volatile.LoadUint32(&o.CBC.Reg) & 0xfff
}

// XDMAC_XDMAC_CHID.CC: Channel Configuration Register (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCC_TYPE(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x1)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_TYPE() uint32 {
	return volatile.LoadUint32(&o.CC.Reg) & 0x1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_MBSIZE(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x6)|value<<1)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_MBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x6) >> 1
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_DSYNC(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x10)|value<<4)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_DSYNC() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x10) >> 4
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_SWREQ(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x40)|value<<6)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_SWREQ() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x40) >> 6
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_MEMSET(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x80)|value<<7)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_MEMSET() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x80) >> 7
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_CSIZE(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x700)|value<<8)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_CSIZE() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x700) >> 8
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x1800)|value<<11)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x1800) >> 11
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_SIF(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x2000)|value<<13)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_SIF() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x2000) >> 13
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_DIF(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x4000)|value<<14)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_DIF() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x4000) >> 14
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_SAM(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x30000)|value<<16)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_SAM() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x30000) >> 16
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_DAM(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0xc0000)|value<<18)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_DAM() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0xc0000) >> 18
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_INITD(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x200000)|value<<21)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_INITD() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x200000) >> 21
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_RDIP(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x400000)|value<<22)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_RDIP() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x400000) >> 22
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_WRIP(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x800000)|value<<23)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_WRIP() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x800000) >> 23
}
func (o *XDMAC_XDMAC_CHID_Type) SetCC_PERID(value uint32) {
	volatile.StoreUint32(&o.CC.Reg, volatile.LoadUint32(&o.CC.Reg)&^(0x7f000000)|value<<24)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCC_PERID() uint32 {
	return (volatile.LoadUint32(&o.CC.Reg) & 0x7f000000) >> 24
}

// XDMAC_XDMAC_CHID.CDS_MSP: Channel Data Stride Memory Set Pattern (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCDS_MSP_SDS_MSP(value uint32) {
	volatile.StoreUint32(&o.CDS_MSP.Reg, volatile.LoadUint32(&o.CDS_MSP.Reg)&^(0xffff)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCDS_MSP_SDS_MSP() uint32 {
	return volatile.LoadUint32(&o.CDS_MSP.Reg) & 0xffff
}
func (o *XDMAC_XDMAC_CHID_Type) SetCDS_MSP_DDS_MSP(value uint32) {
	volatile.StoreUint32(&o.CDS_MSP.Reg, volatile.LoadUint32(&o.CDS_MSP.Reg)&^(0xffff0000)|value<<16)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCDS_MSP_DDS_MSP() uint32 {
	return (volatile.LoadUint32(&o.CDS_MSP.Reg) & 0xffff0000) >> 16
}

// XDMAC_XDMAC_CHID.CSUS: Channel Source Microblock Stride (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCSUS_SUBS(value uint32) {
	volatile.StoreUint32(&o.CSUS.Reg, volatile.LoadUint32(&o.CSUS.Reg)&^(0xffffff)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCSUS_SUBS() uint32 {
	return volatile.LoadUint32(&o.CSUS.Reg) & 0xffffff
}

// XDMAC_XDMAC_CHID.CDUS: Channel Destination Microblock Stride (chid = 0)
func (o *XDMAC_XDMAC_CHID_Type) SetCDUS_DUBS(value uint32) {
	volatile.StoreUint32(&o.CDUS.Reg, volatile.LoadUint32(&o.CDUS.Reg)&^(0xffffff)|value)
}
func (o *XDMAC_XDMAC_CHID_Type) GetCDUS_DUBS() uint32 {
	return volatile.LoadUint32(&o.CDUS.Reg) & 0xffffff
}

type LOCKBIT_Type struct {
	WORD0 volatile.Register32 // 0x0
}

// LOCKBIT.WORD0: Lock Bits Word 0
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_0(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x1)|value)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_0() uint32 {
	return volatile.LoadUint32(&o.WORD0.Reg) & 0x1
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_1(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x2)|value<<1)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_1() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x2) >> 1
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_2(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x4)|value<<2)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_2() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x4) >> 2
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_3(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x8)|value<<3)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_3() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x8) >> 3
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_4(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x10)|value<<4)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_4() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x10) >> 4
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_5(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x20)|value<<5)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_5() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x20) >> 5
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_6(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x40)|value<<6)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_6() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x40) >> 6
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_7(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x80)|value<<7)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_7() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x80) >> 7
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_8(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x100)|value<<8)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_8() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x100) >> 8
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_9(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x200)|value<<9)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_9() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x200) >> 9
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_10(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x400)|value<<10)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_10() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x400) >> 10
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_11(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x800)|value<<11)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_11() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x800) >> 11
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_12(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x1000)|value<<12)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_12() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x1000) >> 12
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_13(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x2000)|value<<13)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_13() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x2000) >> 13
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_14(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x4000)|value<<14)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_14() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x4000) >> 14
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_15(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x8000)|value<<15)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_15() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x8000) >> 15
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_16(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x10000)|value<<16)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_16() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x10000) >> 16
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_17(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x20000)|value<<17)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_17() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x20000) >> 17
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_18(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x40000)|value<<18)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_18() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x40000) >> 18
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_19(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x80000)|value<<19)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_19() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x80000) >> 19
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_20(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x100000)|value<<20)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_20() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x100000) >> 20
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_21(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x200000)|value<<21)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_21() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x200000) >> 21
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_22(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x400000)|value<<22)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_22() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x400000) >> 22
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_23(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x800000)|value<<23)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_23() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x800000) >> 23
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_24(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x1000000)|value<<24)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_24() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x1000000) >> 24
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_25(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x2000000)|value<<25)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_25() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x2000000) >> 25
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_26(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x4000000)|value<<26)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_26() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x4000000) >> 26
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_27(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x8000000)|value<<27)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_27() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x8000000) >> 27
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_28(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x10000000)|value<<28)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_28() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x10000000) >> 28
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_29(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x20000000)|value<<29)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_29() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x20000000) >> 29
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_30(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x40000000)|value<<30)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_30() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x40000000) >> 30
}
func (o *LOCKBIT_Type) SetWORD0_LOCK_REGION_31(value uint32) {
	volatile.StoreUint32(&o.WORD0.Reg, volatile.LoadUint32(&o.WORD0.Reg)&^(0x80000000)|value<<31)
}
func (o *LOCKBIT_Type) GetWORD0_LOCK_REGION_31() uint32 {
	return (volatile.LoadUint32(&o.WORD0.Reg) & 0x80000000) >> 31
}

// System control not in SCB
type SCnSCB_Type struct {
	_     [4]byte
	ICTR  volatile.Register32 // 0x4
	ACTLR volatile.Register32 // 0x8
}

// SCnSCB.ICTR: Interrupt Controller Type Register
func (o *SCnSCB_Type) SetICTR_INTLINESNUM(value uint32) {
	volatile.StoreUint32(&o.ICTR.Reg, volatile.LoadUint32(&o.ICTR.Reg)&^(0xf)|value)
}
func (o *SCnSCB_Type) GetICTR_INTLINESNUM() uint32 {
	return volatile.LoadUint32(&o.ICTR.Reg) & 0xf
}

// SCnSCB.ACTLR: Auxiliary Control Register
func (o *SCnSCB_Type) SetACTLR_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4)|value<<2)
}
func (o *SCnSCB_Type) GetACTLR_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4) >> 2
}
func (o *SCnSCB_Type) SetACTLR_FPEXCODIS(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x400)|value<<10)
}
func (o *SCnSCB_Type) GetACTLR_FPEXCODIS() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x400) >> 10
}
func (o *SCnSCB_Type) SetACTLR_DISRAMODE(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x800)|value<<11)
}
func (o *SCnSCB_Type) GetACTLR_DISRAMODE() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x800) >> 11
}
func (o *SCnSCB_Type) SetACTLR_DISITMATBFLUSH(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCnSCB_Type) GetACTLR_DISITMATBFLUSH() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x1000) >> 12
}
func (o *SCnSCB_Type) SetACTLR_DISBTACREAD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCnSCB_Type) GetACTLR_DISBTACREAD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x2000) >> 13
}
func (o *SCnSCB_Type) SetACTLR_DISBTACALLOC(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCnSCB_Type) GetACTLR_DISBTACALLOC() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4000) >> 14
}
func (o *SCnSCB_Type) SetACTLR_DISCRITAXIRUR(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCnSCB_Type) GetACTLR_DISCRITAXIRUR() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x8000) >> 15
}
func (o *SCnSCB_Type) SetACTLR_DISDI(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCnSCB_Type) GetACTLR_DISDI() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x1f0000) >> 16
}
func (o *SCnSCB_Type) SetACTLR_DISISSCH1(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x3e00000)|value<<21)
}
func (o *SCnSCB_Type) GetACTLR_DISISSCH1() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x3e00000) >> 21
}
func (o *SCnSCB_Type) SetACTLR_DISDYNADD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCnSCB_Type) GetACTLR_DISDYNADD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4000000) >> 26
}
func (o *SCnSCB_Type) SetACTLR_DISCRITAXIRUW(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCnSCB_Type) GetACTLR_DISCRITAXIRUW() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x8000000) >> 27
}
func (o *SCnSCB_Type) SetACTLR_DISFPUISSOPT(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCnSCB_Type) GetACTLR_DISFPUISSOPT() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x10000000) >> 28
}

// System Control Block
type SCB_Type struct {
	CPUID  volatile.Register32 // 0x0
	ICSR   volatile.Register32 // 0x4
	VTOR   volatile.Register32 // 0x8
	AIRCR  volatile.Register32 // 0xC
	SCR    volatile.Register32 // 0x10
	CCR    volatile.Register32 // 0x14
	SHPR1  volatile.Register32 // 0x18
	SHPR2  volatile.Register32 // 0x1C
	SHPR3  volatile.Register32 // 0x20
	SHCSR  volatile.Register32 // 0x24
	CFSR   volatile.Register32 // 0x28
	HFSR   volatile.Register32 // 0x2C
	DFSR   volatile.Register32 // 0x30
	MMFAR  volatile.Register32 // 0x34
	BFAR   volatile.Register32 // 0x38
	AFSR   volatile.Register32 // 0x3C
	_      [56]byte
	CLIDR  volatile.Register32 // 0x78
	CTR    volatile.Register32 // 0x7C
	CCSIDR volatile.Register32 // 0x80
	CSSELR volatile.Register32 // 0x84
	CPACR  volatile.Register32 // 0x88
	_      [372]byte
	STIR   volatile.Register32 // 0x200
	_      [60]byte
	MVFR0  volatile.Register32 // 0x240
	MVFR1  volatile.Register32 // 0x244
	MVFR2  volatile.Register32 // 0x248
}

// SCB.CPUID: CPUID Base Register
func (o *SCB_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_ARCHITECTURE(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_ARCHITECTURE() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt Control and State Register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x3f000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x3f000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_ISRPREEMPT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800000)|value<<23)
}
func (o *SCB_Type) GetICSR_ISRPREEMPT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800000) >> 23
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector Table Offset Register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SCB.AIRCR: Application Interrupt and Reset Control Register
func (o *SCB_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SCB_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SCB_Type) SetAIRCR_ENDIANNESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANNESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System Control Register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and Control Register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCCR_DC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCCR_DC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCCR_IC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCCR_IC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCCR_BP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCCR_BP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40000) >> 18
}

// SCB.SHPR1: System Handler Priority Register 1
func (o *SCB_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SCB_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SCB_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SCB.SHPR2: System Handler Priority Register 2
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System Handler Priority Register 3
func (o *SCB_Type) SetSHPR3_PRI_12(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR3_PRI_12() uint32 {
	return volatile.LoadUint32(&o.SHPR3.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SCB.SHCSR: System Handler Control and State Register
func (o *SCB_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SCB_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SCB.CFSR: Configurable Fault Status Registers
func (o *SCB_Type) SetCFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR.Reg) & 0x1
}
func (o *SCB_Type) SetCFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20)|value<<5)
}
func (o *SCB_Type) GetCFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20) >> 5
}
func (o *SCB_Type) SetCFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetCFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetCFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetCFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetCFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetCFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetCFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetCFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetCFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetCFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetCFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetCFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetCFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x40000) >> 18
}
func (o *SCB_Type) SetCFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SCB_Type) GetCFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80000) >> 19
}
func (o *SCB_Type) SetCFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SCB_Type) GetCFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000000) >> 24
}
func (o *SCB_Type) SetCFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetCFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000000) >> 25
}

// SCB.HFSR: HardFault Status register
func (o *SCB_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetHFSR_DEBUGEVT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetHFSR_DEBUGEVT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SCB.DFSR: Debug Fault Status Register
func (o *SCB_Type) SetDFSR_HALTED(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetDFSR_HALTED() uint32 {
	return volatile.LoadUint32(&o.DFSR.Reg) & 0x1
}
func (o *SCB_Type) SetDFSR_BKPT(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetDFSR_BKPT() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetDFSR_DWTTRAP(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetDFSR_DWTTRAP() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetDFSR_VCATCH(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetDFSR_VCATCH() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetDFSR_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetDFSR_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x10) >> 4
}

// SCB.MMFAR: MemManage Fault Address Register
func (o *SCB_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SCB_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SCB.BFAR: BusFault Address Register
func (o *SCB_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SCB_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SCB.CLIDR: Cache Level ID Register
func (o *SCB_Type) SetCLIDR_LoC(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000000)|value<<24)
}
func (o *SCB_Type) GetCLIDR_LoC() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000000) >> 24
}
func (o *SCB_Type) SetCLIDR_LoU(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000000)|value<<27)
}
func (o *SCB_Type) GetCLIDR_LoU() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000000) >> 27
}

// SCB.CTR: Cache Type Register
func (o *SCB_Type) SetCTR_IMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCTR_IMINLINE() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0xf
}
func (o *SCB_Type) SetCTR_DMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCTR_DMINLINE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCTR_ERG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCTR_ERG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCTR_CWG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetCTR_CWG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf000000) >> 24
}
func (o *SCB_Type) SetCTR_FORMAT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xe0000000)|value<<29)
}
func (o *SCB_Type) GetCTR_FORMAT() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xe0000000) >> 29
}

// SCB.CCSIDR: Cache Size ID Register
func (o *SCB_Type) SetCCSIDR_LineSize(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x7)|value)
}
func (o *SCB_Type) GetCCSIDR_LineSize() uint32 {
	return volatile.LoadUint32(&o.CCSIDR.Reg) & 0x7
}
func (o *SCB_Type) SetCCSIDR_Associativity(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0xff8)|value<<3)
}
func (o *SCB_Type) GetCCSIDR_Associativity() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0xff8) >> 3
}
func (o *SCB_Type) SetCCSIDR_NumSets(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0xffff000)|value<<12)
}
func (o *SCB_Type) GetCCSIDR_NumSets() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0xffff000) >> 12
}
func (o *SCB_Type) SetCCSIDR_WA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetCCSIDR_WA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetCCSIDR_RA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SCB_Type) GetCCSIDR_RA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x20000000) >> 29
}
func (o *SCB_Type) SetCCSIDR_WB(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetCCSIDR_WB() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetCCSIDR_WT(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetCCSIDR_WT() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x80000000) >> 31
}

// SCB.CSSELR: Cache Size Selection Register
func (o *SCB_Type) SetCSSELR_IND(value uint32) {
	volatile.StoreUint32(&o.CSSELR.Reg, volatile.LoadUint32(&o.CSSELR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCSSELR_IND() uint32 {
	return volatile.LoadUint32(&o.CSSELR.Reg) & 0x1
}
func (o *SCB_Type) SetCSSELR_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CSSELR.Reg, volatile.LoadUint32(&o.CSSELR.Reg)&^(0xe)|value<<1)
}
func (o *SCB_Type) GetCSSELR_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CSSELR.Reg) & 0xe) >> 1
}

// SCB.CPACR: Coprocessor Access Control Register
func (o *SCB_Type) SetCPACR_CP10(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300000)|value<<20)
}
func (o *SCB_Type) GetCPACR_CP10() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300000) >> 20
}
func (o *SCB_Type) SetCPACR_CP11(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00000)|value<<22)
}
func (o *SCB_Type) GetCPACR_CP11() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00000) >> 22
}

// SCB.STIR: Software Trigger Interrupt Register
func (o *SCB_Type) SetSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.STIR.Reg, volatile.LoadUint32(&o.STIR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.STIR.Reg) & 0x1ff
}

// System timer
type SysTick_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// SysTick.CSR: Control and Status Register
func (o *SysTick_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *SysTick_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *SysTick_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *SysTick_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *SysTick_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *SysTick_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *SysTick_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *SysTick_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// SysTick.RVR: Reload Value Register
func (o *SysTick_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// SysTick.CVR: Current Value Register
func (o *SysTick_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// SysTick.CALIB: Calibration Value Register
func (o *SysTick_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *SysTick_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *SysTick_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *SysTick_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *SysTick_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER [8]volatile.Register32 // 0x0
	_    [96]byte
	ICER [8]volatile.Register32 // 0x80
	_    [96]byte
	ISPR [8]volatile.Register32 // 0x100
	_    [96]byte
	ICPR [8]volatile.Register32 // 0x180
	_    [96]byte
	IABR [8]volatile.Register32 // 0x200
	_    [224]byte
	IP   [240]volatile.Register8 // 0x300
	_    [2576]byte
	STIR volatile.Register32 // 0xE00
}

// NVIC.ISER: Interrupt Set Enable Register n
func (o *NVIC_Type) SetISER(idx int, value uint32) {
	volatile.StoreUint32(&o.ISER[idx].Reg, value)
}
func (o *NVIC_Type) GetISER(idx int) uint32 {
	return volatile.LoadUint32(&o.ISER[idx].Reg)
}

// NVIC.ICER: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetICER(idx int, value uint32) {
	volatile.StoreUint32(&o.ICER[idx].Reg, value)
}
func (o *NVIC_Type) GetICER(idx int) uint32 {
	return volatile.LoadUint32(&o.ICER[idx].Reg)
}

// NVIC.ISPR: Interrupt Set Pending Register n
func (o *NVIC_Type) SetISPR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISPR[idx].Reg, value)
}
func (o *NVIC_Type) GetISPR(idx int) uint32 {
	return volatile.LoadUint32(&o.ISPR[idx].Reg)
}

// NVIC.ICPR: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetICPR(idx int, value uint32) {
	volatile.StoreUint32(&o.ICPR[idx].Reg, value)
}
func (o *NVIC_Type) GetICPR(idx int) uint32 {
	return volatile.LoadUint32(&o.ICPR[idx].Reg)
}

// NVIC.IABR: Interrupt Active bit Register n
func (o *NVIC_Type) SetIABR(idx int, value uint32) {
	volatile.StoreUint32(&o.IABR[idx].Reg, value)
}
func (o *NVIC_Type) GetIABR(idx int) uint32 {
	return volatile.LoadUint32(&o.IABR[idx].Reg)
}

// NVIC.IP: Interrupt Priority Register (8Bit wide) n
func (o *NVIC_Type) SetIP(idx int, value uint8) {
	volatile.StoreUint8(&o.IP[idx].Reg, value)
}
func (o *NVIC_Type) GetIP(idx int) uint8 {
	return volatile.LoadUint8(&o.IP[idx].Reg)
}

// NVIC.STIR: Software Trigger Interrupt Register
func (o *NVIC_Type) SetSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.STIR.Reg, volatile.LoadUint32(&o.STIR.Reg)&^(0x1ff)|value)
}
func (o *NVIC_Type) GetSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.STIR.Reg) & 0x1ff
}

// Memory Protection Unit
type MPU_Type struct {
	TYPE    volatile.Register32 // 0x0
	CTRL    volatile.Register32 // 0x4
	RNR     volatile.Register32 // 0x8
	RBAR    volatile.Register32 // 0xC
	RASR    volatile.Register32 // 0x10
	RBAR_A1 volatile.Register32 // 0x14
	RASR_A1 volatile.Register32 // 0x18
	RBAR_A2 volatile.Register32 // 0x1C
	RASR_A2 volatile.Register32 // 0x20
	RBAR_A3 volatile.Register32 // 0x24
	RASR_A3 volatile.Register32 // 0x28
}

// MPU.TYPE: MPU Type Register
func (o *MPU_Type) SetTYPE_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPE_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPE.Reg) & 0x1
}
func (o *MPU_Type) SetTYPE_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPE_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPE_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPE_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU Control Register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU Region Number Register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU Region Base Address Register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU Region Attribute and Size Register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// Floating Point Unit
type FPU_Type struct {
	_      [4]byte
	FPCCR  volatile.Register32 // 0x4
	FPCAR  volatile.Register32 // 0x8
	FPDSCR volatile.Register32 // 0xC
	MVFR0  volatile.Register32 // 0x10
	MVFR1  volatile.Register32 // 0x14
	MVFR2  volatile.Register32 // 0x18
}

// FPU.FPCCR: Floating-point Context Control Register
func (o *FPU_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *FPU_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *FPU_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *FPU_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *FPU_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *FPU_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// FPU.FPCAR: Floating-point Context Address Register
func (o *FPU_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FPU_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// FPU.FPDSCR: Floating-point Default Status Control Register
func (o *FPU_Type) SetFPDSCR_RMode(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *FPU_Type) GetFPDSCR_RMode() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0xc00000) >> 22
}
func (o *FPU_Type) SetFPDSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *FPU_Type) GetFPDSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x1000000) >> 24
}
func (o *FPU_Type) SetFPDSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *FPU_Type) GetFPDSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x2000000) >> 25
}
func (o *FPU_Type) SetFPDSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *FPU_Type) GetFPDSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x4000000) >> 26
}

// FPU.MVFR0: Media and VFP Feature Register 0
func (o *FPU_Type) SetMVFR0_A_SIMD_registers(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf)|value)
}
func (o *FPU_Type) GetMVFR0_A_SIMD_registers() uint32 {
	return volatile.LoadUint32(&o.MVFR0.Reg) & 0xf
}
func (o *FPU_Type) SetMVFR0_Single_precision(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0)|value<<4)
}
func (o *FPU_Type) GetMVFR0_Single_precision() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0) >> 4
}
func (o *FPU_Type) SetMVFR0_Double_precision(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf00)|value<<8)
}
func (o *FPU_Type) GetMVFR0_Double_precision() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf00) >> 8
}
func (o *FPU_Type) SetMVFR0_FP_excep_trapping(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf000)|value<<12)
}
func (o *FPU_Type) GetMVFR0_FP_excep_trapping() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf000) >> 12
}
func (o *FPU_Type) SetMVFR0_Divide(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FPU_Type) GetMVFR0_Divide() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0000) >> 16
}
func (o *FPU_Type) SetMVFR0_Square_root(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf00000)|value<<20)
}
func (o *FPU_Type) GetMVFR0_Square_root() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf00000) >> 20
}
func (o *FPU_Type) SetMVFR0_Short_vectors(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf000000)|value<<24)
}
func (o *FPU_Type) GetMVFR0_Short_vectors() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf000000) >> 24
}
func (o *FPU_Type) SetMVFR0_FP_rounding_modes(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *FPU_Type) GetMVFR0_FP_rounding_modes() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0000000) >> 28
}

// FPU.MVFR1: Media and VFP Feature Register 1
func (o *FPU_Type) SetMVFR1_FtZ_mode(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf)|value)
}
func (o *FPU_Type) GetMVFR1_FtZ_mode() uint32 {
	return volatile.LoadUint32(&o.MVFR1.Reg) & 0xf
}
func (o *FPU_Type) SetMVFR1_D_NaN_mode(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf0)|value<<4)
}
func (o *FPU_Type) GetMVFR1_D_NaN_mode() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf0) >> 4
}
func (o *FPU_Type) SetMVFR1_FP_HPFP(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FPU_Type) GetMVFR1_FP_HPFP() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf000000) >> 24
}
func (o *FPU_Type) SetMVFR1_FP_fused_MAC(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *FPU_Type) GetMVFR1_FP_fused_MAC() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf0000000) >> 28
}

// FPU.MVFR2: Media and VFP Feature Register 2
func (o *FPU_Type) SetMVFR2_VFP_Misc(value uint32) {
	volatile.StoreUint32(&o.MVFR2.Reg, volatile.LoadUint32(&o.MVFR2.Reg)&^(0xf0)|value<<4)
}
func (o *FPU_Type) GetMVFR2_VFP_Misc() uint32 {
	return (volatile.LoadUint32(&o.MVFR2.Reg) & 0xf0) >> 4
}

// Constants for ACC: Analog Comparator Controller
const (
	// CR: Control Register
	// Position of SWRST field.
	ACC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	ACC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	ACC_CR_SWRST = 0x1

	// MR: Mode Register
	// Position of SELMINUS field.
	ACC_MR_SELMINUS_Pos = 0x0
	// Bit mask of SELMINUS field.
	ACC_MR_SELMINUS_Msk = 0x7
	// Select TS
	ACC_MR_SELMINUS_TS = 0x0
	// Select VREFP
	ACC_MR_SELMINUS_VREFP = 0x1
	// Select DAC0
	ACC_MR_SELMINUS_DAC0 = 0x2
	// Select DAC1
	ACC_MR_SELMINUS_DAC1 = 0x3
	// Select AFE0_AD0
	ACC_MR_SELMINUS_AFE0_AD0 = 0x4
	// Select AFE0_AD1
	ACC_MR_SELMINUS_AFE0_AD1 = 0x5
	// Select AFE0_AD2
	ACC_MR_SELMINUS_AFE0_AD2 = 0x6
	// Select AFE0_AD3
	ACC_MR_SELMINUS_AFE0_AD3 = 0x7
	// Position of SELPLUS field.
	ACC_MR_SELPLUS_Pos = 0x4
	// Bit mask of SELPLUS field.
	ACC_MR_SELPLUS_Msk = 0x70
	// Select AFE0_AD0
	ACC_MR_SELPLUS_AFE0_AD0 = 0x0
	// Select AFE0_AD1
	ACC_MR_SELPLUS_AFE0_AD1 = 0x1
	// Select AFE0_AD2
	ACC_MR_SELPLUS_AFE0_AD2 = 0x2
	// Select AFE0_AD3
	ACC_MR_SELPLUS_AFE0_AD3 = 0x3
	// Select AFE0_AD4
	ACC_MR_SELPLUS_AFE0_AD4 = 0x4
	// Select AFE0_AD5
	ACC_MR_SELPLUS_AFE0_AD5 = 0x5
	// Select AFE1_AD0
	ACC_MR_SELPLUS_AFE1_AD0 = 0x6
	// Select AFE1_AD1
	ACC_MR_SELPLUS_AFE1_AD1 = 0x7
	// Position of ACEN field.
	ACC_MR_ACEN_Pos = 0x8
	// Bit mask of ACEN field.
	ACC_MR_ACEN_Msk = 0x100
	// Bit ACEN.
	ACC_MR_ACEN = 0x100
	// Analog comparator disabled.
	ACC_MR_ACEN_DIS = 0x0
	// Analog comparator enabled.
	ACC_MR_ACEN_EN = 0x1
	// Position of EDGETYP field.
	ACC_MR_EDGETYP_Pos = 0x9
	// Bit mask of EDGETYP field.
	ACC_MR_EDGETYP_Msk = 0x600
	// Only rising edge of comparator output
	ACC_MR_EDGETYP_RISING = 0x0
	// Falling edge of comparator output
	ACC_MR_EDGETYP_FALLING = 0x1
	// Any edge of comparator output
	ACC_MR_EDGETYP_ANY = 0x2
	// Position of INV field.
	ACC_MR_INV_Pos = 0xc
	// Bit mask of INV field.
	ACC_MR_INV_Msk = 0x1000
	// Bit INV.
	ACC_MR_INV = 0x1000
	// Analog comparator output is directly processed.
	ACC_MR_INV_DIS = 0x0
	// Analog comparator output is inverted prior to being processed.
	ACC_MR_INV_EN = 0x1
	// Position of SELFS field.
	ACC_MR_SELFS_Pos = 0xd
	// Bit mask of SELFS field.
	ACC_MR_SELFS_Msk = 0x2000
	// Bit SELFS.
	ACC_MR_SELFS = 0x2000
	// The CE flag is used to drive the FAULT output.
	ACC_MR_SELFS_CE = 0x0
	// The output of the analog comparator flag is used to drive the FAULT output.
	ACC_MR_SELFS_OUTPUT = 0x1
	// Position of FE field.
	ACC_MR_FE_Pos = 0xe
	// Bit mask of FE field.
	ACC_MR_FE_Msk = 0x4000
	// Bit FE.
	ACC_MR_FE = 0x4000
	// The FAULT output is tied to 0.
	ACC_MR_FE_DIS = 0x0
	// The FAULT output is driven by the signal defined by SELFS.
	ACC_MR_FE_EN = 0x1

	// IER: Interrupt Enable Register
	// Position of CE field.
	ACC_IER_CE_Pos = 0x0
	// Bit mask of CE field.
	ACC_IER_CE_Msk = 0x1
	// Bit CE.
	ACC_IER_CE = 0x1

	// IDR: Interrupt Disable Register
	// Position of CE field.
	ACC_IDR_CE_Pos = 0x0
	// Bit mask of CE field.
	ACC_IDR_CE_Msk = 0x1
	// Bit CE.
	ACC_IDR_CE = 0x1

	// IMR: Interrupt Mask Register
	// Position of CE field.
	ACC_IMR_CE_Pos = 0x0
	// Bit mask of CE field.
	ACC_IMR_CE_Msk = 0x1
	// Bit CE.
	ACC_IMR_CE = 0x1

	// ISR: Interrupt Status Register
	// Position of CE field.
	ACC_ISR_CE_Pos = 0x0
	// Bit mask of CE field.
	ACC_ISR_CE_Msk = 0x1
	// Bit CE.
	ACC_ISR_CE = 0x1
	// Position of SCO field.
	ACC_ISR_SCO_Pos = 0x1
	// Bit mask of SCO field.
	ACC_ISR_SCO_Msk = 0x2
	// Bit SCO.
	ACC_ISR_SCO = 0x2
	// Position of MASK field.
	ACC_ISR_MASK_Pos = 0x1f
	// Bit mask of MASK field.
	ACC_ISR_MASK_Msk = 0x80000000
	// Bit MASK.
	ACC_ISR_MASK = 0x80000000

	// ACR: Analog Control Register
	// Position of ISEL field.
	ACC_ACR_ISEL_Pos = 0x0
	// Bit mask of ISEL field.
	ACC_ACR_ISEL_Msk = 0x1
	// Bit ISEL.
	ACC_ACR_ISEL = 0x1
	// Low-power option.
	ACC_ACR_ISEL_LOPW = 0x0
	// High-speed option.
	ACC_ACR_ISEL_HISP = 0x1
	// Position of HYST field.
	ACC_ACR_HYST_Pos = 0x1
	// Bit mask of HYST field.
	ACC_ACR_HYST_Msk = 0x6

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	ACC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	ACC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	ACC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	ACC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	ACC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0.
	ACC_WPMR_WPKEY_PASSWD = 0x414343

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	ACC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	ACC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	ACC_WPSR_WPVS = 0x1
)

// Constants for AES: Advanced Encryption Standard
const (
	// CR: Control Register
	// Position of START field.
	AES_CR_START_Pos = 0x0
	// Bit mask of START field.
	AES_CR_START_Msk = 0x1
	// Bit START.
	AES_CR_START = 0x1
	// Position of SWRST field.
	AES_CR_SWRST_Pos = 0x8
	// Bit mask of SWRST field.
	AES_CR_SWRST_Msk = 0x100
	// Bit SWRST.
	AES_CR_SWRST = 0x100

	// MR: Mode Register
	// Position of CIPHER field.
	AES_MR_CIPHER_Pos = 0x0
	// Bit mask of CIPHER field.
	AES_MR_CIPHER_Msk = 0x1
	// Bit CIPHER.
	AES_MR_CIPHER = 0x1
	// Position of GTAGEN field.
	AES_MR_GTAGEN_Pos = 0x1
	// Bit mask of GTAGEN field.
	AES_MR_GTAGEN_Msk = 0x2
	// Bit GTAGEN.
	AES_MR_GTAGEN = 0x2
	// Position of DUALBUFF field.
	AES_MR_DUALBUFF_Pos = 0x3
	// Bit mask of DUALBUFF field.
	AES_MR_DUALBUFF_Msk = 0x8
	// Bit DUALBUFF.
	AES_MR_DUALBUFF = 0x8
	// AES_IDATARx cannot be written during processing of previous block.
	AES_MR_DUALBUFF_INACTIVE = 0x0
	// AES_IDATARx can be written during processing of previous block when SMOD = 2. It speeds up the overall runtime of large files.
	AES_MR_DUALBUFF_ACTIVE = 0x1
	// Position of PROCDLY field.
	AES_MR_PROCDLY_Pos = 0x4
	// Bit mask of PROCDLY field.
	AES_MR_PROCDLY_Msk = 0xf0
	// Position of SMOD field.
	AES_MR_SMOD_Pos = 0x8
	// Bit mask of SMOD field.
	AES_MR_SMOD_Msk = 0x300
	// Manual Mode
	AES_MR_SMOD_MANUAL_START = 0x0
	// Auto Mode
	AES_MR_SMOD_AUTO_START = 0x1
	// AES_IDATAR0 access only Auto Mode (DMA)
	AES_MR_SMOD_IDATAR0_START = 0x2
	// Position of KEYSIZE field.
	AES_MR_KEYSIZE_Pos = 0xa
	// Bit mask of KEYSIZE field.
	AES_MR_KEYSIZE_Msk = 0xc00
	// AES Key Size is 128 bits
	AES_MR_KEYSIZE_AES128 = 0x0
	// AES Key Size is 192 bits
	AES_MR_KEYSIZE_AES192 = 0x1
	// AES Key Size is 256 bits
	AES_MR_KEYSIZE_AES256 = 0x2
	// Position of OPMOD field.
	AES_MR_OPMOD_Pos = 0xc
	// Bit mask of OPMOD field.
	AES_MR_OPMOD_Msk = 0x7000
	// ECB: Electronic Code Book mode
	AES_MR_OPMOD_ECB = 0x0
	// CBC: Cipher Block Chaining mode
	AES_MR_OPMOD_CBC = 0x1
	// OFB: Output Feedback mode
	AES_MR_OPMOD_OFB = 0x2
	// CFB: Cipher Feedback mode
	AES_MR_OPMOD_CFB = 0x3
	// CTR: Counter mode (16-bit internal counter)
	AES_MR_OPMOD_CTR = 0x4
	// GCM: Galois/Counter mode
	AES_MR_OPMOD_GCM = 0x5
	// Position of LOD field.
	AES_MR_LOD_Pos = 0xf
	// Bit mask of LOD field.
	AES_MR_LOD_Msk = 0x8000
	// Bit LOD.
	AES_MR_LOD = 0x8000
	// Position of CFBS field.
	AES_MR_CFBS_Pos = 0x10
	// Bit mask of CFBS field.
	AES_MR_CFBS_Msk = 0x70000
	// 128-bit
	AES_MR_CFBS_SIZE_128BIT = 0x0
	// 64-bit
	AES_MR_CFBS_SIZE_64BIT = 0x1
	// 32-bit
	AES_MR_CFBS_SIZE_32BIT = 0x2
	// 16-bit
	AES_MR_CFBS_SIZE_16BIT = 0x3
	// 8-bit
	AES_MR_CFBS_SIZE_8BIT = 0x4
	// Position of CKEY field.
	AES_MR_CKEY_Pos = 0x14
	// Bit mask of CKEY field.
	AES_MR_CKEY_Msk = 0xf00000
	// This field must be written with 0xE to allow CMTYPx bit configuration changes. Any other values will abort the write operation in CMTYPx bits.Always reads as 0.
	AES_MR_CKEY_PASSWD = 0xe

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	AES_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IER_DATRDY = 0x1
	// Position of URAD field.
	AES_IER_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IER_URAD_Msk = 0x100
	// Bit URAD.
	AES_IER_URAD = 0x100
	// Position of TAGRDY field.
	AES_IER_TAGRDY_Pos = 0x10
	// Bit mask of TAGRDY field.
	AES_IER_TAGRDY_Msk = 0x10000
	// Bit TAGRDY.
	AES_IER_TAGRDY = 0x10000

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	AES_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IDR_DATRDY = 0x1
	// Position of URAD field.
	AES_IDR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IDR_URAD_Msk = 0x100
	// Bit URAD.
	AES_IDR_URAD = 0x100
	// Position of TAGRDY field.
	AES_IDR_TAGRDY_Pos = 0x10
	// Bit mask of TAGRDY field.
	AES_IDR_TAGRDY_Msk = 0x10000
	// Bit TAGRDY.
	AES_IDR_TAGRDY = 0x10000

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	AES_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IMR_DATRDY = 0x1
	// Position of URAD field.
	AES_IMR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IMR_URAD_Msk = 0x100
	// Bit URAD.
	AES_IMR_URAD = 0x100
	// Position of TAGRDY field.
	AES_IMR_TAGRDY_Pos = 0x10
	// Bit mask of TAGRDY field.
	AES_IMR_TAGRDY_Msk = 0x10000
	// Bit TAGRDY.
	AES_IMR_TAGRDY = 0x10000

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	AES_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_ISR_DATRDY = 0x1
	// Position of URAD field.
	AES_ISR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_ISR_URAD_Msk = 0x100
	// Bit URAD.
	AES_ISR_URAD = 0x100
	// Position of URAT field.
	AES_ISR_URAT_Pos = 0xc
	// Bit mask of URAT field.
	AES_ISR_URAT_Msk = 0xf000
	// Input Data Register written during the data processing when SMOD = 0x2 mode.
	AES_ISR_URAT_IDR_WR_PROCESSING = 0x0
	// Output Data Register read during the data processing.
	AES_ISR_URAT_ODR_RD_PROCESSING = 0x1
	// Mode Register written during the data processing.
	AES_ISR_URAT_MR_WR_PROCESSING = 0x2
	// Output Data Register read during the sub-keys generation.
	AES_ISR_URAT_ODR_RD_SUBKGEN = 0x3
	// Mode Register written during the sub-keys generation.
	AES_ISR_URAT_MR_WR_SUBKGEN = 0x4
	// Write-only register read access.
	AES_ISR_URAT_WOR_RD_ACCESS = 0x5
	// Position of TAGRDY field.
	AES_ISR_TAGRDY_Pos = 0x10
	// Bit mask of TAGRDY field.
	AES_ISR_TAGRDY_Msk = 0x10000
	// Bit TAGRDY.
	AES_ISR_TAGRDY = 0x10000

	// KEYWR: Key Word Register 0
	// Position of KEYW field.
	AES_KEYWR_KEYW_Pos = 0x0
	// Bit mask of KEYW field.
	AES_KEYWR_KEYW_Msk = 0xffffffff

	// IDATAR: Input Data Register 0
	// Position of IDATA field.
	AES_IDATAR_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	AES_IDATAR_IDATA_Msk = 0xffffffff

	// ODATAR: Output Data Register 0
	// Position of ODATA field.
	AES_ODATAR_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	AES_ODATAR_ODATA_Msk = 0xffffffff

	// IVR: Initialization Vector Register 0
	// Position of IV field.
	AES_IVR_IV_Pos = 0x0
	// Bit mask of IV field.
	AES_IVR_IV_Msk = 0xffffffff

	// AADLENR: Additional Authenticated Data Length Register
	// Position of AADLEN field.
	AES_AADLENR_AADLEN_Pos = 0x0
	// Bit mask of AADLEN field.
	AES_AADLENR_AADLEN_Msk = 0xffffffff

	// CLENR: Plaintext/Ciphertext Length Register
	// Position of CLEN field.
	AES_CLENR_CLEN_Pos = 0x0
	// Bit mask of CLEN field.
	AES_CLENR_CLEN_Msk = 0xffffffff

	// GHASHR: GCM Intermediate Hash Word Register 0
	// Position of GHASH field.
	AES_GHASHR_GHASH_Pos = 0x0
	// Bit mask of GHASH field.
	AES_GHASHR_GHASH_Msk = 0xffffffff

	// TAGR: GCM Authentication Tag Word Register 0
	// Position of TAG field.
	AES_TAGR_TAG_Pos = 0x0
	// Bit mask of TAG field.
	AES_TAGR_TAG_Msk = 0xffffffff

	// CTRR: GCM Encryption Counter Value Register
	// Position of CTR field.
	AES_CTRR_CTR_Pos = 0x0
	// Bit mask of CTR field.
	AES_CTRR_CTR_Msk = 0xffffffff

	// GCMHR: GCM H Word Register 0
	// Position of H field.
	AES_GCMHR_H_Pos = 0x0
	// Bit mask of H field.
	AES_GCMHR_H_Msk = 0xffffffff
)

// Constants for AFEC0: Analog Front-End Controller
const (
	// CR: AFEC Control Register
	// Position of SWRST field.
	AFEC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	AFEC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	AFEC_CR_SWRST = 0x1
	// Position of START field.
	AFEC_CR_START_Pos = 0x1
	// Bit mask of START field.
	AFEC_CR_START_Msk = 0x2
	// Bit START.
	AFEC_CR_START = 0x2

	// MR: AFEC Mode Register
	// Position of TRGEN field.
	AFEC_MR_TRGEN_Pos = 0x0
	// Bit mask of TRGEN field.
	AFEC_MR_TRGEN_Msk = 0x1
	// Bit TRGEN.
	AFEC_MR_TRGEN = 0x1
	// Hardware triggers are disabled. Starting a conversion is only possible by software.
	AFEC_MR_TRGEN_DIS = 0x0
	// Hardware trigger selected by TRGSEL field is enabled.
	AFEC_MR_TRGEN_EN = 0x1
	// Position of TRGSEL field.
	AFEC_MR_TRGSEL_Pos = 0x1
	// Bit mask of TRGSEL field.
	AFEC_MR_TRGSEL_Msk = 0xe
	// AFE0_ADTRG for AFEC0 / AFE1_ADTRG for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG0 = 0x0
	// TIOA Output of the Timer Counter Channel 0 for AFEC0/TIOA Output of the Timer Counter Channel 3 for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG1 = 0x1
	// TIOA Output of the Timer Counter Channel 1 for AFEC0/TIOA Output of the Timer Counter Channel 4 for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG2 = 0x2
	// TIOA Output of the Timer Counter Channel 2 for AFEC0/TIOA Output of the Timer Counter Channel 5 for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG3 = 0x3
	// PWM0 event line 0 for AFEC0 / PWM1 event line 0 for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG4 = 0x4
	// PWM0 event line 1 for AFEC0 / PWM1 event line 1 for AFEC1
	AFEC_MR_TRGSEL_AFEC_TRIG5 = 0x5
	// Analog Comparator
	AFEC_MR_TRGSEL_AFEC_TRIG6 = 0x6
	// Position of SLEEP field.
	AFEC_MR_SLEEP_Pos = 0x5
	// Bit mask of SLEEP field.
	AFEC_MR_SLEEP_Msk = 0x20
	// Bit SLEEP.
	AFEC_MR_SLEEP = 0x20
	// Normal mode: The AFE and reference voltage circuitry are kept ON between conversions.
	AFEC_MR_SLEEP_NORMAL = 0x0
	// Sleep mode: The AFE and reference voltage circuitry are OFF between conversions.
	AFEC_MR_SLEEP_SLEEP = 0x1
	// Position of FWUP field.
	AFEC_MR_FWUP_Pos = 0x6
	// Bit mask of FWUP field.
	AFEC_MR_FWUP_Msk = 0x40
	// Bit FWUP.
	AFEC_MR_FWUP = 0x40
	// Normal Sleep mode: The sleep mode is defined by the SLEEP bit.
	AFEC_MR_FWUP_OFF = 0x0
	// Fast wake-up Sleep mode: The voltage reference is ON between conversions and AFE is OFF.
	AFEC_MR_FWUP_ON = 0x1
	// Position of FREERUN field.
	AFEC_MR_FREERUN_Pos = 0x7
	// Bit mask of FREERUN field.
	AFEC_MR_FREERUN_Msk = 0x80
	// Bit FREERUN.
	AFEC_MR_FREERUN = 0x80
	// Normal mode
	AFEC_MR_FREERUN_OFF = 0x0
	// Free Run mode: Never wait for any trigger.
	AFEC_MR_FREERUN_ON = 0x1
	// Position of PRESCAL field.
	AFEC_MR_PRESCAL_Pos = 0x8
	// Bit mask of PRESCAL field.
	AFEC_MR_PRESCAL_Msk = 0xff00
	// Position of STARTUP field.
	AFEC_MR_STARTUP_Pos = 0x10
	// Bit mask of STARTUP field.
	AFEC_MR_STARTUP_Msk = 0xf0000
	// 0 periods of AFE clock
	AFEC_MR_STARTUP_SUT0 = 0x0
	// 8 periods of AFE clock
	AFEC_MR_STARTUP_SUT8 = 0x1
	// 16 periods of AFE clock
	AFEC_MR_STARTUP_SUT16 = 0x2
	// 24 periods of AFE clock
	AFEC_MR_STARTUP_SUT24 = 0x3
	// 64 periods of AFE clock
	AFEC_MR_STARTUP_SUT64 = 0x4
	// 80 periods of AFE clock
	AFEC_MR_STARTUP_SUT80 = 0x5
	// 96 periods of AFE clock
	AFEC_MR_STARTUP_SUT96 = 0x6
	// 112 periods of AFE clock
	AFEC_MR_STARTUP_SUT112 = 0x7
	// 512 periods of AFE clock
	AFEC_MR_STARTUP_SUT512 = 0x8
	// 576 periods of AFE clock
	AFEC_MR_STARTUP_SUT576 = 0x9
	// 640 periods of AFE clock
	AFEC_MR_STARTUP_SUT640 = 0xa
	// 704 periods of AFE clock
	AFEC_MR_STARTUP_SUT704 = 0xb
	// 768 periods of AFE clock
	AFEC_MR_STARTUP_SUT768 = 0xc
	// 832 periods of AFE clock
	AFEC_MR_STARTUP_SUT832 = 0xd
	// 896 periods of AFE clock
	AFEC_MR_STARTUP_SUT896 = 0xe
	// 960 periods of AFE clock
	AFEC_MR_STARTUP_SUT960 = 0xf
	// Position of ONE field.
	AFEC_MR_ONE_Pos = 0x17
	// Bit mask of ONE field.
	AFEC_MR_ONE_Msk = 0x800000
	// Bit ONE.
	AFEC_MR_ONE = 0x800000
	// Position of TRACKTIM field.
	AFEC_MR_TRACKTIM_Pos = 0x18
	// Bit mask of TRACKTIM field.
	AFEC_MR_TRACKTIM_Msk = 0xf000000
	// Position of TRANSFER field.
	AFEC_MR_TRANSFER_Pos = 0x1c
	// Bit mask of TRANSFER field.
	AFEC_MR_TRANSFER_Msk = 0x30000000
	// Position of USEQ field.
	AFEC_MR_USEQ_Pos = 0x1f
	// Bit mask of USEQ field.
	AFEC_MR_USEQ_Msk = 0x80000000
	// Bit USEQ.
	AFEC_MR_USEQ = 0x80000000
	// Normal mode: The controller converts channels in a simple numeric order.
	AFEC_MR_USEQ_NUM_ORDER = 0x0
	// User Sequence mode: The sequence respects what is defined in AFEC_SEQ1R and AFEC_SEQ1R.
	AFEC_MR_USEQ_REG_ORDER = 0x1

	// EMR: AFEC Extended Mode Register
	// Position of CMPMODE field.
	AFEC_EMR_CMPMODE_Pos = 0x0
	// Bit mask of CMPMODE field.
	AFEC_EMR_CMPMODE_Msk = 0x3
	// Generates an event when the converted data is lower than the low threshold of the window.
	AFEC_EMR_CMPMODE_LOW = 0x0
	// Generates an event when the converted data is higher than the high threshold of the window.
	AFEC_EMR_CMPMODE_HIGH = 0x1
	// Generates an event when the converted data is in the comparison window.
	AFEC_EMR_CMPMODE_IN = 0x2
	// Generates an event when the converted data is out of the comparison window.
	AFEC_EMR_CMPMODE_OUT = 0x3
	// Position of CMPSEL field.
	AFEC_EMR_CMPSEL_Pos = 0x3
	// Bit mask of CMPSEL field.
	AFEC_EMR_CMPSEL_Msk = 0xf8
	// Position of CMPALL field.
	AFEC_EMR_CMPALL_Pos = 0x9
	// Bit mask of CMPALL field.
	AFEC_EMR_CMPALL_Msk = 0x200
	// Bit CMPALL.
	AFEC_EMR_CMPALL = 0x200
	// Position of CMPFILTER field.
	AFEC_EMR_CMPFILTER_Pos = 0xc
	// Bit mask of CMPFILTER field.
	AFEC_EMR_CMPFILTER_Msk = 0x3000
	// Position of RES field.
	AFEC_EMR_RES_Pos = 0x10
	// Bit mask of RES field.
	AFEC_EMR_RES_Msk = 0x70000
	// 12-bit resolution, AFE sample rate is maximum (no averaging).
	AFEC_EMR_RES_NO_AVERAGE = 0x0
	// 13-bit resolution, AFE sample rate divided by 4 (averaging).
	AFEC_EMR_RES_OSR4 = 0x2
	// 14-bit resolution, AFE sample rate divided by 16 (averaging).
	AFEC_EMR_RES_OSR16 = 0x3
	// 15-bit resolution, AFE sample rate divided by 64 (averaging).
	AFEC_EMR_RES_OSR64 = 0x4
	// 16-bit resolution, AFE sample rate divided by 256 (averaging).
	AFEC_EMR_RES_OSR256 = 0x5
	// Position of TAG field.
	AFEC_EMR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	AFEC_EMR_TAG_Msk = 0x1000000
	// Bit TAG.
	AFEC_EMR_TAG = 0x1000000
	// Position of STM field.
	AFEC_EMR_STM_Pos = 0x19
	// Bit mask of STM field.
	AFEC_EMR_STM_Msk = 0x2000000
	// Bit STM.
	AFEC_EMR_STM = 0x2000000
	// Position of SIGNMODE field.
	AFEC_EMR_SIGNMODE_Pos = 0x1c
	// Bit mask of SIGNMODE field.
	AFEC_EMR_SIGNMODE_Msk = 0x30000000
	// Single-Ended channels: Unsigned conversions.Differential channels: Signed conversions.
	AFEC_EMR_SIGNMODE_SE_UNSG_DF_SIGN = 0x0
	// Single-Ended channels: Signed conversions.Differential channels: Unsigned conversions.
	AFEC_EMR_SIGNMODE_SE_SIGN_DF_UNSG = 0x1
	// All channels: Unsigned conversions.
	AFEC_EMR_SIGNMODE_ALL_UNSIGNED = 0x2
	// All channels: Signed conversions.
	AFEC_EMR_SIGNMODE_ALL_SIGNED = 0x3

	// SEQ1R: AFEC Channel Sequence 1 Register
	// Position of USCH0 field.
	AFEC_SEQ1R_USCH0_Pos = 0x0
	// Bit mask of USCH0 field.
	AFEC_SEQ1R_USCH0_Msk = 0xf
	// Position of USCH1 field.
	AFEC_SEQ1R_USCH1_Pos = 0x4
	// Bit mask of USCH1 field.
	AFEC_SEQ1R_USCH1_Msk = 0xf0
	// Position of USCH2 field.
	AFEC_SEQ1R_USCH2_Pos = 0x8
	// Bit mask of USCH2 field.
	AFEC_SEQ1R_USCH2_Msk = 0xf00
	// Position of USCH3 field.
	AFEC_SEQ1R_USCH3_Pos = 0xc
	// Bit mask of USCH3 field.
	AFEC_SEQ1R_USCH3_Msk = 0xf000
	// Position of USCH4 field.
	AFEC_SEQ1R_USCH4_Pos = 0x10
	// Bit mask of USCH4 field.
	AFEC_SEQ1R_USCH4_Msk = 0xf0000
	// Position of USCH5 field.
	AFEC_SEQ1R_USCH5_Pos = 0x14
	// Bit mask of USCH5 field.
	AFEC_SEQ1R_USCH5_Msk = 0xf00000
	// Position of USCH6 field.
	AFEC_SEQ1R_USCH6_Pos = 0x18
	// Bit mask of USCH6 field.
	AFEC_SEQ1R_USCH6_Msk = 0xf000000
	// Position of USCH7 field.
	AFEC_SEQ1R_USCH7_Pos = 0x1c
	// Bit mask of USCH7 field.
	AFEC_SEQ1R_USCH7_Msk = 0xf0000000

	// SEQ2R: AFEC Channel Sequence 2 Register
	// Position of USCH8 field.
	AFEC_SEQ2R_USCH8_Pos = 0x0
	// Bit mask of USCH8 field.
	AFEC_SEQ2R_USCH8_Msk = 0xf
	// Position of USCH9 field.
	AFEC_SEQ2R_USCH9_Pos = 0x4
	// Bit mask of USCH9 field.
	AFEC_SEQ2R_USCH9_Msk = 0xf0
	// Position of USCH10 field.
	AFEC_SEQ2R_USCH10_Pos = 0x8
	// Bit mask of USCH10 field.
	AFEC_SEQ2R_USCH10_Msk = 0xf00
	// Position of USCH11 field.
	AFEC_SEQ2R_USCH11_Pos = 0xc
	// Bit mask of USCH11 field.
	AFEC_SEQ2R_USCH11_Msk = 0xf000

	// CHER: AFEC Channel Enable Register
	// Position of CH0 field.
	AFEC_CHER_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	AFEC_CHER_CH0_Msk = 0x1
	// Bit CH0.
	AFEC_CHER_CH0 = 0x1
	// Position of CH1 field.
	AFEC_CHER_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	AFEC_CHER_CH1_Msk = 0x2
	// Bit CH1.
	AFEC_CHER_CH1 = 0x2
	// Position of CH2 field.
	AFEC_CHER_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	AFEC_CHER_CH2_Msk = 0x4
	// Bit CH2.
	AFEC_CHER_CH2 = 0x4
	// Position of CH3 field.
	AFEC_CHER_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	AFEC_CHER_CH3_Msk = 0x8
	// Bit CH3.
	AFEC_CHER_CH3 = 0x8
	// Position of CH4 field.
	AFEC_CHER_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	AFEC_CHER_CH4_Msk = 0x10
	// Bit CH4.
	AFEC_CHER_CH4 = 0x10
	// Position of CH5 field.
	AFEC_CHER_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	AFEC_CHER_CH5_Msk = 0x20
	// Bit CH5.
	AFEC_CHER_CH5 = 0x20
	// Position of CH6 field.
	AFEC_CHER_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	AFEC_CHER_CH6_Msk = 0x40
	// Bit CH6.
	AFEC_CHER_CH6 = 0x40
	// Position of CH7 field.
	AFEC_CHER_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	AFEC_CHER_CH7_Msk = 0x80
	// Bit CH7.
	AFEC_CHER_CH7 = 0x80
	// Position of CH8 field.
	AFEC_CHER_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	AFEC_CHER_CH8_Msk = 0x100
	// Bit CH8.
	AFEC_CHER_CH8 = 0x100
	// Position of CH9 field.
	AFEC_CHER_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	AFEC_CHER_CH9_Msk = 0x200
	// Bit CH9.
	AFEC_CHER_CH9 = 0x200
	// Position of CH10 field.
	AFEC_CHER_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	AFEC_CHER_CH10_Msk = 0x400
	// Bit CH10.
	AFEC_CHER_CH10 = 0x400
	// Position of CH11 field.
	AFEC_CHER_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	AFEC_CHER_CH11_Msk = 0x800
	// Bit CH11.
	AFEC_CHER_CH11 = 0x800

	// CHDR: AFEC Channel Disable Register
	// Position of CH0 field.
	AFEC_CHDR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	AFEC_CHDR_CH0_Msk = 0x1
	// Bit CH0.
	AFEC_CHDR_CH0 = 0x1
	// Position of CH1 field.
	AFEC_CHDR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	AFEC_CHDR_CH1_Msk = 0x2
	// Bit CH1.
	AFEC_CHDR_CH1 = 0x2
	// Position of CH2 field.
	AFEC_CHDR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	AFEC_CHDR_CH2_Msk = 0x4
	// Bit CH2.
	AFEC_CHDR_CH2 = 0x4
	// Position of CH3 field.
	AFEC_CHDR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	AFEC_CHDR_CH3_Msk = 0x8
	// Bit CH3.
	AFEC_CHDR_CH3 = 0x8
	// Position of CH4 field.
	AFEC_CHDR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	AFEC_CHDR_CH4_Msk = 0x10
	// Bit CH4.
	AFEC_CHDR_CH4 = 0x10
	// Position of CH5 field.
	AFEC_CHDR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	AFEC_CHDR_CH5_Msk = 0x20
	// Bit CH5.
	AFEC_CHDR_CH5 = 0x20
	// Position of CH6 field.
	AFEC_CHDR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	AFEC_CHDR_CH6_Msk = 0x40
	// Bit CH6.
	AFEC_CHDR_CH6 = 0x40
	// Position of CH7 field.
	AFEC_CHDR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	AFEC_CHDR_CH7_Msk = 0x80
	// Bit CH7.
	AFEC_CHDR_CH7 = 0x80
	// Position of CH8 field.
	AFEC_CHDR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	AFEC_CHDR_CH8_Msk = 0x100
	// Bit CH8.
	AFEC_CHDR_CH8 = 0x100
	// Position of CH9 field.
	AFEC_CHDR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	AFEC_CHDR_CH9_Msk = 0x200
	// Bit CH9.
	AFEC_CHDR_CH9 = 0x200
	// Position of CH10 field.
	AFEC_CHDR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	AFEC_CHDR_CH10_Msk = 0x400
	// Bit CH10.
	AFEC_CHDR_CH10 = 0x400
	// Position of CH11 field.
	AFEC_CHDR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	AFEC_CHDR_CH11_Msk = 0x800
	// Bit CH11.
	AFEC_CHDR_CH11 = 0x800

	// CHSR: AFEC Channel Status Register
	// Position of CH0 field.
	AFEC_CHSR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	AFEC_CHSR_CH0_Msk = 0x1
	// Bit CH0.
	AFEC_CHSR_CH0 = 0x1
	// Position of CH1 field.
	AFEC_CHSR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	AFEC_CHSR_CH1_Msk = 0x2
	// Bit CH1.
	AFEC_CHSR_CH1 = 0x2
	// Position of CH2 field.
	AFEC_CHSR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	AFEC_CHSR_CH2_Msk = 0x4
	// Bit CH2.
	AFEC_CHSR_CH2 = 0x4
	// Position of CH3 field.
	AFEC_CHSR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	AFEC_CHSR_CH3_Msk = 0x8
	// Bit CH3.
	AFEC_CHSR_CH3 = 0x8
	// Position of CH4 field.
	AFEC_CHSR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	AFEC_CHSR_CH4_Msk = 0x10
	// Bit CH4.
	AFEC_CHSR_CH4 = 0x10
	// Position of CH5 field.
	AFEC_CHSR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	AFEC_CHSR_CH5_Msk = 0x20
	// Bit CH5.
	AFEC_CHSR_CH5 = 0x20
	// Position of CH6 field.
	AFEC_CHSR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	AFEC_CHSR_CH6_Msk = 0x40
	// Bit CH6.
	AFEC_CHSR_CH6 = 0x40
	// Position of CH7 field.
	AFEC_CHSR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	AFEC_CHSR_CH7_Msk = 0x80
	// Bit CH7.
	AFEC_CHSR_CH7 = 0x80
	// Position of CH8 field.
	AFEC_CHSR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	AFEC_CHSR_CH8_Msk = 0x100
	// Bit CH8.
	AFEC_CHSR_CH8 = 0x100
	// Position of CH9 field.
	AFEC_CHSR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	AFEC_CHSR_CH9_Msk = 0x200
	// Bit CH9.
	AFEC_CHSR_CH9 = 0x200
	// Position of CH10 field.
	AFEC_CHSR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	AFEC_CHSR_CH10_Msk = 0x400
	// Bit CH10.
	AFEC_CHSR_CH10 = 0x400
	// Position of CH11 field.
	AFEC_CHSR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	AFEC_CHSR_CH11_Msk = 0x800
	// Bit CH11.
	AFEC_CHSR_CH11 = 0x800

	// LCDR: AFEC Last Converted Data Register
	// Position of LDATA field.
	AFEC_LCDR_LDATA_Pos = 0x0
	// Bit mask of LDATA field.
	AFEC_LCDR_LDATA_Msk = 0xffff
	// Position of CHNB field.
	AFEC_LCDR_CHNB_Pos = 0x18
	// Bit mask of CHNB field.
	AFEC_LCDR_CHNB_Msk = 0xf000000

	// IER: AFEC Interrupt Enable Register
	// Position of EOC0 field.
	AFEC_IER_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	AFEC_IER_EOC0_Msk = 0x1
	// Bit EOC0.
	AFEC_IER_EOC0 = 0x1
	// Position of EOC1 field.
	AFEC_IER_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	AFEC_IER_EOC1_Msk = 0x2
	// Bit EOC1.
	AFEC_IER_EOC1 = 0x2
	// Position of EOC2 field.
	AFEC_IER_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	AFEC_IER_EOC2_Msk = 0x4
	// Bit EOC2.
	AFEC_IER_EOC2 = 0x4
	// Position of EOC3 field.
	AFEC_IER_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	AFEC_IER_EOC3_Msk = 0x8
	// Bit EOC3.
	AFEC_IER_EOC3 = 0x8
	// Position of EOC4 field.
	AFEC_IER_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	AFEC_IER_EOC4_Msk = 0x10
	// Bit EOC4.
	AFEC_IER_EOC4 = 0x10
	// Position of EOC5 field.
	AFEC_IER_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	AFEC_IER_EOC5_Msk = 0x20
	// Bit EOC5.
	AFEC_IER_EOC5 = 0x20
	// Position of EOC6 field.
	AFEC_IER_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	AFEC_IER_EOC6_Msk = 0x40
	// Bit EOC6.
	AFEC_IER_EOC6 = 0x40
	// Position of EOC7 field.
	AFEC_IER_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	AFEC_IER_EOC7_Msk = 0x80
	// Bit EOC7.
	AFEC_IER_EOC7 = 0x80
	// Position of EOC8 field.
	AFEC_IER_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	AFEC_IER_EOC8_Msk = 0x100
	// Bit EOC8.
	AFEC_IER_EOC8 = 0x100
	// Position of EOC9 field.
	AFEC_IER_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	AFEC_IER_EOC9_Msk = 0x200
	// Bit EOC9.
	AFEC_IER_EOC9 = 0x200
	// Position of EOC10 field.
	AFEC_IER_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	AFEC_IER_EOC10_Msk = 0x400
	// Bit EOC10.
	AFEC_IER_EOC10 = 0x400
	// Position of EOC11 field.
	AFEC_IER_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	AFEC_IER_EOC11_Msk = 0x800
	// Bit EOC11.
	AFEC_IER_EOC11 = 0x800
	// Position of DRDY field.
	AFEC_IER_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	AFEC_IER_DRDY_Msk = 0x1000000
	// Bit DRDY.
	AFEC_IER_DRDY = 0x1000000
	// Position of GOVRE field.
	AFEC_IER_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	AFEC_IER_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	AFEC_IER_GOVRE = 0x2000000
	// Position of COMPE field.
	AFEC_IER_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	AFEC_IER_COMPE_Msk = 0x4000000
	// Bit COMPE.
	AFEC_IER_COMPE = 0x4000000
	// Position of TEMPCHG field.
	AFEC_IER_TEMPCHG_Pos = 0x1e
	// Bit mask of TEMPCHG field.
	AFEC_IER_TEMPCHG_Msk = 0x40000000
	// Bit TEMPCHG.
	AFEC_IER_TEMPCHG = 0x40000000

	// IDR: AFEC Interrupt Disable Register
	// Position of EOC0 field.
	AFEC_IDR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	AFEC_IDR_EOC0_Msk = 0x1
	// Bit EOC0.
	AFEC_IDR_EOC0 = 0x1
	// Position of EOC1 field.
	AFEC_IDR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	AFEC_IDR_EOC1_Msk = 0x2
	// Bit EOC1.
	AFEC_IDR_EOC1 = 0x2
	// Position of EOC2 field.
	AFEC_IDR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	AFEC_IDR_EOC2_Msk = 0x4
	// Bit EOC2.
	AFEC_IDR_EOC2 = 0x4
	// Position of EOC3 field.
	AFEC_IDR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	AFEC_IDR_EOC3_Msk = 0x8
	// Bit EOC3.
	AFEC_IDR_EOC3 = 0x8
	// Position of EOC4 field.
	AFEC_IDR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	AFEC_IDR_EOC4_Msk = 0x10
	// Bit EOC4.
	AFEC_IDR_EOC4 = 0x10
	// Position of EOC5 field.
	AFEC_IDR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	AFEC_IDR_EOC5_Msk = 0x20
	// Bit EOC5.
	AFEC_IDR_EOC5 = 0x20
	// Position of EOC6 field.
	AFEC_IDR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	AFEC_IDR_EOC6_Msk = 0x40
	// Bit EOC6.
	AFEC_IDR_EOC6 = 0x40
	// Position of EOC7 field.
	AFEC_IDR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	AFEC_IDR_EOC7_Msk = 0x80
	// Bit EOC7.
	AFEC_IDR_EOC7 = 0x80
	// Position of EOC8 field.
	AFEC_IDR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	AFEC_IDR_EOC8_Msk = 0x100
	// Bit EOC8.
	AFEC_IDR_EOC8 = 0x100
	// Position of EOC9 field.
	AFEC_IDR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	AFEC_IDR_EOC9_Msk = 0x200
	// Bit EOC9.
	AFEC_IDR_EOC9 = 0x200
	// Position of EOC10 field.
	AFEC_IDR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	AFEC_IDR_EOC10_Msk = 0x400
	// Bit EOC10.
	AFEC_IDR_EOC10 = 0x400
	// Position of EOC11 field.
	AFEC_IDR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	AFEC_IDR_EOC11_Msk = 0x800
	// Bit EOC11.
	AFEC_IDR_EOC11 = 0x800
	// Position of DRDY field.
	AFEC_IDR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	AFEC_IDR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	AFEC_IDR_DRDY = 0x1000000
	// Position of GOVRE field.
	AFEC_IDR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	AFEC_IDR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	AFEC_IDR_GOVRE = 0x2000000
	// Position of COMPE field.
	AFEC_IDR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	AFEC_IDR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	AFEC_IDR_COMPE = 0x4000000
	// Position of TEMPCHG field.
	AFEC_IDR_TEMPCHG_Pos = 0x1e
	// Bit mask of TEMPCHG field.
	AFEC_IDR_TEMPCHG_Msk = 0x40000000
	// Bit TEMPCHG.
	AFEC_IDR_TEMPCHG = 0x40000000

	// IMR: AFEC Interrupt Mask Register
	// Position of EOC0 field.
	AFEC_IMR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	AFEC_IMR_EOC0_Msk = 0x1
	// Bit EOC0.
	AFEC_IMR_EOC0 = 0x1
	// Position of EOC1 field.
	AFEC_IMR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	AFEC_IMR_EOC1_Msk = 0x2
	// Bit EOC1.
	AFEC_IMR_EOC1 = 0x2
	// Position of EOC2 field.
	AFEC_IMR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	AFEC_IMR_EOC2_Msk = 0x4
	// Bit EOC2.
	AFEC_IMR_EOC2 = 0x4
	// Position of EOC3 field.
	AFEC_IMR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	AFEC_IMR_EOC3_Msk = 0x8
	// Bit EOC3.
	AFEC_IMR_EOC3 = 0x8
	// Position of EOC4 field.
	AFEC_IMR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	AFEC_IMR_EOC4_Msk = 0x10
	// Bit EOC4.
	AFEC_IMR_EOC4 = 0x10
	// Position of EOC5 field.
	AFEC_IMR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	AFEC_IMR_EOC5_Msk = 0x20
	// Bit EOC5.
	AFEC_IMR_EOC5 = 0x20
	// Position of EOC6 field.
	AFEC_IMR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	AFEC_IMR_EOC6_Msk = 0x40
	// Bit EOC6.
	AFEC_IMR_EOC6 = 0x40
	// Position of EOC7 field.
	AFEC_IMR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	AFEC_IMR_EOC7_Msk = 0x80
	// Bit EOC7.
	AFEC_IMR_EOC7 = 0x80
	// Position of EOC8 field.
	AFEC_IMR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	AFEC_IMR_EOC8_Msk = 0x100
	// Bit EOC8.
	AFEC_IMR_EOC8 = 0x100
	// Position of EOC9 field.
	AFEC_IMR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	AFEC_IMR_EOC9_Msk = 0x200
	// Bit EOC9.
	AFEC_IMR_EOC9 = 0x200
	// Position of EOC10 field.
	AFEC_IMR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	AFEC_IMR_EOC10_Msk = 0x400
	// Bit EOC10.
	AFEC_IMR_EOC10 = 0x400
	// Position of EOC11 field.
	AFEC_IMR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	AFEC_IMR_EOC11_Msk = 0x800
	// Bit EOC11.
	AFEC_IMR_EOC11 = 0x800
	// Position of DRDY field.
	AFEC_IMR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	AFEC_IMR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	AFEC_IMR_DRDY = 0x1000000
	// Position of GOVRE field.
	AFEC_IMR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	AFEC_IMR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	AFEC_IMR_GOVRE = 0x2000000
	// Position of COMPE field.
	AFEC_IMR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	AFEC_IMR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	AFEC_IMR_COMPE = 0x4000000
	// Position of TEMPCHG field.
	AFEC_IMR_TEMPCHG_Pos = 0x1e
	// Bit mask of TEMPCHG field.
	AFEC_IMR_TEMPCHG_Msk = 0x40000000
	// Bit TEMPCHG.
	AFEC_IMR_TEMPCHG = 0x40000000

	// ISR: AFEC Interrupt Status Register
	// Position of EOC0 field.
	AFEC_ISR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	AFEC_ISR_EOC0_Msk = 0x1
	// Bit EOC0.
	AFEC_ISR_EOC0 = 0x1
	// Position of EOC1 field.
	AFEC_ISR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	AFEC_ISR_EOC1_Msk = 0x2
	// Bit EOC1.
	AFEC_ISR_EOC1 = 0x2
	// Position of EOC2 field.
	AFEC_ISR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	AFEC_ISR_EOC2_Msk = 0x4
	// Bit EOC2.
	AFEC_ISR_EOC2 = 0x4
	// Position of EOC3 field.
	AFEC_ISR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	AFEC_ISR_EOC3_Msk = 0x8
	// Bit EOC3.
	AFEC_ISR_EOC3 = 0x8
	// Position of EOC4 field.
	AFEC_ISR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	AFEC_ISR_EOC4_Msk = 0x10
	// Bit EOC4.
	AFEC_ISR_EOC4 = 0x10
	// Position of EOC5 field.
	AFEC_ISR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	AFEC_ISR_EOC5_Msk = 0x20
	// Bit EOC5.
	AFEC_ISR_EOC5 = 0x20
	// Position of EOC6 field.
	AFEC_ISR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	AFEC_ISR_EOC6_Msk = 0x40
	// Bit EOC6.
	AFEC_ISR_EOC6 = 0x40
	// Position of EOC7 field.
	AFEC_ISR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	AFEC_ISR_EOC7_Msk = 0x80
	// Bit EOC7.
	AFEC_ISR_EOC7 = 0x80
	// Position of EOC8 field.
	AFEC_ISR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	AFEC_ISR_EOC8_Msk = 0x100
	// Bit EOC8.
	AFEC_ISR_EOC8 = 0x100
	// Position of EOC9 field.
	AFEC_ISR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	AFEC_ISR_EOC9_Msk = 0x200
	// Bit EOC9.
	AFEC_ISR_EOC9 = 0x200
	// Position of EOC10 field.
	AFEC_ISR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	AFEC_ISR_EOC10_Msk = 0x400
	// Bit EOC10.
	AFEC_ISR_EOC10 = 0x400
	// Position of EOC11 field.
	AFEC_ISR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	AFEC_ISR_EOC11_Msk = 0x800
	// Bit EOC11.
	AFEC_ISR_EOC11 = 0x800
	// Position of DRDY field.
	AFEC_ISR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	AFEC_ISR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	AFEC_ISR_DRDY = 0x1000000
	// Position of GOVRE field.
	AFEC_ISR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	AFEC_ISR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	AFEC_ISR_GOVRE = 0x2000000
	// Position of COMPE field.
	AFEC_ISR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	AFEC_ISR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	AFEC_ISR_COMPE = 0x4000000
	// Position of TEMPCHG field.
	AFEC_ISR_TEMPCHG_Pos = 0x1e
	// Bit mask of TEMPCHG field.
	AFEC_ISR_TEMPCHG_Msk = 0x40000000
	// Bit TEMPCHG.
	AFEC_ISR_TEMPCHG = 0x40000000

	// OVER: AFEC Overrun Status Register
	// Position of OVRE0 field.
	AFEC_OVER_OVRE0_Pos = 0x0
	// Bit mask of OVRE0 field.
	AFEC_OVER_OVRE0_Msk = 0x1
	// Bit OVRE0.
	AFEC_OVER_OVRE0 = 0x1
	// Position of OVRE1 field.
	AFEC_OVER_OVRE1_Pos = 0x1
	// Bit mask of OVRE1 field.
	AFEC_OVER_OVRE1_Msk = 0x2
	// Bit OVRE1.
	AFEC_OVER_OVRE1 = 0x2
	// Position of OVRE2 field.
	AFEC_OVER_OVRE2_Pos = 0x2
	// Bit mask of OVRE2 field.
	AFEC_OVER_OVRE2_Msk = 0x4
	// Bit OVRE2.
	AFEC_OVER_OVRE2 = 0x4
	// Position of OVRE3 field.
	AFEC_OVER_OVRE3_Pos = 0x3
	// Bit mask of OVRE3 field.
	AFEC_OVER_OVRE3_Msk = 0x8
	// Bit OVRE3.
	AFEC_OVER_OVRE3 = 0x8
	// Position of OVRE4 field.
	AFEC_OVER_OVRE4_Pos = 0x4
	// Bit mask of OVRE4 field.
	AFEC_OVER_OVRE4_Msk = 0x10
	// Bit OVRE4.
	AFEC_OVER_OVRE4 = 0x10
	// Position of OVRE5 field.
	AFEC_OVER_OVRE5_Pos = 0x5
	// Bit mask of OVRE5 field.
	AFEC_OVER_OVRE5_Msk = 0x20
	// Bit OVRE5.
	AFEC_OVER_OVRE5 = 0x20
	// Position of OVRE6 field.
	AFEC_OVER_OVRE6_Pos = 0x6
	// Bit mask of OVRE6 field.
	AFEC_OVER_OVRE6_Msk = 0x40
	// Bit OVRE6.
	AFEC_OVER_OVRE6 = 0x40
	// Position of OVRE7 field.
	AFEC_OVER_OVRE7_Pos = 0x7
	// Bit mask of OVRE7 field.
	AFEC_OVER_OVRE7_Msk = 0x80
	// Bit OVRE7.
	AFEC_OVER_OVRE7 = 0x80
	// Position of OVRE8 field.
	AFEC_OVER_OVRE8_Pos = 0x8
	// Bit mask of OVRE8 field.
	AFEC_OVER_OVRE8_Msk = 0x100
	// Bit OVRE8.
	AFEC_OVER_OVRE8 = 0x100
	// Position of OVRE9 field.
	AFEC_OVER_OVRE9_Pos = 0x9
	// Bit mask of OVRE9 field.
	AFEC_OVER_OVRE9_Msk = 0x200
	// Bit OVRE9.
	AFEC_OVER_OVRE9 = 0x200
	// Position of OVRE10 field.
	AFEC_OVER_OVRE10_Pos = 0xa
	// Bit mask of OVRE10 field.
	AFEC_OVER_OVRE10_Msk = 0x400
	// Bit OVRE10.
	AFEC_OVER_OVRE10 = 0x400
	// Position of OVRE11 field.
	AFEC_OVER_OVRE11_Pos = 0xb
	// Bit mask of OVRE11 field.
	AFEC_OVER_OVRE11_Msk = 0x800
	// Bit OVRE11.
	AFEC_OVER_OVRE11 = 0x800

	// CWR: AFEC Compare Window Register
	// Position of LOWTHRES field.
	AFEC_CWR_LOWTHRES_Pos = 0x0
	// Bit mask of LOWTHRES field.
	AFEC_CWR_LOWTHRES_Msk = 0xffff
	// Position of HIGHTHRES field.
	AFEC_CWR_HIGHTHRES_Pos = 0x10
	// Bit mask of HIGHTHRES field.
	AFEC_CWR_HIGHTHRES_Msk = 0xffff0000

	// CGR: AFEC Channel Gain Register
	// Position of GAIN0 field.
	AFEC_CGR_GAIN0_Pos = 0x0
	// Bit mask of GAIN0 field.
	AFEC_CGR_GAIN0_Msk = 0x3
	// Position of GAIN1 field.
	AFEC_CGR_GAIN1_Pos = 0x2
	// Bit mask of GAIN1 field.
	AFEC_CGR_GAIN1_Msk = 0xc
	// Position of GAIN2 field.
	AFEC_CGR_GAIN2_Pos = 0x4
	// Bit mask of GAIN2 field.
	AFEC_CGR_GAIN2_Msk = 0x30
	// Position of GAIN3 field.
	AFEC_CGR_GAIN3_Pos = 0x6
	// Bit mask of GAIN3 field.
	AFEC_CGR_GAIN3_Msk = 0xc0
	// Position of GAIN4 field.
	AFEC_CGR_GAIN4_Pos = 0x8
	// Bit mask of GAIN4 field.
	AFEC_CGR_GAIN4_Msk = 0x300
	// Position of GAIN5 field.
	AFEC_CGR_GAIN5_Pos = 0xa
	// Bit mask of GAIN5 field.
	AFEC_CGR_GAIN5_Msk = 0xc00
	// Position of GAIN6 field.
	AFEC_CGR_GAIN6_Pos = 0xc
	// Bit mask of GAIN6 field.
	AFEC_CGR_GAIN6_Msk = 0x3000
	// Position of GAIN7 field.
	AFEC_CGR_GAIN7_Pos = 0xe
	// Bit mask of GAIN7 field.
	AFEC_CGR_GAIN7_Msk = 0xc000
	// Position of GAIN8 field.
	AFEC_CGR_GAIN8_Pos = 0x10
	// Bit mask of GAIN8 field.
	AFEC_CGR_GAIN8_Msk = 0x30000
	// Position of GAIN9 field.
	AFEC_CGR_GAIN9_Pos = 0x12
	// Bit mask of GAIN9 field.
	AFEC_CGR_GAIN9_Msk = 0xc0000
	// Position of GAIN10 field.
	AFEC_CGR_GAIN10_Pos = 0x14
	// Bit mask of GAIN10 field.
	AFEC_CGR_GAIN10_Msk = 0x300000
	// Position of GAIN11 field.
	AFEC_CGR_GAIN11_Pos = 0x16
	// Bit mask of GAIN11 field.
	AFEC_CGR_GAIN11_Msk = 0xc00000

	// DIFFR: AFEC Channel Differential Register
	// Position of DIFF0 field.
	AFEC_DIFFR_DIFF0_Pos = 0x0
	// Bit mask of DIFF0 field.
	AFEC_DIFFR_DIFF0_Msk = 0x1
	// Bit DIFF0.
	AFEC_DIFFR_DIFF0 = 0x1
	// Position of DIFF1 field.
	AFEC_DIFFR_DIFF1_Pos = 0x1
	// Bit mask of DIFF1 field.
	AFEC_DIFFR_DIFF1_Msk = 0x2
	// Bit DIFF1.
	AFEC_DIFFR_DIFF1 = 0x2
	// Position of DIFF2 field.
	AFEC_DIFFR_DIFF2_Pos = 0x2
	// Bit mask of DIFF2 field.
	AFEC_DIFFR_DIFF2_Msk = 0x4
	// Bit DIFF2.
	AFEC_DIFFR_DIFF2 = 0x4
	// Position of DIFF3 field.
	AFEC_DIFFR_DIFF3_Pos = 0x3
	// Bit mask of DIFF3 field.
	AFEC_DIFFR_DIFF3_Msk = 0x8
	// Bit DIFF3.
	AFEC_DIFFR_DIFF3 = 0x8
	// Position of DIFF4 field.
	AFEC_DIFFR_DIFF4_Pos = 0x4
	// Bit mask of DIFF4 field.
	AFEC_DIFFR_DIFF4_Msk = 0x10
	// Bit DIFF4.
	AFEC_DIFFR_DIFF4 = 0x10
	// Position of DIFF5 field.
	AFEC_DIFFR_DIFF5_Pos = 0x5
	// Bit mask of DIFF5 field.
	AFEC_DIFFR_DIFF5_Msk = 0x20
	// Bit DIFF5.
	AFEC_DIFFR_DIFF5 = 0x20
	// Position of DIFF6 field.
	AFEC_DIFFR_DIFF6_Pos = 0x6
	// Bit mask of DIFF6 field.
	AFEC_DIFFR_DIFF6_Msk = 0x40
	// Bit DIFF6.
	AFEC_DIFFR_DIFF6 = 0x40
	// Position of DIFF7 field.
	AFEC_DIFFR_DIFF7_Pos = 0x7
	// Bit mask of DIFF7 field.
	AFEC_DIFFR_DIFF7_Msk = 0x80
	// Bit DIFF7.
	AFEC_DIFFR_DIFF7 = 0x80
	// Position of DIFF8 field.
	AFEC_DIFFR_DIFF8_Pos = 0x8
	// Bit mask of DIFF8 field.
	AFEC_DIFFR_DIFF8_Msk = 0x100
	// Bit DIFF8.
	AFEC_DIFFR_DIFF8 = 0x100
	// Position of DIFF9 field.
	AFEC_DIFFR_DIFF9_Pos = 0x9
	// Bit mask of DIFF9 field.
	AFEC_DIFFR_DIFF9_Msk = 0x200
	// Bit DIFF9.
	AFEC_DIFFR_DIFF9 = 0x200
	// Position of DIFF10 field.
	AFEC_DIFFR_DIFF10_Pos = 0xa
	// Bit mask of DIFF10 field.
	AFEC_DIFFR_DIFF10_Msk = 0x400
	// Bit DIFF10.
	AFEC_DIFFR_DIFF10 = 0x400
	// Position of DIFF11 field.
	AFEC_DIFFR_DIFF11_Pos = 0xb
	// Bit mask of DIFF11 field.
	AFEC_DIFFR_DIFF11_Msk = 0x800
	// Bit DIFF11.
	AFEC_DIFFR_DIFF11 = 0x800

	// CSELR: AFEC Channel Selection Register
	// Position of CSEL field.
	AFEC_CSELR_CSEL_Pos = 0x0
	// Bit mask of CSEL field.
	AFEC_CSELR_CSEL_Msk = 0xf

	// CDR: AFEC Channel Data Register
	// Position of DATA field.
	AFEC_CDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	AFEC_CDR_DATA_Msk = 0xffff

	// COCR: AFEC Channel Offset Compensation Register
	// Position of AOFF field.
	AFEC_COCR_AOFF_Pos = 0x0
	// Bit mask of AOFF field.
	AFEC_COCR_AOFF_Msk = 0x3ff

	// TEMPMR: AFEC Temperature Sensor Mode Register
	// Position of RTCT field.
	AFEC_TEMPMR_RTCT_Pos = 0x0
	// Bit mask of RTCT field.
	AFEC_TEMPMR_RTCT_Msk = 0x1
	// Bit RTCT.
	AFEC_TEMPMR_RTCT = 0x1
	// Position of TEMPCMPMOD field.
	AFEC_TEMPMR_TEMPCMPMOD_Pos = 0x4
	// Bit mask of TEMPCMPMOD field.
	AFEC_TEMPMR_TEMPCMPMOD_Msk = 0x30
	// Generates an event when the converted data is lower than the low threshold of the window.
	AFEC_TEMPMR_TEMPCMPMOD_LOW = 0x0
	// Generates an event when the converted data is higher than the high threshold of the window.
	AFEC_TEMPMR_TEMPCMPMOD_HIGH = 0x1
	// Generates an event when the converted data is in the comparison window.
	AFEC_TEMPMR_TEMPCMPMOD_IN = 0x2
	// Generates an event when the converted data is out of the comparison window.
	AFEC_TEMPMR_TEMPCMPMOD_OUT = 0x3

	// TEMPCWR: AFEC Temperature Compare Window Register
	// Position of TLOWTHRES field.
	AFEC_TEMPCWR_TLOWTHRES_Pos = 0x0
	// Bit mask of TLOWTHRES field.
	AFEC_TEMPCWR_TLOWTHRES_Msk = 0xffff
	// Position of THIGHTHRES field.
	AFEC_TEMPCWR_THIGHTHRES_Pos = 0x10
	// Bit mask of THIGHTHRES field.
	AFEC_TEMPCWR_THIGHTHRES_Msk = 0xffff0000

	// ACR: AFEC Analog Control Register
	// Position of PGA0EN field.
	AFEC_ACR_PGA0EN_Pos = 0x2
	// Bit mask of PGA0EN field.
	AFEC_ACR_PGA0EN_Msk = 0x4
	// Bit PGA0EN.
	AFEC_ACR_PGA0EN = 0x4
	// Position of PGA1EN field.
	AFEC_ACR_PGA1EN_Pos = 0x3
	// Bit mask of PGA1EN field.
	AFEC_ACR_PGA1EN_Msk = 0x8
	// Bit PGA1EN.
	AFEC_ACR_PGA1EN = 0x8
	// Position of IBCTL field.
	AFEC_ACR_IBCTL_Pos = 0x8
	// Bit mask of IBCTL field.
	AFEC_ACR_IBCTL_Msk = 0x300

	// SHMR: AFEC Sample & Hold Mode Register
	// Position of DUAL0 field.
	AFEC_SHMR_DUAL0_Pos = 0x0
	// Bit mask of DUAL0 field.
	AFEC_SHMR_DUAL0_Msk = 0x1
	// Bit DUAL0.
	AFEC_SHMR_DUAL0 = 0x1
	// Position of DUAL1 field.
	AFEC_SHMR_DUAL1_Pos = 0x1
	// Bit mask of DUAL1 field.
	AFEC_SHMR_DUAL1_Msk = 0x2
	// Bit DUAL1.
	AFEC_SHMR_DUAL1 = 0x2
	// Position of DUAL2 field.
	AFEC_SHMR_DUAL2_Pos = 0x2
	// Bit mask of DUAL2 field.
	AFEC_SHMR_DUAL2_Msk = 0x4
	// Bit DUAL2.
	AFEC_SHMR_DUAL2 = 0x4
	// Position of DUAL3 field.
	AFEC_SHMR_DUAL3_Pos = 0x3
	// Bit mask of DUAL3 field.
	AFEC_SHMR_DUAL3_Msk = 0x8
	// Bit DUAL3.
	AFEC_SHMR_DUAL3 = 0x8
	// Position of DUAL4 field.
	AFEC_SHMR_DUAL4_Pos = 0x4
	// Bit mask of DUAL4 field.
	AFEC_SHMR_DUAL4_Msk = 0x10
	// Bit DUAL4.
	AFEC_SHMR_DUAL4 = 0x10
	// Position of DUAL5 field.
	AFEC_SHMR_DUAL5_Pos = 0x5
	// Bit mask of DUAL5 field.
	AFEC_SHMR_DUAL5_Msk = 0x20
	// Bit DUAL5.
	AFEC_SHMR_DUAL5 = 0x20
	// Position of DUAL6 field.
	AFEC_SHMR_DUAL6_Pos = 0x6
	// Bit mask of DUAL6 field.
	AFEC_SHMR_DUAL6_Msk = 0x40
	// Bit DUAL6.
	AFEC_SHMR_DUAL6 = 0x40
	// Position of DUAL7 field.
	AFEC_SHMR_DUAL7_Pos = 0x7
	// Bit mask of DUAL7 field.
	AFEC_SHMR_DUAL7_Msk = 0x80
	// Bit DUAL7.
	AFEC_SHMR_DUAL7 = 0x80
	// Position of DUAL8 field.
	AFEC_SHMR_DUAL8_Pos = 0x8
	// Bit mask of DUAL8 field.
	AFEC_SHMR_DUAL8_Msk = 0x100
	// Bit DUAL8.
	AFEC_SHMR_DUAL8 = 0x100
	// Position of DUAL9 field.
	AFEC_SHMR_DUAL9_Pos = 0x9
	// Bit mask of DUAL9 field.
	AFEC_SHMR_DUAL9_Msk = 0x200
	// Bit DUAL9.
	AFEC_SHMR_DUAL9 = 0x200
	// Position of DUAL10 field.
	AFEC_SHMR_DUAL10_Pos = 0xa
	// Bit mask of DUAL10 field.
	AFEC_SHMR_DUAL10_Msk = 0x400
	// Bit DUAL10.
	AFEC_SHMR_DUAL10 = 0x400
	// Position of DUAL11 field.
	AFEC_SHMR_DUAL11_Pos = 0xb
	// Bit mask of DUAL11 field.
	AFEC_SHMR_DUAL11_Msk = 0x800
	// Bit DUAL11.
	AFEC_SHMR_DUAL11 = 0x800

	// COSR: AFEC Correction Select Register
	// Position of CSEL field.
	AFEC_COSR_CSEL_Pos = 0x0
	// Bit mask of CSEL field.
	AFEC_COSR_CSEL_Msk = 0x1
	// Bit CSEL.
	AFEC_COSR_CSEL = 0x1

	// CVR: AFEC Correction Values Register
	// Position of OFFSETCORR field.
	AFEC_CVR_OFFSETCORR_Pos = 0x0
	// Bit mask of OFFSETCORR field.
	AFEC_CVR_OFFSETCORR_Msk = 0xffff
	// Position of GAINCORR field.
	AFEC_CVR_GAINCORR_Pos = 0x10
	// Bit mask of GAINCORR field.
	AFEC_CVR_GAINCORR_Msk = 0xffff0000

	// CECR: AFEC Channel Error Correction Register
	// Position of ECORR0 field.
	AFEC_CECR_ECORR0_Pos = 0x0
	// Bit mask of ECORR0 field.
	AFEC_CECR_ECORR0_Msk = 0x1
	// Bit ECORR0.
	AFEC_CECR_ECORR0 = 0x1
	// Position of ECORR1 field.
	AFEC_CECR_ECORR1_Pos = 0x1
	// Bit mask of ECORR1 field.
	AFEC_CECR_ECORR1_Msk = 0x2
	// Bit ECORR1.
	AFEC_CECR_ECORR1 = 0x2
	// Position of ECORR2 field.
	AFEC_CECR_ECORR2_Pos = 0x2
	// Bit mask of ECORR2 field.
	AFEC_CECR_ECORR2_Msk = 0x4
	// Bit ECORR2.
	AFEC_CECR_ECORR2 = 0x4
	// Position of ECORR3 field.
	AFEC_CECR_ECORR3_Pos = 0x3
	// Bit mask of ECORR3 field.
	AFEC_CECR_ECORR3_Msk = 0x8
	// Bit ECORR3.
	AFEC_CECR_ECORR3 = 0x8
	// Position of ECORR4 field.
	AFEC_CECR_ECORR4_Pos = 0x4
	// Bit mask of ECORR4 field.
	AFEC_CECR_ECORR4_Msk = 0x10
	// Bit ECORR4.
	AFEC_CECR_ECORR4 = 0x10
	// Position of ECORR5 field.
	AFEC_CECR_ECORR5_Pos = 0x5
	// Bit mask of ECORR5 field.
	AFEC_CECR_ECORR5_Msk = 0x20
	// Bit ECORR5.
	AFEC_CECR_ECORR5 = 0x20
	// Position of ECORR6 field.
	AFEC_CECR_ECORR6_Pos = 0x6
	// Bit mask of ECORR6 field.
	AFEC_CECR_ECORR6_Msk = 0x40
	// Bit ECORR6.
	AFEC_CECR_ECORR6 = 0x40
	// Position of ECORR7 field.
	AFEC_CECR_ECORR7_Pos = 0x7
	// Bit mask of ECORR7 field.
	AFEC_CECR_ECORR7_Msk = 0x80
	// Bit ECORR7.
	AFEC_CECR_ECORR7 = 0x80
	// Position of ECORR8 field.
	AFEC_CECR_ECORR8_Pos = 0x8
	// Bit mask of ECORR8 field.
	AFEC_CECR_ECORR8_Msk = 0x100
	// Bit ECORR8.
	AFEC_CECR_ECORR8 = 0x100
	// Position of ECORR9 field.
	AFEC_CECR_ECORR9_Pos = 0x9
	// Bit mask of ECORR9 field.
	AFEC_CECR_ECORR9_Msk = 0x200
	// Bit ECORR9.
	AFEC_CECR_ECORR9 = 0x200
	// Position of ECORR10 field.
	AFEC_CECR_ECORR10_Pos = 0xa
	// Bit mask of ECORR10 field.
	AFEC_CECR_ECORR10_Msk = 0x400
	// Bit ECORR10.
	AFEC_CECR_ECORR10 = 0x400
	// Position of ECORR11 field.
	AFEC_CECR_ECORR11_Pos = 0xb
	// Bit mask of ECORR11 field.
	AFEC_CECR_ECORR11_Msk = 0x800
	// Bit ECORR11.
	AFEC_CECR_ECORR11 = 0x800

	// WPMR: AFEC Write Protection Mode Register
	// Position of WPEN field.
	AFEC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	AFEC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	AFEC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	AFEC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	AFEC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit. Always reads as 0.
	AFEC_WPMR_WPKEY_PASSWD = 0x414443

	// WPSR: AFEC Write Protection Status Register
	// Position of WPVS field.
	AFEC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	AFEC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	AFEC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	AFEC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	AFEC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for CHIPID: Chip Identifier
const (
	// CIDR: Chip ID Register
	// Position of VERSION field.
	CHIPID_CIDR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	CHIPID_CIDR_VERSION_Msk = 0x1f
	// Position of EPROC field.
	CHIPID_CIDR_EPROC_Pos = 0x5
	// Bit mask of EPROC field.
	CHIPID_CIDR_EPROC_Msk = 0xe0
	// Cortex-M7
	CHIPID_CIDR_EPROC_SAMx7 = 0x0
	// ARM946ES
	CHIPID_CIDR_EPROC_ARM946ES = 0x1
	// ARM7TDMI
	CHIPID_CIDR_EPROC_ARM7TDMI = 0x2
	// Cortex-M3
	CHIPID_CIDR_EPROC_CM3 = 0x3
	// ARM920T
	CHIPID_CIDR_EPROC_ARM920T = 0x4
	// ARM926EJS
	CHIPID_CIDR_EPROC_ARM926EJS = 0x5
	// Cortex-A5
	CHIPID_CIDR_EPROC_CA5 = 0x6
	// Cortex-M4
	CHIPID_CIDR_EPROC_CM4 = 0x7
	// Position of NVPSIZ field.
	CHIPID_CIDR_NVPSIZ_Pos = 0x8
	// Bit mask of NVPSIZ field.
	CHIPID_CIDR_NVPSIZ_Msk = 0xf00
	// None
	CHIPID_CIDR_NVPSIZ_NONE = 0x0
	// 8 Kbytes
	CHIPID_CIDR_NVPSIZ__8K = 0x1
	// 16 Kbytes
	CHIPID_CIDR_NVPSIZ__16K = 0x2
	// 32 Kbytes
	CHIPID_CIDR_NVPSIZ__32K = 0x3
	// 64 Kbytes
	CHIPID_CIDR_NVPSIZ__64K = 0x5
	// 128 Kbytes
	CHIPID_CIDR_NVPSIZ__128K = 0x7
	// 160 Kbytes
	CHIPID_CIDR_NVPSIZ__160K = 0x8
	// 256 Kbytes
	CHIPID_CIDR_NVPSIZ__256K = 0x9
	// 512 Kbytes
	CHIPID_CIDR_NVPSIZ__512K = 0xa
	// 1024 Kbytes
	CHIPID_CIDR_NVPSIZ__1024K = 0xc
	// 2048 Kbytes
	CHIPID_CIDR_NVPSIZ__2048K = 0xe
	// Position of NVPSIZ2 field.
	CHIPID_CIDR_NVPSIZ2_Pos = 0xc
	// Bit mask of NVPSIZ2 field.
	CHIPID_CIDR_NVPSIZ2_Msk = 0xf000
	// None
	CHIPID_CIDR_NVPSIZ2_NONE = 0x0
	// 8 Kbytes
	CHIPID_CIDR_NVPSIZ2__8K = 0x1
	// 16 Kbytes
	CHIPID_CIDR_NVPSIZ2__16K = 0x2
	// 32 Kbytes
	CHIPID_CIDR_NVPSIZ2__32K = 0x3
	// 64 Kbytes
	CHIPID_CIDR_NVPSIZ2__64K = 0x5
	// 128 Kbytes
	CHIPID_CIDR_NVPSIZ2__128K = 0x7
	// 256 Kbytes
	CHIPID_CIDR_NVPSIZ2__256K = 0x9
	// 512 Kbytes
	CHIPID_CIDR_NVPSIZ2__512K = 0xa
	// 1024 Kbytes
	CHIPID_CIDR_NVPSIZ2__1024K = 0xc
	// 2048 Kbytes
	CHIPID_CIDR_NVPSIZ2__2048K = 0xe
	// Position of SRAMSIZ field.
	CHIPID_CIDR_SRAMSIZ_Pos = 0x10
	// Bit mask of SRAMSIZ field.
	CHIPID_CIDR_SRAMSIZ_Msk = 0xf0000
	// 48 Kbytes
	CHIPID_CIDR_SRAMSIZ__48K = 0x0
	// 192 Kbytes
	CHIPID_CIDR_SRAMSIZ__192K = 0x1
	// 384 Kbytes
	CHIPID_CIDR_SRAMSIZ__384K = 0x2
	// 6 Kbytes
	CHIPID_CIDR_SRAMSIZ__6K = 0x3
	// 24 Kbytes
	CHIPID_CIDR_SRAMSIZ__24K = 0x4
	// 4 Kbytes
	CHIPID_CIDR_SRAMSIZ__4K = 0x5
	// 80 Kbytes
	CHIPID_CIDR_SRAMSIZ__80K = 0x6
	// 160 Kbytes
	CHIPID_CIDR_SRAMSIZ__160K = 0x7
	// 8 Kbytes
	CHIPID_CIDR_SRAMSIZ__8K = 0x8
	// 16 Kbytes
	CHIPID_CIDR_SRAMSIZ__16K = 0x9
	// 32 Kbytes
	CHIPID_CIDR_SRAMSIZ__32K = 0xa
	// 64 Kbytes
	CHIPID_CIDR_SRAMSIZ__64K = 0xb
	// 128 Kbytes
	CHIPID_CIDR_SRAMSIZ__128K = 0xc
	// 256 Kbytes
	CHIPID_CIDR_SRAMSIZ__256K = 0xd
	// 96 Kbytes
	CHIPID_CIDR_SRAMSIZ__96K = 0xe
	// 512 Kbytes
	CHIPID_CIDR_SRAMSIZ__512K = 0xf
	// Position of ARCH field.
	CHIPID_CIDR_ARCH_Pos = 0x14
	// Bit mask of ARCH field.
	CHIPID_CIDR_ARCH_Msk = 0xff00000
	// SAM E70
	CHIPID_CIDR_ARCH_SAME70 = 0x10
	// SAM S70
	CHIPID_CIDR_ARCH_SAMS70 = 0x11
	// SAM V71
	CHIPID_CIDR_ARCH_SAMV71 = 0x12
	// SAM V70
	CHIPID_CIDR_ARCH_SAMV70 = 0x13
	// Position of NVPTYP field.
	CHIPID_CIDR_NVPTYP_Pos = 0x1c
	// Bit mask of NVPTYP field.
	CHIPID_CIDR_NVPTYP_Msk = 0x70000000
	// ROM
	CHIPID_CIDR_NVPTYP_ROM = 0x0
	// ROMless or on-chip Flash
	CHIPID_CIDR_NVPTYP_ROMLESS = 0x1
	// Embedded Flash Memory
	CHIPID_CIDR_NVPTYP_FLASH = 0x2
	// ROM and Embedded Flash Memory- NVPSIZ is ROM size- NVPSIZ2 is Flash size
	CHIPID_CIDR_NVPTYP_ROM_FLASH = 0x3
	// SRAM emulating ROM
	CHIPID_CIDR_NVPTYP_SRAM = 0x4
	// Position of EXT field.
	CHIPID_CIDR_EXT_Pos = 0x1f
	// Bit mask of EXT field.
	CHIPID_CIDR_EXT_Msk = 0x80000000
	// Bit EXT.
	CHIPID_CIDR_EXT = 0x80000000

	// EXID: Chip ID Extension Register
	// Position of EXID field.
	CHIPID_EXID_EXID_Pos = 0x0
	// Bit mask of EXID field.
	CHIPID_EXID_EXID_Msk = 0xffffffff
)

// Constants for DACC: Digital-to-Analog Converter Controller
const (
	// CR: Control Register
	// Position of SWRST field.
	DACC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DACC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	DACC_CR_SWRST = 0x1

	// MR: Mode Register
	// Position of MAXS0 field.
	DACC_MR_MAXS0_Pos = 0x0
	// Bit mask of MAXS0 field.
	DACC_MR_MAXS0_Msk = 0x1
	// Bit MAXS0.
	DACC_MR_MAXS0 = 0x1
	// External trigger mode or Free-running mode enabled. (See TRGENx.DACC_TRIGR.)
	DACC_MR_MAXS0_TRIG_EVENT = 0x0
	// Max speed mode enabled.
	DACC_MR_MAXS0_MAXIMUM = 0x1
	// Position of MAXS1 field.
	DACC_MR_MAXS1_Pos = 0x1
	// Bit mask of MAXS1 field.
	DACC_MR_MAXS1_Msk = 0x2
	// Bit MAXS1.
	DACC_MR_MAXS1 = 0x2
	// External trigger mode or Free-running mode enabled. (See TRGENx.DACC_TRIGR.)
	DACC_MR_MAXS1_TRIG_EVENT = 0x0
	// Max speed mode enabled.
	DACC_MR_MAXS1_MAXIMUM = 0x1
	// Position of WORD field.
	DACC_MR_WORD_Pos = 0x4
	// Bit mask of WORD field.
	DACC_MR_WORD_Msk = 0x10
	// Bit WORD.
	DACC_MR_WORD = 0x10
	// One data to convert is written to the FIFO per access to DACC.
	DACC_MR_WORD_DISABLED = 0x0
	// Two data to convert are written to the FIFO per access to DACC (reduces the number of requests to DMA and the number of system bus accesses).
	DACC_MR_WORD_ENABLED = 0x1
	// Position of ZERO field.
	DACC_MR_ZERO_Pos = 0x5
	// Bit mask of ZERO field.
	DACC_MR_ZERO_Msk = 0x20
	// Bit ZERO.
	DACC_MR_ZERO = 0x20
	// Position of DIFF field.
	DACC_MR_DIFF_Pos = 0x17
	// Bit mask of DIFF field.
	DACC_MR_DIFF_Msk = 0x800000
	// Bit DIFF.
	DACC_MR_DIFF = 0x800000
	// DAC0 and DAC1 are single-ended outputs.
	DACC_MR_DIFF_DISABLED = 0x0
	// DACP and DACN are differential outputs. The differential level is configured by the channel 0 value.
	DACC_MR_DIFF_ENABLED = 0x1
	// Position of PRESCALER field.
	DACC_MR_PRESCALER_Pos = 0x18
	// Bit mask of PRESCALER field.
	DACC_MR_PRESCALER_Msk = 0xf000000

	// TRIGR: Trigger Register
	// Position of TRGEN0 field.
	DACC_TRIGR_TRGEN0_Pos = 0x0
	// Bit mask of TRGEN0 field.
	DACC_TRIGR_TRGEN0_Msk = 0x1
	// Bit TRGEN0.
	DACC_TRIGR_TRGEN0 = 0x1
	// External trigger mode disabled. DACC is in Free-running mode or Max speed mode.
	DACC_TRIGR_TRGEN0_DIS = 0x0
	// External trigger mode enabled.
	DACC_TRIGR_TRGEN0_EN = 0x1
	// Position of TRGEN1 field.
	DACC_TRIGR_TRGEN1_Pos = 0x1
	// Bit mask of TRGEN1 field.
	DACC_TRIGR_TRGEN1_Msk = 0x2
	// Bit TRGEN1.
	DACC_TRIGR_TRGEN1 = 0x2
	// External trigger mode disabled. DACC is in Free-running mode or Max speed mode.
	DACC_TRIGR_TRGEN1_DIS = 0x0
	// External trigger mode enabled.
	DACC_TRIGR_TRGEN1_EN = 0x1
	// Position of TRGSEL0 field.
	DACC_TRIGR_TRGSEL0_Pos = 0x4
	// Bit mask of TRGSEL0 field.
	DACC_TRIGR_TRGSEL0_Msk = 0x70
	// DATRG
	DACC_TRIGR_TRGSEL0_TRGSEL0 = 0x0
	// TC0 output
	DACC_TRIGR_TRGSEL0_TRGSEL1 = 0x1
	// TC1 output
	DACC_TRIGR_TRGSEL0_TRGSEL2 = 0x2
	// TC2 output
	DACC_TRIGR_TRGSEL0_TRGSEL3 = 0x3
	// PWM0 event 0
	DACC_TRIGR_TRGSEL0_TRGSEL4 = 0x4
	// PWM0 event 1
	DACC_TRIGR_TRGSEL0_TRGSEL5 = 0x5
	// PWM1 event 0
	DACC_TRIGR_TRGSEL0_TRGSEL6 = 0x6
	// PWM1 event 1
	DACC_TRIGR_TRGSEL0_TRGSEL7 = 0x7
	// Position of TRGSEL1 field.
	DACC_TRIGR_TRGSEL1_Pos = 0x8
	// Bit mask of TRGSEL1 field.
	DACC_TRIGR_TRGSEL1_Msk = 0x700
	// DATRG
	DACC_TRIGR_TRGSEL1_TRGSEL0 = 0x0
	// TC0 output
	DACC_TRIGR_TRGSEL1_TRGSEL1 = 0x1
	// TC1 output
	DACC_TRIGR_TRGSEL1_TRGSEL2 = 0x2
	// TC2 output
	DACC_TRIGR_TRGSEL1_TRGSEL3 = 0x3
	// PWM0 event 0
	DACC_TRIGR_TRGSEL1_TRGSEL4 = 0x4
	// PWM0 event 1
	DACC_TRIGR_TRGSEL1_TRGSEL5 = 0x5
	// PWM1 event 0
	DACC_TRIGR_TRGSEL1_TRGSEL6 = 0x6
	// PWM1 event 1
	DACC_TRIGR_TRGSEL1_TRGSEL7 = 0x7
	// Position of OSR0 field.
	DACC_TRIGR_OSR0_Pos = 0x10
	// Bit mask of OSR0 field.
	DACC_TRIGR_OSR0_Msk = 0x70000
	// OSR = 1
	DACC_TRIGR_OSR0_OSR_1 = 0x0
	// OSR = 2
	DACC_TRIGR_OSR0_OSR_2 = 0x1
	// OSR = 4
	DACC_TRIGR_OSR0_OSR_4 = 0x2
	// OSR = 8
	DACC_TRIGR_OSR0_OSR_8 = 0x3
	// OSR = 16
	DACC_TRIGR_OSR0_OSR_16 = 0x4
	// OSR = 32
	DACC_TRIGR_OSR0_OSR_32 = 0x5
	// Position of OSR1 field.
	DACC_TRIGR_OSR1_Pos = 0x14
	// Bit mask of OSR1 field.
	DACC_TRIGR_OSR1_Msk = 0x700000
	// OSR = 1
	DACC_TRIGR_OSR1_OSR_1 = 0x0
	// OSR = 2
	DACC_TRIGR_OSR1_OSR_2 = 0x1
	// OSR = 4
	DACC_TRIGR_OSR1_OSR_4 = 0x2
	// OSR = 8
	DACC_TRIGR_OSR1_OSR_8 = 0x3
	// OSR = 16
	DACC_TRIGR_OSR1_OSR_16 = 0x4
	// OSR = 32
	DACC_TRIGR_OSR1_OSR_32 = 0x5

	// CHER: Channel Enable Register
	// Position of CH0 field.
	DACC_CHER_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DACC_CHER_CH0_Msk = 0x1
	// Bit CH0.
	DACC_CHER_CH0 = 0x1
	// Position of CH1 field.
	DACC_CHER_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DACC_CHER_CH1_Msk = 0x2
	// Bit CH1.
	DACC_CHER_CH1 = 0x2

	// CHDR: Channel Disable Register
	// Position of CH0 field.
	DACC_CHDR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DACC_CHDR_CH0_Msk = 0x1
	// Bit CH0.
	DACC_CHDR_CH0 = 0x1
	// Position of CH1 field.
	DACC_CHDR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DACC_CHDR_CH1_Msk = 0x2
	// Bit CH1.
	DACC_CHDR_CH1 = 0x2

	// CHSR: Channel Status Register
	// Position of CH0 field.
	DACC_CHSR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DACC_CHSR_CH0_Msk = 0x1
	// Bit CH0.
	DACC_CHSR_CH0 = 0x1
	// Position of CH1 field.
	DACC_CHSR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	DACC_CHSR_CH1_Msk = 0x2
	// Bit CH1.
	DACC_CHSR_CH1 = 0x2
	// Position of DACRDY0 field.
	DACC_CHSR_DACRDY0_Pos = 0x8
	// Bit mask of DACRDY0 field.
	DACC_CHSR_DACRDY0_Msk = 0x100
	// Bit DACRDY0.
	DACC_CHSR_DACRDY0 = 0x100
	// Position of DACRDY1 field.
	DACC_CHSR_DACRDY1_Pos = 0x9
	// Bit mask of DACRDY1 field.
	DACC_CHSR_DACRDY1_Msk = 0x200
	// Bit DACRDY1.
	DACC_CHSR_DACRDY1 = 0x200

	// CDR: Conversion Data Register 0
	// Position of DATA0 field.
	DACC_CDR_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	DACC_CDR_DATA0_Msk = 0xffff
	// Position of DATA1 field.
	DACC_CDR_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	DACC_CDR_DATA1_Msk = 0xffff0000

	// IER: Interrupt Enable Register
	// Position of TXRDY0 field.
	DACC_IER_TXRDY0_Pos = 0x0
	// Bit mask of TXRDY0 field.
	DACC_IER_TXRDY0_Msk = 0x1
	// Bit TXRDY0.
	DACC_IER_TXRDY0 = 0x1
	// Position of TXRDY1 field.
	DACC_IER_TXRDY1_Pos = 0x1
	// Bit mask of TXRDY1 field.
	DACC_IER_TXRDY1_Msk = 0x2
	// Bit TXRDY1.
	DACC_IER_TXRDY1 = 0x2
	// Position of EOC0 field.
	DACC_IER_EOC0_Pos = 0x4
	// Bit mask of EOC0 field.
	DACC_IER_EOC0_Msk = 0x10
	// Bit EOC0.
	DACC_IER_EOC0 = 0x10
	// Position of EOC1 field.
	DACC_IER_EOC1_Pos = 0x5
	// Bit mask of EOC1 field.
	DACC_IER_EOC1_Msk = 0x20
	// Bit EOC1.
	DACC_IER_EOC1 = 0x20

	// IDR: Interrupt Disable Register
	// Position of TXRDY0 field.
	DACC_IDR_TXRDY0_Pos = 0x0
	// Bit mask of TXRDY0 field.
	DACC_IDR_TXRDY0_Msk = 0x1
	// Bit TXRDY0.
	DACC_IDR_TXRDY0 = 0x1
	// Position of TXRDY1 field.
	DACC_IDR_TXRDY1_Pos = 0x1
	// Bit mask of TXRDY1 field.
	DACC_IDR_TXRDY1_Msk = 0x2
	// Bit TXRDY1.
	DACC_IDR_TXRDY1 = 0x2
	// Position of EOC0 field.
	DACC_IDR_EOC0_Pos = 0x4
	// Bit mask of EOC0 field.
	DACC_IDR_EOC0_Msk = 0x10
	// Bit EOC0.
	DACC_IDR_EOC0 = 0x10
	// Position of EOC1 field.
	DACC_IDR_EOC1_Pos = 0x5
	// Bit mask of EOC1 field.
	DACC_IDR_EOC1_Msk = 0x20
	// Bit EOC1.
	DACC_IDR_EOC1 = 0x20

	// IMR: Interrupt Mask Register
	// Position of TXRDY0 field.
	DACC_IMR_TXRDY0_Pos = 0x0
	// Bit mask of TXRDY0 field.
	DACC_IMR_TXRDY0_Msk = 0x1
	// Bit TXRDY0.
	DACC_IMR_TXRDY0 = 0x1
	// Position of TXRDY1 field.
	DACC_IMR_TXRDY1_Pos = 0x1
	// Bit mask of TXRDY1 field.
	DACC_IMR_TXRDY1_Msk = 0x2
	// Bit TXRDY1.
	DACC_IMR_TXRDY1 = 0x2
	// Position of EOC0 field.
	DACC_IMR_EOC0_Pos = 0x4
	// Bit mask of EOC0 field.
	DACC_IMR_EOC0_Msk = 0x10
	// Bit EOC0.
	DACC_IMR_EOC0 = 0x10
	// Position of EOC1 field.
	DACC_IMR_EOC1_Pos = 0x5
	// Bit mask of EOC1 field.
	DACC_IMR_EOC1_Msk = 0x20
	// Bit EOC1.
	DACC_IMR_EOC1 = 0x20

	// ISR: Interrupt Status Register
	// Position of TXRDY0 field.
	DACC_ISR_TXRDY0_Pos = 0x0
	// Bit mask of TXRDY0 field.
	DACC_ISR_TXRDY0_Msk = 0x1
	// Bit TXRDY0.
	DACC_ISR_TXRDY0 = 0x1
	// Position of TXRDY1 field.
	DACC_ISR_TXRDY1_Pos = 0x1
	// Bit mask of TXRDY1 field.
	DACC_ISR_TXRDY1_Msk = 0x2
	// Bit TXRDY1.
	DACC_ISR_TXRDY1 = 0x2
	// Position of EOC0 field.
	DACC_ISR_EOC0_Pos = 0x4
	// Bit mask of EOC0 field.
	DACC_ISR_EOC0_Msk = 0x10
	// Bit EOC0.
	DACC_ISR_EOC0 = 0x10
	// Position of EOC1 field.
	DACC_ISR_EOC1_Pos = 0x5
	// Bit mask of EOC1 field.
	DACC_ISR_EOC1_Msk = 0x20
	// Bit EOC1.
	DACC_ISR_EOC1 = 0x20

	// ACR: Analog Current Register
	// Position of IBCTLCH0 field.
	DACC_ACR_IBCTLCH0_Pos = 0x0
	// Bit mask of IBCTLCH0 field.
	DACC_ACR_IBCTLCH0_Msk = 0x3
	// Position of IBCTLCH1 field.
	DACC_ACR_IBCTLCH1_Pos = 0x2
	// Bit mask of IBCTLCH1 field.
	DACC_ACR_IBCTLCH1_Msk = 0xc

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	DACC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	DACC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	DACC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	DACC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	DACC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of bit WPEN.Always reads as 0.
	DACC_WPMR_WPKEY_PASSWD = 0x444143

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	DACC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	DACC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	DACC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	DACC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	DACC_WPSR_WPVSRC_Msk = 0xff00
)

// Constants for EFC: Embedded Flash Controller
const (
	// EEFC_FMR: EEFC Flash Mode Register
	// Position of FRDY field.
	EFC_EEFC_FMR_FRDY_Pos = 0x0
	// Bit mask of FRDY field.
	EFC_EEFC_FMR_FRDY_Msk = 0x1
	// Bit FRDY.
	EFC_EEFC_FMR_FRDY = 0x1
	// Position of FWS field.
	EFC_EEFC_FMR_FWS_Pos = 0x8
	// Bit mask of FWS field.
	EFC_EEFC_FMR_FWS_Msk = 0xf00
	// Position of SCOD field.
	EFC_EEFC_FMR_SCOD_Pos = 0x10
	// Bit mask of SCOD field.
	EFC_EEFC_FMR_SCOD_Msk = 0x10000
	// Bit SCOD.
	EFC_EEFC_FMR_SCOD = 0x10000
	// Position of CLOE field.
	EFC_EEFC_FMR_CLOE_Pos = 0x1a
	// Bit mask of CLOE field.
	EFC_EEFC_FMR_CLOE_Msk = 0x4000000
	// Bit CLOE.
	EFC_EEFC_FMR_CLOE = 0x4000000

	// EEFC_FCR: EEFC Flash Command Register
	// Position of FCMD field.
	EFC_EEFC_FCR_FCMD_Pos = 0x0
	// Bit mask of FCMD field.
	EFC_EEFC_FCR_FCMD_Msk = 0xff
	// Get Flash descriptor
	EFC_EEFC_FCR_FCMD_GETD = 0x0
	// Write page
	EFC_EEFC_FCR_FCMD_WP = 0x1
	// Write page and lock
	EFC_EEFC_FCR_FCMD_WPL = 0x2
	// Erase page and write page
	EFC_EEFC_FCR_FCMD_EWP = 0x3
	// Erase page and write page then lock
	EFC_EEFC_FCR_FCMD_EWPL = 0x4
	// Erase all
	EFC_EEFC_FCR_FCMD_EA = 0x5
	// Erase pages
	EFC_EEFC_FCR_FCMD_EPA = 0x7
	// Set lock bit
	EFC_EEFC_FCR_FCMD_SLB = 0x8
	// Clear lock bit
	EFC_EEFC_FCR_FCMD_CLB = 0x9
	// Get lock bit
	EFC_EEFC_FCR_FCMD_GLB = 0xa
	// Set GPNVM bit
	EFC_EEFC_FCR_FCMD_SGPB = 0xb
	// Clear GPNVM bit
	EFC_EEFC_FCR_FCMD_CGPB = 0xc
	// Get GPNVM bit
	EFC_EEFC_FCR_FCMD_GGPB = 0xd
	// Start read unique identifier
	EFC_EEFC_FCR_FCMD_STUI = 0xe
	// Stop read unique identifier
	EFC_EEFC_FCR_FCMD_SPUI = 0xf
	// Get CALIB bit
	EFC_EEFC_FCR_FCMD_GCALB = 0x10
	// Erase sector
	EFC_EEFC_FCR_FCMD_ES = 0x11
	// Write user signature
	EFC_EEFC_FCR_FCMD_WUS = 0x12
	// Erase user signature
	EFC_EEFC_FCR_FCMD_EUS = 0x13
	// Start read user signature
	EFC_EEFC_FCR_FCMD_STUS = 0x14
	// Stop read user signature
	EFC_EEFC_FCR_FCMD_SPUS = 0x15
	// Position of FARG field.
	EFC_EEFC_FCR_FARG_Pos = 0x8
	// Bit mask of FARG field.
	EFC_EEFC_FCR_FARG_Msk = 0xffff00
	// Position of FKEY field.
	EFC_EEFC_FCR_FKEY_Pos = 0x18
	// Bit mask of FKEY field.
	EFC_EEFC_FCR_FKEY_Msk = 0xff000000
	// The 0x5A value enables the command defined by the bits of the register. If the field is written with a different value, the write is not performed and no action is started.
	EFC_EEFC_FCR_FKEY_PASSWD = 0x5a

	// EEFC_FSR: EEFC Flash Status Register
	// Position of FRDY field.
	EFC_EEFC_FSR_FRDY_Pos = 0x0
	// Bit mask of FRDY field.
	EFC_EEFC_FSR_FRDY_Msk = 0x1
	// Bit FRDY.
	EFC_EEFC_FSR_FRDY = 0x1
	// Position of FCMDE field.
	EFC_EEFC_FSR_FCMDE_Pos = 0x1
	// Bit mask of FCMDE field.
	EFC_EEFC_FSR_FCMDE_Msk = 0x2
	// Bit FCMDE.
	EFC_EEFC_FSR_FCMDE = 0x2
	// Position of FLOCKE field.
	EFC_EEFC_FSR_FLOCKE_Pos = 0x2
	// Bit mask of FLOCKE field.
	EFC_EEFC_FSR_FLOCKE_Msk = 0x4
	// Bit FLOCKE.
	EFC_EEFC_FSR_FLOCKE = 0x4
	// Position of FLERR field.
	EFC_EEFC_FSR_FLERR_Pos = 0x3
	// Bit mask of FLERR field.
	EFC_EEFC_FSR_FLERR_Msk = 0x8
	// Bit FLERR.
	EFC_EEFC_FSR_FLERR = 0x8
	// Position of UECCELSB field.
	EFC_EEFC_FSR_UECCELSB_Pos = 0x10
	// Bit mask of UECCELSB field.
	EFC_EEFC_FSR_UECCELSB_Msk = 0x10000
	// Bit UECCELSB.
	EFC_EEFC_FSR_UECCELSB = 0x10000
	// Position of MECCELSB field.
	EFC_EEFC_FSR_MECCELSB_Pos = 0x11
	// Bit mask of MECCELSB field.
	EFC_EEFC_FSR_MECCELSB_Msk = 0x20000
	// Bit MECCELSB.
	EFC_EEFC_FSR_MECCELSB = 0x20000
	// Position of UECCEMSB field.
	EFC_EEFC_FSR_UECCEMSB_Pos = 0x12
	// Bit mask of UECCEMSB field.
	EFC_EEFC_FSR_UECCEMSB_Msk = 0x40000
	// Bit UECCEMSB.
	EFC_EEFC_FSR_UECCEMSB = 0x40000
	// Position of MECCEMSB field.
	EFC_EEFC_FSR_MECCEMSB_Pos = 0x13
	// Bit mask of MECCEMSB field.
	EFC_EEFC_FSR_MECCEMSB_Msk = 0x80000
	// Bit MECCEMSB.
	EFC_EEFC_FSR_MECCEMSB = 0x80000

	// EEFC_FRR: EEFC Flash Result Register
	// Position of FVALUE field.
	EFC_EEFC_FRR_FVALUE_Pos = 0x0
	// Bit mask of FVALUE field.
	EFC_EEFC_FRR_FVALUE_Msk = 0xffffffff

	// EEFC_WPMR: Write Protection Mode Register
	// Position of WPEN field.
	EFC_EEFC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	EFC_EEFC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	EFC_EEFC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	EFC_EEFC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	EFC_EEFC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation.Always reads as 0.
	EFC_EEFC_WPMR_WPKEY_PASSWD = 0x454643
)

// Constants for GMAC: Gigabit Ethernet MAC
const (
	// NCR: Network Control Register
	// Position of LBL field.
	GMAC_NCR_LBL_Pos = 0x1
	// Bit mask of LBL field.
	GMAC_NCR_LBL_Msk = 0x2
	// Bit LBL.
	GMAC_NCR_LBL = 0x2
	// Position of RXEN field.
	GMAC_NCR_RXEN_Pos = 0x2
	// Bit mask of RXEN field.
	GMAC_NCR_RXEN_Msk = 0x4
	// Bit RXEN.
	GMAC_NCR_RXEN = 0x4
	// Position of TXEN field.
	GMAC_NCR_TXEN_Pos = 0x3
	// Bit mask of TXEN field.
	GMAC_NCR_TXEN_Msk = 0x8
	// Bit TXEN.
	GMAC_NCR_TXEN = 0x8
	// Position of MPE field.
	GMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	GMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	GMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	GMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	GMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	GMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	GMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	GMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	GMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	GMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	GMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	GMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	GMAC_NCR_BP = 0x100
	// Position of TSTART field.
	GMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	GMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	GMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	GMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	GMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	GMAC_NCR_THALT = 0x400
	// Position of TXPF field.
	GMAC_NCR_TXPF_Pos = 0xb
	// Bit mask of TXPF field.
	GMAC_NCR_TXPF_Msk = 0x800
	// Bit TXPF.
	GMAC_NCR_TXPF = 0x800
	// Position of TXZQPF field.
	GMAC_NCR_TXZQPF_Pos = 0xc
	// Bit mask of TXZQPF field.
	GMAC_NCR_TXZQPF_Msk = 0x1000
	// Bit TXZQPF.
	GMAC_NCR_TXZQPF = 0x1000
	// Position of SRTSM field.
	GMAC_NCR_SRTSM_Pos = 0xf
	// Bit mask of SRTSM field.
	GMAC_NCR_SRTSM_Msk = 0x8000
	// Bit SRTSM.
	GMAC_NCR_SRTSM = 0x8000
	// Position of ENPBPR field.
	GMAC_NCR_ENPBPR_Pos = 0x10
	// Bit mask of ENPBPR field.
	GMAC_NCR_ENPBPR_Msk = 0x10000
	// Bit ENPBPR.
	GMAC_NCR_ENPBPR = 0x10000
	// Position of TXPBPF field.
	GMAC_NCR_TXPBPF_Pos = 0x11
	// Bit mask of TXPBPF field.
	GMAC_NCR_TXPBPF_Msk = 0x20000
	// Bit TXPBPF.
	GMAC_NCR_TXPBPF = 0x20000
	// Position of FNP field.
	GMAC_NCR_FNP_Pos = 0x12
	// Bit mask of FNP field.
	GMAC_NCR_FNP_Msk = 0x40000
	// Bit FNP.
	GMAC_NCR_FNP = 0x40000

	// NCFGR: Network Configuration Register
	// Position of SPD field.
	GMAC_NCFGR_SPD_Pos = 0x0
	// Bit mask of SPD field.
	GMAC_NCFGR_SPD_Msk = 0x1
	// Bit SPD.
	GMAC_NCFGR_SPD = 0x1
	// Position of FD field.
	GMAC_NCFGR_FD_Pos = 0x1
	// Bit mask of FD field.
	GMAC_NCFGR_FD_Msk = 0x2
	// Bit FD.
	GMAC_NCFGR_FD = 0x2
	// Position of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Pos = 0x2
	// Bit mask of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Msk = 0x4
	// Bit DNVLAN.
	GMAC_NCFGR_DNVLAN = 0x4
	// Position of JFRAME field.
	GMAC_NCFGR_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	GMAC_NCFGR_JFRAME_Msk = 0x8
	// Bit JFRAME.
	GMAC_NCFGR_JFRAME = 0x8
	// Position of CAF field.
	GMAC_NCFGR_CAF_Pos = 0x4
	// Bit mask of CAF field.
	GMAC_NCFGR_CAF_Msk = 0x10
	// Bit CAF.
	GMAC_NCFGR_CAF = 0x10
	// Position of NBC field.
	GMAC_NCFGR_NBC_Pos = 0x5
	// Bit mask of NBC field.
	GMAC_NCFGR_NBC_Msk = 0x20
	// Bit NBC.
	GMAC_NCFGR_NBC = 0x20
	// Position of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Pos = 0x6
	// Bit mask of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Msk = 0x40
	// Bit MTIHEN.
	GMAC_NCFGR_MTIHEN = 0x40
	// Position of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Pos = 0x7
	// Bit mask of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Msk = 0x80
	// Bit UNIHEN.
	GMAC_NCFGR_UNIHEN = 0x80
	// Position of MAXFS field.
	GMAC_NCFGR_MAXFS_Pos = 0x8
	// Bit mask of MAXFS field.
	GMAC_NCFGR_MAXFS_Msk = 0x100
	// Bit MAXFS.
	GMAC_NCFGR_MAXFS = 0x100
	// Position of RTY field.
	GMAC_NCFGR_RTY_Pos = 0xc
	// Bit mask of RTY field.
	GMAC_NCFGR_RTY_Msk = 0x1000
	// Bit RTY.
	GMAC_NCFGR_RTY = 0x1000
	// Position of PEN field.
	GMAC_NCFGR_PEN_Pos = 0xd
	// Bit mask of PEN field.
	GMAC_NCFGR_PEN_Msk = 0x2000
	// Bit PEN.
	GMAC_NCFGR_PEN = 0x2000
	// Position of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Pos = 0xe
	// Bit mask of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Msk = 0xc000
	// Position of LFERD field.
	GMAC_NCFGR_LFERD_Pos = 0x10
	// Bit mask of LFERD field.
	GMAC_NCFGR_LFERD_Msk = 0x10000
	// Bit LFERD.
	GMAC_NCFGR_LFERD = 0x10000
	// Position of RFCS field.
	GMAC_NCFGR_RFCS_Pos = 0x11
	// Bit mask of RFCS field.
	GMAC_NCFGR_RFCS_Msk = 0x20000
	// Bit RFCS.
	GMAC_NCFGR_RFCS = 0x20000
	// Position of CLK field.
	GMAC_NCFGR_CLK_Pos = 0x12
	// Bit mask of CLK field.
	GMAC_NCFGR_CLK_Msk = 0x1c0000
	// MCK divided by 8 (MCK up to 20 MHz)
	GMAC_NCFGR_CLK_MCK_8 = 0x0
	// MCK divided by 16 (MCK up to 40 MHz)
	GMAC_NCFGR_CLK_MCK_16 = 0x1
	// MCK divided by 32 (MCK up to 80 MHz)
	GMAC_NCFGR_CLK_MCK_32 = 0x2
	// MCK divided by 48 (MCK up to 120 MHz)
	GMAC_NCFGR_CLK_MCK_48 = 0x3
	// MCK divided by 64 (MCK up to 160 MHz)
	GMAC_NCFGR_CLK_MCK_64 = 0x4
	// MCK divided by 96 (MCK up to 240 MHz)
	GMAC_NCFGR_CLK_MCK_96 = 0x5
	// Position of DBW field.
	GMAC_NCFGR_DBW_Pos = 0x15
	// Bit mask of DBW field.
	GMAC_NCFGR_DBW_Msk = 0x600000
	// Position of DCPF field.
	GMAC_NCFGR_DCPF_Pos = 0x17
	// Bit mask of DCPF field.
	GMAC_NCFGR_DCPF_Msk = 0x800000
	// Bit DCPF.
	GMAC_NCFGR_DCPF = 0x800000
	// Position of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Pos = 0x18
	// Bit mask of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Msk = 0x1000000
	// Bit RXCOEN.
	GMAC_NCFGR_RXCOEN = 0x1000000
	// Position of EFRHD field.
	GMAC_NCFGR_EFRHD_Pos = 0x19
	// Bit mask of EFRHD field.
	GMAC_NCFGR_EFRHD_Msk = 0x2000000
	// Bit EFRHD.
	GMAC_NCFGR_EFRHD = 0x2000000
	// Position of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Pos = 0x1a
	// Bit mask of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Msk = 0x4000000
	// Bit IRXFCS.
	GMAC_NCFGR_IRXFCS = 0x4000000
	// Position of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Pos = 0x1c
	// Bit mask of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Msk = 0x10000000
	// Bit IPGSEN.
	GMAC_NCFGR_IPGSEN = 0x10000000
	// Position of RXBP field.
	GMAC_NCFGR_RXBP_Pos = 0x1d
	// Bit mask of RXBP field.
	GMAC_NCFGR_RXBP_Msk = 0x20000000
	// Bit RXBP.
	GMAC_NCFGR_RXBP = 0x20000000
	// Position of IRXER field.
	GMAC_NCFGR_IRXER_Pos = 0x1e
	// Bit mask of IRXER field.
	GMAC_NCFGR_IRXER_Msk = 0x40000000
	// Bit IRXER.
	GMAC_NCFGR_IRXER = 0x40000000

	// NSR: Network Status Register
	// Position of MDIO field.
	GMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	GMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	GMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	GMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	GMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	GMAC_NSR_IDLE = 0x4

	// UR: User Register
	// Position of RMII field.
	GMAC_UR_RMII_Pos = 0x0
	// Bit mask of RMII field.
	GMAC_UR_RMII_Msk = 0x1
	// Bit RMII.
	GMAC_UR_RMII = 0x1

	// DCFGR: DMA Configuration Register
	// Position of FBLDO field.
	GMAC_DCFGR_FBLDO_Pos = 0x0
	// Bit mask of FBLDO field.
	GMAC_DCFGR_FBLDO_Msk = 0x1f
	// 00001: Always use SINGLE AHB bursts
	GMAC_DCFGR_FBLDO_SINGLE = 0x1
	// 001xx: Attempt to use INCR4 AHB bursts (Default)
	GMAC_DCFGR_FBLDO_INCR4 = 0x4
	// 01xxx: Attempt to use INCR8 AHB bursts
	GMAC_DCFGR_FBLDO_INCR8 = 0x8
	// 1xxxx: Attempt to use INCR16 AHB bursts
	GMAC_DCFGR_FBLDO_INCR16 = 0x10
	// Position of ESMA field.
	GMAC_DCFGR_ESMA_Pos = 0x6
	// Bit mask of ESMA field.
	GMAC_DCFGR_ESMA_Msk = 0x40
	// Bit ESMA.
	GMAC_DCFGR_ESMA = 0x40
	// Position of ESPA field.
	GMAC_DCFGR_ESPA_Pos = 0x7
	// Bit mask of ESPA field.
	GMAC_DCFGR_ESPA_Msk = 0x80
	// Bit ESPA.
	GMAC_DCFGR_ESPA = 0x80
	// Position of RXBMS field.
	GMAC_DCFGR_RXBMS_Pos = 0x8
	// Bit mask of RXBMS field.
	GMAC_DCFGR_RXBMS_Msk = 0x300
	// 4/8 Kbyte Memory Size
	GMAC_DCFGR_RXBMS_EIGHTH = 0x0
	// 4/4 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_QUARTER = 0x1
	// 4/2 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_HALF = 0x2
	// 4 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_FULL = 0x3
	// Position of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Pos = 0xa
	// Bit mask of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Msk = 0x400
	// Bit TXPBMS.
	GMAC_DCFGR_TXPBMS = 0x400
	// Position of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Pos = 0xb
	// Bit mask of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Msk = 0x800
	// Bit TXCOEN.
	GMAC_DCFGR_TXCOEN = 0x800
	// Position of DRBS field.
	GMAC_DCFGR_DRBS_Pos = 0x10
	// Bit mask of DRBS field.
	GMAC_DCFGR_DRBS_Msk = 0xff0000
	// Position of DDRP field.
	GMAC_DCFGR_DDRP_Pos = 0x18
	// Bit mask of DDRP field.
	GMAC_DCFGR_DDRP_Msk = 0x1000000
	// Bit DDRP.
	GMAC_DCFGR_DDRP = 0x1000000

	// TSR: Transmit Status Register
	// Position of UBR field.
	GMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	GMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	GMAC_TSR_UBR = 0x1
	// Position of COL field.
	GMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	GMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	GMAC_TSR_COL = 0x2
	// Position of RLE field.
	GMAC_TSR_RLE_Pos = 0x2
	// Bit mask of RLE field.
	GMAC_TSR_RLE_Msk = 0x4
	// Bit RLE.
	GMAC_TSR_RLE = 0x4
	// Position of TXGO field.
	GMAC_TSR_TXGO_Pos = 0x3
	// Bit mask of TXGO field.
	GMAC_TSR_TXGO_Msk = 0x8
	// Bit TXGO.
	GMAC_TSR_TXGO = 0x8
	// Position of TFC field.
	GMAC_TSR_TFC_Pos = 0x4
	// Bit mask of TFC field.
	GMAC_TSR_TFC_Msk = 0x10
	// Bit TFC.
	GMAC_TSR_TFC = 0x10
	// Position of TXCOMP field.
	GMAC_TSR_TXCOMP_Pos = 0x5
	// Bit mask of TXCOMP field.
	GMAC_TSR_TXCOMP_Msk = 0x20
	// Bit TXCOMP.
	GMAC_TSR_TXCOMP = 0x20
	// Position of HRESP field.
	GMAC_TSR_HRESP_Pos = 0x8
	// Bit mask of HRESP field.
	GMAC_TSR_HRESP_Msk = 0x100
	// Bit HRESP.
	GMAC_TSR_HRESP = 0x100

	// RBQB: Receive Buffer Queue Base Address Register
	// Position of ADDR field.
	GMAC_RBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_RBQB_ADDR_Msk = 0xfffffffc

	// TBQB: Transmit Buffer Queue Base Address Register
	// Position of ADDR field.
	GMAC_TBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_TBQB_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	GMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	GMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	GMAC_RSR_BNA = 0x1
	// Position of REC field.
	GMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	GMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	GMAC_RSR_REC = 0x2
	// Position of RXOVR field.
	GMAC_RSR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	GMAC_RSR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	GMAC_RSR_RXOVR = 0x4
	// Position of HNO field.
	GMAC_RSR_HNO_Pos = 0x3
	// Bit mask of HNO field.
	GMAC_RSR_HNO_Msk = 0x8
	// Bit HNO.
	GMAC_RSR_HNO = 0x8

	// ISR: Interrupt Status Register
	// Position of MFS field.
	GMAC_ISR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_ISR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_ISR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_ISR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_ISR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_ISR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_ISR_TUR = 0x10
	// Position of RLEX field.
	GMAC_ISR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_ISR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_ISR_RLEX = 0x20
	// Position of TFC field.
	GMAC_ISR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_ISR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_ISR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_ISR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_ISR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_ISR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_ISR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_ISR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_ISR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_ISR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_ISR_PFTR = 0x4000
	// Position of DRQFR field.
	GMAC_ISR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_ISR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_ISR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_ISR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_ISR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_ISR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_ISR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_ISR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_ISR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_ISR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_ISR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_ISR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_ISR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_ISR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_ISR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_ISR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_ISR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_ISR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_ISR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_ISR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_ISR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_ISR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_ISR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_ISR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_ISR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_ISR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_ISR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_ISR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_ISR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_ISR_WOL = 0x10000000

	// IER: Interrupt Enable Register
	// Position of MFS field.
	GMAC_IER_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IER_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IER_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IER_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IER_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IER_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IER_TUR = 0x10
	// Position of RLEX field.
	GMAC_IER_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IER_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IER_RLEX = 0x20
	// Position of TFC field.
	GMAC_IER_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IER_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IER_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IER_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IER_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IER_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IER_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IER_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IER_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IER_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IER_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IER_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IER_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IER_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IER_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IER_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IER_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IER_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IER_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IER_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IER_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IER_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IER_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IER_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IER_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IER_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IER_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IER_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IER_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IER_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IER_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IER_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IER_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IER_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IER_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IER_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IER_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IER_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IER_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IER_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IER_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IER_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IER_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IER_WOL = 0x10000000

	// IDR: Interrupt Disable Register
	// Position of MFS field.
	GMAC_IDR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IDR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IDR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IDR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IDR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IDR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IDR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IDR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IDR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IDR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IDR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IDR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IDR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IDR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IDR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IDR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IDR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IDR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IDR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IDR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IDR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IDR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IDR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IDR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IDR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IDR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IDR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IDR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IDR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IDR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IDR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IDR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IDR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IDR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IDR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IDR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IDR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IDR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IDR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IDR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IDR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IDR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IDR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IDR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IDR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IDR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IDR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IDR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IDR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IDR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IDR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IDR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IDR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IDR_WOL = 0x10000000

	// IMR: Interrupt Mask Register
	// Position of MFS field.
	GMAC_IMR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IMR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IMR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IMR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IMR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IMR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IMR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IMR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IMR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IMR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IMR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IMR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IMR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IMR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IMR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IMR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IMR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IMR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IMR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IMR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IMR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IMR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IMR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IMR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IMR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IMR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IMR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IMR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IMR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IMR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IMR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IMR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IMR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IMR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IMR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IMR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IMR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IMR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IMR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IMR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IMR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IMR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IMR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IMR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IMR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IMR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IMR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IMR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IMR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IMR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IMR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IMR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IMR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IMR_WOL = 0x10000000

	// MAN: PHY Maintenance Register
	// Position of DATA field.
	GMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GMAC_MAN_DATA_Msk = 0xffff
	// Position of WTN field.
	GMAC_MAN_WTN_Pos = 0x10
	// Bit mask of WTN field.
	GMAC_MAN_WTN_Msk = 0x30000
	// Position of REGA field.
	GMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	GMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	GMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	GMAC_MAN_PHYA_Msk = 0xf800000
	// Position of OP field.
	GMAC_MAN_OP_Pos = 0x1c
	// Bit mask of OP field.
	GMAC_MAN_OP_Msk = 0x30000000
	// Position of CLTTO field.
	GMAC_MAN_CLTTO_Pos = 0x1e
	// Bit mask of CLTTO field.
	GMAC_MAN_CLTTO_Msk = 0x40000000
	// Bit CLTTO.
	GMAC_MAN_CLTTO = 0x40000000
	// Position of WZO field.
	GMAC_MAN_WZO_Pos = 0x1f
	// Bit mask of WZO field.
	GMAC_MAN_WZO_Msk = 0x80000000
	// Bit WZO.
	GMAC_MAN_WZO = 0x80000000

	// RPQ: Received Pause Quantum Register
	// Position of RPQ field.
	GMAC_RPQ_RPQ_Pos = 0x0
	// Bit mask of RPQ field.
	GMAC_RPQ_RPQ_Msk = 0xffff

	// TPQ: Transmit Pause Quantum Register
	// Position of TPQ field.
	GMAC_TPQ_TPQ_Pos = 0x0
	// Bit mask of TPQ field.
	GMAC_TPQ_TPQ_Msk = 0xffff

	// TPSF: TX Partial Store and Forward Register
	// Position of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Pos = 0x0
	// Bit mask of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Msk = 0xfff
	// Position of ENTXP field.
	GMAC_TPSF_ENTXP_Pos = 0x1f
	// Bit mask of ENTXP field.
	GMAC_TPSF_ENTXP_Msk = 0x80000000
	// Bit ENTXP.
	GMAC_TPSF_ENTXP = 0x80000000

	// RPSF: RX Partial Store and Forward Register
	// Position of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Pos = 0x0
	// Bit mask of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Msk = 0xfff
	// Position of ENRXP field.
	GMAC_RPSF_ENRXP_Pos = 0x1f
	// Bit mask of ENRXP field.
	GMAC_RPSF_ENRXP_Msk = 0x80000000
	// Bit ENRXP.
	GMAC_RPSF_ENRXP = 0x80000000

	// RJFML: RX Jumbo Frame Max Length Register
	// Position of FML field.
	GMAC_RJFML_FML_Pos = 0x0
	// Bit mask of FML field.
	GMAC_RJFML_FML_Msk = 0x3fff

	// HRB: Hash Register Bottom
	// Position of ADDR field.
	GMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top
	// Position of ADDR field.
	GMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRT_ADDR_Msk = 0xffffffff

	// GMAC_SA.SAB: Specific Address 1 Bottom Register
	// Position of ADDR field.
	GMAC_GMAC_SA_SAB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_GMAC_SA_SAB_ADDR_Msk = 0xffffffff

	// GMAC_SA.SAT: Specific Address 1 Top Register
	// Position of ADDR field.
	GMAC_GMAC_SA_SAT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_GMAC_SA_SAT_ADDR_Msk = 0xffff

	// TIDM1: Type ID Match 1 Register
	// Position of TID field.
	GMAC_TIDM1_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM1_TID_Msk = 0xffff
	// Position of ENID1 field.
	GMAC_TIDM1_ENID1_Pos = 0x1f
	// Bit mask of ENID1 field.
	GMAC_TIDM1_ENID1_Msk = 0x80000000
	// Bit ENID1.
	GMAC_TIDM1_ENID1 = 0x80000000

	// TIDM2: Type ID Match 2 Register
	// Position of TID field.
	GMAC_TIDM2_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM2_TID_Msk = 0xffff
	// Position of ENID2 field.
	GMAC_TIDM2_ENID2_Pos = 0x1f
	// Bit mask of ENID2 field.
	GMAC_TIDM2_ENID2_Msk = 0x80000000
	// Bit ENID2.
	GMAC_TIDM2_ENID2 = 0x80000000

	// TIDM3: Type ID Match 3 Register
	// Position of TID field.
	GMAC_TIDM3_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM3_TID_Msk = 0xffff
	// Position of ENID3 field.
	GMAC_TIDM3_ENID3_Pos = 0x1f
	// Bit mask of ENID3 field.
	GMAC_TIDM3_ENID3_Msk = 0x80000000
	// Bit ENID3.
	GMAC_TIDM3_ENID3 = 0x80000000

	// TIDM4: Type ID Match 4 Register
	// Position of TID field.
	GMAC_TIDM4_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM4_TID_Msk = 0xffff
	// Position of ENID4 field.
	GMAC_TIDM4_ENID4_Pos = 0x1f
	// Bit mask of ENID4 field.
	GMAC_TIDM4_ENID4_Msk = 0x80000000
	// Bit ENID4.
	GMAC_TIDM4_ENID4 = 0x80000000

	// WOL: Wake on LAN Register
	// Position of IP field.
	GMAC_WOL_IP_Pos = 0x0
	// Bit mask of IP field.
	GMAC_WOL_IP_Msk = 0xffff
	// Position of MAG field.
	GMAC_WOL_MAG_Pos = 0x10
	// Bit mask of MAG field.
	GMAC_WOL_MAG_Msk = 0x10000
	// Bit MAG.
	GMAC_WOL_MAG = 0x10000
	// Position of ARP field.
	GMAC_WOL_ARP_Pos = 0x11
	// Bit mask of ARP field.
	GMAC_WOL_ARP_Msk = 0x20000
	// Bit ARP.
	GMAC_WOL_ARP = 0x20000
	// Position of SA1 field.
	GMAC_WOL_SA1_Pos = 0x12
	// Bit mask of SA1 field.
	GMAC_WOL_SA1_Msk = 0x40000
	// Bit SA1.
	GMAC_WOL_SA1 = 0x40000
	// Position of MTI field.
	GMAC_WOL_MTI_Pos = 0x13
	// Bit mask of MTI field.
	GMAC_WOL_MTI_Msk = 0x80000
	// Bit MTI.
	GMAC_WOL_MTI = 0x80000

	// IPGS: IPG Stretch Register
	// Position of FL field.
	GMAC_IPGS_FL_Pos = 0x0
	// Bit mask of FL field.
	GMAC_IPGS_FL_Msk = 0xffff

	// SVLAN: Stacked VLAN Register
	// Position of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Pos = 0x0
	// Bit mask of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Msk = 0xffff
	// Position of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Pos = 0x1f
	// Bit mask of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Msk = 0x80000000
	// Bit ESVLAN.
	GMAC_SVLAN_ESVLAN = 0x80000000

	// TPFCP: Transmit PFC Pause Register
	// Position of PEV field.
	GMAC_TPFCP_PEV_Pos = 0x0
	// Bit mask of PEV field.
	GMAC_TPFCP_PEV_Msk = 0xff
	// Position of PQ field.
	GMAC_TPFCP_PQ_Pos = 0x8
	// Bit mask of PQ field.
	GMAC_TPFCP_PQ_Msk = 0xff00

	// SAMB1: Specific Address 1 Mask Bottom Register
	// Position of ADDR field.
	GMAC_SAMB1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMB1_ADDR_Msk = 0xffffffff

	// SAMT1: Specific Address 1 Mask Top Register
	// Position of ADDR field.
	GMAC_SAMT1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMT1_ADDR_Msk = 0xffff

	// NSC: 1588 Timer Nanosecond Comparison Register
	// Position of NANOSEC field.
	GMAC_NSC_NANOSEC_Pos = 0x0
	// Bit mask of NANOSEC field.
	GMAC_NSC_NANOSEC_Msk = 0x3fffff

	// SCL: 1588 Timer Second Comparison Low Register
	// Position of SEC field.
	GMAC_SCL_SEC_Pos = 0x0
	// Bit mask of SEC field.
	GMAC_SCL_SEC_Msk = 0xffffffff

	// SCH: 1588 Timer Second Comparison High Register
	// Position of SEC field.
	GMAC_SCH_SEC_Pos = 0x0
	// Bit mask of SEC field.
	GMAC_SCH_SEC_Msk = 0xffff

	// EFTSH: PTP Event Frame Transmitted Seconds High Register
	// Position of RUD field.
	GMAC_EFTSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTSH_RUD_Msk = 0xffff

	// EFRSH: PTP Event Frame Received Seconds High Register
	// Position of RUD field.
	GMAC_EFRSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRSH_RUD_Msk = 0xffff

	// PEFTSH: PTP Peer Event Frame Transmitted Seconds High Register
	// Position of RUD field.
	GMAC_PEFTSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTSH_RUD_Msk = 0xffff

	// PEFRSH: PTP Peer Event Frame Received Seconds High Register
	// Position of RUD field.
	GMAC_PEFRSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRSH_RUD_Msk = 0xffff

	// OTLO: Octets Transmitted Low Register
	// Position of TXO field.
	GMAC_OTLO_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTLO_TXO_Msk = 0xffffffff

	// OTHI: Octets Transmitted High Register
	// Position of TXO field.
	GMAC_OTHI_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTHI_TXO_Msk = 0xffff

	// FT: Frames Transmitted Register
	// Position of FTX field.
	GMAC_FT_FTX_Pos = 0x0
	// Bit mask of FTX field.
	GMAC_FT_FTX_Msk = 0xffffffff

	// BCFT: Broadcast Frames Transmitted Register
	// Position of BFTX field.
	GMAC_BCFT_BFTX_Pos = 0x0
	// Bit mask of BFTX field.
	GMAC_BCFT_BFTX_Msk = 0xffffffff

	// MFT: Multicast Frames Transmitted Register
	// Position of MFTX field.
	GMAC_MFT_MFTX_Pos = 0x0
	// Bit mask of MFTX field.
	GMAC_MFT_MFTX_Msk = 0xffffffff

	// PFT: Pause Frames Transmitted Register
	// Position of PFTX field.
	GMAC_PFT_PFTX_Pos = 0x0
	// Bit mask of PFTX field.
	GMAC_PFT_PFTX_Msk = 0xffff

	// BFT64: 64 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_BFT64_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_BFT64_NFTX_Msk = 0xffffffff

	// TBFT127: 65 to 127 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT127_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT127_NFTX_Msk = 0xffffffff

	// TBFT255: 128 to 255 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT255_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT255_NFTX_Msk = 0xffffffff

	// TBFT511: 256 to 511 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT511_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT511_NFTX_Msk = 0xffffffff

	// TBFT1023: 512 to 1023 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1023_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1023_NFTX_Msk = 0xffffffff

	// TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1518_NFTX_Msk = 0xffffffff

	// GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_GTBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_GTBFT1518_NFTX_Msk = 0xffffffff

	// TUR: Transmit Underruns Register
	// Position of TXUNR field.
	GMAC_TUR_TXUNR_Pos = 0x0
	// Bit mask of TXUNR field.
	GMAC_TUR_TXUNR_Msk = 0x3ff

	// SCF: Single Collision Frames Register
	// Position of SCOL field.
	GMAC_SCF_SCOL_Pos = 0x0
	// Bit mask of SCOL field.
	GMAC_SCF_SCOL_Msk = 0x3ffff

	// MCF: Multiple Collision Frames Register
	// Position of MCOL field.
	GMAC_MCF_MCOL_Pos = 0x0
	// Bit mask of MCOL field.
	GMAC_MCF_MCOL_Msk = 0x3ffff

	// EC: Excessive Collisions Register
	// Position of XCOL field.
	GMAC_EC_XCOL_Pos = 0x0
	// Bit mask of XCOL field.
	GMAC_EC_XCOL_Msk = 0x3ff

	// LC: Late Collisions Register
	// Position of LCOL field.
	GMAC_LC_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	GMAC_LC_LCOL_Msk = 0x3ff

	// DTF: Deferred Transmission Frames Register
	// Position of DEFT field.
	GMAC_DTF_DEFT_Pos = 0x0
	// Bit mask of DEFT field.
	GMAC_DTF_DEFT_Msk = 0x3ffff

	// CSE: Carrier Sense Errors Register
	// Position of CSR field.
	GMAC_CSE_CSR_Pos = 0x0
	// Bit mask of CSR field.
	GMAC_CSE_CSR_Msk = 0x3ff

	// ORLO: Octets Received Low Received Register
	// Position of RXO field.
	GMAC_ORLO_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORLO_RXO_Msk = 0xffffffff

	// ORHI: Octets Received High Received Register
	// Position of RXO field.
	GMAC_ORHI_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORHI_RXO_Msk = 0xffff

	// FR: Frames Received Register
	// Position of FRX field.
	GMAC_FR_FRX_Pos = 0x0
	// Bit mask of FRX field.
	GMAC_FR_FRX_Msk = 0xffffffff

	// BCFR: Broadcast Frames Received Register
	// Position of BFRX field.
	GMAC_BCFR_BFRX_Pos = 0x0
	// Bit mask of BFRX field.
	GMAC_BCFR_BFRX_Msk = 0xffffffff

	// MFR: Multicast Frames Received Register
	// Position of MFRX field.
	GMAC_MFR_MFRX_Pos = 0x0
	// Bit mask of MFRX field.
	GMAC_MFR_MFRX_Msk = 0xffffffff

	// PFR: Pause Frames Received Register
	// Position of PFRX field.
	GMAC_PFR_PFRX_Pos = 0x0
	// Bit mask of PFRX field.
	GMAC_PFR_PFRX_Msk = 0xffff

	// BFR64: 64 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_BFR64_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_BFR64_NFRX_Msk = 0xffffffff

	// TBFR127: 65 to 127 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR127_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR127_NFRX_Msk = 0xffffffff

	// TBFR255: 128 to 255 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR255_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR255_NFRX_Msk = 0xffffffff

	// TBFR511: 256 to 511 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR511_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR511_NFRX_Msk = 0xffffffff

	// TBFR1023: 512 to 1023 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1023_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1023_NFRX_Msk = 0xffffffff

	// TBFR1518: 1024 to 1518 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1518_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1518_NFRX_Msk = 0xffffffff

	// TMXBFR: 1519 to Maximum Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TMXBFR_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TMXBFR_NFRX_Msk = 0xffffffff

	// UFR: Undersize Frames Received Register
	// Position of UFRX field.
	GMAC_UFR_UFRX_Pos = 0x0
	// Bit mask of UFRX field.
	GMAC_UFR_UFRX_Msk = 0x3ff

	// OFR: Oversize Frames Received Register
	// Position of OFRX field.
	GMAC_OFR_OFRX_Pos = 0x0
	// Bit mask of OFRX field.
	GMAC_OFR_OFRX_Msk = 0x3ff

	// JR: Jabbers Received Register
	// Position of JRX field.
	GMAC_JR_JRX_Pos = 0x0
	// Bit mask of JRX field.
	GMAC_JR_JRX_Msk = 0x3ff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCKR field.
	GMAC_FCSE_FCKR_Pos = 0x0
	// Bit mask of FCKR field.
	GMAC_FCSE_FCKR_Msk = 0x3ff

	// LFFE: Length Field Frame Errors Register
	// Position of LFER field.
	GMAC_LFFE_LFER_Pos = 0x0
	// Bit mask of LFER field.
	GMAC_LFFE_LFER_Msk = 0x3ff

	// RSE: Receive Symbol Errors Register
	// Position of RXSE field.
	GMAC_RSE_RXSE_Pos = 0x0
	// Bit mask of RXSE field.
	GMAC_RSE_RXSE_Msk = 0x3ff

	// AE: Alignment Errors Register
	// Position of AER field.
	GMAC_AE_AER_Pos = 0x0
	// Bit mask of AER field.
	GMAC_AE_AER_Msk = 0x3ff

	// RRE: Receive Resource Errors Register
	// Position of RXRER field.
	GMAC_RRE_RXRER_Pos = 0x0
	// Bit mask of RXRER field.
	GMAC_RRE_RXRER_Msk = 0x3ffff

	// ROE: Receive Overrun Register
	// Position of RXOVR field.
	GMAC_ROE_RXOVR_Pos = 0x0
	// Bit mask of RXOVR field.
	GMAC_ROE_RXOVR_Msk = 0x3ff

	// IHCE: IP Header Checksum Errors Register
	// Position of HCKER field.
	GMAC_IHCE_HCKER_Pos = 0x0
	// Bit mask of HCKER field.
	GMAC_IHCE_HCKER_Msk = 0xff

	// TCE: TCP Checksum Errors Register
	// Position of TCKER field.
	GMAC_TCE_TCKER_Pos = 0x0
	// Bit mask of TCKER field.
	GMAC_TCE_TCKER_Msk = 0xff

	// UCE: UDP Checksum Errors Register
	// Position of UCKER field.
	GMAC_UCE_UCKER_Pos = 0x0
	// Bit mask of UCKER field.
	GMAC_UCE_UCKER_Msk = 0xff

	// TISUBN: 1588 Timer Increment Sub-nanoseconds Register
	// Position of LSBTIR field.
	GMAC_TISUBN_LSBTIR_Pos = 0x0
	// Bit mask of LSBTIR field.
	GMAC_TISUBN_LSBTIR_Msk = 0xffff

	// TSH: 1588 Timer Seconds High Register
	// Position of TCS field.
	GMAC_TSH_TCS_Pos = 0x0
	// Bit mask of TCS field.
	GMAC_TSH_TCS_Msk = 0xffff

	// TSL: 1588 Timer Seconds Low Register
	// Position of TCS field.
	GMAC_TSL_TCS_Pos = 0x0
	// Bit mask of TCS field.
	GMAC_TSL_TCS_Msk = 0xffffffff

	// TN: 1588 Timer Nanoseconds Register
	// Position of TNS field.
	GMAC_TN_TNS_Pos = 0x0
	// Bit mask of TNS field.
	GMAC_TN_TNS_Msk = 0x3fffffff

	// TA: 1588 Timer Adjust Register
	// Position of ITDT field.
	GMAC_TA_ITDT_Pos = 0x0
	// Bit mask of ITDT field.
	GMAC_TA_ITDT_Msk = 0x3fffffff
	// Position of ADJ field.
	GMAC_TA_ADJ_Pos = 0x1f
	// Bit mask of ADJ field.
	GMAC_TA_ADJ_Msk = 0x80000000
	// Bit ADJ.
	GMAC_TA_ADJ = 0x80000000

	// TI: 1588 Timer Increment Register
	// Position of CNS field.
	GMAC_TI_CNS_Pos = 0x0
	// Bit mask of CNS field.
	GMAC_TI_CNS_Msk = 0xff
	// Position of ACNS field.
	GMAC_TI_ACNS_Pos = 0x8
	// Bit mask of ACNS field.
	GMAC_TI_ACNS_Msk = 0xff00
	// Position of NIT field.
	GMAC_TI_NIT_Pos = 0x10
	// Bit mask of NIT field.
	GMAC_TI_NIT_Msk = 0xff0000

	// EFTSL: PTP Event Frame Transmitted Seconds Low Register
	// Position of RUD field.
	GMAC_EFTSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTSL_RUD_Msk = 0xffffffff

	// EFTN: PTP Event Frame Transmitted Nanoseconds Register
	// Position of RUD field.
	GMAC_EFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTN_RUD_Msk = 0x3fffffff

	// EFRSL: PTP Event Frame Received Seconds Low Register
	// Position of RUD field.
	GMAC_EFRSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRSL_RUD_Msk = 0xffffffff

	// EFRN: PTP Event Frame Received Nanoseconds Register
	// Position of RUD field.
	GMAC_EFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRN_RUD_Msk = 0x3fffffff

	// PEFTSL: PTP Peer Event Frame Transmitted Seconds Low Register
	// Position of RUD field.
	GMAC_PEFTSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTSL_RUD_Msk = 0xffffffff

	// PEFTN: PTP Peer Event Frame Transmitted Nanoseconds Register
	// Position of RUD field.
	GMAC_PEFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTN_RUD_Msk = 0x3fffffff

	// PEFRSL: PTP Peer Event Frame Received Seconds Low Register
	// Position of RUD field.
	GMAC_PEFRSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRSL_RUD_Msk = 0xffffffff

	// PEFRN: PTP Peer Event Frame Received Nanoseconds Register
	// Position of RUD field.
	GMAC_PEFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRN_RUD_Msk = 0x3fffffff

	// ISRPQ: Interrupt Status Register Priority Queue (index = 1) 0
	// Position of RCOMP field.
	GMAC_ISRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_ISRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_ISRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_ISRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_ISRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_ISRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_ISRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_ISRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_ISRPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_ISRPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_ISRPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_ISRPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_ISRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_ISRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_ISRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_ISRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_ISRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_ISRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_ISRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_ISRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_ISRPQ_HRESP = 0x800

	// TBQBAPQ: Transmit Buffer Queue Base Address Register Priority Queue (index = 1) 0
	// Position of TXBQBA field.
	GMAC_TBQBAPQ_TXBQBA_Pos = 0x2
	// Bit mask of TXBQBA field.
	GMAC_TBQBAPQ_TXBQBA_Msk = 0xfffffffc

	// RBQBAPQ: Receive Buffer Queue Base Address Register Priority Queue (index = 1) 0
	// Position of RXBQBA field.
	GMAC_RBQBAPQ_RXBQBA_Pos = 0x2
	// Bit mask of RXBQBA field.
	GMAC_RBQBAPQ_RXBQBA_Msk = 0xfffffffc

	// RBSRPQ: Receive Buffer Size Register Priority Queue (index = 1) 0
	// Position of RBS field.
	GMAC_RBSRPQ_RBS_Pos = 0x0
	// Bit mask of RBS field.
	GMAC_RBSRPQ_RBS_Msk = 0xffff

	// CBSCR: Credit-Based Shaping Control Register
	// Position of QBE field.
	GMAC_CBSCR_QBE_Pos = 0x0
	// Bit mask of QBE field.
	GMAC_CBSCR_QBE_Msk = 0x1
	// Bit QBE.
	GMAC_CBSCR_QBE = 0x1
	// Position of QAE field.
	GMAC_CBSCR_QAE_Pos = 0x1
	// Bit mask of QAE field.
	GMAC_CBSCR_QAE_Msk = 0x2
	// Bit QAE.
	GMAC_CBSCR_QAE = 0x2

	// CBSISQA: Credit-Based Shaping IdleSlope Register for Queue A
	// Position of IS field.
	GMAC_CBSISQA_IS_Pos = 0x0
	// Bit mask of IS field.
	GMAC_CBSISQA_IS_Msk = 0xffffffff

	// CBSISQB: Credit-Based Shaping IdleSlope Register for Queue B
	// Position of IS field.
	GMAC_CBSISQB_IS_Pos = 0x0
	// Bit mask of IS field.
	GMAC_CBSISQB_IS_Msk = 0xffffffff

	// ST1RPQ: Screening Type 1 Register Priority Queue (index = 0) 0
	// Position of QNB field.
	GMAC_ST1RPQ_QNB_Pos = 0x0
	// Bit mask of QNB field.
	GMAC_ST1RPQ_QNB_Msk = 0x7
	// Position of DSTCM field.
	GMAC_ST1RPQ_DSTCM_Pos = 0x4
	// Bit mask of DSTCM field.
	GMAC_ST1RPQ_DSTCM_Msk = 0xff0
	// Position of UDPM field.
	GMAC_ST1RPQ_UDPM_Pos = 0xc
	// Bit mask of UDPM field.
	GMAC_ST1RPQ_UDPM_Msk = 0xffff000
	// Position of DSTCE field.
	GMAC_ST1RPQ_DSTCE_Pos = 0x1c
	// Bit mask of DSTCE field.
	GMAC_ST1RPQ_DSTCE_Msk = 0x10000000
	// Bit DSTCE.
	GMAC_ST1RPQ_DSTCE = 0x10000000
	// Position of UDPE field.
	GMAC_ST1RPQ_UDPE_Pos = 0x1d
	// Bit mask of UDPE field.
	GMAC_ST1RPQ_UDPE_Msk = 0x20000000
	// Bit UDPE.
	GMAC_ST1RPQ_UDPE = 0x20000000

	// ST2RPQ: Screening Type 2 Register Priority Queue (index = 0) 0
	// Position of QNB field.
	GMAC_ST2RPQ_QNB_Pos = 0x0
	// Bit mask of QNB field.
	GMAC_ST2RPQ_QNB_Msk = 0x7
	// Position of VLANP field.
	GMAC_ST2RPQ_VLANP_Pos = 0x4
	// Bit mask of VLANP field.
	GMAC_ST2RPQ_VLANP_Msk = 0x70
	// Position of VLANE field.
	GMAC_ST2RPQ_VLANE_Pos = 0x8
	// Bit mask of VLANE field.
	GMAC_ST2RPQ_VLANE_Msk = 0x100
	// Bit VLANE.
	GMAC_ST2RPQ_VLANE = 0x100
	// Position of I2ETH field.
	GMAC_ST2RPQ_I2ETH_Pos = 0x9
	// Bit mask of I2ETH field.
	GMAC_ST2RPQ_I2ETH_Msk = 0xe00
	// Position of ETHE field.
	GMAC_ST2RPQ_ETHE_Pos = 0xc
	// Bit mask of ETHE field.
	GMAC_ST2RPQ_ETHE_Msk = 0x1000
	// Bit ETHE.
	GMAC_ST2RPQ_ETHE = 0x1000
	// Position of COMPA field.
	GMAC_ST2RPQ_COMPA_Pos = 0xd
	// Bit mask of COMPA field.
	GMAC_ST2RPQ_COMPA_Msk = 0x3e000
	// Position of COMPAE field.
	GMAC_ST2RPQ_COMPAE_Pos = 0x12
	// Bit mask of COMPAE field.
	GMAC_ST2RPQ_COMPAE_Msk = 0x40000
	// Bit COMPAE.
	GMAC_ST2RPQ_COMPAE = 0x40000
	// Position of COMPB field.
	GMAC_ST2RPQ_COMPB_Pos = 0x13
	// Bit mask of COMPB field.
	GMAC_ST2RPQ_COMPB_Msk = 0xf80000
	// Position of COMPBE field.
	GMAC_ST2RPQ_COMPBE_Pos = 0x18
	// Bit mask of COMPBE field.
	GMAC_ST2RPQ_COMPBE_Msk = 0x1000000
	// Bit COMPBE.
	GMAC_ST2RPQ_COMPBE = 0x1000000
	// Position of COMPC field.
	GMAC_ST2RPQ_COMPC_Pos = 0x19
	// Bit mask of COMPC field.
	GMAC_ST2RPQ_COMPC_Msk = 0x3e000000
	// Position of COMPCE field.
	GMAC_ST2RPQ_COMPCE_Pos = 0x1e
	// Bit mask of COMPCE field.
	GMAC_ST2RPQ_COMPCE_Msk = 0x40000000
	// Bit COMPCE.
	GMAC_ST2RPQ_COMPCE = 0x40000000

	// IERPQ: Interrupt Enable Register Priority Queue (index = 1) 0
	// Position of RCOMP field.
	GMAC_IERPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IERPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IERPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IERPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IERPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IERPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IERPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IERPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IERPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_IERPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IERPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IERPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IERPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IERPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IERPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IERPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IERPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IERPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IERPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IERPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IERPQ_HRESP = 0x800

	// IDRPQ: Interrupt Disable Register Priority Queue (index = 1) 0
	// Position of RCOMP field.
	GMAC_IDRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IDRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IDRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IDRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IDRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IDRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IDRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IDRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IDRPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_IDRPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IDRPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IDRPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IDRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IDRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IDRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IDRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IDRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IDRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IDRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IDRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IDRPQ_HRESP = 0x800

	// IMRPQ: Interrupt Mask Register Priority Queue (index = 1) 0
	// Position of RCOMP field.
	GMAC_IMRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IMRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IMRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IMRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IMRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IMRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IMRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IMRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IMRPQ_RLEX = 0x20
	// Position of AHB field.
	GMAC_IMRPQ_AHB_Pos = 0x6
	// Bit mask of AHB field.
	GMAC_IMRPQ_AHB_Msk = 0x40
	// Bit AHB.
	GMAC_IMRPQ_AHB = 0x40
	// Position of TCOMP field.
	GMAC_IMRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IMRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IMRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IMRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IMRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IMRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IMRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IMRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IMRPQ_HRESP = 0x800

	// ST2ER: Screening Type 2 Ethertype Register (index = 0) 0
	// Position of COMPVAL field.
	GMAC_ST2ER_COMPVAL_Pos = 0x0
	// Bit mask of COMPVAL field.
	GMAC_ST2ER_COMPVAL_Msk = 0xffff

	// ST2CW00: Screening Type 2 Compare Word 0 Register (index = 0)
	// Position of MASKVAL field.
	GMAC_ST2CW00_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW00_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW00_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW00_COMPVAL_Msk = 0xffff0000

	// ST2CW10: Screening Type 2 Compare Word 1 Register (index = 0)
	// Position of OFFSVAL field.
	GMAC_ST2CW10_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW10_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW10_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW10_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW10_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW10_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW10_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW10_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW01: Screening Type 2 Compare Word 0 Register (index = 1)
	// Position of MASKVAL field.
	GMAC_ST2CW01_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW01_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW01_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW01_COMPVAL_Msk = 0xffff0000

	// ST2CW11: Screening Type 2 Compare Word 1 Register (index = 1)
	// Position of OFFSVAL field.
	GMAC_ST2CW11_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW11_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW11_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW11_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW11_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW11_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW11_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW11_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW02: Screening Type 2 Compare Word 0 Register (index = 2)
	// Position of MASKVAL field.
	GMAC_ST2CW02_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW02_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW02_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW02_COMPVAL_Msk = 0xffff0000

	// ST2CW12: Screening Type 2 Compare Word 1 Register (index = 2)
	// Position of OFFSVAL field.
	GMAC_ST2CW12_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW12_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW12_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW12_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW12_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW12_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW12_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW12_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW03: Screening Type 2 Compare Word 0 Register (index = 3)
	// Position of MASKVAL field.
	GMAC_ST2CW03_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW03_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW03_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW03_COMPVAL_Msk = 0xffff0000

	// ST2CW13: Screening Type 2 Compare Word 1 Register (index = 3)
	// Position of OFFSVAL field.
	GMAC_ST2CW13_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW13_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW13_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW13_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW13_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW13_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW13_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW13_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW04: Screening Type 2 Compare Word 0 Register (index = 4)
	// Position of MASKVAL field.
	GMAC_ST2CW04_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW04_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW04_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW04_COMPVAL_Msk = 0xffff0000

	// ST2CW14: Screening Type 2 Compare Word 1 Register (index = 4)
	// Position of OFFSVAL field.
	GMAC_ST2CW14_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW14_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW14_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW14_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW14_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW14_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW14_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW14_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW05: Screening Type 2 Compare Word 0 Register (index = 5)
	// Position of MASKVAL field.
	GMAC_ST2CW05_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW05_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW05_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW05_COMPVAL_Msk = 0xffff0000

	// ST2CW15: Screening Type 2 Compare Word 1 Register (index = 5)
	// Position of OFFSVAL field.
	GMAC_ST2CW15_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW15_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW15_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW15_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW15_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW15_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW15_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW15_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW06: Screening Type 2 Compare Word 0 Register (index = 6)
	// Position of MASKVAL field.
	GMAC_ST2CW06_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW06_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW06_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW06_COMPVAL_Msk = 0xffff0000

	// ST2CW16: Screening Type 2 Compare Word 1 Register (index = 6)
	// Position of OFFSVAL field.
	GMAC_ST2CW16_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW16_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW16_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW16_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW16_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW16_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW16_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW16_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW07: Screening Type 2 Compare Word 0 Register (index = 7)
	// Position of MASKVAL field.
	GMAC_ST2CW07_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW07_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW07_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW07_COMPVAL_Msk = 0xffff0000

	// ST2CW17: Screening Type 2 Compare Word 1 Register (index = 7)
	// Position of OFFSVAL field.
	GMAC_ST2CW17_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW17_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW17_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW17_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW17_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW17_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW17_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW17_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW08: Screening Type 2 Compare Word 0 Register (index = 8)
	// Position of MASKVAL field.
	GMAC_ST2CW08_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW08_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW08_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW08_COMPVAL_Msk = 0xffff0000

	// ST2CW18: Screening Type 2 Compare Word 1 Register (index = 8)
	// Position of OFFSVAL field.
	GMAC_ST2CW18_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW18_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW18_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW18_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW18_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW18_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW18_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW18_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW09: Screening Type 2 Compare Word 0 Register (index = 9)
	// Position of MASKVAL field.
	GMAC_ST2CW09_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW09_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW09_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW09_COMPVAL_Msk = 0xffff0000

	// ST2CW19: Screening Type 2 Compare Word 1 Register (index = 9)
	// Position of OFFSVAL field.
	GMAC_ST2CW19_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW19_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW19_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW19_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW19_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW19_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW19_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW19_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW010: Screening Type 2 Compare Word 0 Register (index = 10)
	// Position of MASKVAL field.
	GMAC_ST2CW010_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW010_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW010_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW010_COMPVAL_Msk = 0xffff0000

	// ST2CW110: Screening Type 2 Compare Word 1 Register (index = 10)
	// Position of OFFSVAL field.
	GMAC_ST2CW110_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW110_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW110_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW110_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW110_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW110_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW110_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW110_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW011: Screening Type 2 Compare Word 0 Register (index = 11)
	// Position of MASKVAL field.
	GMAC_ST2CW011_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW011_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW011_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW011_COMPVAL_Msk = 0xffff0000

	// ST2CW111: Screening Type 2 Compare Word 1 Register (index = 11)
	// Position of OFFSVAL field.
	GMAC_ST2CW111_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW111_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW111_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW111_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW111_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW111_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW111_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW111_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW012: Screening Type 2 Compare Word 0 Register (index = 12)
	// Position of MASKVAL field.
	GMAC_ST2CW012_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW012_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW012_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW012_COMPVAL_Msk = 0xffff0000

	// ST2CW112: Screening Type 2 Compare Word 1 Register (index = 12)
	// Position of OFFSVAL field.
	GMAC_ST2CW112_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW112_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW112_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW112_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW112_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW112_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW112_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW112_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW013: Screening Type 2 Compare Word 0 Register (index = 13)
	// Position of MASKVAL field.
	GMAC_ST2CW013_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW013_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW013_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW013_COMPVAL_Msk = 0xffff0000

	// ST2CW113: Screening Type 2 Compare Word 1 Register (index = 13)
	// Position of OFFSVAL field.
	GMAC_ST2CW113_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW113_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW113_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW113_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW113_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW113_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW113_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW113_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW014: Screening Type 2 Compare Word 0 Register (index = 14)
	// Position of MASKVAL field.
	GMAC_ST2CW014_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW014_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW014_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW014_COMPVAL_Msk = 0xffff0000

	// ST2CW114: Screening Type 2 Compare Word 1 Register (index = 14)
	// Position of OFFSVAL field.
	GMAC_ST2CW114_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW114_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW114_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW114_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW114_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW114_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW114_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW114_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW015: Screening Type 2 Compare Word 0 Register (index = 15)
	// Position of MASKVAL field.
	GMAC_ST2CW015_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW015_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW015_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW015_COMPVAL_Msk = 0xffff0000

	// ST2CW115: Screening Type 2 Compare Word 1 Register (index = 15)
	// Position of OFFSVAL field.
	GMAC_ST2CW115_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW115_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW115_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW115_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW115_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW115_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW115_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW115_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW016: Screening Type 2 Compare Word 0 Register (index = 16)
	// Position of MASKVAL field.
	GMAC_ST2CW016_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW016_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW016_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW016_COMPVAL_Msk = 0xffff0000

	// ST2CW116: Screening Type 2 Compare Word 1 Register (index = 16)
	// Position of OFFSVAL field.
	GMAC_ST2CW116_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW116_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW116_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW116_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW116_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW116_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW116_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW116_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW017: Screening Type 2 Compare Word 0 Register (index = 17)
	// Position of MASKVAL field.
	GMAC_ST2CW017_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW017_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW017_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW017_COMPVAL_Msk = 0xffff0000

	// ST2CW117: Screening Type 2 Compare Word 1 Register (index = 17)
	// Position of OFFSVAL field.
	GMAC_ST2CW117_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW117_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW117_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW117_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW117_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW117_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW117_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW117_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW018: Screening Type 2 Compare Word 0 Register (index = 18)
	// Position of MASKVAL field.
	GMAC_ST2CW018_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW018_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW018_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW018_COMPVAL_Msk = 0xffff0000

	// ST2CW118: Screening Type 2 Compare Word 1 Register (index = 18)
	// Position of OFFSVAL field.
	GMAC_ST2CW118_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW118_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW118_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW118_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW118_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW118_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW118_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW118_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW019: Screening Type 2 Compare Word 0 Register (index = 19)
	// Position of MASKVAL field.
	GMAC_ST2CW019_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW019_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW019_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW019_COMPVAL_Msk = 0xffff0000

	// ST2CW119: Screening Type 2 Compare Word 1 Register (index = 19)
	// Position of OFFSVAL field.
	GMAC_ST2CW119_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW119_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW119_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW119_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW119_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW119_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW119_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW119_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW020: Screening Type 2 Compare Word 0 Register (index = 20)
	// Position of MASKVAL field.
	GMAC_ST2CW020_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW020_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW020_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW020_COMPVAL_Msk = 0xffff0000

	// ST2CW120: Screening Type 2 Compare Word 1 Register (index = 20)
	// Position of OFFSVAL field.
	GMAC_ST2CW120_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW120_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW120_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW120_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW120_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW120_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW120_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW120_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW021: Screening Type 2 Compare Word 0 Register (index = 21)
	// Position of MASKVAL field.
	GMAC_ST2CW021_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW021_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW021_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW021_COMPVAL_Msk = 0xffff0000

	// ST2CW121: Screening Type 2 Compare Word 1 Register (index = 21)
	// Position of OFFSVAL field.
	GMAC_ST2CW121_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW121_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW121_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW121_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW121_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW121_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW121_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW121_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW022: Screening Type 2 Compare Word 0 Register (index = 22)
	// Position of MASKVAL field.
	GMAC_ST2CW022_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW022_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW022_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW022_COMPVAL_Msk = 0xffff0000

	// ST2CW122: Screening Type 2 Compare Word 1 Register (index = 22)
	// Position of OFFSVAL field.
	GMAC_ST2CW122_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW122_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW122_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW122_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW122_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW122_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW122_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW122_OFFSSTRT_TCP_UDP = 0x3

	// ST2CW023: Screening Type 2 Compare Word 0 Register (index = 23)
	// Position of MASKVAL field.
	GMAC_ST2CW023_MASKVAL_Pos = 0x0
	// Bit mask of MASKVAL field.
	GMAC_ST2CW023_MASKVAL_Msk = 0xffff
	// Position of COMPVAL field.
	GMAC_ST2CW023_COMPVAL_Pos = 0x10
	// Bit mask of COMPVAL field.
	GMAC_ST2CW023_COMPVAL_Msk = 0xffff0000

	// ST2CW123: Screening Type 2 Compare Word 1 Register (index = 23)
	// Position of OFFSVAL field.
	GMAC_ST2CW123_OFFSVAL_Pos = 0x0
	// Bit mask of OFFSVAL field.
	GMAC_ST2CW123_OFFSVAL_Msk = 0x7f
	// Position of OFFSSTRT field.
	GMAC_ST2CW123_OFFSSTRT_Pos = 0x7
	// Bit mask of OFFSSTRT field.
	GMAC_ST2CW123_OFFSSTRT_Msk = 0x180
	// Offset from the start of the frame
	GMAC_ST2CW123_OFFSSTRT_FRAMESTART = 0x0
	// Offset from the byte after the EtherType field
	GMAC_ST2CW123_OFFSSTRT_ETHERTYPE = 0x1
	// Offset from the byte after the IP header field
	GMAC_ST2CW123_OFFSSTRT_IP = 0x2
	// Offset from the byte after the TCP/UDP header field
	GMAC_ST2CW123_OFFSSTRT_TCP_UDP = 0x3
)

// Constants for GPBR: General Purpose Backup Registers
const (
	// SYS_GPBR: General Purpose Backup Register 0
	// Position of GPBR_VALUE field.
	GPBR_SYS_GPBR_GPBR_VALUE_Pos = 0x0
	// Bit mask of GPBR_VALUE field.
	GPBR_SYS_GPBR_GPBR_VALUE_Msk = 0xffffffff
)

// Constants for ICM: Integrity Check Monitor
const (
	// CFG: Configuration Register
	// Position of WBDIS field.
	ICM_CFG_WBDIS_Pos = 0x0
	// Bit mask of WBDIS field.
	ICM_CFG_WBDIS_Msk = 0x1
	// Bit WBDIS.
	ICM_CFG_WBDIS = 0x1
	// Position of EOMDIS field.
	ICM_CFG_EOMDIS_Pos = 0x1
	// Bit mask of EOMDIS field.
	ICM_CFG_EOMDIS_Msk = 0x2
	// Bit EOMDIS.
	ICM_CFG_EOMDIS = 0x2
	// Position of SLBDIS field.
	ICM_CFG_SLBDIS_Pos = 0x2
	// Bit mask of SLBDIS field.
	ICM_CFG_SLBDIS_Msk = 0x4
	// Bit SLBDIS.
	ICM_CFG_SLBDIS = 0x4
	// Position of BBC field.
	ICM_CFG_BBC_Pos = 0x4
	// Bit mask of BBC field.
	ICM_CFG_BBC_Msk = 0xf0
	// Position of ASCD field.
	ICM_CFG_ASCD_Pos = 0x8
	// Bit mask of ASCD field.
	ICM_CFG_ASCD_Msk = 0x100
	// Bit ASCD.
	ICM_CFG_ASCD = 0x100
	// Position of DUALBUFF field.
	ICM_CFG_DUALBUFF_Pos = 0x9
	// Bit mask of DUALBUFF field.
	ICM_CFG_DUALBUFF_Msk = 0x200
	// Bit DUALBUFF.
	ICM_CFG_DUALBUFF = 0x200
	// Position of UIHASH field.
	ICM_CFG_UIHASH_Pos = 0xc
	// Bit mask of UIHASH field.
	ICM_CFG_UIHASH_Msk = 0x1000
	// Bit UIHASH.
	ICM_CFG_UIHASH = 0x1000
	// Position of UALGO field.
	ICM_CFG_UALGO_Pos = 0xd
	// Bit mask of UALGO field.
	ICM_CFG_UALGO_Msk = 0xe000
	// SHA1 algorithm processed
	ICM_CFG_UALGO_SHA1 = 0x0
	// SHA256 algorithm processed
	ICM_CFG_UALGO_SHA256 = 0x1
	// SHA224 algorithm processed
	ICM_CFG_UALGO_SHA224 = 0x4

	// CTRL: Control Register
	// Position of ENABLE field.
	ICM_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ICM_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ICM_CTRL_ENABLE = 0x1
	// Position of DISABLE field.
	ICM_CTRL_DISABLE_Pos = 0x1
	// Bit mask of DISABLE field.
	ICM_CTRL_DISABLE_Msk = 0x2
	// Bit DISABLE.
	ICM_CTRL_DISABLE = 0x2
	// Position of SWRST field.
	ICM_CTRL_SWRST_Pos = 0x2
	// Bit mask of SWRST field.
	ICM_CTRL_SWRST_Msk = 0x4
	// Bit SWRST.
	ICM_CTRL_SWRST = 0x4
	// Position of REHASH field.
	ICM_CTRL_REHASH_Pos = 0x4
	// Bit mask of REHASH field.
	ICM_CTRL_REHASH_Msk = 0xf0
	// Position of RMDIS field.
	ICM_CTRL_RMDIS_Pos = 0x8
	// Bit mask of RMDIS field.
	ICM_CTRL_RMDIS_Msk = 0xf00
	// Position of RMEN field.
	ICM_CTRL_RMEN_Pos = 0xc
	// Bit mask of RMEN field.
	ICM_CTRL_RMEN_Msk = 0xf000

	// SR: Status Register
	// Position of ENABLE field.
	ICM_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ICM_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ICM_SR_ENABLE = 0x1
	// Position of RAWRMDIS field.
	ICM_SR_RAWRMDIS_Pos = 0x8
	// Bit mask of RAWRMDIS field.
	ICM_SR_RAWRMDIS_Msk = 0xf00
	// Position of RMDIS field.
	ICM_SR_RMDIS_Pos = 0xc
	// Bit mask of RMDIS field.
	ICM_SR_RMDIS_Msk = 0xf000

	// IER: Interrupt Enable Register
	// Position of RHC field.
	ICM_IER_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IER_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IER_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IER_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IER_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IER_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IER_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IER_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IER_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IER_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IER_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IER_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IER_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IER_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IER_URAD = 0x1000000

	// IDR: Interrupt Disable Register
	// Position of RHC field.
	ICM_IDR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IDR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IDR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IDR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IDR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IDR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IDR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IDR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IDR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IDR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IDR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IDR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IDR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IDR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IDR_URAD = 0x1000000

	// IMR: Interrupt Mask Register
	// Position of RHC field.
	ICM_IMR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IMR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IMR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IMR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IMR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IMR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IMR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IMR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IMR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IMR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IMR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IMR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IMR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IMR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IMR_URAD = 0x1000000

	// ISR: Interrupt Status Register
	// Position of RHC field.
	ICM_ISR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_ISR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_ISR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_ISR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_ISR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_ISR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_ISR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_ISR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_ISR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_ISR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_ISR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_ISR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_ISR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_ISR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_ISR_URAD = 0x1000000

	// UASR: Undefined Access Status Register
	// Position of URAT field.
	ICM_UASR_URAT_Pos = 0x0
	// Bit mask of URAT field.
	ICM_UASR_URAT_Msk = 0x7
	// Unspecified structure member set to one detected when the descriptor is loaded.
	ICM_UASR_URAT_UNSPEC_STRUCT_MEMBER = 0x0
	// ICM_CFG modified during active monitoring.
	ICM_UASR_URAT_ICM_CFG_MODIFIED = 0x1
	// ICM_DSCR modified during active monitoring.
	ICM_UASR_URAT_ICM_DSCR_MODIFIED = 0x2
	// ICM_HASH modified during active monitoring
	ICM_UASR_URAT_ICM_HASH_MODIFIED = 0x3
	// Write-only register read access
	ICM_UASR_URAT_READ_ACCESS = 0x4

	// DSCR: Region Descriptor Area Start Address Register
	// Position of DASA field.
	ICM_DSCR_DASA_Pos = 0x6
	// Bit mask of DASA field.
	ICM_DSCR_DASA_Msk = 0xffffffc0

	// HASH: Region Hash Area Start Address Register
	// Position of HASA field.
	ICM_HASH_HASA_Pos = 0x7
	// Bit mask of HASA field.
	ICM_HASH_HASA_Msk = 0xffffff80

	// UIHVAL: User Initial Hash Value 0 Register 0
	// Position of VAL field.
	ICM_UIHVAL_VAL_Pos = 0x0
	// Bit mask of VAL field.
	ICM_UIHVAL_VAL_Msk = 0xffffffff
)

// Constants for ISI: Image Sensor Interface
const (
	// CFG1: ISI Configuration 1 Register
	// Position of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Pos = 0x2
	// Bit mask of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Msk = 0x4
	// Bit HSYNC_POL.
	ISI_CFG1_HSYNC_POL = 0x4
	// Position of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Pos = 0x3
	// Bit mask of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Msk = 0x8
	// Bit VSYNC_POL.
	ISI_CFG1_VSYNC_POL = 0x8
	// Position of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Pos = 0x4
	// Bit mask of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Msk = 0x10
	// Bit PIXCLK_POL.
	ISI_CFG1_PIXCLK_POL = 0x10
	// Position of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Pos = 0x6
	// Bit mask of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Msk = 0x40
	// Bit EMB_SYNC.
	ISI_CFG1_EMB_SYNC = 0x40
	// Position of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Pos = 0x7
	// Bit mask of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Msk = 0x80
	// Bit CRC_SYNC.
	ISI_CFG1_CRC_SYNC = 0x80
	// Position of FRATE field.
	ISI_CFG1_FRATE_Pos = 0x8
	// Bit mask of FRATE field.
	ISI_CFG1_FRATE_Msk = 0x700
	// Position of DISCR field.
	ISI_CFG1_DISCR_Pos = 0xb
	// Bit mask of DISCR field.
	ISI_CFG1_DISCR_Msk = 0x800
	// Bit DISCR.
	ISI_CFG1_DISCR = 0x800
	// Position of FULL field.
	ISI_CFG1_FULL_Pos = 0xc
	// Bit mask of FULL field.
	ISI_CFG1_FULL_Msk = 0x1000
	// Bit FULL.
	ISI_CFG1_FULL = 0x1000
	// Position of THMASK field.
	ISI_CFG1_THMASK_Pos = 0xd
	// Bit mask of THMASK field.
	ISI_CFG1_THMASK_Msk = 0x6000
	// Only 4 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_4 = 0x0
	// Only 4 and 8 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_8 = 0x1
	// 4, 8 and 16 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_16 = 0x2
	// Position of SLD field.
	ISI_CFG1_SLD_Pos = 0x10
	// Bit mask of SLD field.
	ISI_CFG1_SLD_Msk = 0xff0000
	// Position of SFD field.
	ISI_CFG1_SFD_Pos = 0x18
	// Bit mask of SFD field.
	ISI_CFG1_SFD_Msk = 0xff000000

	// CFG2: ISI Configuration 2 Register
	// Position of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Pos = 0x0
	// Bit mask of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Msk = 0x7ff
	// Position of GS_MODE field.
	ISI_CFG2_GS_MODE_Pos = 0xb
	// Bit mask of GS_MODE field.
	ISI_CFG2_GS_MODE_Msk = 0x800
	// Bit GS_MODE.
	ISI_CFG2_GS_MODE = 0x800
	// Position of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Pos = 0xc
	// Bit mask of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Msk = 0x1000
	// Bit RGB_MODE.
	ISI_CFG2_RGB_MODE = 0x1000
	// Position of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Pos = 0xd
	// Bit mask of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Msk = 0x2000
	// Bit GRAYSCALE.
	ISI_CFG2_GRAYSCALE = 0x2000
	// Position of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Pos = 0xe
	// Bit mask of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Msk = 0x4000
	// Bit RGB_SWAP.
	ISI_CFG2_RGB_SWAP = 0x4000
	// Position of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Pos = 0xf
	// Bit mask of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Msk = 0x8000
	// Bit COL_SPACE.
	ISI_CFG2_COL_SPACE = 0x8000
	// Position of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Pos = 0x10
	// Bit mask of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Msk = 0x7ff0000
	// Position of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Pos = 0x1c
	// Bit mask of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Msk = 0x30000000
	// Byte 0 Cb(i)Byte 1 Y(i)Byte 2 Cr(i)Byte 3 Y(i+1)
	ISI_CFG2_YCC_SWAP_DEFAULT = 0x0
	// Byte 0 Cr(i)Byte 1 Y(i)Byte 2 Cb(i)Byte 3 Y(i+1)
	ISI_CFG2_YCC_SWAP_MODE1 = 0x1
	// Byte 0 Y(i)Byte 1 Cb(i)Byte 2 Y(i+1)Byte 3 Cr(i)
	ISI_CFG2_YCC_SWAP_MODE2 = 0x2
	// Byte 0 Y(i)Byte 1 Cr(i)Byte 2 Y(i+1)Byte 3 Cb(i)
	ISI_CFG2_YCC_SWAP_MODE3 = 0x3
	// Position of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Pos = 0x1e
	// Bit mask of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Msk = 0xc0000000
	// Byte 0 R/G(MSB)Byte 1 G(LSB)/BByte 2 R/G(MSB)Byte 3 G(LSB)/B
	ISI_CFG2_RGB_CFG_DEFAULT = 0x0
	// Byte 0 B/G(MSB)Byte 1 G(LSB)/RByte 2 B/G(MSB)Byte 3 G(LSB)/R
	ISI_CFG2_RGB_CFG_MODE1 = 0x1
	// Byte 0 G(LSB)/RByte 1 B/G(MSB)Byte 2 G(LSB)/RByte 3 B/G(MSB)
	ISI_CFG2_RGB_CFG_MODE2 = 0x2
	// Byte 0 G(LSB)/BByte 1 R/G(MSB)Byte 2 G(LSB)/BByte 3 R/G(MSB)
	ISI_CFG2_RGB_CFG_MODE3 = 0x3

	// PSIZE: ISI Preview Size Register
	// Position of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Pos = 0x0
	// Bit mask of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Msk = 0x3ff
	// Position of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Pos = 0x10
	// Bit mask of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Msk = 0x3ff0000

	// PDECF: ISI Preview Decimation Factor Register
	// Position of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Pos = 0x0
	// Bit mask of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Msk = 0xff

	// Y2R_SET0: ISI Color Space Conversion YCrCb To RGB Set 0 Register
	// Position of C0 field.
	ISI_Y2R_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_Y2R_SET0_C0_Msk = 0xff
	// Position of C1 field.
	ISI_Y2R_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_Y2R_SET0_C1_Msk = 0xff00
	// Position of C2 field.
	ISI_Y2R_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_Y2R_SET0_C2_Msk = 0xff0000
	// Position of C3 field.
	ISI_Y2R_SET0_C3_Pos = 0x18
	// Bit mask of C3 field.
	ISI_Y2R_SET0_C3_Msk = 0xff000000

	// Y2R_SET1: ISI Color Space Conversion YCrCb To RGB Set 1 Register
	// Position of C4 field.
	ISI_Y2R_SET1_C4_Pos = 0x0
	// Bit mask of C4 field.
	ISI_Y2R_SET1_C4_Msk = 0x1ff
	// Position of Yoff field.
	ISI_Y2R_SET1_Yoff_Pos = 0xc
	// Bit mask of Yoff field.
	ISI_Y2R_SET1_Yoff_Msk = 0x1000
	// Bit Yoff.
	ISI_Y2R_SET1_Yoff = 0x1000
	// Position of Croff field.
	ISI_Y2R_SET1_Croff_Pos = 0xd
	// Bit mask of Croff field.
	ISI_Y2R_SET1_Croff_Msk = 0x2000
	// Bit Croff.
	ISI_Y2R_SET1_Croff = 0x2000
	// Position of Cboff field.
	ISI_Y2R_SET1_Cboff_Pos = 0xe
	// Bit mask of Cboff field.
	ISI_Y2R_SET1_Cboff_Msk = 0x4000
	// Bit Cboff.
	ISI_Y2R_SET1_Cboff = 0x4000

	// R2Y_SET0: ISI Color Space Conversion RGB To YCrCb Set 0 Register
	// Position of C0 field.
	ISI_R2Y_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_R2Y_SET0_C0_Msk = 0x7f
	// Position of C1 field.
	ISI_R2Y_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_R2Y_SET0_C1_Msk = 0x7f00
	// Position of C2 field.
	ISI_R2Y_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_R2Y_SET0_C2_Msk = 0x7f0000
	// Position of Roff field.
	ISI_R2Y_SET0_Roff_Pos = 0x18
	// Bit mask of Roff field.
	ISI_R2Y_SET0_Roff_Msk = 0x1000000
	// Bit Roff.
	ISI_R2Y_SET0_Roff = 0x1000000

	// R2Y_SET1: ISI Color Space Conversion RGB To YCrCb Set 1 Register
	// Position of C3 field.
	ISI_R2Y_SET1_C3_Pos = 0x0
	// Bit mask of C3 field.
	ISI_R2Y_SET1_C3_Msk = 0x7f
	// Position of C4 field.
	ISI_R2Y_SET1_C4_Pos = 0x8
	// Bit mask of C4 field.
	ISI_R2Y_SET1_C4_Msk = 0x7f00
	// Position of C5 field.
	ISI_R2Y_SET1_C5_Pos = 0x10
	// Bit mask of C5 field.
	ISI_R2Y_SET1_C5_Msk = 0x7f0000
	// Position of Goff field.
	ISI_R2Y_SET1_Goff_Pos = 0x18
	// Bit mask of Goff field.
	ISI_R2Y_SET1_Goff_Msk = 0x1000000
	// Bit Goff.
	ISI_R2Y_SET1_Goff = 0x1000000

	// R2Y_SET2: ISI Color Space Conversion RGB To YCrCb Set 2 Register
	// Position of C6 field.
	ISI_R2Y_SET2_C6_Pos = 0x0
	// Bit mask of C6 field.
	ISI_R2Y_SET2_C6_Msk = 0x7f
	// Position of C7 field.
	ISI_R2Y_SET2_C7_Pos = 0x8
	// Bit mask of C7 field.
	ISI_R2Y_SET2_C7_Msk = 0x7f00
	// Position of C8 field.
	ISI_R2Y_SET2_C8_Pos = 0x10
	// Bit mask of C8 field.
	ISI_R2Y_SET2_C8_Msk = 0x7f0000
	// Position of Boff field.
	ISI_R2Y_SET2_Boff_Pos = 0x18
	// Bit mask of Boff field.
	ISI_R2Y_SET2_Boff_Msk = 0x1000000
	// Bit Boff.
	ISI_R2Y_SET2_Boff = 0x1000000

	// CR: ISI Control Register
	// Position of ISI_EN field.
	ISI_CR_ISI_EN_Pos = 0x0
	// Bit mask of ISI_EN field.
	ISI_CR_ISI_EN_Msk = 0x1
	// Bit ISI_EN.
	ISI_CR_ISI_EN = 0x1
	// Position of ISI_DIS field.
	ISI_CR_ISI_DIS_Pos = 0x1
	// Bit mask of ISI_DIS field.
	ISI_CR_ISI_DIS_Msk = 0x2
	// Bit ISI_DIS.
	ISI_CR_ISI_DIS = 0x2
	// Position of ISI_SRST field.
	ISI_CR_ISI_SRST_Pos = 0x2
	// Bit mask of ISI_SRST field.
	ISI_CR_ISI_SRST_Msk = 0x4
	// Bit ISI_SRST.
	ISI_CR_ISI_SRST = 0x4
	// Position of ISI_CDC field.
	ISI_CR_ISI_CDC_Pos = 0x8
	// Bit mask of ISI_CDC field.
	ISI_CR_ISI_CDC_Msk = 0x100
	// Bit ISI_CDC.
	ISI_CR_ISI_CDC = 0x100

	// SR: ISI Status Register
	// Position of ENABLE field.
	ISI_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ISI_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ISI_SR_ENABLE = 0x1
	// Position of DIS_DONE field.
	ISI_SR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_SR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_SR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_SR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_SR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_SR_SRST = 0x4
	// Position of CDC_PND field.
	ISI_SR_CDC_PND_Pos = 0x8
	// Bit mask of CDC_PND field.
	ISI_SR_CDC_PND_Msk = 0x100
	// Bit CDC_PND.
	ISI_SR_CDC_PND = 0x100
	// Position of VSYNC field.
	ISI_SR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_SR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_SR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_SR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_SR_CXFR_DONE = 0x20000
	// Position of SIP field.
	ISI_SR_SIP_Pos = 0x13
	// Bit mask of SIP field.
	ISI_SR_SIP_Msk = 0x80000
	// Bit SIP.
	ISI_SR_SIP = 0x80000
	// Position of P_OVR field.
	ISI_SR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_SR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_SR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_SR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_SR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_SR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_SR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_SR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_SR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_SR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_SR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_SR_FR_OVR = 0x8000000

	// IER: ISI Interrupt Enable Register
	// Position of DIS_DONE field.
	ISI_IER_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IER_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IER_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IER_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IER_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IER_SRST = 0x4
	// Position of VSYNC field.
	ISI_IER_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IER_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IER_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IER_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IER_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IER_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IER_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IER_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IER_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IER_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IER_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IER_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IER_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IER_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IER_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IER_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IER_FR_OVR = 0x8000000

	// IDR: ISI Interrupt Disable Register
	// Position of DIS_DONE field.
	ISI_IDR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IDR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IDR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IDR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IDR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IDR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IDR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IDR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IDR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IDR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IDR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IDR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IDR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IDR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IDR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IDR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IDR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IDR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IDR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IDR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IDR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IDR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IDR_FR_OVR = 0x8000000

	// IMR: ISI Interrupt Mask Register
	// Position of DIS_DONE field.
	ISI_IMR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IMR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IMR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IMR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IMR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IMR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IMR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IMR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IMR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IMR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IMR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IMR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IMR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IMR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IMR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IMR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IMR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IMR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IMR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IMR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IMR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IMR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IMR_FR_OVR = 0x8000000

	// DMA_CHER: DMA Channel Enable Register
	// Position of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Pos = 0x0
	// Bit mask of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Msk = 0x1
	// Bit P_CH_EN.
	ISI_DMA_CHER_P_CH_EN = 0x1
	// Position of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Pos = 0x1
	// Bit mask of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Msk = 0x2
	// Bit C_CH_EN.
	ISI_DMA_CHER_C_CH_EN = 0x2

	// DMA_CHDR: DMA Channel Disable Register
	// Position of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Pos = 0x0
	// Bit mask of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Msk = 0x1
	// Bit P_CH_DIS.
	ISI_DMA_CHDR_P_CH_DIS = 0x1
	// Position of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Pos = 0x1
	// Bit mask of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Msk = 0x2
	// Bit C_CH_DIS.
	ISI_DMA_CHDR_C_CH_DIS = 0x2

	// DMA_CHSR: DMA Channel Status Register
	// Position of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Pos = 0x0
	// Bit mask of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Msk = 0x1
	// Bit P_CH_S.
	ISI_DMA_CHSR_P_CH_S = 0x1
	// Position of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Pos = 0x1
	// Bit mask of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Msk = 0x2
	// Bit C_CH_S.
	ISI_DMA_CHSR_C_CH_S = 0x2

	// DMA_P_ADDR: DMA Preview Base Address Register
	// Position of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Pos = 0x2
	// Bit mask of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Msk = 0xfffffffc

	// DMA_P_CTRL: DMA Preview Control Register
	// Position of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Pos = 0x0
	// Bit mask of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Msk = 0x1
	// Bit P_FETCH.
	ISI_DMA_P_CTRL_P_FETCH = 0x1
	// Position of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Pos = 0x1
	// Bit mask of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Msk = 0x2
	// Bit P_WB.
	ISI_DMA_P_CTRL_P_WB = 0x2
	// Position of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Pos = 0x2
	// Bit mask of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Msk = 0x4
	// Bit P_IEN.
	ISI_DMA_P_CTRL_P_IEN = 0x4
	// Position of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Pos = 0x3
	// Bit mask of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Msk = 0x8
	// Bit P_DONE.
	ISI_DMA_P_CTRL_P_DONE = 0x8

	// DMA_P_DSCR: DMA Preview Descriptor Address Register
	// Position of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Pos = 0x2
	// Bit mask of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Msk = 0xfffffffc

	// DMA_C_ADDR: DMA Codec Base Address Register
	// Position of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Pos = 0x2
	// Bit mask of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Msk = 0xfffffffc

	// DMA_C_CTRL: DMA Codec Control Register
	// Position of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Pos = 0x0
	// Bit mask of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Msk = 0x1
	// Bit C_FETCH.
	ISI_DMA_C_CTRL_C_FETCH = 0x1
	// Position of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Pos = 0x1
	// Bit mask of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Msk = 0x2
	// Bit C_WB.
	ISI_DMA_C_CTRL_C_WB = 0x2
	// Position of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Pos = 0x2
	// Bit mask of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Msk = 0x4
	// Bit C_IEN.
	ISI_DMA_C_CTRL_C_IEN = 0x4
	// Position of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Pos = 0x3
	// Bit mask of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Msk = 0x8
	// Bit C_DONE.
	ISI_DMA_C_CTRL_C_DONE = 0x8

	// DMA_C_DSCR: DMA Codec Descriptor Address Register
	// Position of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Pos = 0x2
	// Bit mask of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Msk = 0xfffffffc

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	ISI_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	ISI_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	ISI_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	ISI_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	ISI_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0.
	ISI_WPMR_WPKEY_PASSWD = 0x495349

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	ISI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	ISI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	ISI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	ISI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	ISI_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MATRIX: AHB Bus Matrix
const (
	// MCFG: Master Configuration Register 0
	// Position of ULBT field.
	MATRIX_MCFG_ULBT_Pos = 0x0
	// Bit mask of ULBT field.
	MATRIX_MCFG_ULBT_Msk = 0x7
	// Unlimited Length Burst-No predicted end of burst is generated, therefore INCR bursts coming from this master can only be broken if the Slave Slot Cycle Limit is reached. If the Slot Cycle Limit is not reached, the burst is normally completed by the master, at the latest, on the next AHB 1-Kbyte address boundary, allowing up to 256-beat word bursts or 128-beat double-word bursts.This value should not be used in the very particular case of a master capable of performing back-to-back undefined length bursts on a single slave, since this could indefinitely freeze the slave arbitration and thus prevent another master from accessing this slave.
	MATRIX_MCFG_ULBT_UNLTD_LENGTH = 0x0
	// Single Access-The undefined length burst is treated as a succession of single accesses, allowing re-arbitration at each beat of the INCR burst or bursts sequence.
	MATRIX_MCFG_ULBT_SINGLE_ACCESS = 0x1
	// 4-beat Burst-The undefined length burst or bursts sequence is split into 4-beat bursts or less, allowing re-arbitration every 4 beats.
	MATRIX_MCFG_ULBT__4BEAT_BURST = 0x2
	// 8-beat Burst-The undefined length burst or bursts sequence is split into 8-beat bursts or less, allowing re-arbitration every 8 beats.
	MATRIX_MCFG_ULBT__8BEAT_BURST = 0x3
	// 16-beat Burst-The undefined length burst or bursts sequence is split into 16-beat bursts or less, allowing re-arbitration every 16 beats.
	MATRIX_MCFG_ULBT__16BEAT_BURST = 0x4
	// 32-beat Burst -The undefined length burst or bursts sequence is split into 32-beat bursts or less, allowing re-arbitration every 32 beats.
	MATRIX_MCFG_ULBT__32BEAT_BURST = 0x5
	// 64-beat Burst-The undefined length burst or bursts sequence is split into 64-beat bursts or less, allowing re-arbitration every 64 beats.
	MATRIX_MCFG_ULBT__64BEAT_BURST = 0x6
	// 128-beat Burst-The undefined length burst or bursts sequence is split into 128-beat bursts or less, allowing re-arbitration every 128 beats.
	MATRIX_MCFG_ULBT__128BEAT_BURST = 0x7

	// SCFG: Slave Configuration Register 0
	// Position of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Pos = 0x0
	// Bit mask of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Msk = 0x1ff
	// Position of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Pos = 0x10
	// Bit mask of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Msk = 0x30000
	// No Default Master-At the end of the current slave access, if no other master request is pending, the slave is disconnected from all masters.This results in a one clock cycle latency for the first access of a burst transfer or for a single access.
	MATRIX_SCFG_DEFMSTR_TYPE_NONE = 0x0
	// Last Default Master-At the end of the current slave access, if no other master request is pending, the slave stays connected to the last master having accessed it.This results in not having one clock cycle latency when the last master tries to access the slave again.
	MATRIX_SCFG_DEFMSTR_TYPE_LAST = 0x1
	// Fixed Default Master-At the end of the current slave access, if no other master request is pending, the slave connects to the fixed master the number that has been written in the FIXED_DEFMSTR field.This results in not having one clock cycle latency when the fixed master tries to access the slave again.
	MATRIX_SCFG_DEFMSTR_TYPE_FIXED = 0x2
	// Position of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Pos = 0x12
	// Bit mask of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Msk = 0x3c0000

	// MATRIX_PR.PRAS: Priority Register A for Slave 0
	// Position of M0PR field.
	MATRIX_MATRIX_PR_PRAS_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_MATRIX_PR_PRAS_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_MATRIX_PR_PRAS_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_MATRIX_PR_PRAS_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_MATRIX_PR_PRAS_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_MATRIX_PR_PRAS_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_MATRIX_PR_PRAS_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_MATRIX_PR_PRAS_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_MATRIX_PR_PRAS_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_MATRIX_PR_PRAS_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_MATRIX_PR_PRAS_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_MATRIX_PR_PRAS_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_MATRIX_PR_PRAS_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_MATRIX_PR_PRAS_M6PR_Msk = 0x3000000

	// MATRIX_PR.PRBS: Priority Register B for Slave 0
	// Position of M8PR field.
	MATRIX_MATRIX_PR_PRBS_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_MATRIX_PR_PRBS_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_MATRIX_PR_PRBS_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_MATRIX_PR_PRBS_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_MATRIX_PR_PRBS_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_MATRIX_PR_PRBS_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_MATRIX_PR_PRBS_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_MATRIX_PR_PRBS_M11PR_Msk = 0x3000

	// MRCR: Master Remap Control Register
	// Position of RCB0 field.
	MATRIX_MRCR_RCB0_Pos = 0x0
	// Bit mask of RCB0 field.
	MATRIX_MRCR_RCB0_Msk = 0x1
	// Bit RCB0.
	MATRIX_MRCR_RCB0 = 0x1
	// Position of RCB1 field.
	MATRIX_MRCR_RCB1_Pos = 0x1
	// Bit mask of RCB1 field.
	MATRIX_MRCR_RCB1_Msk = 0x2
	// Bit RCB1.
	MATRIX_MRCR_RCB1 = 0x2
	// Position of RCB2 field.
	MATRIX_MRCR_RCB2_Pos = 0x2
	// Bit mask of RCB2 field.
	MATRIX_MRCR_RCB2_Msk = 0x4
	// Bit RCB2.
	MATRIX_MRCR_RCB2 = 0x4
	// Position of RCB3 field.
	MATRIX_MRCR_RCB3_Pos = 0x3
	// Bit mask of RCB3 field.
	MATRIX_MRCR_RCB3_Msk = 0x8
	// Bit RCB3.
	MATRIX_MRCR_RCB3 = 0x8
	// Position of RCB4 field.
	MATRIX_MRCR_RCB4_Pos = 0x4
	// Bit mask of RCB4 field.
	MATRIX_MRCR_RCB4_Msk = 0x10
	// Bit RCB4.
	MATRIX_MRCR_RCB4 = 0x10
	// Position of RCB5 field.
	MATRIX_MRCR_RCB5_Pos = 0x5
	// Bit mask of RCB5 field.
	MATRIX_MRCR_RCB5_Msk = 0x20
	// Bit RCB5.
	MATRIX_MRCR_RCB5 = 0x20
	// Position of RCB6 field.
	MATRIX_MRCR_RCB6_Pos = 0x6
	// Bit mask of RCB6 field.
	MATRIX_MRCR_RCB6_Msk = 0x40
	// Bit RCB6.
	MATRIX_MRCR_RCB6 = 0x40
	// Position of RCB8 field.
	MATRIX_MRCR_RCB8_Pos = 0x8
	// Bit mask of RCB8 field.
	MATRIX_MRCR_RCB8_Msk = 0x100
	// Bit RCB8.
	MATRIX_MRCR_RCB8 = 0x100
	// Position of RCB9 field.
	MATRIX_MRCR_RCB9_Pos = 0x9
	// Bit mask of RCB9 field.
	MATRIX_MRCR_RCB9_Msk = 0x200
	// Bit RCB9.
	MATRIX_MRCR_RCB9 = 0x200
	// Position of RCB10 field.
	MATRIX_MRCR_RCB10_Pos = 0xa
	// Bit mask of RCB10 field.
	MATRIX_MRCR_RCB10_Msk = 0x400
	// Bit RCB10.
	MATRIX_MRCR_RCB10 = 0x400
	// Position of RCB11 field.
	MATRIX_MRCR_RCB11_Pos = 0xb
	// Bit mask of RCB11 field.
	MATRIX_MRCR_RCB11_Msk = 0x800
	// Bit RCB11.
	MATRIX_MRCR_RCB11 = 0x800

	// CCFG_CAN0: CAN0 Configuration Register
	// Position of CAN0DMABA field.
	MATRIX_CCFG_CAN0_CAN0DMABA_Pos = 0x10
	// Bit mask of CAN0DMABA field.
	MATRIX_CCFG_CAN0_CAN0DMABA_Msk = 0xffff0000

	// CCFG_SYSIO: System I/O Configuration Register
	// Position of SYSIO4 field.
	MATRIX_CCFG_SYSIO_SYSIO4_Pos = 0x4
	// Bit mask of SYSIO4 field.
	MATRIX_CCFG_SYSIO_SYSIO4_Msk = 0x10
	// Bit SYSIO4.
	MATRIX_CCFG_SYSIO_SYSIO4 = 0x10
	// Position of SYSIO5 field.
	MATRIX_CCFG_SYSIO_SYSIO5_Pos = 0x5
	// Bit mask of SYSIO5 field.
	MATRIX_CCFG_SYSIO_SYSIO5_Msk = 0x20
	// Bit SYSIO5.
	MATRIX_CCFG_SYSIO_SYSIO5 = 0x20
	// Position of SYSIO6 field.
	MATRIX_CCFG_SYSIO_SYSIO6_Pos = 0x6
	// Bit mask of SYSIO6 field.
	MATRIX_CCFG_SYSIO_SYSIO6_Msk = 0x40
	// Bit SYSIO6.
	MATRIX_CCFG_SYSIO_SYSIO6 = 0x40
	// Position of SYSIO7 field.
	MATRIX_CCFG_SYSIO_SYSIO7_Pos = 0x7
	// Bit mask of SYSIO7 field.
	MATRIX_CCFG_SYSIO_SYSIO7_Msk = 0x80
	// Bit SYSIO7.
	MATRIX_CCFG_SYSIO_SYSIO7 = 0x80
	// Position of SYSIO12 field.
	MATRIX_CCFG_SYSIO_SYSIO12_Pos = 0xc
	// Bit mask of SYSIO12 field.
	MATRIX_CCFG_SYSIO_SYSIO12_Msk = 0x1000
	// Bit SYSIO12.
	MATRIX_CCFG_SYSIO_SYSIO12 = 0x1000

	// CCFG_SMCNFCS: SMC NAND Flash Chip Select Configuration Register
	// Position of SMC_NFCS0 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS0_Pos = 0x0
	// Bit mask of SMC_NFCS0 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS0_Msk = 0x1
	// Bit SMC_NFCS0.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS0 = 0x1
	// Position of SMC_NFCS1 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS1_Pos = 0x1
	// Bit mask of SMC_NFCS1 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS1_Msk = 0x2
	// Bit SMC_NFCS1.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS1 = 0x2
	// Position of SMC_NFCS2 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS2_Pos = 0x2
	// Bit mask of SMC_NFCS2 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS2_Msk = 0x4
	// Bit SMC_NFCS2.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS2 = 0x4
	// Position of SMC_NFCS3 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS3_Pos = 0x3
	// Bit mask of SMC_NFCS3 field.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS3_Msk = 0x8
	// Bit SMC_NFCS3.
	MATRIX_CCFG_SMCNFCS_SMC_NFCS3 = 0x8
	// Position of SDRAMEN field.
	MATRIX_CCFG_SMCNFCS_SDRAMEN_Pos = 0x4
	// Bit mask of SDRAMEN field.
	MATRIX_CCFG_SMCNFCS_SDRAMEN_Msk = 0x10
	// Bit SDRAMEN.
	MATRIX_CCFG_SMCNFCS_SDRAMEN = 0x10

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	MATRIX_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	MATRIX_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	MATRIX_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	MATRIX_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	MATRIX_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0.
	MATRIX_WPMR_WPKEY_PASSWD = 0x4d4154

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	MATRIX_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	MATRIX_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	MATRIX_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MCAN0: Controller Area Network
const (
	// CUST: Customer Register
	// Position of CSV field.
	MCAN_CUST_CSV_Pos = 0x0
	// Bit mask of CSV field.
	MCAN_CUST_CSV_Msk = 0xffffffff

	// FBTP: Fast Bit Timing and Prescaler Register
	// Position of FSJW field.
	MCAN_FBTP_FSJW_Pos = 0x0
	// Bit mask of FSJW field.
	MCAN_FBTP_FSJW_Msk = 0x3
	// Position of FTSEG2 field.
	MCAN_FBTP_FTSEG2_Pos = 0x4
	// Bit mask of FTSEG2 field.
	MCAN_FBTP_FTSEG2_Msk = 0x70
	// Position of FTSEG1 field.
	MCAN_FBTP_FTSEG1_Pos = 0x8
	// Bit mask of FTSEG1 field.
	MCAN_FBTP_FTSEG1_Msk = 0xf00
	// Position of FBRP field.
	MCAN_FBTP_FBRP_Pos = 0x10
	// Bit mask of FBRP field.
	MCAN_FBTP_FBRP_Msk = 0x1f0000
	// Position of TDC field.
	MCAN_FBTP_TDC_Pos = 0x17
	// Bit mask of TDC field.
	MCAN_FBTP_TDC_Msk = 0x800000
	// Bit TDC.
	MCAN_FBTP_TDC = 0x800000
	// Transceiver Delay Compensation disabled.
	MCAN_FBTP_TDC_DISABLED = 0x0
	// Transceiver Delay Compensation enabled.
	MCAN_FBTP_TDC_ENABLED = 0x1
	// Position of TDCO field.
	MCAN_FBTP_TDCO_Pos = 0x18
	// Bit mask of TDCO field.
	MCAN_FBTP_TDCO_Msk = 0x1f000000

	// TEST: Test Register
	// Position of LBCK field.
	MCAN_TEST_LBCK_Pos = 0x4
	// Bit mask of LBCK field.
	MCAN_TEST_LBCK_Msk = 0x10
	// Bit LBCK.
	MCAN_TEST_LBCK = 0x10
	// Reset value. Loop Back mode is disabled.
	MCAN_TEST_LBCK_DISABLED = 0x0
	// Loop Back mode is enabled (see Section 1.5.1.9).
	MCAN_TEST_LBCK_ENABLED = 0x1
	// Position of TX field.
	MCAN_TEST_TX_Pos = 0x5
	// Bit mask of TX field.
	MCAN_TEST_TX_Msk = 0x60
	// Reset value, CANTX controlled by the CAN Core, updated at the end of the CAN bit time.
	MCAN_TEST_TX_RESET = 0x0
	// Sample Point can be monitored at pin CANTX.
	MCAN_TEST_TX_SAMPLE_POINT_MONITORING = 0x1
	// Dominant ('0') level at pin CANTX.
	MCAN_TEST_TX_DOMINANT = 0x2
	// Recessive ('1') at pin CANTX.
	MCAN_TEST_TX_RECESSIVE = 0x3
	// Position of RX field.
	MCAN_TEST_RX_Pos = 0x7
	// Bit mask of RX field.
	MCAN_TEST_RX_Msk = 0x80
	// Bit RX.
	MCAN_TEST_RX = 0x80
	// Position of TDCV field.
	MCAN_TEST_TDCV_Pos = 0x8
	// Bit mask of TDCV field.
	MCAN_TEST_TDCV_Msk = 0x3f00

	// RWD: RAM Watchdog Register
	// Position of WDC field.
	MCAN_RWD_WDC_Pos = 0x0
	// Bit mask of WDC field.
	MCAN_RWD_WDC_Msk = 0xff
	// Position of WDV field.
	MCAN_RWD_WDV_Pos = 0x8
	// Bit mask of WDV field.
	MCAN_RWD_WDV_Msk = 0xff00

	// CCCR: CC Control Register
	// Position of INIT field.
	MCAN_CCCR_INIT_Pos = 0x0
	// Bit mask of INIT field.
	MCAN_CCCR_INIT_Msk = 0x1
	// Bit INIT.
	MCAN_CCCR_INIT = 0x1
	// Normal operation.
	MCAN_CCCR_INIT_DISABLED = 0x0
	// Initialization is started.
	MCAN_CCCR_INIT_ENABLED = 0x1
	// Position of CCE field.
	MCAN_CCCR_CCE_Pos = 0x1
	// Bit mask of CCE field.
	MCAN_CCCR_CCE_Msk = 0x2
	// Bit CCE.
	MCAN_CCCR_CCE = 0x2
	// The processor has no write access to the protected configuration registers.
	MCAN_CCCR_CCE_PROTECTED = 0x0
	// The processor has write access to the protected configuration registers (while MCAN_CCCR.INIT = '1').
	MCAN_CCCR_CCE_CONFIGURABLE = 0x1
	// Position of ASM field.
	MCAN_CCCR_ASM_Pos = 0x2
	// Bit mask of ASM field.
	MCAN_CCCR_ASM_Msk = 0x4
	// Bit ASM.
	MCAN_CCCR_ASM = 0x4
	// Normal CAN operation.
	MCAN_CCCR_ASM_NORMAL = 0x0
	// Restricted operation mode active.
	MCAN_CCCR_ASM_RESTRICTED = 0x1
	// Position of CSA field.
	MCAN_CCCR_CSA_Pos = 0x3
	// Bit mask of CSA field.
	MCAN_CCCR_CSA_Msk = 0x8
	// Bit CSA.
	MCAN_CCCR_CSA = 0x8
	// Position of CSR field.
	MCAN_CCCR_CSR_Pos = 0x4
	// Bit mask of CSR field.
	MCAN_CCCR_CSR_Msk = 0x10
	// Bit CSR.
	MCAN_CCCR_CSR = 0x10
	// No clock stop is requested.
	MCAN_CCCR_CSR_NO_CLOCK_STOP = 0x0
	// Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after all pend-ing transfer requests have been completed and the CAN bus reached idle.
	MCAN_CCCR_CSR_CLOCK_STOP = 0x1
	// Position of MON field.
	MCAN_CCCR_MON_Pos = 0x5
	// Bit mask of MON field.
	MCAN_CCCR_MON_Msk = 0x20
	// Bit MON.
	MCAN_CCCR_MON = 0x20
	// Bus Monitoring mode is disabled.
	MCAN_CCCR_MON_DISABLED = 0x0
	// Bus Monitoring mode is enabled.
	MCAN_CCCR_MON_ENABLED = 0x1
	// Position of DAR field.
	MCAN_CCCR_DAR_Pos = 0x6
	// Bit mask of DAR field.
	MCAN_CCCR_DAR_Msk = 0x40
	// Bit DAR.
	MCAN_CCCR_DAR = 0x40
	// Automatic retransmission of messages not transmitted successfully enabled.
	MCAN_CCCR_DAR_AUTO_RETX = 0x0
	// Automatic retransmission disabled.
	MCAN_CCCR_DAR_NO_AUTO_RETX = 0x1
	// Position of TEST field.
	MCAN_CCCR_TEST_Pos = 0x7
	// Bit mask of TEST field.
	MCAN_CCCR_TEST_Msk = 0x80
	// Bit TEST.
	MCAN_CCCR_TEST = 0x80
	// Normal operation, MCAN_TEST register holds reset values.
	MCAN_CCCR_TEST_DISABLED = 0x0
	// Test mode, write access to MCAN_TEST register enabled.
	MCAN_CCCR_TEST_ENABLED = 0x1
	// Position of CME field.
	MCAN_CCCR_CME_Pos = 0x8
	// Bit mask of CME field.
	MCAN_CCCR_CME_Msk = 0x300
	// CAN operation according to ISO11898-1 enabled
	MCAN_CCCR_CME_ISO11898_1 = 0x0
	// CAN FD operation enabled
	MCAN_CCCR_CME_FD = 0x1
	// Position of CMR field.
	MCAN_CCCR_CMR_Pos = 0xa
	// Bit mask of CMR field.
	MCAN_CCCR_CMR_Msk = 0xc00
	// No mode change
	MCAN_CCCR_CMR_NO_CHANGE = 0x0
	// Request CAN FD operation
	MCAN_CCCR_CMR_FD = 0x1
	// Request CAN FD operation with bit rate switching
	MCAN_CCCR_CMR_FD_BITRATE_SWITCH = 0x2
	// Request CAN operation according ISO11898-1
	MCAN_CCCR_CMR_ISO11898_1 = 0x3
	// Position of FDO field.
	MCAN_CCCR_FDO_Pos = 0xc
	// Bit mask of FDO field.
	MCAN_CCCR_FDO_Msk = 0x1000
	// Bit FDO.
	MCAN_CCCR_FDO = 0x1000
	// Position of FDBS field.
	MCAN_CCCR_FDBS_Pos = 0xd
	// Bit mask of FDBS field.
	MCAN_CCCR_FDBS_Msk = 0x2000
	// Bit FDBS.
	MCAN_CCCR_FDBS = 0x2000
	// Position of TXP field.
	MCAN_CCCR_TXP_Pos = 0xe
	// Bit mask of TXP field.
	MCAN_CCCR_TXP_Msk = 0x4000
	// Bit TXP.
	MCAN_CCCR_TXP = 0x4000

	// BTP: Bit Timing and Prescaler Register
	// Position of SJW field.
	MCAN_BTP_SJW_Pos = 0x0
	// Bit mask of SJW field.
	MCAN_BTP_SJW_Msk = 0xf
	// Position of TSEG2 field.
	MCAN_BTP_TSEG2_Pos = 0x4
	// Bit mask of TSEG2 field.
	MCAN_BTP_TSEG2_Msk = 0xf0
	// Position of TSEG1 field.
	MCAN_BTP_TSEG1_Pos = 0x8
	// Bit mask of TSEG1 field.
	MCAN_BTP_TSEG1_Msk = 0x3f00
	// Position of BRP field.
	MCAN_BTP_BRP_Pos = 0x10
	// Bit mask of BRP field.
	MCAN_BTP_BRP_Msk = 0x3ff0000

	// TSCC: Timestamp Counter Configuration Register
	// Position of TSS field.
	MCAN_TSCC_TSS_Pos = 0x0
	// Bit mask of TSS field.
	MCAN_TSCC_TSS_Msk = 0x3
	// Timestamp counter value always 0x0000
	MCAN_TSCC_TSS_ALWAYS_0 = 0x0
	// Timestamp counter value incremented according to TCP
	MCAN_TSCC_TSS_TCP_INC = 0x1
	// External timestamp counter value used
	MCAN_TSCC_TSS_EXT_TIMESTAMP = 0x2
	// Position of TCP field.
	MCAN_TSCC_TCP_Pos = 0x10
	// Bit mask of TCP field.
	MCAN_TSCC_TCP_Msk = 0xf0000

	// TSCV: Timestamp Counter Value Register
	// Position of TSC field.
	MCAN_TSCV_TSC_Pos = 0x0
	// Bit mask of TSC field.
	MCAN_TSCV_TSC_Msk = 0xffff

	// TOCC: Timeout Counter Configuration Register
	// Position of ETOC field.
	MCAN_TOCC_ETOC_Pos = 0x0
	// Bit mask of ETOC field.
	MCAN_TOCC_ETOC_Msk = 0x1
	// Bit ETOC.
	MCAN_TOCC_ETOC = 0x1
	// Timeout Counter disabled.
	MCAN_TOCC_ETOC_NO_TIMEOUT = 0x0
	// Timeout Counter enabled.
	MCAN_TOCC_ETOC_TOS_CONTROLLED = 0x1
	// Position of TOS field.
	MCAN_TOCC_TOS_Pos = 0x1
	// Bit mask of TOS field.
	MCAN_TOCC_TOS_Msk = 0x6
	// Continuous operation
	MCAN_TOCC_TOS_CONTINUOUS = 0x0
	// Timeout controlled by Tx Event FIFO
	MCAN_TOCC_TOS_TX_EV_TIMEOUT = 0x1
	// Timeout controlled by Receive FIFO 0
	MCAN_TOCC_TOS_RX0_EV_TIMEOUT = 0x2
	// Timeout controlled by Receive FIFO 1
	MCAN_TOCC_TOS_RX1_EV_TIMEOUT = 0x3
	// Position of TOP field.
	MCAN_TOCC_TOP_Pos = 0x10
	// Bit mask of TOP field.
	MCAN_TOCC_TOP_Msk = 0xffff0000

	// TOCV: Timeout Counter Value Register
	// Position of TOC field.
	MCAN_TOCV_TOC_Pos = 0x0
	// Bit mask of TOC field.
	MCAN_TOCV_TOC_Msk = 0xffff

	// ECR: Error Counter Register
	// Position of TEC field.
	MCAN_ECR_TEC_Pos = 0x0
	// Bit mask of TEC field.
	MCAN_ECR_TEC_Msk = 0xff
	// Position of REC field.
	MCAN_ECR_REC_Pos = 0x8
	// Bit mask of REC field.
	MCAN_ECR_REC_Msk = 0x7f00
	// Position of RP field.
	MCAN_ECR_RP_Pos = 0xf
	// Bit mask of RP field.
	MCAN_ECR_RP_Msk = 0x8000
	// Bit RP.
	MCAN_ECR_RP = 0x8000
	// Position of CEL field.
	MCAN_ECR_CEL_Pos = 0x10
	// Bit mask of CEL field.
	MCAN_ECR_CEL_Msk = 0xff0000

	// PSR: Protocol Status Register
	// Position of LEC field.
	MCAN_PSR_LEC_Pos = 0x0
	// Bit mask of LEC field.
	MCAN_PSR_LEC_Msk = 0x7
	// No error occurred since LEC has been reset by successful reception or transmission.
	MCAN_PSR_LEC_NO_ERROR = 0x0
	// More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
	MCAN_PSR_LEC_STUFF_ERROR = 0x1
	// A fixed format part of a received frame has the wrong format.
	MCAN_PSR_LEC_FORM_ERROR = 0x2
	// The message transmitted by the MCAN was not acknowledged by another node.
	MCAN_PSR_LEC_ACK_ERROR = 0x3
	// During the transmission of a message (with the exception of the arbitration field), the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus value was dominant.
	MCAN_PSR_LEC_BIT1_ERROR = 0x4
	// During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value '0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the processor to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at dominant or continuously disturbed).
	MCAN_PSR_LEC_BIT0_ERROR = 0x5
	// The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data.
	MCAN_PSR_LEC_CRC_ERROR = 0x6
	// Any read access to the Protocol Status Register re-initializes the LEC to '7'. When the LEC shows the value '7', no CAN bus event was detected since the last processor read access to the Protocol Status Register.
	MCAN_PSR_LEC_NO_CHANGE = 0x7
	// Position of ACT field.
	MCAN_PSR_ACT_Pos = 0x3
	// Bit mask of ACT field.
	MCAN_PSR_ACT_Msk = 0x18
	// Node is synchronizing on CAN communication
	MCAN_PSR_ACT_SYNCHRONIZING = 0x0
	// Node is neither receiver nor transmitter
	MCAN_PSR_ACT_IDLE = 0x1
	// Node is operating as receiver
	MCAN_PSR_ACT_RECEIVER = 0x2
	// Node is operating as transmitter
	MCAN_PSR_ACT_TRANSMITTER = 0x3
	// Position of EP field.
	MCAN_PSR_EP_Pos = 0x5
	// Bit mask of EP field.
	MCAN_PSR_EP_Msk = 0x20
	// Bit EP.
	MCAN_PSR_EP = 0x20
	// Position of EW field.
	MCAN_PSR_EW_Pos = 0x6
	// Bit mask of EW field.
	MCAN_PSR_EW_Msk = 0x40
	// Bit EW.
	MCAN_PSR_EW = 0x40
	// Position of BO field.
	MCAN_PSR_BO_Pos = 0x7
	// Bit mask of BO field.
	MCAN_PSR_BO_Msk = 0x80
	// Bit BO.
	MCAN_PSR_BO = 0x80
	// Position of FLEC field.
	MCAN_PSR_FLEC_Pos = 0x8
	// Bit mask of FLEC field.
	MCAN_PSR_FLEC_Msk = 0x700
	// Position of RESI field.
	MCAN_PSR_RESI_Pos = 0xb
	// Bit mask of RESI field.
	MCAN_PSR_RESI_Msk = 0x800
	// Bit RESI.
	MCAN_PSR_RESI = 0x800
	// Position of RBRS field.
	MCAN_PSR_RBRS_Pos = 0xc
	// Bit mask of RBRS field.
	MCAN_PSR_RBRS_Msk = 0x1000
	// Bit RBRS.
	MCAN_PSR_RBRS = 0x1000
	// Position of REDL field.
	MCAN_PSR_REDL_Pos = 0xd
	// Bit mask of REDL field.
	MCAN_PSR_REDL_Msk = 0x2000
	// Bit REDL.
	MCAN_PSR_REDL = 0x2000

	// IR: Interrupt Register
	// Position of RF0N field.
	MCAN_IR_RF0N_Pos = 0x0
	// Bit mask of RF0N field.
	MCAN_IR_RF0N_Msk = 0x1
	// Bit RF0N.
	MCAN_IR_RF0N = 0x1
	// Position of RF0W field.
	MCAN_IR_RF0W_Pos = 0x1
	// Bit mask of RF0W field.
	MCAN_IR_RF0W_Msk = 0x2
	// Bit RF0W.
	MCAN_IR_RF0W = 0x2
	// Position of RF0F field.
	MCAN_IR_RF0F_Pos = 0x2
	// Bit mask of RF0F field.
	MCAN_IR_RF0F_Msk = 0x4
	// Bit RF0F.
	MCAN_IR_RF0F = 0x4
	// Position of RF0L field.
	MCAN_IR_RF0L_Pos = 0x3
	// Bit mask of RF0L field.
	MCAN_IR_RF0L_Msk = 0x8
	// Bit RF0L.
	MCAN_IR_RF0L = 0x8
	// Position of RF1N field.
	MCAN_IR_RF1N_Pos = 0x4
	// Bit mask of RF1N field.
	MCAN_IR_RF1N_Msk = 0x10
	// Bit RF1N.
	MCAN_IR_RF1N = 0x10
	// Position of RF1W field.
	MCAN_IR_RF1W_Pos = 0x5
	// Bit mask of RF1W field.
	MCAN_IR_RF1W_Msk = 0x20
	// Bit RF1W.
	MCAN_IR_RF1W = 0x20
	// Position of RF1F field.
	MCAN_IR_RF1F_Pos = 0x6
	// Bit mask of RF1F field.
	MCAN_IR_RF1F_Msk = 0x40
	// Bit RF1F.
	MCAN_IR_RF1F = 0x40
	// Position of RF1L field.
	MCAN_IR_RF1L_Pos = 0x7
	// Bit mask of RF1L field.
	MCAN_IR_RF1L_Msk = 0x80
	// Bit RF1L.
	MCAN_IR_RF1L = 0x80
	// Position of HPM field.
	MCAN_IR_HPM_Pos = 0x8
	// Bit mask of HPM field.
	MCAN_IR_HPM_Msk = 0x100
	// Bit HPM.
	MCAN_IR_HPM = 0x100
	// Position of TC field.
	MCAN_IR_TC_Pos = 0x9
	// Bit mask of TC field.
	MCAN_IR_TC_Msk = 0x200
	// Bit TC.
	MCAN_IR_TC = 0x200
	// Position of TCF field.
	MCAN_IR_TCF_Pos = 0xa
	// Bit mask of TCF field.
	MCAN_IR_TCF_Msk = 0x400
	// Bit TCF.
	MCAN_IR_TCF = 0x400
	// Position of TFE field.
	MCAN_IR_TFE_Pos = 0xb
	// Bit mask of TFE field.
	MCAN_IR_TFE_Msk = 0x800
	// Bit TFE.
	MCAN_IR_TFE = 0x800
	// Position of TEFN field.
	MCAN_IR_TEFN_Pos = 0xc
	// Bit mask of TEFN field.
	MCAN_IR_TEFN_Msk = 0x1000
	// Bit TEFN.
	MCAN_IR_TEFN = 0x1000
	// Position of TEFW field.
	MCAN_IR_TEFW_Pos = 0xd
	// Bit mask of TEFW field.
	MCAN_IR_TEFW_Msk = 0x2000
	// Bit TEFW.
	MCAN_IR_TEFW = 0x2000
	// Position of TEFF field.
	MCAN_IR_TEFF_Pos = 0xe
	// Bit mask of TEFF field.
	MCAN_IR_TEFF_Msk = 0x4000
	// Bit TEFF.
	MCAN_IR_TEFF = 0x4000
	// Position of TEFL field.
	MCAN_IR_TEFL_Pos = 0xf
	// Bit mask of TEFL field.
	MCAN_IR_TEFL_Msk = 0x8000
	// Bit TEFL.
	MCAN_IR_TEFL = 0x8000
	// Position of TSW field.
	MCAN_IR_TSW_Pos = 0x10
	// Bit mask of TSW field.
	MCAN_IR_TSW_Msk = 0x10000
	// Bit TSW.
	MCAN_IR_TSW = 0x10000
	// Position of MRAF field.
	MCAN_IR_MRAF_Pos = 0x11
	// Bit mask of MRAF field.
	MCAN_IR_MRAF_Msk = 0x20000
	// Bit MRAF.
	MCAN_IR_MRAF = 0x20000
	// Position of TOO field.
	MCAN_IR_TOO_Pos = 0x12
	// Bit mask of TOO field.
	MCAN_IR_TOO_Msk = 0x40000
	// Bit TOO.
	MCAN_IR_TOO = 0x40000
	// Position of DRX field.
	MCAN_IR_DRX_Pos = 0x13
	// Bit mask of DRX field.
	MCAN_IR_DRX_Msk = 0x80000
	// Bit DRX.
	MCAN_IR_DRX = 0x80000
	// Position of ELO field.
	MCAN_IR_ELO_Pos = 0x16
	// Bit mask of ELO field.
	MCAN_IR_ELO_Msk = 0x400000
	// Bit ELO.
	MCAN_IR_ELO = 0x400000
	// Position of EP field.
	MCAN_IR_EP_Pos = 0x17
	// Bit mask of EP field.
	MCAN_IR_EP_Msk = 0x800000
	// Bit EP.
	MCAN_IR_EP = 0x800000
	// Position of EW field.
	MCAN_IR_EW_Pos = 0x18
	// Bit mask of EW field.
	MCAN_IR_EW_Msk = 0x1000000
	// Bit EW.
	MCAN_IR_EW = 0x1000000
	// Position of BO field.
	MCAN_IR_BO_Pos = 0x19
	// Bit mask of BO field.
	MCAN_IR_BO_Msk = 0x2000000
	// Bit BO.
	MCAN_IR_BO = 0x2000000
	// Position of WDI field.
	MCAN_IR_WDI_Pos = 0x1a
	// Bit mask of WDI field.
	MCAN_IR_WDI_Msk = 0x4000000
	// Bit WDI.
	MCAN_IR_WDI = 0x4000000
	// Position of CRCE field.
	MCAN_IR_CRCE_Pos = 0x1b
	// Bit mask of CRCE field.
	MCAN_IR_CRCE_Msk = 0x8000000
	// Bit CRCE.
	MCAN_IR_CRCE = 0x8000000
	// Position of BE field.
	MCAN_IR_BE_Pos = 0x1c
	// Bit mask of BE field.
	MCAN_IR_BE_Msk = 0x10000000
	// Bit BE.
	MCAN_IR_BE = 0x10000000
	// Position of ACKE field.
	MCAN_IR_ACKE_Pos = 0x1d
	// Bit mask of ACKE field.
	MCAN_IR_ACKE_Msk = 0x20000000
	// Bit ACKE.
	MCAN_IR_ACKE = 0x20000000
	// Position of FOE field.
	MCAN_IR_FOE_Pos = 0x1e
	// Bit mask of FOE field.
	MCAN_IR_FOE_Msk = 0x40000000
	// Bit FOE.
	MCAN_IR_FOE = 0x40000000
	// Position of STE field.
	MCAN_IR_STE_Pos = 0x1f
	// Bit mask of STE field.
	MCAN_IR_STE_Msk = 0x80000000
	// Bit STE.
	MCAN_IR_STE = 0x80000000

	// IE: Interrupt Enable Register
	// Position of RF0NE field.
	MCAN_IE_RF0NE_Pos = 0x0
	// Bit mask of RF0NE field.
	MCAN_IE_RF0NE_Msk = 0x1
	// Bit RF0NE.
	MCAN_IE_RF0NE = 0x1
	// Position of RF0WE field.
	MCAN_IE_RF0WE_Pos = 0x1
	// Bit mask of RF0WE field.
	MCAN_IE_RF0WE_Msk = 0x2
	// Bit RF0WE.
	MCAN_IE_RF0WE = 0x2
	// Position of RF0FE field.
	MCAN_IE_RF0FE_Pos = 0x2
	// Bit mask of RF0FE field.
	MCAN_IE_RF0FE_Msk = 0x4
	// Bit RF0FE.
	MCAN_IE_RF0FE = 0x4
	// Position of RF0LE field.
	MCAN_IE_RF0LE_Pos = 0x3
	// Bit mask of RF0LE field.
	MCAN_IE_RF0LE_Msk = 0x8
	// Bit RF0LE.
	MCAN_IE_RF0LE = 0x8
	// Position of RF1NE field.
	MCAN_IE_RF1NE_Pos = 0x4
	// Bit mask of RF1NE field.
	MCAN_IE_RF1NE_Msk = 0x10
	// Bit RF1NE.
	MCAN_IE_RF1NE = 0x10
	// Position of RF1WE field.
	MCAN_IE_RF1WE_Pos = 0x5
	// Bit mask of RF1WE field.
	MCAN_IE_RF1WE_Msk = 0x20
	// Bit RF1WE.
	MCAN_IE_RF1WE = 0x20
	// Position of RF1FE field.
	MCAN_IE_RF1FE_Pos = 0x6
	// Bit mask of RF1FE field.
	MCAN_IE_RF1FE_Msk = 0x40
	// Bit RF1FE.
	MCAN_IE_RF1FE = 0x40
	// Position of RF1LE field.
	MCAN_IE_RF1LE_Pos = 0x7
	// Bit mask of RF1LE field.
	MCAN_IE_RF1LE_Msk = 0x80
	// Bit RF1LE.
	MCAN_IE_RF1LE = 0x80
	// Position of HPME field.
	MCAN_IE_HPME_Pos = 0x8
	// Bit mask of HPME field.
	MCAN_IE_HPME_Msk = 0x100
	// Bit HPME.
	MCAN_IE_HPME = 0x100
	// Position of TCE field.
	MCAN_IE_TCE_Pos = 0x9
	// Bit mask of TCE field.
	MCAN_IE_TCE_Msk = 0x200
	// Bit TCE.
	MCAN_IE_TCE = 0x200
	// Position of TCFE field.
	MCAN_IE_TCFE_Pos = 0xa
	// Bit mask of TCFE field.
	MCAN_IE_TCFE_Msk = 0x400
	// Bit TCFE.
	MCAN_IE_TCFE = 0x400
	// Position of TFEE field.
	MCAN_IE_TFEE_Pos = 0xb
	// Bit mask of TFEE field.
	MCAN_IE_TFEE_Msk = 0x800
	// Bit TFEE.
	MCAN_IE_TFEE = 0x800
	// Position of TEFNE field.
	MCAN_IE_TEFNE_Pos = 0xc
	// Bit mask of TEFNE field.
	MCAN_IE_TEFNE_Msk = 0x1000
	// Bit TEFNE.
	MCAN_IE_TEFNE = 0x1000
	// Position of TEFWE field.
	MCAN_IE_TEFWE_Pos = 0xd
	// Bit mask of TEFWE field.
	MCAN_IE_TEFWE_Msk = 0x2000
	// Bit TEFWE.
	MCAN_IE_TEFWE = 0x2000
	// Position of TEFFE field.
	MCAN_IE_TEFFE_Pos = 0xe
	// Bit mask of TEFFE field.
	MCAN_IE_TEFFE_Msk = 0x4000
	// Bit TEFFE.
	MCAN_IE_TEFFE = 0x4000
	// Position of TEFLE field.
	MCAN_IE_TEFLE_Pos = 0xf
	// Bit mask of TEFLE field.
	MCAN_IE_TEFLE_Msk = 0x8000
	// Bit TEFLE.
	MCAN_IE_TEFLE = 0x8000
	// Position of TSWE field.
	MCAN_IE_TSWE_Pos = 0x10
	// Bit mask of TSWE field.
	MCAN_IE_TSWE_Msk = 0x10000
	// Bit TSWE.
	MCAN_IE_TSWE = 0x10000
	// Position of MRAFE field.
	MCAN_IE_MRAFE_Pos = 0x11
	// Bit mask of MRAFE field.
	MCAN_IE_MRAFE_Msk = 0x20000
	// Bit MRAFE.
	MCAN_IE_MRAFE = 0x20000
	// Position of TOOE field.
	MCAN_IE_TOOE_Pos = 0x12
	// Bit mask of TOOE field.
	MCAN_IE_TOOE_Msk = 0x40000
	// Bit TOOE.
	MCAN_IE_TOOE = 0x40000
	// Position of DRXE field.
	MCAN_IE_DRXE_Pos = 0x13
	// Bit mask of DRXE field.
	MCAN_IE_DRXE_Msk = 0x80000
	// Bit DRXE.
	MCAN_IE_DRXE = 0x80000
	// Position of ELOE field.
	MCAN_IE_ELOE_Pos = 0x16
	// Bit mask of ELOE field.
	MCAN_IE_ELOE_Msk = 0x400000
	// Bit ELOE.
	MCAN_IE_ELOE = 0x400000
	// Position of EPE field.
	MCAN_IE_EPE_Pos = 0x17
	// Bit mask of EPE field.
	MCAN_IE_EPE_Msk = 0x800000
	// Bit EPE.
	MCAN_IE_EPE = 0x800000
	// Position of EWE field.
	MCAN_IE_EWE_Pos = 0x18
	// Bit mask of EWE field.
	MCAN_IE_EWE_Msk = 0x1000000
	// Bit EWE.
	MCAN_IE_EWE = 0x1000000
	// Position of BOE field.
	MCAN_IE_BOE_Pos = 0x19
	// Bit mask of BOE field.
	MCAN_IE_BOE_Msk = 0x2000000
	// Bit BOE.
	MCAN_IE_BOE = 0x2000000
	// Position of WDIE field.
	MCAN_IE_WDIE_Pos = 0x1a
	// Bit mask of WDIE field.
	MCAN_IE_WDIE_Msk = 0x4000000
	// Bit WDIE.
	MCAN_IE_WDIE = 0x4000000
	// Position of CRCEE field.
	MCAN_IE_CRCEE_Pos = 0x1b
	// Bit mask of CRCEE field.
	MCAN_IE_CRCEE_Msk = 0x8000000
	// Bit CRCEE.
	MCAN_IE_CRCEE = 0x8000000
	// Position of BEE field.
	MCAN_IE_BEE_Pos = 0x1c
	// Bit mask of BEE field.
	MCAN_IE_BEE_Msk = 0x10000000
	// Bit BEE.
	MCAN_IE_BEE = 0x10000000
	// Position of ACKEE field.
	MCAN_IE_ACKEE_Pos = 0x1d
	// Bit mask of ACKEE field.
	MCAN_IE_ACKEE_Msk = 0x20000000
	// Bit ACKEE.
	MCAN_IE_ACKEE = 0x20000000
	// Position of FOEE field.
	MCAN_IE_FOEE_Pos = 0x1e
	// Bit mask of FOEE field.
	MCAN_IE_FOEE_Msk = 0x40000000
	// Bit FOEE.
	MCAN_IE_FOEE = 0x40000000
	// Position of STEE field.
	MCAN_IE_STEE_Pos = 0x1f
	// Bit mask of STEE field.
	MCAN_IE_STEE_Msk = 0x80000000
	// Bit STEE.
	MCAN_IE_STEE = 0x80000000

	// ILS: Interrupt Line Select Register
	// Position of RF0NL field.
	MCAN_ILS_RF0NL_Pos = 0x0
	// Bit mask of RF0NL field.
	MCAN_ILS_RF0NL_Msk = 0x1
	// Bit RF0NL.
	MCAN_ILS_RF0NL = 0x1
	// Position of RF0WL field.
	MCAN_ILS_RF0WL_Pos = 0x1
	// Bit mask of RF0WL field.
	MCAN_ILS_RF0WL_Msk = 0x2
	// Bit RF0WL.
	MCAN_ILS_RF0WL = 0x2
	// Position of RF0FL field.
	MCAN_ILS_RF0FL_Pos = 0x2
	// Bit mask of RF0FL field.
	MCAN_ILS_RF0FL_Msk = 0x4
	// Bit RF0FL.
	MCAN_ILS_RF0FL = 0x4
	// Position of RF0LL field.
	MCAN_ILS_RF0LL_Pos = 0x3
	// Bit mask of RF0LL field.
	MCAN_ILS_RF0LL_Msk = 0x8
	// Bit RF0LL.
	MCAN_ILS_RF0LL = 0x8
	// Position of RF1NL field.
	MCAN_ILS_RF1NL_Pos = 0x4
	// Bit mask of RF1NL field.
	MCAN_ILS_RF1NL_Msk = 0x10
	// Bit RF1NL.
	MCAN_ILS_RF1NL = 0x10
	// Position of RF1WL field.
	MCAN_ILS_RF1WL_Pos = 0x5
	// Bit mask of RF1WL field.
	MCAN_ILS_RF1WL_Msk = 0x20
	// Bit RF1WL.
	MCAN_ILS_RF1WL = 0x20
	// Position of RF1FL field.
	MCAN_ILS_RF1FL_Pos = 0x6
	// Bit mask of RF1FL field.
	MCAN_ILS_RF1FL_Msk = 0x40
	// Bit RF1FL.
	MCAN_ILS_RF1FL = 0x40
	// Position of RF1LL field.
	MCAN_ILS_RF1LL_Pos = 0x7
	// Bit mask of RF1LL field.
	MCAN_ILS_RF1LL_Msk = 0x80
	// Bit RF1LL.
	MCAN_ILS_RF1LL = 0x80
	// Position of HPML field.
	MCAN_ILS_HPML_Pos = 0x8
	// Bit mask of HPML field.
	MCAN_ILS_HPML_Msk = 0x100
	// Bit HPML.
	MCAN_ILS_HPML = 0x100
	// Position of TCL field.
	MCAN_ILS_TCL_Pos = 0x9
	// Bit mask of TCL field.
	MCAN_ILS_TCL_Msk = 0x200
	// Bit TCL.
	MCAN_ILS_TCL = 0x200
	// Position of TCFL field.
	MCAN_ILS_TCFL_Pos = 0xa
	// Bit mask of TCFL field.
	MCAN_ILS_TCFL_Msk = 0x400
	// Bit TCFL.
	MCAN_ILS_TCFL = 0x400
	// Position of TFEL field.
	MCAN_ILS_TFEL_Pos = 0xb
	// Bit mask of TFEL field.
	MCAN_ILS_TFEL_Msk = 0x800
	// Bit TFEL.
	MCAN_ILS_TFEL = 0x800
	// Position of TEFNL field.
	MCAN_ILS_TEFNL_Pos = 0xc
	// Bit mask of TEFNL field.
	MCAN_ILS_TEFNL_Msk = 0x1000
	// Bit TEFNL.
	MCAN_ILS_TEFNL = 0x1000
	// Position of TEFWL field.
	MCAN_ILS_TEFWL_Pos = 0xd
	// Bit mask of TEFWL field.
	MCAN_ILS_TEFWL_Msk = 0x2000
	// Bit TEFWL.
	MCAN_ILS_TEFWL = 0x2000
	// Position of TEFFL field.
	MCAN_ILS_TEFFL_Pos = 0xe
	// Bit mask of TEFFL field.
	MCAN_ILS_TEFFL_Msk = 0x4000
	// Bit TEFFL.
	MCAN_ILS_TEFFL = 0x4000
	// Position of TEFLL field.
	MCAN_ILS_TEFLL_Pos = 0xf
	// Bit mask of TEFLL field.
	MCAN_ILS_TEFLL_Msk = 0x8000
	// Bit TEFLL.
	MCAN_ILS_TEFLL = 0x8000
	// Position of TSWL field.
	MCAN_ILS_TSWL_Pos = 0x10
	// Bit mask of TSWL field.
	MCAN_ILS_TSWL_Msk = 0x10000
	// Bit TSWL.
	MCAN_ILS_TSWL = 0x10000
	// Position of MRAFL field.
	MCAN_ILS_MRAFL_Pos = 0x11
	// Bit mask of MRAFL field.
	MCAN_ILS_MRAFL_Msk = 0x20000
	// Bit MRAFL.
	MCAN_ILS_MRAFL = 0x20000
	// Position of TOOL field.
	MCAN_ILS_TOOL_Pos = 0x12
	// Bit mask of TOOL field.
	MCAN_ILS_TOOL_Msk = 0x40000
	// Bit TOOL.
	MCAN_ILS_TOOL = 0x40000
	// Position of DRXL field.
	MCAN_ILS_DRXL_Pos = 0x13
	// Bit mask of DRXL field.
	MCAN_ILS_DRXL_Msk = 0x80000
	// Bit DRXL.
	MCAN_ILS_DRXL = 0x80000
	// Position of ELOL field.
	MCAN_ILS_ELOL_Pos = 0x16
	// Bit mask of ELOL field.
	MCAN_ILS_ELOL_Msk = 0x400000
	// Bit ELOL.
	MCAN_ILS_ELOL = 0x400000
	// Position of EPL field.
	MCAN_ILS_EPL_Pos = 0x17
	// Bit mask of EPL field.
	MCAN_ILS_EPL_Msk = 0x800000
	// Bit EPL.
	MCAN_ILS_EPL = 0x800000
	// Position of EWL field.
	MCAN_ILS_EWL_Pos = 0x18
	// Bit mask of EWL field.
	MCAN_ILS_EWL_Msk = 0x1000000
	// Bit EWL.
	MCAN_ILS_EWL = 0x1000000
	// Position of BOL field.
	MCAN_ILS_BOL_Pos = 0x19
	// Bit mask of BOL field.
	MCAN_ILS_BOL_Msk = 0x2000000
	// Bit BOL.
	MCAN_ILS_BOL = 0x2000000
	// Position of WDIL field.
	MCAN_ILS_WDIL_Pos = 0x1a
	// Bit mask of WDIL field.
	MCAN_ILS_WDIL_Msk = 0x4000000
	// Bit WDIL.
	MCAN_ILS_WDIL = 0x4000000
	// Position of CRCEL field.
	MCAN_ILS_CRCEL_Pos = 0x1b
	// Bit mask of CRCEL field.
	MCAN_ILS_CRCEL_Msk = 0x8000000
	// Bit CRCEL.
	MCAN_ILS_CRCEL = 0x8000000
	// Position of BEL field.
	MCAN_ILS_BEL_Pos = 0x1c
	// Bit mask of BEL field.
	MCAN_ILS_BEL_Msk = 0x10000000
	// Bit BEL.
	MCAN_ILS_BEL = 0x10000000
	// Position of ACKEL field.
	MCAN_ILS_ACKEL_Pos = 0x1d
	// Bit mask of ACKEL field.
	MCAN_ILS_ACKEL_Msk = 0x20000000
	// Bit ACKEL.
	MCAN_ILS_ACKEL = 0x20000000
	// Position of FOEL field.
	MCAN_ILS_FOEL_Pos = 0x1e
	// Bit mask of FOEL field.
	MCAN_ILS_FOEL_Msk = 0x40000000
	// Bit FOEL.
	MCAN_ILS_FOEL = 0x40000000
	// Position of STEL field.
	MCAN_ILS_STEL_Pos = 0x1f
	// Bit mask of STEL field.
	MCAN_ILS_STEL_Msk = 0x80000000
	// Bit STEL.
	MCAN_ILS_STEL = 0x80000000

	// ILE: Interrupt Line Enable Register
	// Position of EINT0 field.
	MCAN_ILE_EINT0_Pos = 0x0
	// Bit mask of EINT0 field.
	MCAN_ILE_EINT0_Msk = 0x1
	// Bit EINT0.
	MCAN_ILE_EINT0 = 0x1
	// Position of EINT1 field.
	MCAN_ILE_EINT1_Pos = 0x1
	// Bit mask of EINT1 field.
	MCAN_ILE_EINT1_Msk = 0x2
	// Bit EINT1.
	MCAN_ILE_EINT1 = 0x2

	// GFC: Global Filter Configuration Register
	// Position of RRFE field.
	MCAN_GFC_RRFE_Pos = 0x0
	// Bit mask of RRFE field.
	MCAN_GFC_RRFE_Msk = 0x1
	// Bit RRFE.
	MCAN_GFC_RRFE = 0x1
	// Filter remote frames with 29-bit extended IDs.
	MCAN_GFC_RRFE_FILTER = 0x0
	// Reject all remote frames with 29-bit extended IDs.
	MCAN_GFC_RRFE_REJECT = 0x1
	// Position of RRFS field.
	MCAN_GFC_RRFS_Pos = 0x1
	// Bit mask of RRFS field.
	MCAN_GFC_RRFS_Msk = 0x2
	// Bit RRFS.
	MCAN_GFC_RRFS = 0x2
	// Filter remote frames with 11-bit standard IDs.
	MCAN_GFC_RRFS_FILTER = 0x0
	// Reject all remote frames with 11-bit standard IDs.
	MCAN_GFC_RRFS_REJECT = 0x1
	// Position of ANFE field.
	MCAN_GFC_ANFE_Pos = 0x2
	// Bit mask of ANFE field.
	MCAN_GFC_ANFE_Msk = 0xc
	// Message stored in Receive FIFO 0
	MCAN_GFC_ANFE_RX_FIFO_0 = 0x0
	// Message stored in Receive FIFO 1
	MCAN_GFC_ANFE_RX_FIFO_1 = 0x1
	// Position of ANFS field.
	MCAN_GFC_ANFS_Pos = 0x4
	// Bit mask of ANFS field.
	MCAN_GFC_ANFS_Msk = 0x30
	// Message stored in Receive FIFO 0
	MCAN_GFC_ANFS_RX_FIFO_0 = 0x0
	// Message stored in Receive FIFO 1
	MCAN_GFC_ANFS_RX_FIFO_1 = 0x1

	// SIDFC: Standard ID Filter Configuration Register
	// Position of FLSSA field.
	MCAN_SIDFC_FLSSA_Pos = 0x2
	// Bit mask of FLSSA field.
	MCAN_SIDFC_FLSSA_Msk = 0xfffc
	// Position of LSS field.
	MCAN_SIDFC_LSS_Pos = 0x10
	// Bit mask of LSS field.
	MCAN_SIDFC_LSS_Msk = 0xff0000

	// XIDFC: Extended ID Filter Configuration Register
	// Position of FLESA field.
	MCAN_XIDFC_FLESA_Pos = 0x2
	// Bit mask of FLESA field.
	MCAN_XIDFC_FLESA_Msk = 0xfffc
	// Position of LSE field.
	MCAN_XIDFC_LSE_Pos = 0x10
	// Bit mask of LSE field.
	MCAN_XIDFC_LSE_Msk = 0x7f0000

	// XIDAM: Extended ID AND Mask Register
	// Position of EIDM field.
	MCAN_XIDAM_EIDM_Pos = 0x0
	// Bit mask of EIDM field.
	MCAN_XIDAM_EIDM_Msk = 0x1fffffff

	// HPMS: High Priority Message Status Register
	// Position of BIDX field.
	MCAN_HPMS_BIDX_Pos = 0x0
	// Bit mask of BIDX field.
	MCAN_HPMS_BIDX_Msk = 0x3f
	// Position of MSI field.
	MCAN_HPMS_MSI_Pos = 0x6
	// Bit mask of MSI field.
	MCAN_HPMS_MSI_Msk = 0xc0
	// No FIFO selected.
	MCAN_HPMS_MSI_NO_FIFO_SEL = 0x0
	// FIFO message.
	MCAN_HPMS_MSI_LOST = 0x1
	// Message stored in FIFO 0.
	MCAN_HPMS_MSI_FIFO_0 = 0x2
	// Message stored in FIFO 1.
	MCAN_HPMS_MSI_FIFO_1 = 0x3
	// Position of FIDX field.
	MCAN_HPMS_FIDX_Pos = 0x8
	// Bit mask of FIDX field.
	MCAN_HPMS_FIDX_Msk = 0x7f00
	// Position of FLST field.
	MCAN_HPMS_FLST_Pos = 0xf
	// Bit mask of FLST field.
	MCAN_HPMS_FLST_Msk = 0x8000
	// Bit FLST.
	MCAN_HPMS_FLST = 0x8000

	// NDAT1: New Data 1 Register
	// Position of ND0 field.
	MCAN_NDAT1_ND0_Pos = 0x0
	// Bit mask of ND0 field.
	MCAN_NDAT1_ND0_Msk = 0x1
	// Bit ND0.
	MCAN_NDAT1_ND0 = 0x1
	// Position of ND1 field.
	MCAN_NDAT1_ND1_Pos = 0x1
	// Bit mask of ND1 field.
	MCAN_NDAT1_ND1_Msk = 0x2
	// Bit ND1.
	MCAN_NDAT1_ND1 = 0x2
	// Position of ND2 field.
	MCAN_NDAT1_ND2_Pos = 0x2
	// Bit mask of ND2 field.
	MCAN_NDAT1_ND2_Msk = 0x4
	// Bit ND2.
	MCAN_NDAT1_ND2 = 0x4
	// Position of ND3 field.
	MCAN_NDAT1_ND3_Pos = 0x3
	// Bit mask of ND3 field.
	MCAN_NDAT1_ND3_Msk = 0x8
	// Bit ND3.
	MCAN_NDAT1_ND3 = 0x8
	// Position of ND4 field.
	MCAN_NDAT1_ND4_Pos = 0x4
	// Bit mask of ND4 field.
	MCAN_NDAT1_ND4_Msk = 0x10
	// Bit ND4.
	MCAN_NDAT1_ND4 = 0x10
	// Position of ND5 field.
	MCAN_NDAT1_ND5_Pos = 0x5
	// Bit mask of ND5 field.
	MCAN_NDAT1_ND5_Msk = 0x20
	// Bit ND5.
	MCAN_NDAT1_ND5 = 0x20
	// Position of ND6 field.
	MCAN_NDAT1_ND6_Pos = 0x6
	// Bit mask of ND6 field.
	MCAN_NDAT1_ND6_Msk = 0x40
	// Bit ND6.
	MCAN_NDAT1_ND6 = 0x40
	// Position of ND7 field.
	MCAN_NDAT1_ND7_Pos = 0x7
	// Bit mask of ND7 field.
	MCAN_NDAT1_ND7_Msk = 0x80
	// Bit ND7.
	MCAN_NDAT1_ND7 = 0x80
	// Position of ND8 field.
	MCAN_NDAT1_ND8_Pos = 0x8
	// Bit mask of ND8 field.
	MCAN_NDAT1_ND8_Msk = 0x100
	// Bit ND8.
	MCAN_NDAT1_ND8 = 0x100
	// Position of ND9 field.
	MCAN_NDAT1_ND9_Pos = 0x9
	// Bit mask of ND9 field.
	MCAN_NDAT1_ND9_Msk = 0x200
	// Bit ND9.
	MCAN_NDAT1_ND9 = 0x200
	// Position of ND10 field.
	MCAN_NDAT1_ND10_Pos = 0xa
	// Bit mask of ND10 field.
	MCAN_NDAT1_ND10_Msk = 0x400
	// Bit ND10.
	MCAN_NDAT1_ND10 = 0x400
	// Position of ND11 field.
	MCAN_NDAT1_ND11_Pos = 0xb
	// Bit mask of ND11 field.
	MCAN_NDAT1_ND11_Msk = 0x800
	// Bit ND11.
	MCAN_NDAT1_ND11 = 0x800
	// Position of ND12 field.
	MCAN_NDAT1_ND12_Pos = 0xc
	// Bit mask of ND12 field.
	MCAN_NDAT1_ND12_Msk = 0x1000
	// Bit ND12.
	MCAN_NDAT1_ND12 = 0x1000
	// Position of ND13 field.
	MCAN_NDAT1_ND13_Pos = 0xd
	// Bit mask of ND13 field.
	MCAN_NDAT1_ND13_Msk = 0x2000
	// Bit ND13.
	MCAN_NDAT1_ND13 = 0x2000
	// Position of ND14 field.
	MCAN_NDAT1_ND14_Pos = 0xe
	// Bit mask of ND14 field.
	MCAN_NDAT1_ND14_Msk = 0x4000
	// Bit ND14.
	MCAN_NDAT1_ND14 = 0x4000
	// Position of ND15 field.
	MCAN_NDAT1_ND15_Pos = 0xf
	// Bit mask of ND15 field.
	MCAN_NDAT1_ND15_Msk = 0x8000
	// Bit ND15.
	MCAN_NDAT1_ND15 = 0x8000
	// Position of ND16 field.
	MCAN_NDAT1_ND16_Pos = 0x10
	// Bit mask of ND16 field.
	MCAN_NDAT1_ND16_Msk = 0x10000
	// Bit ND16.
	MCAN_NDAT1_ND16 = 0x10000
	// Position of ND17 field.
	MCAN_NDAT1_ND17_Pos = 0x11
	// Bit mask of ND17 field.
	MCAN_NDAT1_ND17_Msk = 0x20000
	// Bit ND17.
	MCAN_NDAT1_ND17 = 0x20000
	// Position of ND18 field.
	MCAN_NDAT1_ND18_Pos = 0x12
	// Bit mask of ND18 field.
	MCAN_NDAT1_ND18_Msk = 0x40000
	// Bit ND18.
	MCAN_NDAT1_ND18 = 0x40000
	// Position of ND19 field.
	MCAN_NDAT1_ND19_Pos = 0x13
	// Bit mask of ND19 field.
	MCAN_NDAT1_ND19_Msk = 0x80000
	// Bit ND19.
	MCAN_NDAT1_ND19 = 0x80000
	// Position of ND20 field.
	MCAN_NDAT1_ND20_Pos = 0x14
	// Bit mask of ND20 field.
	MCAN_NDAT1_ND20_Msk = 0x100000
	// Bit ND20.
	MCAN_NDAT1_ND20 = 0x100000
	// Position of ND21 field.
	MCAN_NDAT1_ND21_Pos = 0x15
	// Bit mask of ND21 field.
	MCAN_NDAT1_ND21_Msk = 0x200000
	// Bit ND21.
	MCAN_NDAT1_ND21 = 0x200000
	// Position of ND22 field.
	MCAN_NDAT1_ND22_Pos = 0x16
	// Bit mask of ND22 field.
	MCAN_NDAT1_ND22_Msk = 0x400000
	// Bit ND22.
	MCAN_NDAT1_ND22 = 0x400000
	// Position of ND23 field.
	MCAN_NDAT1_ND23_Pos = 0x17
	// Bit mask of ND23 field.
	MCAN_NDAT1_ND23_Msk = 0x800000
	// Bit ND23.
	MCAN_NDAT1_ND23 = 0x800000
	// Position of ND24 field.
	MCAN_NDAT1_ND24_Pos = 0x18
	// Bit mask of ND24 field.
	MCAN_NDAT1_ND24_Msk = 0x1000000
	// Bit ND24.
	MCAN_NDAT1_ND24 = 0x1000000
	// Position of ND25 field.
	MCAN_NDAT1_ND25_Pos = 0x19
	// Bit mask of ND25 field.
	MCAN_NDAT1_ND25_Msk = 0x2000000
	// Bit ND25.
	MCAN_NDAT1_ND25 = 0x2000000
	// Position of ND26 field.
	MCAN_NDAT1_ND26_Pos = 0x1a
	// Bit mask of ND26 field.
	MCAN_NDAT1_ND26_Msk = 0x4000000
	// Bit ND26.
	MCAN_NDAT1_ND26 = 0x4000000
	// Position of ND27 field.
	MCAN_NDAT1_ND27_Pos = 0x1b
	// Bit mask of ND27 field.
	MCAN_NDAT1_ND27_Msk = 0x8000000
	// Bit ND27.
	MCAN_NDAT1_ND27 = 0x8000000
	// Position of ND28 field.
	MCAN_NDAT1_ND28_Pos = 0x1c
	// Bit mask of ND28 field.
	MCAN_NDAT1_ND28_Msk = 0x10000000
	// Bit ND28.
	MCAN_NDAT1_ND28 = 0x10000000
	// Position of ND29 field.
	MCAN_NDAT1_ND29_Pos = 0x1d
	// Bit mask of ND29 field.
	MCAN_NDAT1_ND29_Msk = 0x20000000
	// Bit ND29.
	MCAN_NDAT1_ND29 = 0x20000000
	// Position of ND30 field.
	MCAN_NDAT1_ND30_Pos = 0x1e
	// Bit mask of ND30 field.
	MCAN_NDAT1_ND30_Msk = 0x40000000
	// Bit ND30.
	MCAN_NDAT1_ND30 = 0x40000000
	// Position of ND31 field.
	MCAN_NDAT1_ND31_Pos = 0x1f
	// Bit mask of ND31 field.
	MCAN_NDAT1_ND31_Msk = 0x80000000
	// Bit ND31.
	MCAN_NDAT1_ND31 = 0x80000000

	// NDAT2: New Data 2 Register
	// Position of ND32 field.
	MCAN_NDAT2_ND32_Pos = 0x0
	// Bit mask of ND32 field.
	MCAN_NDAT2_ND32_Msk = 0x1
	// Bit ND32.
	MCAN_NDAT2_ND32 = 0x1
	// Position of ND33 field.
	MCAN_NDAT2_ND33_Pos = 0x1
	// Bit mask of ND33 field.
	MCAN_NDAT2_ND33_Msk = 0x2
	// Bit ND33.
	MCAN_NDAT2_ND33 = 0x2
	// Position of ND34 field.
	MCAN_NDAT2_ND34_Pos = 0x2
	// Bit mask of ND34 field.
	MCAN_NDAT2_ND34_Msk = 0x4
	// Bit ND34.
	MCAN_NDAT2_ND34 = 0x4
	// Position of ND35 field.
	MCAN_NDAT2_ND35_Pos = 0x3
	// Bit mask of ND35 field.
	MCAN_NDAT2_ND35_Msk = 0x8
	// Bit ND35.
	MCAN_NDAT2_ND35 = 0x8
	// Position of ND36 field.
	MCAN_NDAT2_ND36_Pos = 0x4
	// Bit mask of ND36 field.
	MCAN_NDAT2_ND36_Msk = 0x10
	// Bit ND36.
	MCAN_NDAT2_ND36 = 0x10
	// Position of ND37 field.
	MCAN_NDAT2_ND37_Pos = 0x5
	// Bit mask of ND37 field.
	MCAN_NDAT2_ND37_Msk = 0x20
	// Bit ND37.
	MCAN_NDAT2_ND37 = 0x20
	// Position of ND38 field.
	MCAN_NDAT2_ND38_Pos = 0x6
	// Bit mask of ND38 field.
	MCAN_NDAT2_ND38_Msk = 0x40
	// Bit ND38.
	MCAN_NDAT2_ND38 = 0x40
	// Position of ND39 field.
	MCAN_NDAT2_ND39_Pos = 0x7
	// Bit mask of ND39 field.
	MCAN_NDAT2_ND39_Msk = 0x80
	// Bit ND39.
	MCAN_NDAT2_ND39 = 0x80
	// Position of ND40 field.
	MCAN_NDAT2_ND40_Pos = 0x8
	// Bit mask of ND40 field.
	MCAN_NDAT2_ND40_Msk = 0x100
	// Bit ND40.
	MCAN_NDAT2_ND40 = 0x100
	// Position of ND41 field.
	MCAN_NDAT2_ND41_Pos = 0x9
	// Bit mask of ND41 field.
	MCAN_NDAT2_ND41_Msk = 0x200
	// Bit ND41.
	MCAN_NDAT2_ND41 = 0x200
	// Position of ND42 field.
	MCAN_NDAT2_ND42_Pos = 0xa
	// Bit mask of ND42 field.
	MCAN_NDAT2_ND42_Msk = 0x400
	// Bit ND42.
	MCAN_NDAT2_ND42 = 0x400
	// Position of ND43 field.
	MCAN_NDAT2_ND43_Pos = 0xb
	// Bit mask of ND43 field.
	MCAN_NDAT2_ND43_Msk = 0x800
	// Bit ND43.
	MCAN_NDAT2_ND43 = 0x800
	// Position of ND44 field.
	MCAN_NDAT2_ND44_Pos = 0xc
	// Bit mask of ND44 field.
	MCAN_NDAT2_ND44_Msk = 0x1000
	// Bit ND44.
	MCAN_NDAT2_ND44 = 0x1000
	// Position of ND45 field.
	MCAN_NDAT2_ND45_Pos = 0xd
	// Bit mask of ND45 field.
	MCAN_NDAT2_ND45_Msk = 0x2000
	// Bit ND45.
	MCAN_NDAT2_ND45 = 0x2000
	// Position of ND46 field.
	MCAN_NDAT2_ND46_Pos = 0xe
	// Bit mask of ND46 field.
	MCAN_NDAT2_ND46_Msk = 0x4000
	// Bit ND46.
	MCAN_NDAT2_ND46 = 0x4000
	// Position of ND47 field.
	MCAN_NDAT2_ND47_Pos = 0xf
	// Bit mask of ND47 field.
	MCAN_NDAT2_ND47_Msk = 0x8000
	// Bit ND47.
	MCAN_NDAT2_ND47 = 0x8000
	// Position of ND48 field.
	MCAN_NDAT2_ND48_Pos = 0x10
	// Bit mask of ND48 field.
	MCAN_NDAT2_ND48_Msk = 0x10000
	// Bit ND48.
	MCAN_NDAT2_ND48 = 0x10000
	// Position of ND49 field.
	MCAN_NDAT2_ND49_Pos = 0x11
	// Bit mask of ND49 field.
	MCAN_NDAT2_ND49_Msk = 0x20000
	// Bit ND49.
	MCAN_NDAT2_ND49 = 0x20000
	// Position of ND50 field.
	MCAN_NDAT2_ND50_Pos = 0x12
	// Bit mask of ND50 field.
	MCAN_NDAT2_ND50_Msk = 0x40000
	// Bit ND50.
	MCAN_NDAT2_ND50 = 0x40000
	// Position of ND51 field.
	MCAN_NDAT2_ND51_Pos = 0x13
	// Bit mask of ND51 field.
	MCAN_NDAT2_ND51_Msk = 0x80000
	// Bit ND51.
	MCAN_NDAT2_ND51 = 0x80000
	// Position of ND52 field.
	MCAN_NDAT2_ND52_Pos = 0x14
	// Bit mask of ND52 field.
	MCAN_NDAT2_ND52_Msk = 0x100000
	// Bit ND52.
	MCAN_NDAT2_ND52 = 0x100000
	// Position of ND53 field.
	MCAN_NDAT2_ND53_Pos = 0x15
	// Bit mask of ND53 field.
	MCAN_NDAT2_ND53_Msk = 0x200000
	// Bit ND53.
	MCAN_NDAT2_ND53 = 0x200000
	// Position of ND54 field.
	MCAN_NDAT2_ND54_Pos = 0x16
	// Bit mask of ND54 field.
	MCAN_NDAT2_ND54_Msk = 0x400000
	// Bit ND54.
	MCAN_NDAT2_ND54 = 0x400000
	// Position of ND55 field.
	MCAN_NDAT2_ND55_Pos = 0x17
	// Bit mask of ND55 field.
	MCAN_NDAT2_ND55_Msk = 0x800000
	// Bit ND55.
	MCAN_NDAT2_ND55 = 0x800000
	// Position of ND56 field.
	MCAN_NDAT2_ND56_Pos = 0x18
	// Bit mask of ND56 field.
	MCAN_NDAT2_ND56_Msk = 0x1000000
	// Bit ND56.
	MCAN_NDAT2_ND56 = 0x1000000
	// Position of ND57 field.
	MCAN_NDAT2_ND57_Pos = 0x19
	// Bit mask of ND57 field.
	MCAN_NDAT2_ND57_Msk = 0x2000000
	// Bit ND57.
	MCAN_NDAT2_ND57 = 0x2000000
	// Position of ND58 field.
	MCAN_NDAT2_ND58_Pos = 0x1a
	// Bit mask of ND58 field.
	MCAN_NDAT2_ND58_Msk = 0x4000000
	// Bit ND58.
	MCAN_NDAT2_ND58 = 0x4000000
	// Position of ND59 field.
	MCAN_NDAT2_ND59_Pos = 0x1b
	// Bit mask of ND59 field.
	MCAN_NDAT2_ND59_Msk = 0x8000000
	// Bit ND59.
	MCAN_NDAT2_ND59 = 0x8000000
	// Position of ND60 field.
	MCAN_NDAT2_ND60_Pos = 0x1c
	// Bit mask of ND60 field.
	MCAN_NDAT2_ND60_Msk = 0x10000000
	// Bit ND60.
	MCAN_NDAT2_ND60 = 0x10000000
	// Position of ND61 field.
	MCAN_NDAT2_ND61_Pos = 0x1d
	// Bit mask of ND61 field.
	MCAN_NDAT2_ND61_Msk = 0x20000000
	// Bit ND61.
	MCAN_NDAT2_ND61 = 0x20000000
	// Position of ND62 field.
	MCAN_NDAT2_ND62_Pos = 0x1e
	// Bit mask of ND62 field.
	MCAN_NDAT2_ND62_Msk = 0x40000000
	// Bit ND62.
	MCAN_NDAT2_ND62 = 0x40000000
	// Position of ND63 field.
	MCAN_NDAT2_ND63_Pos = 0x1f
	// Bit mask of ND63 field.
	MCAN_NDAT2_ND63_Msk = 0x80000000
	// Bit ND63.
	MCAN_NDAT2_ND63 = 0x80000000

	// RXF0C: Receive FIFO 0 Configuration Register
	// Position of F0SA field.
	MCAN_RXF0C_F0SA_Pos = 0x2
	// Bit mask of F0SA field.
	MCAN_RXF0C_F0SA_Msk = 0xfffc
	// Position of F0S field.
	MCAN_RXF0C_F0S_Pos = 0x10
	// Bit mask of F0S field.
	MCAN_RXF0C_F0S_Msk = 0x7f0000
	// Position of F0WM field.
	MCAN_RXF0C_F0WM_Pos = 0x18
	// Bit mask of F0WM field.
	MCAN_RXF0C_F0WM_Msk = 0x7f000000
	// Position of F0OM field.
	MCAN_RXF0C_F0OM_Pos = 0x1f
	// Bit mask of F0OM field.
	MCAN_RXF0C_F0OM_Msk = 0x80000000
	// Bit F0OM.
	MCAN_RXF0C_F0OM = 0x80000000

	// RXF0S: Receive FIFO 0 Status Register
	// Position of F0FL field.
	MCAN_RXF0S_F0FL_Pos = 0x0
	// Bit mask of F0FL field.
	MCAN_RXF0S_F0FL_Msk = 0x7f
	// Position of F0GI field.
	MCAN_RXF0S_F0GI_Pos = 0x8
	// Bit mask of F0GI field.
	MCAN_RXF0S_F0GI_Msk = 0x3f00
	// Position of F0PI field.
	MCAN_RXF0S_F0PI_Pos = 0x10
	// Bit mask of F0PI field.
	MCAN_RXF0S_F0PI_Msk = 0x3f0000
	// Position of F0F field.
	MCAN_RXF0S_F0F_Pos = 0x18
	// Bit mask of F0F field.
	MCAN_RXF0S_F0F_Msk = 0x1000000
	// Bit F0F.
	MCAN_RXF0S_F0F = 0x1000000
	// Position of RF0L field.
	MCAN_RXF0S_RF0L_Pos = 0x19
	// Bit mask of RF0L field.
	MCAN_RXF0S_RF0L_Msk = 0x2000000
	// Bit RF0L.
	MCAN_RXF0S_RF0L = 0x2000000

	// RXF0A: Receive FIFO 0 Acknowledge Register
	// Position of F0AI field.
	MCAN_RXF0A_F0AI_Pos = 0x0
	// Bit mask of F0AI field.
	MCAN_RXF0A_F0AI_Msk = 0x3f

	// RXBC: Receive Rx Buffer Configuration Register
	// Position of RBSA field.
	MCAN_RXBC_RBSA_Pos = 0x2
	// Bit mask of RBSA field.
	MCAN_RXBC_RBSA_Msk = 0xfffc

	// RXF1C: Receive FIFO 1 Configuration Register
	// Position of F1SA field.
	MCAN_RXF1C_F1SA_Pos = 0x2
	// Bit mask of F1SA field.
	MCAN_RXF1C_F1SA_Msk = 0xfffc
	// Position of F1S field.
	MCAN_RXF1C_F1S_Pos = 0x10
	// Bit mask of F1S field.
	MCAN_RXF1C_F1S_Msk = 0x7f0000
	// Position of F1WM field.
	MCAN_RXF1C_F1WM_Pos = 0x18
	// Bit mask of F1WM field.
	MCAN_RXF1C_F1WM_Msk = 0x7f000000
	// Position of F1OM field.
	MCAN_RXF1C_F1OM_Pos = 0x1f
	// Bit mask of F1OM field.
	MCAN_RXF1C_F1OM_Msk = 0x80000000
	// Bit F1OM.
	MCAN_RXF1C_F1OM = 0x80000000

	// RXF1S: Receive FIFO 1 Status Register
	// Position of F1FL field.
	MCAN_RXF1S_F1FL_Pos = 0x0
	// Bit mask of F1FL field.
	MCAN_RXF1S_F1FL_Msk = 0x7f
	// Position of F1GI field.
	MCAN_RXF1S_F1GI_Pos = 0x8
	// Bit mask of F1GI field.
	MCAN_RXF1S_F1GI_Msk = 0x3f00
	// Position of F1PI field.
	MCAN_RXF1S_F1PI_Pos = 0x10
	// Bit mask of F1PI field.
	MCAN_RXF1S_F1PI_Msk = 0x3f0000
	// Position of F1F field.
	MCAN_RXF1S_F1F_Pos = 0x18
	// Bit mask of F1F field.
	MCAN_RXF1S_F1F_Msk = 0x1000000
	// Bit F1F.
	MCAN_RXF1S_F1F = 0x1000000
	// Position of RF1L field.
	MCAN_RXF1S_RF1L_Pos = 0x19
	// Bit mask of RF1L field.
	MCAN_RXF1S_RF1L_Msk = 0x2000000
	// Bit RF1L.
	MCAN_RXF1S_RF1L = 0x2000000
	// Position of DMS field.
	MCAN_RXF1S_DMS_Pos = 0x1e
	// Bit mask of DMS field.
	MCAN_RXF1S_DMS_Msk = 0xc0000000
	// Idle state, wait for reception of debug messages, DMA request is cleared.
	MCAN_RXF1S_DMS_IDLE = 0x0
	// Debug message A received.
	MCAN_RXF1S_DMS_MSG_A = 0x1
	// Debug messages A, B received.
	MCAN_RXF1S_DMS_MSG_AB = 0x2
	// Debug messages A, B, C received, DMA request is set.
	MCAN_RXF1S_DMS_MSG_ABC = 0x3

	// RXF1A: Receive FIFO 1 Acknowledge Register
	// Position of F1AI field.
	MCAN_RXF1A_F1AI_Pos = 0x0
	// Bit mask of F1AI field.
	MCAN_RXF1A_F1AI_Msk = 0x3f

	// RXESC: Receive Buffer / FIFO Element Size Configuration Register
	// Position of F0DS field.
	MCAN_RXESC_F0DS_Pos = 0x0
	// Bit mask of F0DS field.
	MCAN_RXESC_F0DS_Msk = 0x7
	// 8-byte data field
	MCAN_RXESC_F0DS__8_BYTE = 0x0
	// 12-byte data field
	MCAN_RXESC_F0DS__12_BYTE = 0x1
	// 16-byte data field
	MCAN_RXESC_F0DS__16_BYTE = 0x2
	// 20-byte data field
	MCAN_RXESC_F0DS__20_BYTE = 0x3
	// 24-byte data field
	MCAN_RXESC_F0DS__24_BYTE = 0x4
	// 32-byte data field
	MCAN_RXESC_F0DS__32_BYTE = 0x5
	// 48-byte data field
	MCAN_RXESC_F0DS__48_BYTE = 0x6
	// 64-byte data field
	MCAN_RXESC_F0DS__64_BYTE = 0x7
	// Position of F1DS field.
	MCAN_RXESC_F1DS_Pos = 0x4
	// Bit mask of F1DS field.
	MCAN_RXESC_F1DS_Msk = 0x70
	// 8-byte data field
	MCAN_RXESC_F1DS__8_BYTE = 0x0
	// 12-byte data field
	MCAN_RXESC_F1DS__12_BYTE = 0x1
	// 16-byte data field
	MCAN_RXESC_F1DS__16_BYTE = 0x2
	// 20-byte data field
	MCAN_RXESC_F1DS__20_BYTE = 0x3
	// 24-byte data field
	MCAN_RXESC_F1DS__24_BYTE = 0x4
	// 32-byte data field
	MCAN_RXESC_F1DS__32_BYTE = 0x5
	// 48-byte data field
	MCAN_RXESC_F1DS__48_BYTE = 0x6
	// 64-byte data field
	MCAN_RXESC_F1DS__64_BYTE = 0x7
	// Position of RBDS field.
	MCAN_RXESC_RBDS_Pos = 0x8
	// Bit mask of RBDS field.
	MCAN_RXESC_RBDS_Msk = 0x700
	// 8-byte data field
	MCAN_RXESC_RBDS__8_BYTE = 0x0
	// 12-byte data field
	MCAN_RXESC_RBDS__12_BYTE = 0x1
	// 16-byte data field
	MCAN_RXESC_RBDS__16_BYTE = 0x2
	// 20-byte data field
	MCAN_RXESC_RBDS__20_BYTE = 0x3
	// 24-byte data field
	MCAN_RXESC_RBDS__24_BYTE = 0x4
	// 32-byte data field
	MCAN_RXESC_RBDS__32_BYTE = 0x5
	// 48-byte data field
	MCAN_RXESC_RBDS__48_BYTE = 0x6
	// 64-byte data field
	MCAN_RXESC_RBDS__64_BYTE = 0x7

	// TXBC: Transmit Buffer Configuration Register
	// Position of TBSA field.
	MCAN_TXBC_TBSA_Pos = 0x2
	// Bit mask of TBSA field.
	MCAN_TXBC_TBSA_Msk = 0xfffc
	// Position of NDTB field.
	MCAN_TXBC_NDTB_Pos = 0x10
	// Bit mask of NDTB field.
	MCAN_TXBC_NDTB_Msk = 0x3f0000
	// Position of TFQS field.
	MCAN_TXBC_TFQS_Pos = 0x18
	// Bit mask of TFQS field.
	MCAN_TXBC_TFQS_Msk = 0x3f000000
	// Position of TFQM field.
	MCAN_TXBC_TFQM_Pos = 0x1e
	// Bit mask of TFQM field.
	MCAN_TXBC_TFQM_Msk = 0x40000000
	// Bit TFQM.
	MCAN_TXBC_TFQM = 0x40000000

	// TXFQS: Transmit FIFO/Queue Status Register
	// Position of TFFL field.
	MCAN_TXFQS_TFFL_Pos = 0x0
	// Bit mask of TFFL field.
	MCAN_TXFQS_TFFL_Msk = 0x3f
	// Position of TFGI field.
	MCAN_TXFQS_TFGI_Pos = 0x8
	// Bit mask of TFGI field.
	MCAN_TXFQS_TFGI_Msk = 0x1f00
	// Position of TFQPI field.
	MCAN_TXFQS_TFQPI_Pos = 0x10
	// Bit mask of TFQPI field.
	MCAN_TXFQS_TFQPI_Msk = 0x1f0000
	// Position of TFQF field.
	MCAN_TXFQS_TFQF_Pos = 0x15
	// Bit mask of TFQF field.
	MCAN_TXFQS_TFQF_Msk = 0x200000
	// Bit TFQF.
	MCAN_TXFQS_TFQF = 0x200000

	// TXESC: Transmit Buffer Element Size Configuration Register
	// Position of TBDS field.
	MCAN_TXESC_TBDS_Pos = 0x0
	// Bit mask of TBDS field.
	MCAN_TXESC_TBDS_Msk = 0x7
	// 8-byte data field
	MCAN_TXESC_TBDS__8_BYTE = 0x0
	// 12-byte data field
	MCAN_TXESC_TBDS__12_BYTE = 0x1
	// 16-byte data field
	MCAN_TXESC_TBDS__16_BYTE = 0x2
	// 20-byte data field
	MCAN_TXESC_TBDS__20_BYTE = 0x3
	// 24-byte data field
	MCAN_TXESC_TBDS__24_BYTE = 0x4
	// 32-byte data field
	MCAN_TXESC_TBDS__32_BYTE = 0x5
	// 4- byte data field
	MCAN_TXESC_TBDS__48_BYTE = 0x6
	// 64-byte data field
	MCAN_TXESC_TBDS__64_BYTE = 0x7

	// TXBRP: Transmit Buffer Request Pending Register
	// Position of TRP0 field.
	MCAN_TXBRP_TRP0_Pos = 0x0
	// Bit mask of TRP0 field.
	MCAN_TXBRP_TRP0_Msk = 0x1
	// Bit TRP0.
	MCAN_TXBRP_TRP0 = 0x1
	// Position of TRP1 field.
	MCAN_TXBRP_TRP1_Pos = 0x1
	// Bit mask of TRP1 field.
	MCAN_TXBRP_TRP1_Msk = 0x2
	// Bit TRP1.
	MCAN_TXBRP_TRP1 = 0x2
	// Position of TRP2 field.
	MCAN_TXBRP_TRP2_Pos = 0x2
	// Bit mask of TRP2 field.
	MCAN_TXBRP_TRP2_Msk = 0x4
	// Bit TRP2.
	MCAN_TXBRP_TRP2 = 0x4
	// Position of TRP3 field.
	MCAN_TXBRP_TRP3_Pos = 0x3
	// Bit mask of TRP3 field.
	MCAN_TXBRP_TRP3_Msk = 0x8
	// Bit TRP3.
	MCAN_TXBRP_TRP3 = 0x8
	// Position of TRP4 field.
	MCAN_TXBRP_TRP4_Pos = 0x4
	// Bit mask of TRP4 field.
	MCAN_TXBRP_TRP4_Msk = 0x10
	// Bit TRP4.
	MCAN_TXBRP_TRP4 = 0x10
	// Position of TRP5 field.
	MCAN_TXBRP_TRP5_Pos = 0x5
	// Bit mask of TRP5 field.
	MCAN_TXBRP_TRP5_Msk = 0x20
	// Bit TRP5.
	MCAN_TXBRP_TRP5 = 0x20
	// Position of TRP6 field.
	MCAN_TXBRP_TRP6_Pos = 0x6
	// Bit mask of TRP6 field.
	MCAN_TXBRP_TRP6_Msk = 0x40
	// Bit TRP6.
	MCAN_TXBRP_TRP6 = 0x40
	// Position of TRP7 field.
	MCAN_TXBRP_TRP7_Pos = 0x7
	// Bit mask of TRP7 field.
	MCAN_TXBRP_TRP7_Msk = 0x80
	// Bit TRP7.
	MCAN_TXBRP_TRP7 = 0x80
	// Position of TRP8 field.
	MCAN_TXBRP_TRP8_Pos = 0x8
	// Bit mask of TRP8 field.
	MCAN_TXBRP_TRP8_Msk = 0x100
	// Bit TRP8.
	MCAN_TXBRP_TRP8 = 0x100
	// Position of TRP9 field.
	MCAN_TXBRP_TRP9_Pos = 0x9
	// Bit mask of TRP9 field.
	MCAN_TXBRP_TRP9_Msk = 0x200
	// Bit TRP9.
	MCAN_TXBRP_TRP9 = 0x200
	// Position of TRP10 field.
	MCAN_TXBRP_TRP10_Pos = 0xa
	// Bit mask of TRP10 field.
	MCAN_TXBRP_TRP10_Msk = 0x400
	// Bit TRP10.
	MCAN_TXBRP_TRP10 = 0x400
	// Position of TRP11 field.
	MCAN_TXBRP_TRP11_Pos = 0xb
	// Bit mask of TRP11 field.
	MCAN_TXBRP_TRP11_Msk = 0x800
	// Bit TRP11.
	MCAN_TXBRP_TRP11 = 0x800
	// Position of TRP12 field.
	MCAN_TXBRP_TRP12_Pos = 0xc
	// Bit mask of TRP12 field.
	MCAN_TXBRP_TRP12_Msk = 0x1000
	// Bit TRP12.
	MCAN_TXBRP_TRP12 = 0x1000
	// Position of TRP13 field.
	MCAN_TXBRP_TRP13_Pos = 0xd
	// Bit mask of TRP13 field.
	MCAN_TXBRP_TRP13_Msk = 0x2000
	// Bit TRP13.
	MCAN_TXBRP_TRP13 = 0x2000
	// Position of TRP14 field.
	MCAN_TXBRP_TRP14_Pos = 0xe
	// Bit mask of TRP14 field.
	MCAN_TXBRP_TRP14_Msk = 0x4000
	// Bit TRP14.
	MCAN_TXBRP_TRP14 = 0x4000
	// Position of TRP15 field.
	MCAN_TXBRP_TRP15_Pos = 0xf
	// Bit mask of TRP15 field.
	MCAN_TXBRP_TRP15_Msk = 0x8000
	// Bit TRP15.
	MCAN_TXBRP_TRP15 = 0x8000
	// Position of TRP16 field.
	MCAN_TXBRP_TRP16_Pos = 0x10
	// Bit mask of TRP16 field.
	MCAN_TXBRP_TRP16_Msk = 0x10000
	// Bit TRP16.
	MCAN_TXBRP_TRP16 = 0x10000
	// Position of TRP17 field.
	MCAN_TXBRP_TRP17_Pos = 0x11
	// Bit mask of TRP17 field.
	MCAN_TXBRP_TRP17_Msk = 0x20000
	// Bit TRP17.
	MCAN_TXBRP_TRP17 = 0x20000
	// Position of TRP18 field.
	MCAN_TXBRP_TRP18_Pos = 0x12
	// Bit mask of TRP18 field.
	MCAN_TXBRP_TRP18_Msk = 0x40000
	// Bit TRP18.
	MCAN_TXBRP_TRP18 = 0x40000
	// Position of TRP19 field.
	MCAN_TXBRP_TRP19_Pos = 0x13
	// Bit mask of TRP19 field.
	MCAN_TXBRP_TRP19_Msk = 0x80000
	// Bit TRP19.
	MCAN_TXBRP_TRP19 = 0x80000
	// Position of TRP20 field.
	MCAN_TXBRP_TRP20_Pos = 0x14
	// Bit mask of TRP20 field.
	MCAN_TXBRP_TRP20_Msk = 0x100000
	// Bit TRP20.
	MCAN_TXBRP_TRP20 = 0x100000
	// Position of TRP21 field.
	MCAN_TXBRP_TRP21_Pos = 0x15
	// Bit mask of TRP21 field.
	MCAN_TXBRP_TRP21_Msk = 0x200000
	// Bit TRP21.
	MCAN_TXBRP_TRP21 = 0x200000
	// Position of TRP22 field.
	MCAN_TXBRP_TRP22_Pos = 0x16
	// Bit mask of TRP22 field.
	MCAN_TXBRP_TRP22_Msk = 0x400000
	// Bit TRP22.
	MCAN_TXBRP_TRP22 = 0x400000
	// Position of TRP23 field.
	MCAN_TXBRP_TRP23_Pos = 0x17
	// Bit mask of TRP23 field.
	MCAN_TXBRP_TRP23_Msk = 0x800000
	// Bit TRP23.
	MCAN_TXBRP_TRP23 = 0x800000
	// Position of TRP24 field.
	MCAN_TXBRP_TRP24_Pos = 0x18
	// Bit mask of TRP24 field.
	MCAN_TXBRP_TRP24_Msk = 0x1000000
	// Bit TRP24.
	MCAN_TXBRP_TRP24 = 0x1000000
	// Position of TRP25 field.
	MCAN_TXBRP_TRP25_Pos = 0x19
	// Bit mask of TRP25 field.
	MCAN_TXBRP_TRP25_Msk = 0x2000000
	// Bit TRP25.
	MCAN_TXBRP_TRP25 = 0x2000000
	// Position of TRP26 field.
	MCAN_TXBRP_TRP26_Pos = 0x1a
	// Bit mask of TRP26 field.
	MCAN_TXBRP_TRP26_Msk = 0x4000000
	// Bit TRP26.
	MCAN_TXBRP_TRP26 = 0x4000000
	// Position of TRP27 field.
	MCAN_TXBRP_TRP27_Pos = 0x1b
	// Bit mask of TRP27 field.
	MCAN_TXBRP_TRP27_Msk = 0x8000000
	// Bit TRP27.
	MCAN_TXBRP_TRP27 = 0x8000000
	// Position of TRP28 field.
	MCAN_TXBRP_TRP28_Pos = 0x1c
	// Bit mask of TRP28 field.
	MCAN_TXBRP_TRP28_Msk = 0x10000000
	// Bit TRP28.
	MCAN_TXBRP_TRP28 = 0x10000000
	// Position of TRP29 field.
	MCAN_TXBRP_TRP29_Pos = 0x1d
	// Bit mask of TRP29 field.
	MCAN_TXBRP_TRP29_Msk = 0x20000000
	// Bit TRP29.
	MCAN_TXBRP_TRP29 = 0x20000000
	// Position of TRP30 field.
	MCAN_TXBRP_TRP30_Pos = 0x1e
	// Bit mask of TRP30 field.
	MCAN_TXBRP_TRP30_Msk = 0x40000000
	// Bit TRP30.
	MCAN_TXBRP_TRP30 = 0x40000000
	// Position of TRP31 field.
	MCAN_TXBRP_TRP31_Pos = 0x1f
	// Bit mask of TRP31 field.
	MCAN_TXBRP_TRP31_Msk = 0x80000000
	// Bit TRP31.
	MCAN_TXBRP_TRP31 = 0x80000000

	// TXBAR: Transmit Buffer Add Request Register
	// Position of AR0 field.
	MCAN_TXBAR_AR0_Pos = 0x0
	// Bit mask of AR0 field.
	MCAN_TXBAR_AR0_Msk = 0x1
	// Bit AR0.
	MCAN_TXBAR_AR0 = 0x1
	// Position of AR1 field.
	MCAN_TXBAR_AR1_Pos = 0x1
	// Bit mask of AR1 field.
	MCAN_TXBAR_AR1_Msk = 0x2
	// Bit AR1.
	MCAN_TXBAR_AR1 = 0x2
	// Position of AR2 field.
	MCAN_TXBAR_AR2_Pos = 0x2
	// Bit mask of AR2 field.
	MCAN_TXBAR_AR2_Msk = 0x4
	// Bit AR2.
	MCAN_TXBAR_AR2 = 0x4
	// Position of AR3 field.
	MCAN_TXBAR_AR3_Pos = 0x3
	// Bit mask of AR3 field.
	MCAN_TXBAR_AR3_Msk = 0x8
	// Bit AR3.
	MCAN_TXBAR_AR3 = 0x8
	// Position of AR4 field.
	MCAN_TXBAR_AR4_Pos = 0x4
	// Bit mask of AR4 field.
	MCAN_TXBAR_AR4_Msk = 0x10
	// Bit AR4.
	MCAN_TXBAR_AR4 = 0x10
	// Position of AR5 field.
	MCAN_TXBAR_AR5_Pos = 0x5
	// Bit mask of AR5 field.
	MCAN_TXBAR_AR5_Msk = 0x20
	// Bit AR5.
	MCAN_TXBAR_AR5 = 0x20
	// Position of AR6 field.
	MCAN_TXBAR_AR6_Pos = 0x6
	// Bit mask of AR6 field.
	MCAN_TXBAR_AR6_Msk = 0x40
	// Bit AR6.
	MCAN_TXBAR_AR6 = 0x40
	// Position of AR7 field.
	MCAN_TXBAR_AR7_Pos = 0x7
	// Bit mask of AR7 field.
	MCAN_TXBAR_AR7_Msk = 0x80
	// Bit AR7.
	MCAN_TXBAR_AR7 = 0x80
	// Position of AR8 field.
	MCAN_TXBAR_AR8_Pos = 0x8
	// Bit mask of AR8 field.
	MCAN_TXBAR_AR8_Msk = 0x100
	// Bit AR8.
	MCAN_TXBAR_AR8 = 0x100
	// Position of AR9 field.
	MCAN_TXBAR_AR9_Pos = 0x9
	// Bit mask of AR9 field.
	MCAN_TXBAR_AR9_Msk = 0x200
	// Bit AR9.
	MCAN_TXBAR_AR9 = 0x200
	// Position of AR10 field.
	MCAN_TXBAR_AR10_Pos = 0xa
	// Bit mask of AR10 field.
	MCAN_TXBAR_AR10_Msk = 0x400
	// Bit AR10.
	MCAN_TXBAR_AR10 = 0x400
	// Position of AR11 field.
	MCAN_TXBAR_AR11_Pos = 0xb
	// Bit mask of AR11 field.
	MCAN_TXBAR_AR11_Msk = 0x800
	// Bit AR11.
	MCAN_TXBAR_AR11 = 0x800
	// Position of AR12 field.
	MCAN_TXBAR_AR12_Pos = 0xc
	// Bit mask of AR12 field.
	MCAN_TXBAR_AR12_Msk = 0x1000
	// Bit AR12.
	MCAN_TXBAR_AR12 = 0x1000
	// Position of AR13 field.
	MCAN_TXBAR_AR13_Pos = 0xd
	// Bit mask of AR13 field.
	MCAN_TXBAR_AR13_Msk = 0x2000
	// Bit AR13.
	MCAN_TXBAR_AR13 = 0x2000
	// Position of AR14 field.
	MCAN_TXBAR_AR14_Pos = 0xe
	// Bit mask of AR14 field.
	MCAN_TXBAR_AR14_Msk = 0x4000
	// Bit AR14.
	MCAN_TXBAR_AR14 = 0x4000
	// Position of AR15 field.
	MCAN_TXBAR_AR15_Pos = 0xf
	// Bit mask of AR15 field.
	MCAN_TXBAR_AR15_Msk = 0x8000
	// Bit AR15.
	MCAN_TXBAR_AR15 = 0x8000
	// Position of AR16 field.
	MCAN_TXBAR_AR16_Pos = 0x10
	// Bit mask of AR16 field.
	MCAN_TXBAR_AR16_Msk = 0x10000
	// Bit AR16.
	MCAN_TXBAR_AR16 = 0x10000
	// Position of AR17 field.
	MCAN_TXBAR_AR17_Pos = 0x11
	// Bit mask of AR17 field.
	MCAN_TXBAR_AR17_Msk = 0x20000
	// Bit AR17.
	MCAN_TXBAR_AR17 = 0x20000
	// Position of AR18 field.
	MCAN_TXBAR_AR18_Pos = 0x12
	// Bit mask of AR18 field.
	MCAN_TXBAR_AR18_Msk = 0x40000
	// Bit AR18.
	MCAN_TXBAR_AR18 = 0x40000
	// Position of AR19 field.
	MCAN_TXBAR_AR19_Pos = 0x13
	// Bit mask of AR19 field.
	MCAN_TXBAR_AR19_Msk = 0x80000
	// Bit AR19.
	MCAN_TXBAR_AR19 = 0x80000
	// Position of AR20 field.
	MCAN_TXBAR_AR20_Pos = 0x14
	// Bit mask of AR20 field.
	MCAN_TXBAR_AR20_Msk = 0x100000
	// Bit AR20.
	MCAN_TXBAR_AR20 = 0x100000
	// Position of AR21 field.
	MCAN_TXBAR_AR21_Pos = 0x15
	// Bit mask of AR21 field.
	MCAN_TXBAR_AR21_Msk = 0x200000
	// Bit AR21.
	MCAN_TXBAR_AR21 = 0x200000
	// Position of AR22 field.
	MCAN_TXBAR_AR22_Pos = 0x16
	// Bit mask of AR22 field.
	MCAN_TXBAR_AR22_Msk = 0x400000
	// Bit AR22.
	MCAN_TXBAR_AR22 = 0x400000
	// Position of AR23 field.
	MCAN_TXBAR_AR23_Pos = 0x17
	// Bit mask of AR23 field.
	MCAN_TXBAR_AR23_Msk = 0x800000
	// Bit AR23.
	MCAN_TXBAR_AR23 = 0x800000
	// Position of AR24 field.
	MCAN_TXBAR_AR24_Pos = 0x18
	// Bit mask of AR24 field.
	MCAN_TXBAR_AR24_Msk = 0x1000000
	// Bit AR24.
	MCAN_TXBAR_AR24 = 0x1000000
	// Position of AR25 field.
	MCAN_TXBAR_AR25_Pos = 0x19
	// Bit mask of AR25 field.
	MCAN_TXBAR_AR25_Msk = 0x2000000
	// Bit AR25.
	MCAN_TXBAR_AR25 = 0x2000000
	// Position of AR26 field.
	MCAN_TXBAR_AR26_Pos = 0x1a
	// Bit mask of AR26 field.
	MCAN_TXBAR_AR26_Msk = 0x4000000
	// Bit AR26.
	MCAN_TXBAR_AR26 = 0x4000000
	// Position of AR27 field.
	MCAN_TXBAR_AR27_Pos = 0x1b
	// Bit mask of AR27 field.
	MCAN_TXBAR_AR27_Msk = 0x8000000
	// Bit AR27.
	MCAN_TXBAR_AR27 = 0x8000000
	// Position of AR28 field.
	MCAN_TXBAR_AR28_Pos = 0x1c
	// Bit mask of AR28 field.
	MCAN_TXBAR_AR28_Msk = 0x10000000
	// Bit AR28.
	MCAN_TXBAR_AR28 = 0x10000000
	// Position of AR29 field.
	MCAN_TXBAR_AR29_Pos = 0x1d
	// Bit mask of AR29 field.
	MCAN_TXBAR_AR29_Msk = 0x20000000
	// Bit AR29.
	MCAN_TXBAR_AR29 = 0x20000000
	// Position of AR30 field.
	MCAN_TXBAR_AR30_Pos = 0x1e
	// Bit mask of AR30 field.
	MCAN_TXBAR_AR30_Msk = 0x40000000
	// Bit AR30.
	MCAN_TXBAR_AR30 = 0x40000000
	// Position of AR31 field.
	MCAN_TXBAR_AR31_Pos = 0x1f
	// Bit mask of AR31 field.
	MCAN_TXBAR_AR31_Msk = 0x80000000
	// Bit AR31.
	MCAN_TXBAR_AR31 = 0x80000000

	// TXBCR: Transmit Buffer Cancellation Request Register
	// Position of CR0 field.
	MCAN_TXBCR_CR0_Pos = 0x0
	// Bit mask of CR0 field.
	MCAN_TXBCR_CR0_Msk = 0x1
	// Bit CR0.
	MCAN_TXBCR_CR0 = 0x1
	// Position of CR1 field.
	MCAN_TXBCR_CR1_Pos = 0x1
	// Bit mask of CR1 field.
	MCAN_TXBCR_CR1_Msk = 0x2
	// Bit CR1.
	MCAN_TXBCR_CR1 = 0x2
	// Position of CR2 field.
	MCAN_TXBCR_CR2_Pos = 0x2
	// Bit mask of CR2 field.
	MCAN_TXBCR_CR2_Msk = 0x4
	// Bit CR2.
	MCAN_TXBCR_CR2 = 0x4
	// Position of CR3 field.
	MCAN_TXBCR_CR3_Pos = 0x3
	// Bit mask of CR3 field.
	MCAN_TXBCR_CR3_Msk = 0x8
	// Bit CR3.
	MCAN_TXBCR_CR3 = 0x8
	// Position of CR4 field.
	MCAN_TXBCR_CR4_Pos = 0x4
	// Bit mask of CR4 field.
	MCAN_TXBCR_CR4_Msk = 0x10
	// Bit CR4.
	MCAN_TXBCR_CR4 = 0x10
	// Position of CR5 field.
	MCAN_TXBCR_CR5_Pos = 0x5
	// Bit mask of CR5 field.
	MCAN_TXBCR_CR5_Msk = 0x20
	// Bit CR5.
	MCAN_TXBCR_CR5 = 0x20
	// Position of CR6 field.
	MCAN_TXBCR_CR6_Pos = 0x6
	// Bit mask of CR6 field.
	MCAN_TXBCR_CR6_Msk = 0x40
	// Bit CR6.
	MCAN_TXBCR_CR6 = 0x40
	// Position of CR7 field.
	MCAN_TXBCR_CR7_Pos = 0x7
	// Bit mask of CR7 field.
	MCAN_TXBCR_CR7_Msk = 0x80
	// Bit CR7.
	MCAN_TXBCR_CR7 = 0x80
	// Position of CR8 field.
	MCAN_TXBCR_CR8_Pos = 0x8
	// Bit mask of CR8 field.
	MCAN_TXBCR_CR8_Msk = 0x100
	// Bit CR8.
	MCAN_TXBCR_CR8 = 0x100
	// Position of CR9 field.
	MCAN_TXBCR_CR9_Pos = 0x9
	// Bit mask of CR9 field.
	MCAN_TXBCR_CR9_Msk = 0x200
	// Bit CR9.
	MCAN_TXBCR_CR9 = 0x200
	// Position of CR10 field.
	MCAN_TXBCR_CR10_Pos = 0xa
	// Bit mask of CR10 field.
	MCAN_TXBCR_CR10_Msk = 0x400
	// Bit CR10.
	MCAN_TXBCR_CR10 = 0x400
	// Position of CR11 field.
	MCAN_TXBCR_CR11_Pos = 0xb
	// Bit mask of CR11 field.
	MCAN_TXBCR_CR11_Msk = 0x800
	// Bit CR11.
	MCAN_TXBCR_CR11 = 0x800
	// Position of CR12 field.
	MCAN_TXBCR_CR12_Pos = 0xc
	// Bit mask of CR12 field.
	MCAN_TXBCR_CR12_Msk = 0x1000
	// Bit CR12.
	MCAN_TXBCR_CR12 = 0x1000
	// Position of CR13 field.
	MCAN_TXBCR_CR13_Pos = 0xd
	// Bit mask of CR13 field.
	MCAN_TXBCR_CR13_Msk = 0x2000
	// Bit CR13.
	MCAN_TXBCR_CR13 = 0x2000
	// Position of CR14 field.
	MCAN_TXBCR_CR14_Pos = 0xe
	// Bit mask of CR14 field.
	MCAN_TXBCR_CR14_Msk = 0x4000
	// Bit CR14.
	MCAN_TXBCR_CR14 = 0x4000
	// Position of CR15 field.
	MCAN_TXBCR_CR15_Pos = 0xf
	// Bit mask of CR15 field.
	MCAN_TXBCR_CR15_Msk = 0x8000
	// Bit CR15.
	MCAN_TXBCR_CR15 = 0x8000
	// Position of CR16 field.
	MCAN_TXBCR_CR16_Pos = 0x10
	// Bit mask of CR16 field.
	MCAN_TXBCR_CR16_Msk = 0x10000
	// Bit CR16.
	MCAN_TXBCR_CR16 = 0x10000
	// Position of CR17 field.
	MCAN_TXBCR_CR17_Pos = 0x11
	// Bit mask of CR17 field.
	MCAN_TXBCR_CR17_Msk = 0x20000
	// Bit CR17.
	MCAN_TXBCR_CR17 = 0x20000
	// Position of CR18 field.
	MCAN_TXBCR_CR18_Pos = 0x12
	// Bit mask of CR18 field.
	MCAN_TXBCR_CR18_Msk = 0x40000
	// Bit CR18.
	MCAN_TXBCR_CR18 = 0x40000
	// Position of CR19 field.
	MCAN_TXBCR_CR19_Pos = 0x13
	// Bit mask of CR19 field.
	MCAN_TXBCR_CR19_Msk = 0x80000
	// Bit CR19.
	MCAN_TXBCR_CR19 = 0x80000
	// Position of CR20 field.
	MCAN_TXBCR_CR20_Pos = 0x14
	// Bit mask of CR20 field.
	MCAN_TXBCR_CR20_Msk = 0x100000
	// Bit CR20.
	MCAN_TXBCR_CR20 = 0x100000
	// Position of CR21 field.
	MCAN_TXBCR_CR21_Pos = 0x15
	// Bit mask of CR21 field.
	MCAN_TXBCR_CR21_Msk = 0x200000
	// Bit CR21.
	MCAN_TXBCR_CR21 = 0x200000
	// Position of CR22 field.
	MCAN_TXBCR_CR22_Pos = 0x16
	// Bit mask of CR22 field.
	MCAN_TXBCR_CR22_Msk = 0x400000
	// Bit CR22.
	MCAN_TXBCR_CR22 = 0x400000
	// Position of CR23 field.
	MCAN_TXBCR_CR23_Pos = 0x17
	// Bit mask of CR23 field.
	MCAN_TXBCR_CR23_Msk = 0x800000
	// Bit CR23.
	MCAN_TXBCR_CR23 = 0x800000
	// Position of CR24 field.
	MCAN_TXBCR_CR24_Pos = 0x18
	// Bit mask of CR24 field.
	MCAN_TXBCR_CR24_Msk = 0x1000000
	// Bit CR24.
	MCAN_TXBCR_CR24 = 0x1000000
	// Position of CR25 field.
	MCAN_TXBCR_CR25_Pos = 0x19
	// Bit mask of CR25 field.
	MCAN_TXBCR_CR25_Msk = 0x2000000
	// Bit CR25.
	MCAN_TXBCR_CR25 = 0x2000000
	// Position of CR26 field.
	MCAN_TXBCR_CR26_Pos = 0x1a
	// Bit mask of CR26 field.
	MCAN_TXBCR_CR26_Msk = 0x4000000
	// Bit CR26.
	MCAN_TXBCR_CR26 = 0x4000000
	// Position of CR27 field.
	MCAN_TXBCR_CR27_Pos = 0x1b
	// Bit mask of CR27 field.
	MCAN_TXBCR_CR27_Msk = 0x8000000
	// Bit CR27.
	MCAN_TXBCR_CR27 = 0x8000000
	// Position of CR28 field.
	MCAN_TXBCR_CR28_Pos = 0x1c
	// Bit mask of CR28 field.
	MCAN_TXBCR_CR28_Msk = 0x10000000
	// Bit CR28.
	MCAN_TXBCR_CR28 = 0x10000000
	// Position of CR29 field.
	MCAN_TXBCR_CR29_Pos = 0x1d
	// Bit mask of CR29 field.
	MCAN_TXBCR_CR29_Msk = 0x20000000
	// Bit CR29.
	MCAN_TXBCR_CR29 = 0x20000000
	// Position of CR30 field.
	MCAN_TXBCR_CR30_Pos = 0x1e
	// Bit mask of CR30 field.
	MCAN_TXBCR_CR30_Msk = 0x40000000
	// Bit CR30.
	MCAN_TXBCR_CR30 = 0x40000000
	// Position of CR31 field.
	MCAN_TXBCR_CR31_Pos = 0x1f
	// Bit mask of CR31 field.
	MCAN_TXBCR_CR31_Msk = 0x80000000
	// Bit CR31.
	MCAN_TXBCR_CR31 = 0x80000000

	// TXBTO: Transmit Buffer Transmission Occurred Register
	// Position of TO0 field.
	MCAN_TXBTO_TO0_Pos = 0x0
	// Bit mask of TO0 field.
	MCAN_TXBTO_TO0_Msk = 0x1
	// Bit TO0.
	MCAN_TXBTO_TO0 = 0x1
	// Position of TO1 field.
	MCAN_TXBTO_TO1_Pos = 0x1
	// Bit mask of TO1 field.
	MCAN_TXBTO_TO1_Msk = 0x2
	// Bit TO1.
	MCAN_TXBTO_TO1 = 0x2
	// Position of TO2 field.
	MCAN_TXBTO_TO2_Pos = 0x2
	// Bit mask of TO2 field.
	MCAN_TXBTO_TO2_Msk = 0x4
	// Bit TO2.
	MCAN_TXBTO_TO2 = 0x4
	// Position of TO3 field.
	MCAN_TXBTO_TO3_Pos = 0x3
	// Bit mask of TO3 field.
	MCAN_TXBTO_TO3_Msk = 0x8
	// Bit TO3.
	MCAN_TXBTO_TO3 = 0x8
	// Position of TO4 field.
	MCAN_TXBTO_TO4_Pos = 0x4
	// Bit mask of TO4 field.
	MCAN_TXBTO_TO4_Msk = 0x10
	// Bit TO4.
	MCAN_TXBTO_TO4 = 0x10
	// Position of TO5 field.
	MCAN_TXBTO_TO5_Pos = 0x5
	// Bit mask of TO5 field.
	MCAN_TXBTO_TO5_Msk = 0x20
	// Bit TO5.
	MCAN_TXBTO_TO5 = 0x20
	// Position of TO6 field.
	MCAN_TXBTO_TO6_Pos = 0x6
	// Bit mask of TO6 field.
	MCAN_TXBTO_TO6_Msk = 0x40
	// Bit TO6.
	MCAN_TXBTO_TO6 = 0x40
	// Position of TO7 field.
	MCAN_TXBTO_TO7_Pos = 0x7
	// Bit mask of TO7 field.
	MCAN_TXBTO_TO7_Msk = 0x80
	// Bit TO7.
	MCAN_TXBTO_TO7 = 0x80
	// Position of TO8 field.
	MCAN_TXBTO_TO8_Pos = 0x8
	// Bit mask of TO8 field.
	MCAN_TXBTO_TO8_Msk = 0x100
	// Bit TO8.
	MCAN_TXBTO_TO8 = 0x100
	// Position of TO9 field.
	MCAN_TXBTO_TO9_Pos = 0x9
	// Bit mask of TO9 field.
	MCAN_TXBTO_TO9_Msk = 0x200
	// Bit TO9.
	MCAN_TXBTO_TO9 = 0x200
	// Position of TO10 field.
	MCAN_TXBTO_TO10_Pos = 0xa
	// Bit mask of TO10 field.
	MCAN_TXBTO_TO10_Msk = 0x400
	// Bit TO10.
	MCAN_TXBTO_TO10 = 0x400
	// Position of TO11 field.
	MCAN_TXBTO_TO11_Pos = 0xb
	// Bit mask of TO11 field.
	MCAN_TXBTO_TO11_Msk = 0x800
	// Bit TO11.
	MCAN_TXBTO_TO11 = 0x800
	// Position of TO12 field.
	MCAN_TXBTO_TO12_Pos = 0xc
	// Bit mask of TO12 field.
	MCAN_TXBTO_TO12_Msk = 0x1000
	// Bit TO12.
	MCAN_TXBTO_TO12 = 0x1000
	// Position of TO13 field.
	MCAN_TXBTO_TO13_Pos = 0xd
	// Bit mask of TO13 field.
	MCAN_TXBTO_TO13_Msk = 0x2000
	// Bit TO13.
	MCAN_TXBTO_TO13 = 0x2000
	// Position of TO14 field.
	MCAN_TXBTO_TO14_Pos = 0xe
	// Bit mask of TO14 field.
	MCAN_TXBTO_TO14_Msk = 0x4000
	// Bit TO14.
	MCAN_TXBTO_TO14 = 0x4000
	// Position of TO15 field.
	MCAN_TXBTO_TO15_Pos = 0xf
	// Bit mask of TO15 field.
	MCAN_TXBTO_TO15_Msk = 0x8000
	// Bit TO15.
	MCAN_TXBTO_TO15 = 0x8000
	// Position of TO16 field.
	MCAN_TXBTO_TO16_Pos = 0x10
	// Bit mask of TO16 field.
	MCAN_TXBTO_TO16_Msk = 0x10000
	// Bit TO16.
	MCAN_TXBTO_TO16 = 0x10000
	// Position of TO17 field.
	MCAN_TXBTO_TO17_Pos = 0x11
	// Bit mask of TO17 field.
	MCAN_TXBTO_TO17_Msk = 0x20000
	// Bit TO17.
	MCAN_TXBTO_TO17 = 0x20000
	// Position of TO18 field.
	MCAN_TXBTO_TO18_Pos = 0x12
	// Bit mask of TO18 field.
	MCAN_TXBTO_TO18_Msk = 0x40000
	// Bit TO18.
	MCAN_TXBTO_TO18 = 0x40000
	// Position of TO19 field.
	MCAN_TXBTO_TO19_Pos = 0x13
	// Bit mask of TO19 field.
	MCAN_TXBTO_TO19_Msk = 0x80000
	// Bit TO19.
	MCAN_TXBTO_TO19 = 0x80000
	// Position of TO20 field.
	MCAN_TXBTO_TO20_Pos = 0x14
	// Bit mask of TO20 field.
	MCAN_TXBTO_TO20_Msk = 0x100000
	// Bit TO20.
	MCAN_TXBTO_TO20 = 0x100000
	// Position of TO21 field.
	MCAN_TXBTO_TO21_Pos = 0x15
	// Bit mask of TO21 field.
	MCAN_TXBTO_TO21_Msk = 0x200000
	// Bit TO21.
	MCAN_TXBTO_TO21 = 0x200000
	// Position of TO22 field.
	MCAN_TXBTO_TO22_Pos = 0x16
	// Bit mask of TO22 field.
	MCAN_TXBTO_TO22_Msk = 0x400000
	// Bit TO22.
	MCAN_TXBTO_TO22 = 0x400000
	// Position of TO23 field.
	MCAN_TXBTO_TO23_Pos = 0x17
	// Bit mask of TO23 field.
	MCAN_TXBTO_TO23_Msk = 0x800000
	// Bit TO23.
	MCAN_TXBTO_TO23 = 0x800000
	// Position of TO24 field.
	MCAN_TXBTO_TO24_Pos = 0x18
	// Bit mask of TO24 field.
	MCAN_TXBTO_TO24_Msk = 0x1000000
	// Bit TO24.
	MCAN_TXBTO_TO24 = 0x1000000
	// Position of TO25 field.
	MCAN_TXBTO_TO25_Pos = 0x19
	// Bit mask of TO25 field.
	MCAN_TXBTO_TO25_Msk = 0x2000000
	// Bit TO25.
	MCAN_TXBTO_TO25 = 0x2000000
	// Position of TO26 field.
	MCAN_TXBTO_TO26_Pos = 0x1a
	// Bit mask of TO26 field.
	MCAN_TXBTO_TO26_Msk = 0x4000000
	// Bit TO26.
	MCAN_TXBTO_TO26 = 0x4000000
	// Position of TO27 field.
	MCAN_TXBTO_TO27_Pos = 0x1b
	// Bit mask of TO27 field.
	MCAN_TXBTO_TO27_Msk = 0x8000000
	// Bit TO27.
	MCAN_TXBTO_TO27 = 0x8000000
	// Position of TO28 field.
	MCAN_TXBTO_TO28_Pos = 0x1c
	// Bit mask of TO28 field.
	MCAN_TXBTO_TO28_Msk = 0x10000000
	// Bit TO28.
	MCAN_TXBTO_TO28 = 0x10000000
	// Position of TO29 field.
	MCAN_TXBTO_TO29_Pos = 0x1d
	// Bit mask of TO29 field.
	MCAN_TXBTO_TO29_Msk = 0x20000000
	// Bit TO29.
	MCAN_TXBTO_TO29 = 0x20000000
	// Position of TO30 field.
	MCAN_TXBTO_TO30_Pos = 0x1e
	// Bit mask of TO30 field.
	MCAN_TXBTO_TO30_Msk = 0x40000000
	// Bit TO30.
	MCAN_TXBTO_TO30 = 0x40000000
	// Position of TO31 field.
	MCAN_TXBTO_TO31_Pos = 0x1f
	// Bit mask of TO31 field.
	MCAN_TXBTO_TO31_Msk = 0x80000000
	// Bit TO31.
	MCAN_TXBTO_TO31 = 0x80000000

	// TXBCF: Transmit Buffer Cancellation Finished Register
	// Position of CF0 field.
	MCAN_TXBCF_CF0_Pos = 0x0
	// Bit mask of CF0 field.
	MCAN_TXBCF_CF0_Msk = 0x1
	// Bit CF0.
	MCAN_TXBCF_CF0 = 0x1
	// Position of CF1 field.
	MCAN_TXBCF_CF1_Pos = 0x1
	// Bit mask of CF1 field.
	MCAN_TXBCF_CF1_Msk = 0x2
	// Bit CF1.
	MCAN_TXBCF_CF1 = 0x2
	// Position of CF2 field.
	MCAN_TXBCF_CF2_Pos = 0x2
	// Bit mask of CF2 field.
	MCAN_TXBCF_CF2_Msk = 0x4
	// Bit CF2.
	MCAN_TXBCF_CF2 = 0x4
	// Position of CF3 field.
	MCAN_TXBCF_CF3_Pos = 0x3
	// Bit mask of CF3 field.
	MCAN_TXBCF_CF3_Msk = 0x8
	// Bit CF3.
	MCAN_TXBCF_CF3 = 0x8
	// Position of CF4 field.
	MCAN_TXBCF_CF4_Pos = 0x4
	// Bit mask of CF4 field.
	MCAN_TXBCF_CF4_Msk = 0x10
	// Bit CF4.
	MCAN_TXBCF_CF4 = 0x10
	// Position of CF5 field.
	MCAN_TXBCF_CF5_Pos = 0x5
	// Bit mask of CF5 field.
	MCAN_TXBCF_CF5_Msk = 0x20
	// Bit CF5.
	MCAN_TXBCF_CF5 = 0x20
	// Position of CF6 field.
	MCAN_TXBCF_CF6_Pos = 0x6
	// Bit mask of CF6 field.
	MCAN_TXBCF_CF6_Msk = 0x40
	// Bit CF6.
	MCAN_TXBCF_CF6 = 0x40
	// Position of CF7 field.
	MCAN_TXBCF_CF7_Pos = 0x7
	// Bit mask of CF7 field.
	MCAN_TXBCF_CF7_Msk = 0x80
	// Bit CF7.
	MCAN_TXBCF_CF7 = 0x80
	// Position of CF8 field.
	MCAN_TXBCF_CF8_Pos = 0x8
	// Bit mask of CF8 field.
	MCAN_TXBCF_CF8_Msk = 0x100
	// Bit CF8.
	MCAN_TXBCF_CF8 = 0x100
	// Position of CF9 field.
	MCAN_TXBCF_CF9_Pos = 0x9
	// Bit mask of CF9 field.
	MCAN_TXBCF_CF9_Msk = 0x200
	// Bit CF9.
	MCAN_TXBCF_CF9 = 0x200
	// Position of CF10 field.
	MCAN_TXBCF_CF10_Pos = 0xa
	// Bit mask of CF10 field.
	MCAN_TXBCF_CF10_Msk = 0x400
	// Bit CF10.
	MCAN_TXBCF_CF10 = 0x400
	// Position of CF11 field.
	MCAN_TXBCF_CF11_Pos = 0xb
	// Bit mask of CF11 field.
	MCAN_TXBCF_CF11_Msk = 0x800
	// Bit CF11.
	MCAN_TXBCF_CF11 = 0x800
	// Position of CF12 field.
	MCAN_TXBCF_CF12_Pos = 0xc
	// Bit mask of CF12 field.
	MCAN_TXBCF_CF12_Msk = 0x1000
	// Bit CF12.
	MCAN_TXBCF_CF12 = 0x1000
	// Position of CF13 field.
	MCAN_TXBCF_CF13_Pos = 0xd
	// Bit mask of CF13 field.
	MCAN_TXBCF_CF13_Msk = 0x2000
	// Bit CF13.
	MCAN_TXBCF_CF13 = 0x2000
	// Position of CF14 field.
	MCAN_TXBCF_CF14_Pos = 0xe
	// Bit mask of CF14 field.
	MCAN_TXBCF_CF14_Msk = 0x4000
	// Bit CF14.
	MCAN_TXBCF_CF14 = 0x4000
	// Position of CF15 field.
	MCAN_TXBCF_CF15_Pos = 0xf
	// Bit mask of CF15 field.
	MCAN_TXBCF_CF15_Msk = 0x8000
	// Bit CF15.
	MCAN_TXBCF_CF15 = 0x8000
	// Position of CF16 field.
	MCAN_TXBCF_CF16_Pos = 0x10
	// Bit mask of CF16 field.
	MCAN_TXBCF_CF16_Msk = 0x10000
	// Bit CF16.
	MCAN_TXBCF_CF16 = 0x10000
	// Position of CF17 field.
	MCAN_TXBCF_CF17_Pos = 0x11
	// Bit mask of CF17 field.
	MCAN_TXBCF_CF17_Msk = 0x20000
	// Bit CF17.
	MCAN_TXBCF_CF17 = 0x20000
	// Position of CF18 field.
	MCAN_TXBCF_CF18_Pos = 0x12
	// Bit mask of CF18 field.
	MCAN_TXBCF_CF18_Msk = 0x40000
	// Bit CF18.
	MCAN_TXBCF_CF18 = 0x40000
	// Position of CF19 field.
	MCAN_TXBCF_CF19_Pos = 0x13
	// Bit mask of CF19 field.
	MCAN_TXBCF_CF19_Msk = 0x80000
	// Bit CF19.
	MCAN_TXBCF_CF19 = 0x80000
	// Position of CF20 field.
	MCAN_TXBCF_CF20_Pos = 0x14
	// Bit mask of CF20 field.
	MCAN_TXBCF_CF20_Msk = 0x100000
	// Bit CF20.
	MCAN_TXBCF_CF20 = 0x100000
	// Position of CF21 field.
	MCAN_TXBCF_CF21_Pos = 0x15
	// Bit mask of CF21 field.
	MCAN_TXBCF_CF21_Msk = 0x200000
	// Bit CF21.
	MCAN_TXBCF_CF21 = 0x200000
	// Position of CF22 field.
	MCAN_TXBCF_CF22_Pos = 0x16
	// Bit mask of CF22 field.
	MCAN_TXBCF_CF22_Msk = 0x400000
	// Bit CF22.
	MCAN_TXBCF_CF22 = 0x400000
	// Position of CF23 field.
	MCAN_TXBCF_CF23_Pos = 0x17
	// Bit mask of CF23 field.
	MCAN_TXBCF_CF23_Msk = 0x800000
	// Bit CF23.
	MCAN_TXBCF_CF23 = 0x800000
	// Position of CF24 field.
	MCAN_TXBCF_CF24_Pos = 0x18
	// Bit mask of CF24 field.
	MCAN_TXBCF_CF24_Msk = 0x1000000
	// Bit CF24.
	MCAN_TXBCF_CF24 = 0x1000000
	// Position of CF25 field.
	MCAN_TXBCF_CF25_Pos = 0x19
	// Bit mask of CF25 field.
	MCAN_TXBCF_CF25_Msk = 0x2000000
	// Bit CF25.
	MCAN_TXBCF_CF25 = 0x2000000
	// Position of CF26 field.
	MCAN_TXBCF_CF26_Pos = 0x1a
	// Bit mask of CF26 field.
	MCAN_TXBCF_CF26_Msk = 0x4000000
	// Bit CF26.
	MCAN_TXBCF_CF26 = 0x4000000
	// Position of CF27 field.
	MCAN_TXBCF_CF27_Pos = 0x1b
	// Bit mask of CF27 field.
	MCAN_TXBCF_CF27_Msk = 0x8000000
	// Bit CF27.
	MCAN_TXBCF_CF27 = 0x8000000
	// Position of CF28 field.
	MCAN_TXBCF_CF28_Pos = 0x1c
	// Bit mask of CF28 field.
	MCAN_TXBCF_CF28_Msk = 0x10000000
	// Bit CF28.
	MCAN_TXBCF_CF28 = 0x10000000
	// Position of CF29 field.
	MCAN_TXBCF_CF29_Pos = 0x1d
	// Bit mask of CF29 field.
	MCAN_TXBCF_CF29_Msk = 0x20000000
	// Bit CF29.
	MCAN_TXBCF_CF29 = 0x20000000
	// Position of CF30 field.
	MCAN_TXBCF_CF30_Pos = 0x1e
	// Bit mask of CF30 field.
	MCAN_TXBCF_CF30_Msk = 0x40000000
	// Bit CF30.
	MCAN_TXBCF_CF30 = 0x40000000
	// Position of CF31 field.
	MCAN_TXBCF_CF31_Pos = 0x1f
	// Bit mask of CF31 field.
	MCAN_TXBCF_CF31_Msk = 0x80000000
	// Bit CF31.
	MCAN_TXBCF_CF31 = 0x80000000

	// TXBTIE: Transmit Buffer Transmission Interrupt Enable Register
	// Position of TIE0 field.
	MCAN_TXBTIE_TIE0_Pos = 0x0
	// Bit mask of TIE0 field.
	MCAN_TXBTIE_TIE0_Msk = 0x1
	// Bit TIE0.
	MCAN_TXBTIE_TIE0 = 0x1
	// Position of TIE1 field.
	MCAN_TXBTIE_TIE1_Pos = 0x1
	// Bit mask of TIE1 field.
	MCAN_TXBTIE_TIE1_Msk = 0x2
	// Bit TIE1.
	MCAN_TXBTIE_TIE1 = 0x2
	// Position of TIE2 field.
	MCAN_TXBTIE_TIE2_Pos = 0x2
	// Bit mask of TIE2 field.
	MCAN_TXBTIE_TIE2_Msk = 0x4
	// Bit TIE2.
	MCAN_TXBTIE_TIE2 = 0x4
	// Position of TIE3 field.
	MCAN_TXBTIE_TIE3_Pos = 0x3
	// Bit mask of TIE3 field.
	MCAN_TXBTIE_TIE3_Msk = 0x8
	// Bit TIE3.
	MCAN_TXBTIE_TIE3 = 0x8
	// Position of TIE4 field.
	MCAN_TXBTIE_TIE4_Pos = 0x4
	// Bit mask of TIE4 field.
	MCAN_TXBTIE_TIE4_Msk = 0x10
	// Bit TIE4.
	MCAN_TXBTIE_TIE4 = 0x10
	// Position of TIE5 field.
	MCAN_TXBTIE_TIE5_Pos = 0x5
	// Bit mask of TIE5 field.
	MCAN_TXBTIE_TIE5_Msk = 0x20
	// Bit TIE5.
	MCAN_TXBTIE_TIE5 = 0x20
	// Position of TIE6 field.
	MCAN_TXBTIE_TIE6_Pos = 0x6
	// Bit mask of TIE6 field.
	MCAN_TXBTIE_TIE6_Msk = 0x40
	// Bit TIE6.
	MCAN_TXBTIE_TIE6 = 0x40
	// Position of TIE7 field.
	MCAN_TXBTIE_TIE7_Pos = 0x7
	// Bit mask of TIE7 field.
	MCAN_TXBTIE_TIE7_Msk = 0x80
	// Bit TIE7.
	MCAN_TXBTIE_TIE7 = 0x80
	// Position of TIE8 field.
	MCAN_TXBTIE_TIE8_Pos = 0x8
	// Bit mask of TIE8 field.
	MCAN_TXBTIE_TIE8_Msk = 0x100
	// Bit TIE8.
	MCAN_TXBTIE_TIE8 = 0x100
	// Position of TIE9 field.
	MCAN_TXBTIE_TIE9_Pos = 0x9
	// Bit mask of TIE9 field.
	MCAN_TXBTIE_TIE9_Msk = 0x200
	// Bit TIE9.
	MCAN_TXBTIE_TIE9 = 0x200
	// Position of TIE10 field.
	MCAN_TXBTIE_TIE10_Pos = 0xa
	// Bit mask of TIE10 field.
	MCAN_TXBTIE_TIE10_Msk = 0x400
	// Bit TIE10.
	MCAN_TXBTIE_TIE10 = 0x400
	// Position of TIE11 field.
	MCAN_TXBTIE_TIE11_Pos = 0xb
	// Bit mask of TIE11 field.
	MCAN_TXBTIE_TIE11_Msk = 0x800
	// Bit TIE11.
	MCAN_TXBTIE_TIE11 = 0x800
	// Position of TIE12 field.
	MCAN_TXBTIE_TIE12_Pos = 0xc
	// Bit mask of TIE12 field.
	MCAN_TXBTIE_TIE12_Msk = 0x1000
	// Bit TIE12.
	MCAN_TXBTIE_TIE12 = 0x1000
	// Position of TIE13 field.
	MCAN_TXBTIE_TIE13_Pos = 0xd
	// Bit mask of TIE13 field.
	MCAN_TXBTIE_TIE13_Msk = 0x2000
	// Bit TIE13.
	MCAN_TXBTIE_TIE13 = 0x2000
	// Position of TIE14 field.
	MCAN_TXBTIE_TIE14_Pos = 0xe
	// Bit mask of TIE14 field.
	MCAN_TXBTIE_TIE14_Msk = 0x4000
	// Bit TIE14.
	MCAN_TXBTIE_TIE14 = 0x4000
	// Position of TIE15 field.
	MCAN_TXBTIE_TIE15_Pos = 0xf
	// Bit mask of TIE15 field.
	MCAN_TXBTIE_TIE15_Msk = 0x8000
	// Bit TIE15.
	MCAN_TXBTIE_TIE15 = 0x8000
	// Position of TIE16 field.
	MCAN_TXBTIE_TIE16_Pos = 0x10
	// Bit mask of TIE16 field.
	MCAN_TXBTIE_TIE16_Msk = 0x10000
	// Bit TIE16.
	MCAN_TXBTIE_TIE16 = 0x10000
	// Position of TIE17 field.
	MCAN_TXBTIE_TIE17_Pos = 0x11
	// Bit mask of TIE17 field.
	MCAN_TXBTIE_TIE17_Msk = 0x20000
	// Bit TIE17.
	MCAN_TXBTIE_TIE17 = 0x20000
	// Position of TIE18 field.
	MCAN_TXBTIE_TIE18_Pos = 0x12
	// Bit mask of TIE18 field.
	MCAN_TXBTIE_TIE18_Msk = 0x40000
	// Bit TIE18.
	MCAN_TXBTIE_TIE18 = 0x40000
	// Position of TIE19 field.
	MCAN_TXBTIE_TIE19_Pos = 0x13
	// Bit mask of TIE19 field.
	MCAN_TXBTIE_TIE19_Msk = 0x80000
	// Bit TIE19.
	MCAN_TXBTIE_TIE19 = 0x80000
	// Position of TIE20 field.
	MCAN_TXBTIE_TIE20_Pos = 0x14
	// Bit mask of TIE20 field.
	MCAN_TXBTIE_TIE20_Msk = 0x100000
	// Bit TIE20.
	MCAN_TXBTIE_TIE20 = 0x100000
	// Position of TIE21 field.
	MCAN_TXBTIE_TIE21_Pos = 0x15
	// Bit mask of TIE21 field.
	MCAN_TXBTIE_TIE21_Msk = 0x200000
	// Bit TIE21.
	MCAN_TXBTIE_TIE21 = 0x200000
	// Position of TIE22 field.
	MCAN_TXBTIE_TIE22_Pos = 0x16
	// Bit mask of TIE22 field.
	MCAN_TXBTIE_TIE22_Msk = 0x400000
	// Bit TIE22.
	MCAN_TXBTIE_TIE22 = 0x400000
	// Position of TIE23 field.
	MCAN_TXBTIE_TIE23_Pos = 0x17
	// Bit mask of TIE23 field.
	MCAN_TXBTIE_TIE23_Msk = 0x800000
	// Bit TIE23.
	MCAN_TXBTIE_TIE23 = 0x800000
	// Position of TIE24 field.
	MCAN_TXBTIE_TIE24_Pos = 0x18
	// Bit mask of TIE24 field.
	MCAN_TXBTIE_TIE24_Msk = 0x1000000
	// Bit TIE24.
	MCAN_TXBTIE_TIE24 = 0x1000000
	// Position of TIE25 field.
	MCAN_TXBTIE_TIE25_Pos = 0x19
	// Bit mask of TIE25 field.
	MCAN_TXBTIE_TIE25_Msk = 0x2000000
	// Bit TIE25.
	MCAN_TXBTIE_TIE25 = 0x2000000
	// Position of TIE26 field.
	MCAN_TXBTIE_TIE26_Pos = 0x1a
	// Bit mask of TIE26 field.
	MCAN_TXBTIE_TIE26_Msk = 0x4000000
	// Bit TIE26.
	MCAN_TXBTIE_TIE26 = 0x4000000
	// Position of TIE27 field.
	MCAN_TXBTIE_TIE27_Pos = 0x1b
	// Bit mask of TIE27 field.
	MCAN_TXBTIE_TIE27_Msk = 0x8000000
	// Bit TIE27.
	MCAN_TXBTIE_TIE27 = 0x8000000
	// Position of TIE28 field.
	MCAN_TXBTIE_TIE28_Pos = 0x1c
	// Bit mask of TIE28 field.
	MCAN_TXBTIE_TIE28_Msk = 0x10000000
	// Bit TIE28.
	MCAN_TXBTIE_TIE28 = 0x10000000
	// Position of TIE29 field.
	MCAN_TXBTIE_TIE29_Pos = 0x1d
	// Bit mask of TIE29 field.
	MCAN_TXBTIE_TIE29_Msk = 0x20000000
	// Bit TIE29.
	MCAN_TXBTIE_TIE29 = 0x20000000
	// Position of TIE30 field.
	MCAN_TXBTIE_TIE30_Pos = 0x1e
	// Bit mask of TIE30 field.
	MCAN_TXBTIE_TIE30_Msk = 0x40000000
	// Bit TIE30.
	MCAN_TXBTIE_TIE30 = 0x40000000
	// Position of TIE31 field.
	MCAN_TXBTIE_TIE31_Pos = 0x1f
	// Bit mask of TIE31 field.
	MCAN_TXBTIE_TIE31_Msk = 0x80000000
	// Bit TIE31.
	MCAN_TXBTIE_TIE31 = 0x80000000

	// TXBCIE: Transmit Buffer Cancellation Finished Interrupt Enable Register
	// Position of CFIE0 field.
	MCAN_TXBCIE_CFIE0_Pos = 0x0
	// Bit mask of CFIE0 field.
	MCAN_TXBCIE_CFIE0_Msk = 0x1
	// Bit CFIE0.
	MCAN_TXBCIE_CFIE0 = 0x1
	// Position of CFIE1 field.
	MCAN_TXBCIE_CFIE1_Pos = 0x1
	// Bit mask of CFIE1 field.
	MCAN_TXBCIE_CFIE1_Msk = 0x2
	// Bit CFIE1.
	MCAN_TXBCIE_CFIE1 = 0x2
	// Position of CFIE2 field.
	MCAN_TXBCIE_CFIE2_Pos = 0x2
	// Bit mask of CFIE2 field.
	MCAN_TXBCIE_CFIE2_Msk = 0x4
	// Bit CFIE2.
	MCAN_TXBCIE_CFIE2 = 0x4
	// Position of CFIE3 field.
	MCAN_TXBCIE_CFIE3_Pos = 0x3
	// Bit mask of CFIE3 field.
	MCAN_TXBCIE_CFIE3_Msk = 0x8
	// Bit CFIE3.
	MCAN_TXBCIE_CFIE3 = 0x8
	// Position of CFIE4 field.
	MCAN_TXBCIE_CFIE4_Pos = 0x4
	// Bit mask of CFIE4 field.
	MCAN_TXBCIE_CFIE4_Msk = 0x10
	// Bit CFIE4.
	MCAN_TXBCIE_CFIE4 = 0x10
	// Position of CFIE5 field.
	MCAN_TXBCIE_CFIE5_Pos = 0x5
	// Bit mask of CFIE5 field.
	MCAN_TXBCIE_CFIE5_Msk = 0x20
	// Bit CFIE5.
	MCAN_TXBCIE_CFIE5 = 0x20
	// Position of CFIE6 field.
	MCAN_TXBCIE_CFIE6_Pos = 0x6
	// Bit mask of CFIE6 field.
	MCAN_TXBCIE_CFIE6_Msk = 0x40
	// Bit CFIE6.
	MCAN_TXBCIE_CFIE6 = 0x40
	// Position of CFIE7 field.
	MCAN_TXBCIE_CFIE7_Pos = 0x7
	// Bit mask of CFIE7 field.
	MCAN_TXBCIE_CFIE7_Msk = 0x80
	// Bit CFIE7.
	MCAN_TXBCIE_CFIE7 = 0x80
	// Position of CFIE8 field.
	MCAN_TXBCIE_CFIE8_Pos = 0x8
	// Bit mask of CFIE8 field.
	MCAN_TXBCIE_CFIE8_Msk = 0x100
	// Bit CFIE8.
	MCAN_TXBCIE_CFIE8 = 0x100
	// Position of CFIE9 field.
	MCAN_TXBCIE_CFIE9_Pos = 0x9
	// Bit mask of CFIE9 field.
	MCAN_TXBCIE_CFIE9_Msk = 0x200
	// Bit CFIE9.
	MCAN_TXBCIE_CFIE9 = 0x200
	// Position of CFIE10 field.
	MCAN_TXBCIE_CFIE10_Pos = 0xa
	// Bit mask of CFIE10 field.
	MCAN_TXBCIE_CFIE10_Msk = 0x400
	// Bit CFIE10.
	MCAN_TXBCIE_CFIE10 = 0x400
	// Position of CFIE11 field.
	MCAN_TXBCIE_CFIE11_Pos = 0xb
	// Bit mask of CFIE11 field.
	MCAN_TXBCIE_CFIE11_Msk = 0x800
	// Bit CFIE11.
	MCAN_TXBCIE_CFIE11 = 0x800
	// Position of CFIE12 field.
	MCAN_TXBCIE_CFIE12_Pos = 0xc
	// Bit mask of CFIE12 field.
	MCAN_TXBCIE_CFIE12_Msk = 0x1000
	// Bit CFIE12.
	MCAN_TXBCIE_CFIE12 = 0x1000
	// Position of CFIE13 field.
	MCAN_TXBCIE_CFIE13_Pos = 0xd
	// Bit mask of CFIE13 field.
	MCAN_TXBCIE_CFIE13_Msk = 0x2000
	// Bit CFIE13.
	MCAN_TXBCIE_CFIE13 = 0x2000
	// Position of CFIE14 field.
	MCAN_TXBCIE_CFIE14_Pos = 0xe
	// Bit mask of CFIE14 field.
	MCAN_TXBCIE_CFIE14_Msk = 0x4000
	// Bit CFIE14.
	MCAN_TXBCIE_CFIE14 = 0x4000
	// Position of CFIE15 field.
	MCAN_TXBCIE_CFIE15_Pos = 0xf
	// Bit mask of CFIE15 field.
	MCAN_TXBCIE_CFIE15_Msk = 0x8000
	// Bit CFIE15.
	MCAN_TXBCIE_CFIE15 = 0x8000
	// Position of CFIE16 field.
	MCAN_TXBCIE_CFIE16_Pos = 0x10
	// Bit mask of CFIE16 field.
	MCAN_TXBCIE_CFIE16_Msk = 0x10000
	// Bit CFIE16.
	MCAN_TXBCIE_CFIE16 = 0x10000
	// Position of CFIE17 field.
	MCAN_TXBCIE_CFIE17_Pos = 0x11
	// Bit mask of CFIE17 field.
	MCAN_TXBCIE_CFIE17_Msk = 0x20000
	// Bit CFIE17.
	MCAN_TXBCIE_CFIE17 = 0x20000
	// Position of CFIE18 field.
	MCAN_TXBCIE_CFIE18_Pos = 0x12
	// Bit mask of CFIE18 field.
	MCAN_TXBCIE_CFIE18_Msk = 0x40000
	// Bit CFIE18.
	MCAN_TXBCIE_CFIE18 = 0x40000
	// Position of CFIE19 field.
	MCAN_TXBCIE_CFIE19_Pos = 0x13
	// Bit mask of CFIE19 field.
	MCAN_TXBCIE_CFIE19_Msk = 0x80000
	// Bit CFIE19.
	MCAN_TXBCIE_CFIE19 = 0x80000
	// Position of CFIE20 field.
	MCAN_TXBCIE_CFIE20_Pos = 0x14
	// Bit mask of CFIE20 field.
	MCAN_TXBCIE_CFIE20_Msk = 0x100000
	// Bit CFIE20.
	MCAN_TXBCIE_CFIE20 = 0x100000
	// Position of CFIE21 field.
	MCAN_TXBCIE_CFIE21_Pos = 0x15
	// Bit mask of CFIE21 field.
	MCAN_TXBCIE_CFIE21_Msk = 0x200000
	// Bit CFIE21.
	MCAN_TXBCIE_CFIE21 = 0x200000
	// Position of CFIE22 field.
	MCAN_TXBCIE_CFIE22_Pos = 0x16
	// Bit mask of CFIE22 field.
	MCAN_TXBCIE_CFIE22_Msk = 0x400000
	// Bit CFIE22.
	MCAN_TXBCIE_CFIE22 = 0x400000
	// Position of CFIE23 field.
	MCAN_TXBCIE_CFIE23_Pos = 0x17
	// Bit mask of CFIE23 field.
	MCAN_TXBCIE_CFIE23_Msk = 0x800000
	// Bit CFIE23.
	MCAN_TXBCIE_CFIE23 = 0x800000
	// Position of CFIE24 field.
	MCAN_TXBCIE_CFIE24_Pos = 0x18
	// Bit mask of CFIE24 field.
	MCAN_TXBCIE_CFIE24_Msk = 0x1000000
	// Bit CFIE24.
	MCAN_TXBCIE_CFIE24 = 0x1000000
	// Position of CFIE25 field.
	MCAN_TXBCIE_CFIE25_Pos = 0x19
	// Bit mask of CFIE25 field.
	MCAN_TXBCIE_CFIE25_Msk = 0x2000000
	// Bit CFIE25.
	MCAN_TXBCIE_CFIE25 = 0x2000000
	// Position of CFIE26 field.
	MCAN_TXBCIE_CFIE26_Pos = 0x1a
	// Bit mask of CFIE26 field.
	MCAN_TXBCIE_CFIE26_Msk = 0x4000000
	// Bit CFIE26.
	MCAN_TXBCIE_CFIE26 = 0x4000000
	// Position of CFIE27 field.
	MCAN_TXBCIE_CFIE27_Pos = 0x1b
	// Bit mask of CFIE27 field.
	MCAN_TXBCIE_CFIE27_Msk = 0x8000000
	// Bit CFIE27.
	MCAN_TXBCIE_CFIE27 = 0x8000000
	// Position of CFIE28 field.
	MCAN_TXBCIE_CFIE28_Pos = 0x1c
	// Bit mask of CFIE28 field.
	MCAN_TXBCIE_CFIE28_Msk = 0x10000000
	// Bit CFIE28.
	MCAN_TXBCIE_CFIE28 = 0x10000000
	// Position of CFIE29 field.
	MCAN_TXBCIE_CFIE29_Pos = 0x1d
	// Bit mask of CFIE29 field.
	MCAN_TXBCIE_CFIE29_Msk = 0x20000000
	// Bit CFIE29.
	MCAN_TXBCIE_CFIE29 = 0x20000000
	// Position of CFIE30 field.
	MCAN_TXBCIE_CFIE30_Pos = 0x1e
	// Bit mask of CFIE30 field.
	MCAN_TXBCIE_CFIE30_Msk = 0x40000000
	// Bit CFIE30.
	MCAN_TXBCIE_CFIE30 = 0x40000000
	// Position of CFIE31 field.
	MCAN_TXBCIE_CFIE31_Pos = 0x1f
	// Bit mask of CFIE31 field.
	MCAN_TXBCIE_CFIE31_Msk = 0x80000000
	// Bit CFIE31.
	MCAN_TXBCIE_CFIE31 = 0x80000000

	// TXEFC: Transmit Event FIFO Configuration Register
	// Position of EFSA field.
	MCAN_TXEFC_EFSA_Pos = 0x2
	// Bit mask of EFSA field.
	MCAN_TXEFC_EFSA_Msk = 0xfffc
	// Position of EFS field.
	MCAN_TXEFC_EFS_Pos = 0x10
	// Bit mask of EFS field.
	MCAN_TXEFC_EFS_Msk = 0x3f0000
	// Position of EFWM field.
	MCAN_TXEFC_EFWM_Pos = 0x18
	// Bit mask of EFWM field.
	MCAN_TXEFC_EFWM_Msk = 0x3f000000

	// TXEFS: Transmit Event FIFO Status Register
	// Position of EFFL field.
	MCAN_TXEFS_EFFL_Pos = 0x0
	// Bit mask of EFFL field.
	MCAN_TXEFS_EFFL_Msk = 0x3f
	// Position of EFGI field.
	MCAN_TXEFS_EFGI_Pos = 0x8
	// Bit mask of EFGI field.
	MCAN_TXEFS_EFGI_Msk = 0x1f00
	// Position of EFPI field.
	MCAN_TXEFS_EFPI_Pos = 0x10
	// Bit mask of EFPI field.
	MCAN_TXEFS_EFPI_Msk = 0x1f0000
	// Position of EFF field.
	MCAN_TXEFS_EFF_Pos = 0x18
	// Bit mask of EFF field.
	MCAN_TXEFS_EFF_Msk = 0x1000000
	// Bit EFF.
	MCAN_TXEFS_EFF = 0x1000000
	// Position of TEFL field.
	MCAN_TXEFS_TEFL_Pos = 0x19
	// Bit mask of TEFL field.
	MCAN_TXEFS_TEFL_Msk = 0x2000000
	// Bit TEFL.
	MCAN_TXEFS_TEFL = 0x2000000

	// TXEFA: Transmit Event FIFO Acknowledge Register
	// Position of EFAI field.
	MCAN_TXEFA_EFAI_Pos = 0x0
	// Bit mask of EFAI field.
	MCAN_TXEFA_EFAI_Msk = 0x1f
)

// Constants for PIOA: Parallel Input/Output Controller
const (
	// PER: PIO Enable Register
	// Position of P0 field.
	PIO_PER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PER_P0_Msk = 0x1
	// Bit P0.
	PIO_PER_P0 = 0x1
	// Position of P1 field.
	PIO_PER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PER_P1_Msk = 0x2
	// Bit P1.
	PIO_PER_P1 = 0x2
	// Position of P2 field.
	PIO_PER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PER_P2_Msk = 0x4
	// Bit P2.
	PIO_PER_P2 = 0x4
	// Position of P3 field.
	PIO_PER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PER_P3_Msk = 0x8
	// Bit P3.
	PIO_PER_P3 = 0x8
	// Position of P4 field.
	PIO_PER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PER_P4_Msk = 0x10
	// Bit P4.
	PIO_PER_P4 = 0x10
	// Position of P5 field.
	PIO_PER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PER_P5_Msk = 0x20
	// Bit P5.
	PIO_PER_P5 = 0x20
	// Position of P6 field.
	PIO_PER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PER_P6_Msk = 0x40
	// Bit P6.
	PIO_PER_P6 = 0x40
	// Position of P7 field.
	PIO_PER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PER_P7_Msk = 0x80
	// Bit P7.
	PIO_PER_P7 = 0x80
	// Position of P8 field.
	PIO_PER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PER_P8_Msk = 0x100
	// Bit P8.
	PIO_PER_P8 = 0x100
	// Position of P9 field.
	PIO_PER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PER_P9_Msk = 0x200
	// Bit P9.
	PIO_PER_P9 = 0x200
	// Position of P10 field.
	PIO_PER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PER_P10_Msk = 0x400
	// Bit P10.
	PIO_PER_P10 = 0x400
	// Position of P11 field.
	PIO_PER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PER_P11_Msk = 0x800
	// Bit P11.
	PIO_PER_P11 = 0x800
	// Position of P12 field.
	PIO_PER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PER_P12 = 0x1000
	// Position of P13 field.
	PIO_PER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PER_P13 = 0x2000
	// Position of P14 field.
	PIO_PER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PER_P14 = 0x4000
	// Position of P15 field.
	PIO_PER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PER_P15 = 0x8000
	// Position of P16 field.
	PIO_PER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PER_P16 = 0x10000
	// Position of P17 field.
	PIO_PER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PER_P17 = 0x20000
	// Position of P18 field.
	PIO_PER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PER_P18 = 0x40000
	// Position of P19 field.
	PIO_PER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PER_P19 = 0x80000
	// Position of P20 field.
	PIO_PER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PER_P20 = 0x100000
	// Position of P21 field.
	PIO_PER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PER_P21 = 0x200000
	// Position of P22 field.
	PIO_PER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PER_P22 = 0x400000
	// Position of P23 field.
	PIO_PER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PER_P23 = 0x800000
	// Position of P24 field.
	PIO_PER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PER_P31 = 0x80000000

	// PDR: PIO Disable Register
	// Position of P0 field.
	PIO_PDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDR_P0 = 0x1
	// Position of P1 field.
	PIO_PDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDR_P1 = 0x2
	// Position of P2 field.
	PIO_PDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDR_P2 = 0x4
	// Position of P3 field.
	PIO_PDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDR_P3 = 0x8
	// Position of P4 field.
	PIO_PDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDR_P4 = 0x10
	// Position of P5 field.
	PIO_PDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDR_P5 = 0x20
	// Position of P6 field.
	PIO_PDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDR_P6 = 0x40
	// Position of P7 field.
	PIO_PDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDR_P7 = 0x80
	// Position of P8 field.
	PIO_PDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDR_P8 = 0x100
	// Position of P9 field.
	PIO_PDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDR_P9 = 0x200
	// Position of P10 field.
	PIO_PDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDR_P10 = 0x400
	// Position of P11 field.
	PIO_PDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDR_P11 = 0x800
	// Position of P12 field.
	PIO_PDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDR_P31 = 0x80000000

	// PSR: PIO Status Register
	// Position of P0 field.
	PIO_PSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PSR_P0 = 0x1
	// Position of P1 field.
	PIO_PSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PSR_P1 = 0x2
	// Position of P2 field.
	PIO_PSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PSR_P2 = 0x4
	// Position of P3 field.
	PIO_PSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PSR_P3 = 0x8
	// Position of P4 field.
	PIO_PSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PSR_P4 = 0x10
	// Position of P5 field.
	PIO_PSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PSR_P5 = 0x20
	// Position of P6 field.
	PIO_PSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PSR_P6 = 0x40
	// Position of P7 field.
	PIO_PSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PSR_P7 = 0x80
	// Position of P8 field.
	PIO_PSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PSR_P8 = 0x100
	// Position of P9 field.
	PIO_PSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PSR_P9 = 0x200
	// Position of P10 field.
	PIO_PSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PSR_P10 = 0x400
	// Position of P11 field.
	PIO_PSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PSR_P11 = 0x800
	// Position of P12 field.
	PIO_PSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PSR_P31 = 0x80000000

	// OER: Output Enable Register
	// Position of P0 field.
	PIO_OER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OER_P0_Msk = 0x1
	// Bit P0.
	PIO_OER_P0 = 0x1
	// Position of P1 field.
	PIO_OER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OER_P1_Msk = 0x2
	// Bit P1.
	PIO_OER_P1 = 0x2
	// Position of P2 field.
	PIO_OER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OER_P2_Msk = 0x4
	// Bit P2.
	PIO_OER_P2 = 0x4
	// Position of P3 field.
	PIO_OER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OER_P3_Msk = 0x8
	// Bit P3.
	PIO_OER_P3 = 0x8
	// Position of P4 field.
	PIO_OER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OER_P4_Msk = 0x10
	// Bit P4.
	PIO_OER_P4 = 0x10
	// Position of P5 field.
	PIO_OER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OER_P5_Msk = 0x20
	// Bit P5.
	PIO_OER_P5 = 0x20
	// Position of P6 field.
	PIO_OER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OER_P6_Msk = 0x40
	// Bit P6.
	PIO_OER_P6 = 0x40
	// Position of P7 field.
	PIO_OER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OER_P7_Msk = 0x80
	// Bit P7.
	PIO_OER_P7 = 0x80
	// Position of P8 field.
	PIO_OER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OER_P8_Msk = 0x100
	// Bit P8.
	PIO_OER_P8 = 0x100
	// Position of P9 field.
	PIO_OER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OER_P9_Msk = 0x200
	// Bit P9.
	PIO_OER_P9 = 0x200
	// Position of P10 field.
	PIO_OER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OER_P10_Msk = 0x400
	// Bit P10.
	PIO_OER_P10 = 0x400
	// Position of P11 field.
	PIO_OER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OER_P11_Msk = 0x800
	// Bit P11.
	PIO_OER_P11 = 0x800
	// Position of P12 field.
	PIO_OER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OER_P12 = 0x1000
	// Position of P13 field.
	PIO_OER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OER_P13 = 0x2000
	// Position of P14 field.
	PIO_OER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OER_P14 = 0x4000
	// Position of P15 field.
	PIO_OER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OER_P15 = 0x8000
	// Position of P16 field.
	PIO_OER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OER_P16 = 0x10000
	// Position of P17 field.
	PIO_OER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OER_P17 = 0x20000
	// Position of P18 field.
	PIO_OER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OER_P18 = 0x40000
	// Position of P19 field.
	PIO_OER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OER_P19 = 0x80000
	// Position of P20 field.
	PIO_OER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OER_P20 = 0x100000
	// Position of P21 field.
	PIO_OER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OER_P21 = 0x200000
	// Position of P22 field.
	PIO_OER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OER_P22 = 0x400000
	// Position of P23 field.
	PIO_OER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OER_P23 = 0x800000
	// Position of P24 field.
	PIO_OER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OER_P31 = 0x80000000

	// ODR: Output Disable Register
	// Position of P0 field.
	PIO_ODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODR_P0 = 0x1
	// Position of P1 field.
	PIO_ODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODR_P1 = 0x2
	// Position of P2 field.
	PIO_ODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODR_P2 = 0x4
	// Position of P3 field.
	PIO_ODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODR_P3 = 0x8
	// Position of P4 field.
	PIO_ODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODR_P4 = 0x10
	// Position of P5 field.
	PIO_ODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODR_P5 = 0x20
	// Position of P6 field.
	PIO_ODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODR_P6 = 0x40
	// Position of P7 field.
	PIO_ODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODR_P7 = 0x80
	// Position of P8 field.
	PIO_ODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODR_P8 = 0x100
	// Position of P9 field.
	PIO_ODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODR_P9 = 0x200
	// Position of P10 field.
	PIO_ODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODR_P10 = 0x400
	// Position of P11 field.
	PIO_ODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODR_P11 = 0x800
	// Position of P12 field.
	PIO_ODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODR_P31 = 0x80000000

	// OSR: Output Status Register
	// Position of P0 field.
	PIO_OSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OSR_P0 = 0x1
	// Position of P1 field.
	PIO_OSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OSR_P1 = 0x2
	// Position of P2 field.
	PIO_OSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OSR_P2 = 0x4
	// Position of P3 field.
	PIO_OSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OSR_P3 = 0x8
	// Position of P4 field.
	PIO_OSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OSR_P4 = 0x10
	// Position of P5 field.
	PIO_OSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OSR_P5 = 0x20
	// Position of P6 field.
	PIO_OSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OSR_P6 = 0x40
	// Position of P7 field.
	PIO_OSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OSR_P7 = 0x80
	// Position of P8 field.
	PIO_OSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OSR_P8 = 0x100
	// Position of P9 field.
	PIO_OSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OSR_P9 = 0x200
	// Position of P10 field.
	PIO_OSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OSR_P10 = 0x400
	// Position of P11 field.
	PIO_OSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OSR_P11 = 0x800
	// Position of P12 field.
	PIO_OSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OSR_P31 = 0x80000000

	// IFER: Glitch Input Filter Enable Register
	// Position of P0 field.
	PIO_IFER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFER_P0 = 0x1
	// Position of P1 field.
	PIO_IFER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFER_P1 = 0x2
	// Position of P2 field.
	PIO_IFER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFER_P2 = 0x4
	// Position of P3 field.
	PIO_IFER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFER_P3 = 0x8
	// Position of P4 field.
	PIO_IFER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFER_P4 = 0x10
	// Position of P5 field.
	PIO_IFER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFER_P5 = 0x20
	// Position of P6 field.
	PIO_IFER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFER_P6 = 0x40
	// Position of P7 field.
	PIO_IFER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFER_P7 = 0x80
	// Position of P8 field.
	PIO_IFER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFER_P8 = 0x100
	// Position of P9 field.
	PIO_IFER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFER_P9 = 0x200
	// Position of P10 field.
	PIO_IFER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFER_P10 = 0x400
	// Position of P11 field.
	PIO_IFER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFER_P11 = 0x800
	// Position of P12 field.
	PIO_IFER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFER_P31 = 0x80000000

	// IFDR: Glitch Input Filter Disable Register
	// Position of P0 field.
	PIO_IFDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFDR_P31 = 0x80000000

	// IFSR: Glitch Input Filter Status Register
	// Position of P0 field.
	PIO_IFSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSR_P31 = 0x80000000

	// SODR: Set Output Data Register
	// Position of P0 field.
	PIO_SODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_SODR_P0_Msk = 0x1
	// Bit P0.
	PIO_SODR_P0 = 0x1
	// Position of P1 field.
	PIO_SODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_SODR_P1_Msk = 0x2
	// Bit P1.
	PIO_SODR_P1 = 0x2
	// Position of P2 field.
	PIO_SODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_SODR_P2_Msk = 0x4
	// Bit P2.
	PIO_SODR_P2 = 0x4
	// Position of P3 field.
	PIO_SODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_SODR_P3_Msk = 0x8
	// Bit P3.
	PIO_SODR_P3 = 0x8
	// Position of P4 field.
	PIO_SODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_SODR_P4_Msk = 0x10
	// Bit P4.
	PIO_SODR_P4 = 0x10
	// Position of P5 field.
	PIO_SODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_SODR_P5_Msk = 0x20
	// Bit P5.
	PIO_SODR_P5 = 0x20
	// Position of P6 field.
	PIO_SODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_SODR_P6_Msk = 0x40
	// Bit P6.
	PIO_SODR_P6 = 0x40
	// Position of P7 field.
	PIO_SODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_SODR_P7_Msk = 0x80
	// Bit P7.
	PIO_SODR_P7 = 0x80
	// Position of P8 field.
	PIO_SODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_SODR_P8_Msk = 0x100
	// Bit P8.
	PIO_SODR_P8 = 0x100
	// Position of P9 field.
	PIO_SODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_SODR_P9_Msk = 0x200
	// Bit P9.
	PIO_SODR_P9 = 0x200
	// Position of P10 field.
	PIO_SODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_SODR_P10_Msk = 0x400
	// Bit P10.
	PIO_SODR_P10 = 0x400
	// Position of P11 field.
	PIO_SODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_SODR_P11_Msk = 0x800
	// Bit P11.
	PIO_SODR_P11 = 0x800
	// Position of P12 field.
	PIO_SODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_SODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_SODR_P12 = 0x1000
	// Position of P13 field.
	PIO_SODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_SODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_SODR_P13 = 0x2000
	// Position of P14 field.
	PIO_SODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_SODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_SODR_P14 = 0x4000
	// Position of P15 field.
	PIO_SODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_SODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_SODR_P15 = 0x8000
	// Position of P16 field.
	PIO_SODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_SODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_SODR_P16 = 0x10000
	// Position of P17 field.
	PIO_SODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_SODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_SODR_P17 = 0x20000
	// Position of P18 field.
	PIO_SODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_SODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_SODR_P18 = 0x40000
	// Position of P19 field.
	PIO_SODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_SODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_SODR_P19 = 0x80000
	// Position of P20 field.
	PIO_SODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_SODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_SODR_P20 = 0x100000
	// Position of P21 field.
	PIO_SODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_SODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_SODR_P21 = 0x200000
	// Position of P22 field.
	PIO_SODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_SODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_SODR_P22 = 0x400000
	// Position of P23 field.
	PIO_SODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_SODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_SODR_P23 = 0x800000
	// Position of P24 field.
	PIO_SODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_SODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_SODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_SODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_SODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_SODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_SODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_SODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_SODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_SODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_SODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_SODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_SODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_SODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_SODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_SODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_SODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_SODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_SODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_SODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_SODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_SODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_SODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_SODR_P31 = 0x80000000

	// CODR: Clear Output Data Register
	// Position of P0 field.
	PIO_CODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_CODR_P0_Msk = 0x1
	// Bit P0.
	PIO_CODR_P0 = 0x1
	// Position of P1 field.
	PIO_CODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_CODR_P1_Msk = 0x2
	// Bit P1.
	PIO_CODR_P1 = 0x2
	// Position of P2 field.
	PIO_CODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_CODR_P2_Msk = 0x4
	// Bit P2.
	PIO_CODR_P2 = 0x4
	// Position of P3 field.
	PIO_CODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_CODR_P3_Msk = 0x8
	// Bit P3.
	PIO_CODR_P3 = 0x8
	// Position of P4 field.
	PIO_CODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_CODR_P4_Msk = 0x10
	// Bit P4.
	PIO_CODR_P4 = 0x10
	// Position of P5 field.
	PIO_CODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_CODR_P5_Msk = 0x20
	// Bit P5.
	PIO_CODR_P5 = 0x20
	// Position of P6 field.
	PIO_CODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_CODR_P6_Msk = 0x40
	// Bit P6.
	PIO_CODR_P6 = 0x40
	// Position of P7 field.
	PIO_CODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_CODR_P7_Msk = 0x80
	// Bit P7.
	PIO_CODR_P7 = 0x80
	// Position of P8 field.
	PIO_CODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_CODR_P8_Msk = 0x100
	// Bit P8.
	PIO_CODR_P8 = 0x100
	// Position of P9 field.
	PIO_CODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_CODR_P9_Msk = 0x200
	// Bit P9.
	PIO_CODR_P9 = 0x200
	// Position of P10 field.
	PIO_CODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_CODR_P10_Msk = 0x400
	// Bit P10.
	PIO_CODR_P10 = 0x400
	// Position of P11 field.
	PIO_CODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_CODR_P11_Msk = 0x800
	// Bit P11.
	PIO_CODR_P11 = 0x800
	// Position of P12 field.
	PIO_CODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_CODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_CODR_P12 = 0x1000
	// Position of P13 field.
	PIO_CODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_CODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_CODR_P13 = 0x2000
	// Position of P14 field.
	PIO_CODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_CODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_CODR_P14 = 0x4000
	// Position of P15 field.
	PIO_CODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_CODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_CODR_P15 = 0x8000
	// Position of P16 field.
	PIO_CODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_CODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_CODR_P16 = 0x10000
	// Position of P17 field.
	PIO_CODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_CODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_CODR_P17 = 0x20000
	// Position of P18 field.
	PIO_CODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_CODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_CODR_P18 = 0x40000
	// Position of P19 field.
	PIO_CODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_CODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_CODR_P19 = 0x80000
	// Position of P20 field.
	PIO_CODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_CODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_CODR_P20 = 0x100000
	// Position of P21 field.
	PIO_CODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_CODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_CODR_P21 = 0x200000
	// Position of P22 field.
	PIO_CODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_CODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_CODR_P22 = 0x400000
	// Position of P23 field.
	PIO_CODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_CODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_CODR_P23 = 0x800000
	// Position of P24 field.
	PIO_CODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_CODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_CODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_CODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_CODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_CODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_CODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_CODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_CODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_CODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_CODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_CODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_CODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_CODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_CODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_CODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_CODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_CODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_CODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_CODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_CODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_CODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_CODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_CODR_P31 = 0x80000000

	// ODSR: Output Data Status Register
	// Position of P0 field.
	PIO_ODSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODSR_P0 = 0x1
	// Position of P1 field.
	PIO_ODSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODSR_P1 = 0x2
	// Position of P2 field.
	PIO_ODSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODSR_P2 = 0x4
	// Position of P3 field.
	PIO_ODSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODSR_P3 = 0x8
	// Position of P4 field.
	PIO_ODSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODSR_P4 = 0x10
	// Position of P5 field.
	PIO_ODSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODSR_P5 = 0x20
	// Position of P6 field.
	PIO_ODSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODSR_P6 = 0x40
	// Position of P7 field.
	PIO_ODSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODSR_P7 = 0x80
	// Position of P8 field.
	PIO_ODSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODSR_P8 = 0x100
	// Position of P9 field.
	PIO_ODSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODSR_P9 = 0x200
	// Position of P10 field.
	PIO_ODSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODSR_P10 = 0x400
	// Position of P11 field.
	PIO_ODSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODSR_P11 = 0x800
	// Position of P12 field.
	PIO_ODSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODSR_P31 = 0x80000000

	// PDSR: Pin Data Status Register
	// Position of P0 field.
	PIO_PDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDSR_P31 = 0x80000000

	// IER: Interrupt Enable Register
	// Position of P0 field.
	PIO_IER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IER_P0_Msk = 0x1
	// Bit P0.
	PIO_IER_P0 = 0x1
	// Position of P1 field.
	PIO_IER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IER_P1_Msk = 0x2
	// Bit P1.
	PIO_IER_P1 = 0x2
	// Position of P2 field.
	PIO_IER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IER_P2_Msk = 0x4
	// Bit P2.
	PIO_IER_P2 = 0x4
	// Position of P3 field.
	PIO_IER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IER_P3_Msk = 0x8
	// Bit P3.
	PIO_IER_P3 = 0x8
	// Position of P4 field.
	PIO_IER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IER_P4_Msk = 0x10
	// Bit P4.
	PIO_IER_P4 = 0x10
	// Position of P5 field.
	PIO_IER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IER_P5_Msk = 0x20
	// Bit P5.
	PIO_IER_P5 = 0x20
	// Position of P6 field.
	PIO_IER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IER_P6_Msk = 0x40
	// Bit P6.
	PIO_IER_P6 = 0x40
	// Position of P7 field.
	PIO_IER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IER_P7_Msk = 0x80
	// Bit P7.
	PIO_IER_P7 = 0x80
	// Position of P8 field.
	PIO_IER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IER_P8_Msk = 0x100
	// Bit P8.
	PIO_IER_P8 = 0x100
	// Position of P9 field.
	PIO_IER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IER_P9_Msk = 0x200
	// Bit P9.
	PIO_IER_P9 = 0x200
	// Position of P10 field.
	PIO_IER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IER_P10_Msk = 0x400
	// Bit P10.
	PIO_IER_P10 = 0x400
	// Position of P11 field.
	PIO_IER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IER_P11_Msk = 0x800
	// Bit P11.
	PIO_IER_P11 = 0x800
	// Position of P12 field.
	PIO_IER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IER_P12 = 0x1000
	// Position of P13 field.
	PIO_IER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IER_P13 = 0x2000
	// Position of P14 field.
	PIO_IER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IER_P14 = 0x4000
	// Position of P15 field.
	PIO_IER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IER_P15 = 0x8000
	// Position of P16 field.
	PIO_IER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IER_P16 = 0x10000
	// Position of P17 field.
	PIO_IER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IER_P17 = 0x20000
	// Position of P18 field.
	PIO_IER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IER_P18 = 0x40000
	// Position of P19 field.
	PIO_IER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IER_P19 = 0x80000
	// Position of P20 field.
	PIO_IER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IER_P20 = 0x100000
	// Position of P21 field.
	PIO_IER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IER_P21 = 0x200000
	// Position of P22 field.
	PIO_IER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IER_P22 = 0x400000
	// Position of P23 field.
	PIO_IER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IER_P23 = 0x800000
	// Position of P24 field.
	PIO_IER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IER_P31 = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of P0 field.
	PIO_IDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IDR_P0 = 0x1
	// Position of P1 field.
	PIO_IDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IDR_P1 = 0x2
	// Position of P2 field.
	PIO_IDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IDR_P2 = 0x4
	// Position of P3 field.
	PIO_IDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IDR_P3 = 0x8
	// Position of P4 field.
	PIO_IDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IDR_P4 = 0x10
	// Position of P5 field.
	PIO_IDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IDR_P5 = 0x20
	// Position of P6 field.
	PIO_IDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IDR_P6 = 0x40
	// Position of P7 field.
	PIO_IDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IDR_P7 = 0x80
	// Position of P8 field.
	PIO_IDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IDR_P8 = 0x100
	// Position of P9 field.
	PIO_IDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IDR_P9 = 0x200
	// Position of P10 field.
	PIO_IDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IDR_P10 = 0x400
	// Position of P11 field.
	PIO_IDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IDR_P11 = 0x800
	// Position of P12 field.
	PIO_IDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IDR_P31 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of P0 field.
	PIO_IMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IMR_P0_Msk = 0x1
	// Bit P0.
	PIO_IMR_P0 = 0x1
	// Position of P1 field.
	PIO_IMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IMR_P1_Msk = 0x2
	// Bit P1.
	PIO_IMR_P1 = 0x2
	// Position of P2 field.
	PIO_IMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IMR_P2_Msk = 0x4
	// Bit P2.
	PIO_IMR_P2 = 0x4
	// Position of P3 field.
	PIO_IMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IMR_P3_Msk = 0x8
	// Bit P3.
	PIO_IMR_P3 = 0x8
	// Position of P4 field.
	PIO_IMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IMR_P4_Msk = 0x10
	// Bit P4.
	PIO_IMR_P4 = 0x10
	// Position of P5 field.
	PIO_IMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IMR_P5_Msk = 0x20
	// Bit P5.
	PIO_IMR_P5 = 0x20
	// Position of P6 field.
	PIO_IMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IMR_P6_Msk = 0x40
	// Bit P6.
	PIO_IMR_P6 = 0x40
	// Position of P7 field.
	PIO_IMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IMR_P7_Msk = 0x80
	// Bit P7.
	PIO_IMR_P7 = 0x80
	// Position of P8 field.
	PIO_IMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IMR_P8_Msk = 0x100
	// Bit P8.
	PIO_IMR_P8 = 0x100
	// Position of P9 field.
	PIO_IMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IMR_P9_Msk = 0x200
	// Bit P9.
	PIO_IMR_P9 = 0x200
	// Position of P10 field.
	PIO_IMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IMR_P10_Msk = 0x400
	// Bit P10.
	PIO_IMR_P10 = 0x400
	// Position of P11 field.
	PIO_IMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IMR_P11_Msk = 0x800
	// Bit P11.
	PIO_IMR_P11 = 0x800
	// Position of P12 field.
	PIO_IMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IMR_P12 = 0x1000
	// Position of P13 field.
	PIO_IMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IMR_P13 = 0x2000
	// Position of P14 field.
	PIO_IMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IMR_P14 = 0x4000
	// Position of P15 field.
	PIO_IMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IMR_P15 = 0x8000
	// Position of P16 field.
	PIO_IMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IMR_P16 = 0x10000
	// Position of P17 field.
	PIO_IMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IMR_P17 = 0x20000
	// Position of P18 field.
	PIO_IMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IMR_P18 = 0x40000
	// Position of P19 field.
	PIO_IMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IMR_P19 = 0x80000
	// Position of P20 field.
	PIO_IMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IMR_P20 = 0x100000
	// Position of P21 field.
	PIO_IMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IMR_P21 = 0x200000
	// Position of P22 field.
	PIO_IMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IMR_P22 = 0x400000
	// Position of P23 field.
	PIO_IMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IMR_P23 = 0x800000
	// Position of P24 field.
	PIO_IMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IMR_P31 = 0x80000000

	// ISR: Interrupt Status Register
	// Position of P0 field.
	PIO_ISR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ISR_P0_Msk = 0x1
	// Bit P0.
	PIO_ISR_P0 = 0x1
	// Position of P1 field.
	PIO_ISR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ISR_P1_Msk = 0x2
	// Bit P1.
	PIO_ISR_P1 = 0x2
	// Position of P2 field.
	PIO_ISR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ISR_P2_Msk = 0x4
	// Bit P2.
	PIO_ISR_P2 = 0x4
	// Position of P3 field.
	PIO_ISR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ISR_P3_Msk = 0x8
	// Bit P3.
	PIO_ISR_P3 = 0x8
	// Position of P4 field.
	PIO_ISR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ISR_P4_Msk = 0x10
	// Bit P4.
	PIO_ISR_P4 = 0x10
	// Position of P5 field.
	PIO_ISR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ISR_P5_Msk = 0x20
	// Bit P5.
	PIO_ISR_P5 = 0x20
	// Position of P6 field.
	PIO_ISR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ISR_P6_Msk = 0x40
	// Bit P6.
	PIO_ISR_P6 = 0x40
	// Position of P7 field.
	PIO_ISR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ISR_P7_Msk = 0x80
	// Bit P7.
	PIO_ISR_P7 = 0x80
	// Position of P8 field.
	PIO_ISR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ISR_P8_Msk = 0x100
	// Bit P8.
	PIO_ISR_P8 = 0x100
	// Position of P9 field.
	PIO_ISR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ISR_P9_Msk = 0x200
	// Bit P9.
	PIO_ISR_P9 = 0x200
	// Position of P10 field.
	PIO_ISR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ISR_P10_Msk = 0x400
	// Bit P10.
	PIO_ISR_P10 = 0x400
	// Position of P11 field.
	PIO_ISR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ISR_P11_Msk = 0x800
	// Bit P11.
	PIO_ISR_P11 = 0x800
	// Position of P12 field.
	PIO_ISR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ISR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ISR_P12 = 0x1000
	// Position of P13 field.
	PIO_ISR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ISR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ISR_P13 = 0x2000
	// Position of P14 field.
	PIO_ISR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ISR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ISR_P14 = 0x4000
	// Position of P15 field.
	PIO_ISR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ISR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ISR_P15 = 0x8000
	// Position of P16 field.
	PIO_ISR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ISR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ISR_P16 = 0x10000
	// Position of P17 field.
	PIO_ISR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ISR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ISR_P17 = 0x20000
	// Position of P18 field.
	PIO_ISR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ISR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ISR_P18 = 0x40000
	// Position of P19 field.
	PIO_ISR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ISR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ISR_P19 = 0x80000
	// Position of P20 field.
	PIO_ISR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ISR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ISR_P20 = 0x100000
	// Position of P21 field.
	PIO_ISR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ISR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ISR_P21 = 0x200000
	// Position of P22 field.
	PIO_ISR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ISR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ISR_P22 = 0x400000
	// Position of P23 field.
	PIO_ISR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ISR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ISR_P23 = 0x800000
	// Position of P24 field.
	PIO_ISR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ISR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ISR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ISR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ISR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ISR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ISR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ISR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ISR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ISR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ISR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ISR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ISR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ISR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ISR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ISR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ISR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ISR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ISR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ISR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ISR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ISR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ISR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ISR_P31 = 0x80000000

	// MDER: Multi-driver Enable Register
	// Position of P0 field.
	PIO_MDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDER_P0_Msk = 0x1
	// Bit P0.
	PIO_MDER_P0 = 0x1
	// Position of P1 field.
	PIO_MDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDER_P1_Msk = 0x2
	// Bit P1.
	PIO_MDER_P1 = 0x2
	// Position of P2 field.
	PIO_MDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDER_P2_Msk = 0x4
	// Bit P2.
	PIO_MDER_P2 = 0x4
	// Position of P3 field.
	PIO_MDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDER_P3_Msk = 0x8
	// Bit P3.
	PIO_MDER_P3 = 0x8
	// Position of P4 field.
	PIO_MDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDER_P4_Msk = 0x10
	// Bit P4.
	PIO_MDER_P4 = 0x10
	// Position of P5 field.
	PIO_MDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDER_P5_Msk = 0x20
	// Bit P5.
	PIO_MDER_P5 = 0x20
	// Position of P6 field.
	PIO_MDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDER_P6_Msk = 0x40
	// Bit P6.
	PIO_MDER_P6 = 0x40
	// Position of P7 field.
	PIO_MDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDER_P7_Msk = 0x80
	// Bit P7.
	PIO_MDER_P7 = 0x80
	// Position of P8 field.
	PIO_MDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDER_P8_Msk = 0x100
	// Bit P8.
	PIO_MDER_P8 = 0x100
	// Position of P9 field.
	PIO_MDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDER_P9_Msk = 0x200
	// Bit P9.
	PIO_MDER_P9 = 0x200
	// Position of P10 field.
	PIO_MDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDER_P10_Msk = 0x400
	// Bit P10.
	PIO_MDER_P10 = 0x400
	// Position of P11 field.
	PIO_MDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDER_P11_Msk = 0x800
	// Bit P11.
	PIO_MDER_P11 = 0x800
	// Position of P12 field.
	PIO_MDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDER_P12 = 0x1000
	// Position of P13 field.
	PIO_MDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDER_P13 = 0x2000
	// Position of P14 field.
	PIO_MDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDER_P14 = 0x4000
	// Position of P15 field.
	PIO_MDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDER_P15 = 0x8000
	// Position of P16 field.
	PIO_MDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDER_P16 = 0x10000
	// Position of P17 field.
	PIO_MDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDER_P17 = 0x20000
	// Position of P18 field.
	PIO_MDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDER_P18 = 0x40000
	// Position of P19 field.
	PIO_MDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDER_P19 = 0x80000
	// Position of P20 field.
	PIO_MDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDER_P20 = 0x100000
	// Position of P21 field.
	PIO_MDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDER_P21 = 0x200000
	// Position of P22 field.
	PIO_MDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDER_P22 = 0x400000
	// Position of P23 field.
	PIO_MDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDER_P23 = 0x800000
	// Position of P24 field.
	PIO_MDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDER_P31 = 0x80000000

	// MDDR: Multi-driver Disable Register
	// Position of P0 field.
	PIO_MDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDDR_P0 = 0x1
	// Position of P1 field.
	PIO_MDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDDR_P1 = 0x2
	// Position of P2 field.
	PIO_MDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDDR_P2 = 0x4
	// Position of P3 field.
	PIO_MDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDDR_P3 = 0x8
	// Position of P4 field.
	PIO_MDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDDR_P4 = 0x10
	// Position of P5 field.
	PIO_MDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDDR_P5 = 0x20
	// Position of P6 field.
	PIO_MDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDDR_P6 = 0x40
	// Position of P7 field.
	PIO_MDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDDR_P7 = 0x80
	// Position of P8 field.
	PIO_MDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDDR_P8 = 0x100
	// Position of P9 field.
	PIO_MDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDDR_P9 = 0x200
	// Position of P10 field.
	PIO_MDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDDR_P10 = 0x400
	// Position of P11 field.
	PIO_MDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDDR_P11 = 0x800
	// Position of P12 field.
	PIO_MDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDDR_P31 = 0x80000000

	// MDSR: Multi-driver Status Register
	// Position of P0 field.
	PIO_MDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDSR_P0 = 0x1
	// Position of P1 field.
	PIO_MDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDSR_P1 = 0x2
	// Position of P2 field.
	PIO_MDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDSR_P2 = 0x4
	// Position of P3 field.
	PIO_MDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDSR_P3 = 0x8
	// Position of P4 field.
	PIO_MDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDSR_P4 = 0x10
	// Position of P5 field.
	PIO_MDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDSR_P5 = 0x20
	// Position of P6 field.
	PIO_MDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDSR_P6 = 0x40
	// Position of P7 field.
	PIO_MDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDSR_P7 = 0x80
	// Position of P8 field.
	PIO_MDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDSR_P8 = 0x100
	// Position of P9 field.
	PIO_MDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDSR_P9 = 0x200
	// Position of P10 field.
	PIO_MDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDSR_P10 = 0x400
	// Position of P11 field.
	PIO_MDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDSR_P11 = 0x800
	// Position of P12 field.
	PIO_MDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDSR_P31 = 0x80000000

	// PUDR: Pull-up Disable Register
	// Position of P0 field.
	PIO_PUDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUDR_P0 = 0x1
	// Position of P1 field.
	PIO_PUDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUDR_P1 = 0x2
	// Position of P2 field.
	PIO_PUDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUDR_P2 = 0x4
	// Position of P3 field.
	PIO_PUDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUDR_P3 = 0x8
	// Position of P4 field.
	PIO_PUDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUDR_P4 = 0x10
	// Position of P5 field.
	PIO_PUDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUDR_P5 = 0x20
	// Position of P6 field.
	PIO_PUDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUDR_P6 = 0x40
	// Position of P7 field.
	PIO_PUDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUDR_P7 = 0x80
	// Position of P8 field.
	PIO_PUDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUDR_P8 = 0x100
	// Position of P9 field.
	PIO_PUDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUDR_P9 = 0x200
	// Position of P10 field.
	PIO_PUDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUDR_P10 = 0x400
	// Position of P11 field.
	PIO_PUDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUDR_P11 = 0x800
	// Position of P12 field.
	PIO_PUDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUDR_P31 = 0x80000000

	// PUER: Pull-up Enable Register
	// Position of P0 field.
	PIO_PUER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUER_P0_Msk = 0x1
	// Bit P0.
	PIO_PUER_P0 = 0x1
	// Position of P1 field.
	PIO_PUER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUER_P1_Msk = 0x2
	// Bit P1.
	PIO_PUER_P1 = 0x2
	// Position of P2 field.
	PIO_PUER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUER_P2_Msk = 0x4
	// Bit P2.
	PIO_PUER_P2 = 0x4
	// Position of P3 field.
	PIO_PUER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUER_P3_Msk = 0x8
	// Bit P3.
	PIO_PUER_P3 = 0x8
	// Position of P4 field.
	PIO_PUER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUER_P4_Msk = 0x10
	// Bit P4.
	PIO_PUER_P4 = 0x10
	// Position of P5 field.
	PIO_PUER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUER_P5_Msk = 0x20
	// Bit P5.
	PIO_PUER_P5 = 0x20
	// Position of P6 field.
	PIO_PUER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUER_P6_Msk = 0x40
	// Bit P6.
	PIO_PUER_P6 = 0x40
	// Position of P7 field.
	PIO_PUER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUER_P7_Msk = 0x80
	// Bit P7.
	PIO_PUER_P7 = 0x80
	// Position of P8 field.
	PIO_PUER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUER_P8_Msk = 0x100
	// Bit P8.
	PIO_PUER_P8 = 0x100
	// Position of P9 field.
	PIO_PUER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUER_P9_Msk = 0x200
	// Bit P9.
	PIO_PUER_P9 = 0x200
	// Position of P10 field.
	PIO_PUER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUER_P10_Msk = 0x400
	// Bit P10.
	PIO_PUER_P10 = 0x400
	// Position of P11 field.
	PIO_PUER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUER_P11_Msk = 0x800
	// Bit P11.
	PIO_PUER_P11 = 0x800
	// Position of P12 field.
	PIO_PUER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUER_P12 = 0x1000
	// Position of P13 field.
	PIO_PUER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUER_P13 = 0x2000
	// Position of P14 field.
	PIO_PUER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUER_P14 = 0x4000
	// Position of P15 field.
	PIO_PUER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUER_P15 = 0x8000
	// Position of P16 field.
	PIO_PUER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUER_P16 = 0x10000
	// Position of P17 field.
	PIO_PUER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUER_P17 = 0x20000
	// Position of P18 field.
	PIO_PUER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUER_P18 = 0x40000
	// Position of P19 field.
	PIO_PUER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUER_P19 = 0x80000
	// Position of P20 field.
	PIO_PUER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUER_P20 = 0x100000
	// Position of P21 field.
	PIO_PUER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUER_P21 = 0x200000
	// Position of P22 field.
	PIO_PUER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUER_P22 = 0x400000
	// Position of P23 field.
	PIO_PUER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUER_P23 = 0x800000
	// Position of P24 field.
	PIO_PUER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUER_P31 = 0x80000000

	// PUSR: Pad Pull-up Status Register
	// Position of P0 field.
	PIO_PUSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUSR_P0 = 0x1
	// Position of P1 field.
	PIO_PUSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUSR_P1 = 0x2
	// Position of P2 field.
	PIO_PUSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUSR_P2 = 0x4
	// Position of P3 field.
	PIO_PUSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUSR_P3 = 0x8
	// Position of P4 field.
	PIO_PUSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUSR_P4 = 0x10
	// Position of P5 field.
	PIO_PUSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUSR_P5 = 0x20
	// Position of P6 field.
	PIO_PUSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUSR_P6 = 0x40
	// Position of P7 field.
	PIO_PUSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUSR_P7 = 0x80
	// Position of P8 field.
	PIO_PUSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUSR_P8 = 0x100
	// Position of P9 field.
	PIO_PUSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUSR_P9 = 0x200
	// Position of P10 field.
	PIO_PUSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUSR_P10 = 0x400
	// Position of P11 field.
	PIO_PUSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUSR_P11 = 0x800
	// Position of P12 field.
	PIO_PUSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUSR_P31 = 0x80000000

	// ABCDSR: Peripheral ABCD Select Register 0
	// Position of P0 field.
	PIO_ABCDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ABCDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ABCDSR_P0 = 0x1
	// Position of P1 field.
	PIO_ABCDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ABCDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ABCDSR_P1 = 0x2
	// Position of P2 field.
	PIO_ABCDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ABCDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ABCDSR_P2 = 0x4
	// Position of P3 field.
	PIO_ABCDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ABCDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ABCDSR_P3 = 0x8
	// Position of P4 field.
	PIO_ABCDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ABCDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ABCDSR_P4 = 0x10
	// Position of P5 field.
	PIO_ABCDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ABCDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ABCDSR_P5 = 0x20
	// Position of P6 field.
	PIO_ABCDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ABCDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ABCDSR_P6 = 0x40
	// Position of P7 field.
	PIO_ABCDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ABCDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ABCDSR_P7 = 0x80
	// Position of P8 field.
	PIO_ABCDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ABCDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ABCDSR_P8 = 0x100
	// Position of P9 field.
	PIO_ABCDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ABCDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ABCDSR_P9 = 0x200
	// Position of P10 field.
	PIO_ABCDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ABCDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ABCDSR_P10 = 0x400
	// Position of P11 field.
	PIO_ABCDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ABCDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ABCDSR_P11 = 0x800
	// Position of P12 field.
	PIO_ABCDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ABCDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ABCDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ABCDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ABCDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ABCDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ABCDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ABCDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ABCDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ABCDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ABCDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ABCDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ABCDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ABCDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ABCDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ABCDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ABCDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ABCDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ABCDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ABCDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ABCDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ABCDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ABCDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ABCDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ABCDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ABCDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ABCDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ABCDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ABCDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ABCDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ABCDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ABCDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ABCDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ABCDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ABCDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ABCDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ABCDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ABCDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ABCDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ABCDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ABCDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ABCDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ABCDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ABCDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ABCDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ABCDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ABCDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ABCDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ABCDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ABCDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ABCDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ABCDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ABCDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ABCDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ABCDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ABCDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ABCDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ABCDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ABCDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ABCDSR_P31 = 0x80000000

	// IFSCDR: Input Filter Slow Clock Disable Register
	// Position of P0 field.
	PIO_IFSCDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCDR_P31 = 0x80000000

	// IFSCER: Input Filter Slow Clock Enable Register
	// Position of P0 field.
	PIO_IFSCER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCER_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCER_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCER_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCER_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCER_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCER_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCER_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCER_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCER_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCER_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCER_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCER_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCER_P31 = 0x80000000

	// IFSCSR: Input Filter Slow Clock Status Register
	// Position of P0 field.
	PIO_IFSCSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCSR_P31 = 0x80000000

	// SCDR: Slow Clock Divider Debouncing Register
	// Position of DIV field.
	PIO_SCDR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	PIO_SCDR_DIV_Msk = 0x3fff

	// PPDDR: Pad Pull-down Disable Register
	// Position of P0 field.
	PIO_PPDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDDR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDDR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDDR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDDR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDDR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDDR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDDR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDDR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDDR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDDR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDDR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDDR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDDR_P31 = 0x80000000

	// PPDER: Pad Pull-down Enable Register
	// Position of P0 field.
	PIO_PPDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDER_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDER_P0 = 0x1
	// Position of P1 field.
	PIO_PPDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDER_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDER_P1 = 0x2
	// Position of P2 field.
	PIO_PPDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDER_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDER_P2 = 0x4
	// Position of P3 field.
	PIO_PPDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDER_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDER_P3 = 0x8
	// Position of P4 field.
	PIO_PPDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDER_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDER_P4 = 0x10
	// Position of P5 field.
	PIO_PPDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDER_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDER_P5 = 0x20
	// Position of P6 field.
	PIO_PPDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDER_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDER_P6 = 0x40
	// Position of P7 field.
	PIO_PPDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDER_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDER_P7 = 0x80
	// Position of P8 field.
	PIO_PPDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDER_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDER_P8 = 0x100
	// Position of P9 field.
	PIO_PPDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDER_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDER_P9 = 0x200
	// Position of P10 field.
	PIO_PPDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDER_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDER_P10 = 0x400
	// Position of P11 field.
	PIO_PPDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDER_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDER_P11 = 0x800
	// Position of P12 field.
	PIO_PPDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDER_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDER_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDER_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDER_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDER_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDER_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDER_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDER_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDER_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDER_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDER_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDER_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDER_P31 = 0x80000000

	// PPDSR: Pad Pull-down Status Register
	// Position of P0 field.
	PIO_PPDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDSR_P31 = 0x80000000

	// OWER: Output Write Enable
	// Position of P0 field.
	PIO_OWER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWER_P0_Msk = 0x1
	// Bit P0.
	PIO_OWER_P0 = 0x1
	// Position of P1 field.
	PIO_OWER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWER_P1_Msk = 0x2
	// Bit P1.
	PIO_OWER_P1 = 0x2
	// Position of P2 field.
	PIO_OWER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWER_P2_Msk = 0x4
	// Bit P2.
	PIO_OWER_P2 = 0x4
	// Position of P3 field.
	PIO_OWER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWER_P3_Msk = 0x8
	// Bit P3.
	PIO_OWER_P3 = 0x8
	// Position of P4 field.
	PIO_OWER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWER_P4_Msk = 0x10
	// Bit P4.
	PIO_OWER_P4 = 0x10
	// Position of P5 field.
	PIO_OWER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWER_P5_Msk = 0x20
	// Bit P5.
	PIO_OWER_P5 = 0x20
	// Position of P6 field.
	PIO_OWER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWER_P6_Msk = 0x40
	// Bit P6.
	PIO_OWER_P6 = 0x40
	// Position of P7 field.
	PIO_OWER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWER_P7_Msk = 0x80
	// Bit P7.
	PIO_OWER_P7 = 0x80
	// Position of P8 field.
	PIO_OWER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWER_P8_Msk = 0x100
	// Bit P8.
	PIO_OWER_P8 = 0x100
	// Position of P9 field.
	PIO_OWER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWER_P9_Msk = 0x200
	// Bit P9.
	PIO_OWER_P9 = 0x200
	// Position of P10 field.
	PIO_OWER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWER_P10_Msk = 0x400
	// Bit P10.
	PIO_OWER_P10 = 0x400
	// Position of P11 field.
	PIO_OWER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWER_P11_Msk = 0x800
	// Bit P11.
	PIO_OWER_P11 = 0x800
	// Position of P12 field.
	PIO_OWER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWER_P12 = 0x1000
	// Position of P13 field.
	PIO_OWER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWER_P13 = 0x2000
	// Position of P14 field.
	PIO_OWER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWER_P14 = 0x4000
	// Position of P15 field.
	PIO_OWER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWER_P15 = 0x8000
	// Position of P16 field.
	PIO_OWER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWER_P16 = 0x10000
	// Position of P17 field.
	PIO_OWER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWER_P17 = 0x20000
	// Position of P18 field.
	PIO_OWER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWER_P18 = 0x40000
	// Position of P19 field.
	PIO_OWER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWER_P19 = 0x80000
	// Position of P20 field.
	PIO_OWER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWER_P20 = 0x100000
	// Position of P21 field.
	PIO_OWER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWER_P21 = 0x200000
	// Position of P22 field.
	PIO_OWER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWER_P22 = 0x400000
	// Position of P23 field.
	PIO_OWER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWER_P23 = 0x800000
	// Position of P24 field.
	PIO_OWER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWER_P31 = 0x80000000

	// OWDR: Output Write Disable
	// Position of P0 field.
	PIO_OWDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWDR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWDR_P0 = 0x1
	// Position of P1 field.
	PIO_OWDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWDR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWDR_P1 = 0x2
	// Position of P2 field.
	PIO_OWDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWDR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWDR_P2 = 0x4
	// Position of P3 field.
	PIO_OWDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWDR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWDR_P3 = 0x8
	// Position of P4 field.
	PIO_OWDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWDR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWDR_P4 = 0x10
	// Position of P5 field.
	PIO_OWDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWDR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWDR_P5 = 0x20
	// Position of P6 field.
	PIO_OWDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWDR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWDR_P6 = 0x40
	// Position of P7 field.
	PIO_OWDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWDR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWDR_P7 = 0x80
	// Position of P8 field.
	PIO_OWDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWDR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWDR_P8 = 0x100
	// Position of P9 field.
	PIO_OWDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWDR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWDR_P9 = 0x200
	// Position of P10 field.
	PIO_OWDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWDR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWDR_P10 = 0x400
	// Position of P11 field.
	PIO_OWDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWDR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWDR_P11 = 0x800
	// Position of P12 field.
	PIO_OWDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWDR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWDR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWDR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWDR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWDR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWDR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWDR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWDR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWDR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWDR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWDR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWDR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWDR_P31 = 0x80000000

	// OWSR: Output Write Status Register
	// Position of P0 field.
	PIO_OWSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWSR_P0 = 0x1
	// Position of P1 field.
	PIO_OWSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWSR_P1 = 0x2
	// Position of P2 field.
	PIO_OWSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWSR_P2 = 0x4
	// Position of P3 field.
	PIO_OWSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWSR_P3 = 0x8
	// Position of P4 field.
	PIO_OWSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWSR_P4 = 0x10
	// Position of P5 field.
	PIO_OWSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWSR_P5 = 0x20
	// Position of P6 field.
	PIO_OWSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWSR_P6 = 0x40
	// Position of P7 field.
	PIO_OWSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWSR_P7 = 0x80
	// Position of P8 field.
	PIO_OWSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWSR_P8 = 0x100
	// Position of P9 field.
	PIO_OWSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWSR_P9 = 0x200
	// Position of P10 field.
	PIO_OWSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWSR_P10 = 0x400
	// Position of P11 field.
	PIO_OWSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWSR_P11 = 0x800
	// Position of P12 field.
	PIO_OWSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWSR_P31 = 0x80000000

	// AIMER: Additional Interrupt Modes Enable Register
	// Position of P0 field.
	PIO_AIMER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMER_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMER_P0 = 0x1
	// Position of P1 field.
	PIO_AIMER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMER_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMER_P1 = 0x2
	// Position of P2 field.
	PIO_AIMER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMER_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMER_P2 = 0x4
	// Position of P3 field.
	PIO_AIMER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMER_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMER_P3 = 0x8
	// Position of P4 field.
	PIO_AIMER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMER_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMER_P4 = 0x10
	// Position of P5 field.
	PIO_AIMER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMER_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMER_P5 = 0x20
	// Position of P6 field.
	PIO_AIMER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMER_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMER_P6 = 0x40
	// Position of P7 field.
	PIO_AIMER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMER_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMER_P7 = 0x80
	// Position of P8 field.
	PIO_AIMER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMER_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMER_P8 = 0x100
	// Position of P9 field.
	PIO_AIMER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMER_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMER_P9 = 0x200
	// Position of P10 field.
	PIO_AIMER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMER_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMER_P10 = 0x400
	// Position of P11 field.
	PIO_AIMER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMER_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMER_P11 = 0x800
	// Position of P12 field.
	PIO_AIMER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMER_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMER_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMER_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMER_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMER_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMER_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMER_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMER_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMER_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMER_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMER_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMER_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMER_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMER_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMER_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMER_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMER_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMER_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMER_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMER_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMER_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMER_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMER_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMER_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMER_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMER_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMER_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMER_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMER_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMER_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMER_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMER_P31 = 0x80000000

	// AIMDR: Additional Interrupt Modes Disable Register
	// Position of P0 field.
	PIO_AIMDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMDR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMDR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMDR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMDR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMDR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMDR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMDR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMDR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMDR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMDR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMDR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMDR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMDR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMDR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMDR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMDR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMDR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMDR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMDR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMDR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMDR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMDR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMDR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMDR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMDR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMDR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMDR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMDR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMDR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMDR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMDR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMDR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMDR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMDR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMDR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMDR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMDR_P31 = 0x80000000

	// AIMMR: Additional Interrupt Modes Mask Register
	// Position of P0 field.
	PIO_AIMMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMMR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMMR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMMR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMMR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMMR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMMR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMMR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMMR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMMR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMMR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMMR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMMR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMMR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMMR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMMR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMMR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMMR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMMR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMMR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMMR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMMR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMMR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMMR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMMR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMMR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMMR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMMR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMMR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMMR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMMR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMMR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMMR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMMR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMMR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMMR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMMR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMMR_P31 = 0x80000000

	// ESR: Edge Select Register
	// Position of P0 field.
	PIO_ESR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ESR_P0_Msk = 0x1
	// Bit P0.
	PIO_ESR_P0 = 0x1
	// Position of P1 field.
	PIO_ESR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ESR_P1_Msk = 0x2
	// Bit P1.
	PIO_ESR_P1 = 0x2
	// Position of P2 field.
	PIO_ESR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ESR_P2_Msk = 0x4
	// Bit P2.
	PIO_ESR_P2 = 0x4
	// Position of P3 field.
	PIO_ESR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ESR_P3_Msk = 0x8
	// Bit P3.
	PIO_ESR_P3 = 0x8
	// Position of P4 field.
	PIO_ESR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ESR_P4_Msk = 0x10
	// Bit P4.
	PIO_ESR_P4 = 0x10
	// Position of P5 field.
	PIO_ESR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ESR_P5_Msk = 0x20
	// Bit P5.
	PIO_ESR_P5 = 0x20
	// Position of P6 field.
	PIO_ESR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ESR_P6_Msk = 0x40
	// Bit P6.
	PIO_ESR_P6 = 0x40
	// Position of P7 field.
	PIO_ESR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ESR_P7_Msk = 0x80
	// Bit P7.
	PIO_ESR_P7 = 0x80
	// Position of P8 field.
	PIO_ESR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ESR_P8_Msk = 0x100
	// Bit P8.
	PIO_ESR_P8 = 0x100
	// Position of P9 field.
	PIO_ESR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ESR_P9_Msk = 0x200
	// Bit P9.
	PIO_ESR_P9 = 0x200
	// Position of P10 field.
	PIO_ESR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ESR_P10_Msk = 0x400
	// Bit P10.
	PIO_ESR_P10 = 0x400
	// Position of P11 field.
	PIO_ESR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ESR_P11_Msk = 0x800
	// Bit P11.
	PIO_ESR_P11 = 0x800
	// Position of P12 field.
	PIO_ESR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ESR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ESR_P12 = 0x1000
	// Position of P13 field.
	PIO_ESR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ESR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ESR_P13 = 0x2000
	// Position of P14 field.
	PIO_ESR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ESR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ESR_P14 = 0x4000
	// Position of P15 field.
	PIO_ESR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ESR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ESR_P15 = 0x8000
	// Position of P16 field.
	PIO_ESR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ESR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ESR_P16 = 0x10000
	// Position of P17 field.
	PIO_ESR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ESR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ESR_P17 = 0x20000
	// Position of P18 field.
	PIO_ESR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ESR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ESR_P18 = 0x40000
	// Position of P19 field.
	PIO_ESR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ESR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ESR_P19 = 0x80000
	// Position of P20 field.
	PIO_ESR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ESR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ESR_P20 = 0x100000
	// Position of P21 field.
	PIO_ESR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ESR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ESR_P21 = 0x200000
	// Position of P22 field.
	PIO_ESR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ESR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ESR_P22 = 0x400000
	// Position of P23 field.
	PIO_ESR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ESR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ESR_P23 = 0x800000
	// Position of P24 field.
	PIO_ESR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ESR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ESR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ESR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ESR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ESR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ESR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ESR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ESR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ESR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ESR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ESR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ESR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ESR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ESR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ESR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ESR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ESR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ESR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ESR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ESR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ESR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ESR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ESR_P31 = 0x80000000

	// LSR: Level Select Register
	// Position of P0 field.
	PIO_LSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LSR_P0 = 0x1
	// Position of P1 field.
	PIO_LSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LSR_P1 = 0x2
	// Position of P2 field.
	PIO_LSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LSR_P2 = 0x4
	// Position of P3 field.
	PIO_LSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LSR_P3 = 0x8
	// Position of P4 field.
	PIO_LSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LSR_P4 = 0x10
	// Position of P5 field.
	PIO_LSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LSR_P5 = 0x20
	// Position of P6 field.
	PIO_LSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LSR_P6 = 0x40
	// Position of P7 field.
	PIO_LSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LSR_P7 = 0x80
	// Position of P8 field.
	PIO_LSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LSR_P8 = 0x100
	// Position of P9 field.
	PIO_LSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LSR_P9 = 0x200
	// Position of P10 field.
	PIO_LSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LSR_P10 = 0x400
	// Position of P11 field.
	PIO_LSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LSR_P11 = 0x800
	// Position of P12 field.
	PIO_LSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LSR_P31 = 0x80000000

	// ELSR: Edge/Level Status Register
	// Position of P0 field.
	PIO_ELSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ELSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ELSR_P0 = 0x1
	// Position of P1 field.
	PIO_ELSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ELSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ELSR_P1 = 0x2
	// Position of P2 field.
	PIO_ELSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ELSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ELSR_P2 = 0x4
	// Position of P3 field.
	PIO_ELSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ELSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ELSR_P3 = 0x8
	// Position of P4 field.
	PIO_ELSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ELSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ELSR_P4 = 0x10
	// Position of P5 field.
	PIO_ELSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ELSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ELSR_P5 = 0x20
	// Position of P6 field.
	PIO_ELSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ELSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ELSR_P6 = 0x40
	// Position of P7 field.
	PIO_ELSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ELSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ELSR_P7 = 0x80
	// Position of P8 field.
	PIO_ELSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ELSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ELSR_P8 = 0x100
	// Position of P9 field.
	PIO_ELSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ELSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ELSR_P9 = 0x200
	// Position of P10 field.
	PIO_ELSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ELSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ELSR_P10 = 0x400
	// Position of P11 field.
	PIO_ELSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ELSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ELSR_P11 = 0x800
	// Position of P12 field.
	PIO_ELSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ELSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ELSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ELSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ELSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ELSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ELSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ELSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ELSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ELSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ELSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ELSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ELSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ELSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ELSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ELSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ELSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ELSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ELSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ELSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ELSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ELSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ELSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ELSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ELSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ELSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ELSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ELSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ELSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ELSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ELSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ELSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ELSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ELSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ELSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ELSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ELSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ELSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ELSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ELSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ELSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ELSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ELSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ELSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ELSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ELSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ELSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ELSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ELSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ELSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ELSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ELSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ELSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ELSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ELSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ELSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ELSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ELSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ELSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ELSR_P31 = 0x80000000

	// FELLSR: Falling Edge/Low-Level Select Register
	// Position of P0 field.
	PIO_FELLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FELLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FELLSR_P0 = 0x1
	// Position of P1 field.
	PIO_FELLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FELLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FELLSR_P1 = 0x2
	// Position of P2 field.
	PIO_FELLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FELLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FELLSR_P2 = 0x4
	// Position of P3 field.
	PIO_FELLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FELLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FELLSR_P3 = 0x8
	// Position of P4 field.
	PIO_FELLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FELLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FELLSR_P4 = 0x10
	// Position of P5 field.
	PIO_FELLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FELLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FELLSR_P5 = 0x20
	// Position of P6 field.
	PIO_FELLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FELLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FELLSR_P6 = 0x40
	// Position of P7 field.
	PIO_FELLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FELLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FELLSR_P7 = 0x80
	// Position of P8 field.
	PIO_FELLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FELLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FELLSR_P8 = 0x100
	// Position of P9 field.
	PIO_FELLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FELLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FELLSR_P9 = 0x200
	// Position of P10 field.
	PIO_FELLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FELLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FELLSR_P10 = 0x400
	// Position of P11 field.
	PIO_FELLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FELLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FELLSR_P11 = 0x800
	// Position of P12 field.
	PIO_FELLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FELLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FELLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FELLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FELLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FELLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FELLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FELLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FELLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FELLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FELLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FELLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FELLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FELLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FELLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FELLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FELLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FELLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FELLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FELLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FELLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FELLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FELLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FELLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FELLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FELLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FELLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FELLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FELLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FELLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FELLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FELLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FELLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FELLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FELLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FELLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FELLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FELLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FELLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FELLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FELLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FELLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FELLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FELLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FELLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FELLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FELLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FELLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FELLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FELLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FELLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FELLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FELLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FELLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FELLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FELLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FELLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FELLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FELLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FELLSR_P31 = 0x80000000

	// REHLSR: Rising Edge/High-Level Select Register
	// Position of P0 field.
	PIO_REHLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_REHLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_REHLSR_P0 = 0x1
	// Position of P1 field.
	PIO_REHLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_REHLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_REHLSR_P1 = 0x2
	// Position of P2 field.
	PIO_REHLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_REHLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_REHLSR_P2 = 0x4
	// Position of P3 field.
	PIO_REHLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_REHLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_REHLSR_P3 = 0x8
	// Position of P4 field.
	PIO_REHLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_REHLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_REHLSR_P4 = 0x10
	// Position of P5 field.
	PIO_REHLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_REHLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_REHLSR_P5 = 0x20
	// Position of P6 field.
	PIO_REHLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_REHLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_REHLSR_P6 = 0x40
	// Position of P7 field.
	PIO_REHLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_REHLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_REHLSR_P7 = 0x80
	// Position of P8 field.
	PIO_REHLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_REHLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_REHLSR_P8 = 0x100
	// Position of P9 field.
	PIO_REHLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_REHLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_REHLSR_P9 = 0x200
	// Position of P10 field.
	PIO_REHLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_REHLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_REHLSR_P10 = 0x400
	// Position of P11 field.
	PIO_REHLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_REHLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_REHLSR_P11 = 0x800
	// Position of P12 field.
	PIO_REHLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_REHLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_REHLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_REHLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_REHLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_REHLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_REHLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_REHLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_REHLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_REHLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_REHLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_REHLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_REHLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_REHLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_REHLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_REHLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_REHLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_REHLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_REHLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_REHLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_REHLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_REHLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_REHLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_REHLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_REHLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_REHLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_REHLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_REHLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_REHLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_REHLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_REHLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_REHLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_REHLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_REHLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_REHLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_REHLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_REHLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_REHLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_REHLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_REHLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_REHLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_REHLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_REHLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_REHLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_REHLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_REHLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_REHLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_REHLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_REHLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_REHLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_REHLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_REHLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_REHLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_REHLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_REHLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_REHLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_REHLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_REHLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_REHLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_REHLSR_P31 = 0x80000000

	// FRLHSR: Fall/Rise - Low/High Status Register
	// Position of P0 field.
	PIO_FRLHSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FRLHSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FRLHSR_P0 = 0x1
	// Position of P1 field.
	PIO_FRLHSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FRLHSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FRLHSR_P1 = 0x2
	// Position of P2 field.
	PIO_FRLHSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FRLHSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FRLHSR_P2 = 0x4
	// Position of P3 field.
	PIO_FRLHSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FRLHSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FRLHSR_P3 = 0x8
	// Position of P4 field.
	PIO_FRLHSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FRLHSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FRLHSR_P4 = 0x10
	// Position of P5 field.
	PIO_FRLHSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FRLHSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FRLHSR_P5 = 0x20
	// Position of P6 field.
	PIO_FRLHSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FRLHSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FRLHSR_P6 = 0x40
	// Position of P7 field.
	PIO_FRLHSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FRLHSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FRLHSR_P7 = 0x80
	// Position of P8 field.
	PIO_FRLHSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FRLHSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FRLHSR_P8 = 0x100
	// Position of P9 field.
	PIO_FRLHSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FRLHSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FRLHSR_P9 = 0x200
	// Position of P10 field.
	PIO_FRLHSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FRLHSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FRLHSR_P10 = 0x400
	// Position of P11 field.
	PIO_FRLHSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FRLHSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FRLHSR_P11 = 0x800
	// Position of P12 field.
	PIO_FRLHSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FRLHSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FRLHSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FRLHSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FRLHSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FRLHSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FRLHSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FRLHSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FRLHSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FRLHSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FRLHSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FRLHSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FRLHSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FRLHSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FRLHSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FRLHSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FRLHSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FRLHSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FRLHSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FRLHSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FRLHSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FRLHSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FRLHSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FRLHSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FRLHSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FRLHSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FRLHSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FRLHSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FRLHSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FRLHSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FRLHSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FRLHSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FRLHSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FRLHSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FRLHSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FRLHSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FRLHSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FRLHSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FRLHSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FRLHSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FRLHSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FRLHSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FRLHSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FRLHSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FRLHSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FRLHSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FRLHSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FRLHSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FRLHSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FRLHSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FRLHSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FRLHSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FRLHSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FRLHSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FRLHSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FRLHSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FRLHSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FRLHSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FRLHSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FRLHSR_P31 = 0x80000000

	// LOCKSR: Lock Status
	// Position of P0 field.
	PIO_LOCKSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LOCKSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LOCKSR_P0 = 0x1
	// Position of P1 field.
	PIO_LOCKSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LOCKSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LOCKSR_P1 = 0x2
	// Position of P2 field.
	PIO_LOCKSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LOCKSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LOCKSR_P2 = 0x4
	// Position of P3 field.
	PIO_LOCKSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LOCKSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LOCKSR_P3 = 0x8
	// Position of P4 field.
	PIO_LOCKSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LOCKSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LOCKSR_P4 = 0x10
	// Position of P5 field.
	PIO_LOCKSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LOCKSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LOCKSR_P5 = 0x20
	// Position of P6 field.
	PIO_LOCKSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LOCKSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LOCKSR_P6 = 0x40
	// Position of P7 field.
	PIO_LOCKSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LOCKSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LOCKSR_P7 = 0x80
	// Position of P8 field.
	PIO_LOCKSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LOCKSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LOCKSR_P8 = 0x100
	// Position of P9 field.
	PIO_LOCKSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LOCKSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LOCKSR_P9 = 0x200
	// Position of P10 field.
	PIO_LOCKSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LOCKSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LOCKSR_P10 = 0x400
	// Position of P11 field.
	PIO_LOCKSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LOCKSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LOCKSR_P11 = 0x800
	// Position of P12 field.
	PIO_LOCKSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LOCKSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LOCKSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LOCKSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LOCKSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LOCKSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LOCKSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LOCKSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LOCKSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LOCKSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LOCKSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LOCKSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LOCKSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LOCKSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LOCKSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LOCKSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LOCKSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LOCKSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LOCKSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LOCKSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LOCKSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LOCKSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LOCKSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LOCKSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LOCKSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LOCKSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LOCKSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LOCKSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LOCKSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LOCKSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LOCKSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LOCKSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LOCKSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LOCKSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LOCKSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LOCKSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LOCKSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LOCKSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LOCKSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LOCKSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LOCKSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LOCKSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LOCKSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LOCKSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LOCKSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LOCKSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LOCKSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LOCKSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LOCKSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LOCKSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LOCKSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LOCKSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LOCKSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LOCKSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LOCKSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LOCKSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LOCKSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LOCKSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LOCKSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LOCKSR_P31 = 0x80000000

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	PIO_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PIO_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PIO_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PIO_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PIO_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit. Always reads as 0.
	PIO_WPMR_WPKEY_PASSWD = 0x50494f

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	PIO_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PIO_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PIO_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PIO_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PIO_WPSR_WPVSRC_Msk = 0xffff00

	// SCHMITT: Schmitt Trigger Register
	// Position of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Pos = 0x0
	// Bit mask of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Msk = 0x1
	// Bit SCHMITT0.
	PIO_SCHMITT_SCHMITT0 = 0x1
	// Position of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Pos = 0x1
	// Bit mask of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Msk = 0x2
	// Bit SCHMITT1.
	PIO_SCHMITT_SCHMITT1 = 0x2
	// Position of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Pos = 0x2
	// Bit mask of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Msk = 0x4
	// Bit SCHMITT2.
	PIO_SCHMITT_SCHMITT2 = 0x4
	// Position of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Pos = 0x3
	// Bit mask of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Msk = 0x8
	// Bit SCHMITT3.
	PIO_SCHMITT_SCHMITT3 = 0x8
	// Position of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Pos = 0x4
	// Bit mask of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Msk = 0x10
	// Bit SCHMITT4.
	PIO_SCHMITT_SCHMITT4 = 0x10
	// Position of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Pos = 0x5
	// Bit mask of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Msk = 0x20
	// Bit SCHMITT5.
	PIO_SCHMITT_SCHMITT5 = 0x20
	// Position of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Pos = 0x6
	// Bit mask of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Msk = 0x40
	// Bit SCHMITT6.
	PIO_SCHMITT_SCHMITT6 = 0x40
	// Position of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Pos = 0x7
	// Bit mask of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Msk = 0x80
	// Bit SCHMITT7.
	PIO_SCHMITT_SCHMITT7 = 0x80
	// Position of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Pos = 0x8
	// Bit mask of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Msk = 0x100
	// Bit SCHMITT8.
	PIO_SCHMITT_SCHMITT8 = 0x100
	// Position of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Pos = 0x9
	// Bit mask of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Msk = 0x200
	// Bit SCHMITT9.
	PIO_SCHMITT_SCHMITT9 = 0x200
	// Position of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Pos = 0xa
	// Bit mask of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Msk = 0x400
	// Bit SCHMITT10.
	PIO_SCHMITT_SCHMITT10 = 0x400
	// Position of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Pos = 0xb
	// Bit mask of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Msk = 0x800
	// Bit SCHMITT11.
	PIO_SCHMITT_SCHMITT11 = 0x800
	// Position of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Pos = 0xc
	// Bit mask of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Msk = 0x1000
	// Bit SCHMITT12.
	PIO_SCHMITT_SCHMITT12 = 0x1000
	// Position of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Pos = 0xd
	// Bit mask of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Msk = 0x2000
	// Bit SCHMITT13.
	PIO_SCHMITT_SCHMITT13 = 0x2000
	// Position of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Pos = 0xe
	// Bit mask of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Msk = 0x4000
	// Bit SCHMITT14.
	PIO_SCHMITT_SCHMITT14 = 0x4000
	// Position of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Pos = 0xf
	// Bit mask of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Msk = 0x8000
	// Bit SCHMITT15.
	PIO_SCHMITT_SCHMITT15 = 0x8000
	// Position of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Pos = 0x10
	// Bit mask of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Msk = 0x10000
	// Bit SCHMITT16.
	PIO_SCHMITT_SCHMITT16 = 0x10000
	// Position of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Pos = 0x11
	// Bit mask of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Msk = 0x20000
	// Bit SCHMITT17.
	PIO_SCHMITT_SCHMITT17 = 0x20000
	// Position of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Pos = 0x12
	// Bit mask of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Msk = 0x40000
	// Bit SCHMITT18.
	PIO_SCHMITT_SCHMITT18 = 0x40000
	// Position of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Pos = 0x13
	// Bit mask of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Msk = 0x80000
	// Bit SCHMITT19.
	PIO_SCHMITT_SCHMITT19 = 0x80000
	// Position of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Pos = 0x14
	// Bit mask of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Msk = 0x100000
	// Bit SCHMITT20.
	PIO_SCHMITT_SCHMITT20 = 0x100000
	// Position of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Pos = 0x15
	// Bit mask of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Msk = 0x200000
	// Bit SCHMITT21.
	PIO_SCHMITT_SCHMITT21 = 0x200000
	// Position of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Pos = 0x16
	// Bit mask of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Msk = 0x400000
	// Bit SCHMITT22.
	PIO_SCHMITT_SCHMITT22 = 0x400000
	// Position of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Pos = 0x17
	// Bit mask of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Msk = 0x800000
	// Bit SCHMITT23.
	PIO_SCHMITT_SCHMITT23 = 0x800000
	// Position of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Pos = 0x18
	// Bit mask of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Msk = 0x1000000
	// Bit SCHMITT24.
	PIO_SCHMITT_SCHMITT24 = 0x1000000
	// Position of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Pos = 0x19
	// Bit mask of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Msk = 0x2000000
	// Bit SCHMITT25.
	PIO_SCHMITT_SCHMITT25 = 0x2000000
	// Position of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Pos = 0x1a
	// Bit mask of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Msk = 0x4000000
	// Bit SCHMITT26.
	PIO_SCHMITT_SCHMITT26 = 0x4000000
	// Position of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Pos = 0x1b
	// Bit mask of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Msk = 0x8000000
	// Bit SCHMITT27.
	PIO_SCHMITT_SCHMITT27 = 0x8000000
	// Position of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Pos = 0x1c
	// Bit mask of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Msk = 0x10000000
	// Bit SCHMITT28.
	PIO_SCHMITT_SCHMITT28 = 0x10000000
	// Position of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Pos = 0x1d
	// Bit mask of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Msk = 0x20000000
	// Bit SCHMITT29.
	PIO_SCHMITT_SCHMITT29 = 0x20000000
	// Position of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Pos = 0x1e
	// Bit mask of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Msk = 0x40000000
	// Bit SCHMITT30.
	PIO_SCHMITT_SCHMITT30 = 0x40000000
	// Position of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Pos = 0x1f
	// Bit mask of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Msk = 0x80000000
	// Bit SCHMITT31.
	PIO_SCHMITT_SCHMITT31 = 0x80000000

	// DRIVER: I/O Drive Register
	// Position of LINE0 field.
	PIO_DRIVER_LINE0_Pos = 0x0
	// Bit mask of LINE0 field.
	PIO_DRIVER_LINE0_Msk = 0x1
	// Bit LINE0.
	PIO_DRIVER_LINE0 = 0x1
	// Lowest drive
	PIO_DRIVER_LINE0_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE0_HIGH_DRIVE = 0x1
	// Position of LINE1 field.
	PIO_DRIVER_LINE1_Pos = 0x1
	// Bit mask of LINE1 field.
	PIO_DRIVER_LINE1_Msk = 0x2
	// Bit LINE1.
	PIO_DRIVER_LINE1 = 0x2
	// Lowest drive
	PIO_DRIVER_LINE1_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE1_HIGH_DRIVE = 0x1
	// Position of LINE2 field.
	PIO_DRIVER_LINE2_Pos = 0x2
	// Bit mask of LINE2 field.
	PIO_DRIVER_LINE2_Msk = 0x4
	// Bit LINE2.
	PIO_DRIVER_LINE2 = 0x4
	// Lowest drive
	PIO_DRIVER_LINE2_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE2_HIGH_DRIVE = 0x1
	// Position of LINE3 field.
	PIO_DRIVER_LINE3_Pos = 0x3
	// Bit mask of LINE3 field.
	PIO_DRIVER_LINE3_Msk = 0x8
	// Bit LINE3.
	PIO_DRIVER_LINE3 = 0x8
	// Lowest drive
	PIO_DRIVER_LINE3_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE3_HIGH_DRIVE = 0x1
	// Position of LINE4 field.
	PIO_DRIVER_LINE4_Pos = 0x4
	// Bit mask of LINE4 field.
	PIO_DRIVER_LINE4_Msk = 0x10
	// Bit LINE4.
	PIO_DRIVER_LINE4 = 0x10
	// Lowest drive
	PIO_DRIVER_LINE4_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE4_HIGH_DRIVE = 0x1
	// Position of LINE5 field.
	PIO_DRIVER_LINE5_Pos = 0x5
	// Bit mask of LINE5 field.
	PIO_DRIVER_LINE5_Msk = 0x20
	// Bit LINE5.
	PIO_DRIVER_LINE5 = 0x20
	// Lowest drive
	PIO_DRIVER_LINE5_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE5_HIGH_DRIVE = 0x1
	// Position of LINE6 field.
	PIO_DRIVER_LINE6_Pos = 0x6
	// Bit mask of LINE6 field.
	PIO_DRIVER_LINE6_Msk = 0x40
	// Bit LINE6.
	PIO_DRIVER_LINE6 = 0x40
	// Lowest drive
	PIO_DRIVER_LINE6_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE6_HIGH_DRIVE = 0x1
	// Position of LINE7 field.
	PIO_DRIVER_LINE7_Pos = 0x7
	// Bit mask of LINE7 field.
	PIO_DRIVER_LINE7_Msk = 0x80
	// Bit LINE7.
	PIO_DRIVER_LINE7 = 0x80
	// Lowest drive
	PIO_DRIVER_LINE7_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE7_HIGH_DRIVE = 0x1
	// Position of LINE8 field.
	PIO_DRIVER_LINE8_Pos = 0x8
	// Bit mask of LINE8 field.
	PIO_DRIVER_LINE8_Msk = 0x100
	// Bit LINE8.
	PIO_DRIVER_LINE8 = 0x100
	// Lowest drive
	PIO_DRIVER_LINE8_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE8_HIGH_DRIVE = 0x1
	// Position of LINE9 field.
	PIO_DRIVER_LINE9_Pos = 0x9
	// Bit mask of LINE9 field.
	PIO_DRIVER_LINE9_Msk = 0x200
	// Bit LINE9.
	PIO_DRIVER_LINE9 = 0x200
	// Lowest drive
	PIO_DRIVER_LINE9_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE9_HIGH_DRIVE = 0x1
	// Position of LINE10 field.
	PIO_DRIVER_LINE10_Pos = 0xa
	// Bit mask of LINE10 field.
	PIO_DRIVER_LINE10_Msk = 0x400
	// Bit LINE10.
	PIO_DRIVER_LINE10 = 0x400
	// Lowest drive
	PIO_DRIVER_LINE10_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE10_HIGH_DRIVE = 0x1
	// Position of LINE11 field.
	PIO_DRIVER_LINE11_Pos = 0xb
	// Bit mask of LINE11 field.
	PIO_DRIVER_LINE11_Msk = 0x800
	// Bit LINE11.
	PIO_DRIVER_LINE11 = 0x800
	// Lowest drive
	PIO_DRIVER_LINE11_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE11_HIGH_DRIVE = 0x1
	// Position of LINE12 field.
	PIO_DRIVER_LINE12_Pos = 0xc
	// Bit mask of LINE12 field.
	PIO_DRIVER_LINE12_Msk = 0x1000
	// Bit LINE12.
	PIO_DRIVER_LINE12 = 0x1000
	// Lowest drive
	PIO_DRIVER_LINE12_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE12_HIGH_DRIVE = 0x1
	// Position of LINE13 field.
	PIO_DRIVER_LINE13_Pos = 0xd
	// Bit mask of LINE13 field.
	PIO_DRIVER_LINE13_Msk = 0x2000
	// Bit LINE13.
	PIO_DRIVER_LINE13 = 0x2000
	// Lowest drive
	PIO_DRIVER_LINE13_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE13_HIGH_DRIVE = 0x1
	// Position of LINE14 field.
	PIO_DRIVER_LINE14_Pos = 0xe
	// Bit mask of LINE14 field.
	PIO_DRIVER_LINE14_Msk = 0x4000
	// Bit LINE14.
	PIO_DRIVER_LINE14 = 0x4000
	// Lowest drive
	PIO_DRIVER_LINE14_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE14_HIGH_DRIVE = 0x1
	// Position of LINE15 field.
	PIO_DRIVER_LINE15_Pos = 0xf
	// Bit mask of LINE15 field.
	PIO_DRIVER_LINE15_Msk = 0x8000
	// Bit LINE15.
	PIO_DRIVER_LINE15 = 0x8000
	// Lowest drive
	PIO_DRIVER_LINE15_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE15_HIGH_DRIVE = 0x1
	// Position of LINE16 field.
	PIO_DRIVER_LINE16_Pos = 0x10
	// Bit mask of LINE16 field.
	PIO_DRIVER_LINE16_Msk = 0x10000
	// Bit LINE16.
	PIO_DRIVER_LINE16 = 0x10000
	// Lowest drive
	PIO_DRIVER_LINE16_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE16_HIGH_DRIVE = 0x1
	// Position of LINE17 field.
	PIO_DRIVER_LINE17_Pos = 0x11
	// Bit mask of LINE17 field.
	PIO_DRIVER_LINE17_Msk = 0x20000
	// Bit LINE17.
	PIO_DRIVER_LINE17 = 0x20000
	// Lowest drive
	PIO_DRIVER_LINE17_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE17_HIGH_DRIVE = 0x1
	// Position of LINE18 field.
	PIO_DRIVER_LINE18_Pos = 0x12
	// Bit mask of LINE18 field.
	PIO_DRIVER_LINE18_Msk = 0x40000
	// Bit LINE18.
	PIO_DRIVER_LINE18 = 0x40000
	// Lowest drive
	PIO_DRIVER_LINE18_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE18_HIGH_DRIVE = 0x1
	// Position of LINE19 field.
	PIO_DRIVER_LINE19_Pos = 0x13
	// Bit mask of LINE19 field.
	PIO_DRIVER_LINE19_Msk = 0x80000
	// Bit LINE19.
	PIO_DRIVER_LINE19 = 0x80000
	// Lowest drive
	PIO_DRIVER_LINE19_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE19_HIGH_DRIVE = 0x1
	// Position of LINE20 field.
	PIO_DRIVER_LINE20_Pos = 0x14
	// Bit mask of LINE20 field.
	PIO_DRIVER_LINE20_Msk = 0x100000
	// Bit LINE20.
	PIO_DRIVER_LINE20 = 0x100000
	// Lowest drive
	PIO_DRIVER_LINE20_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE20_HIGH_DRIVE = 0x1
	// Position of LINE21 field.
	PIO_DRIVER_LINE21_Pos = 0x15
	// Bit mask of LINE21 field.
	PIO_DRIVER_LINE21_Msk = 0x200000
	// Bit LINE21.
	PIO_DRIVER_LINE21 = 0x200000
	// Lowest drive
	PIO_DRIVER_LINE21_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE21_HIGH_DRIVE = 0x1
	// Position of LINE22 field.
	PIO_DRIVER_LINE22_Pos = 0x16
	// Bit mask of LINE22 field.
	PIO_DRIVER_LINE22_Msk = 0x400000
	// Bit LINE22.
	PIO_DRIVER_LINE22 = 0x400000
	// Lowest drive
	PIO_DRIVER_LINE22_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE22_HIGH_DRIVE = 0x1
	// Position of LINE23 field.
	PIO_DRIVER_LINE23_Pos = 0x17
	// Bit mask of LINE23 field.
	PIO_DRIVER_LINE23_Msk = 0x800000
	// Bit LINE23.
	PIO_DRIVER_LINE23 = 0x800000
	// Lowest drive
	PIO_DRIVER_LINE23_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE23_HIGH_DRIVE = 0x1
	// Position of LINE24 field.
	PIO_DRIVER_LINE24_Pos = 0x18
	// Bit mask of LINE24 field.
	PIO_DRIVER_LINE24_Msk = 0x1000000
	// Bit LINE24.
	PIO_DRIVER_LINE24 = 0x1000000
	// Lowest drive
	PIO_DRIVER_LINE24_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE24_HIGH_DRIVE = 0x1
	// Position of LINE25 field.
	PIO_DRIVER_LINE25_Pos = 0x19
	// Bit mask of LINE25 field.
	PIO_DRIVER_LINE25_Msk = 0x2000000
	// Bit LINE25.
	PIO_DRIVER_LINE25 = 0x2000000
	// Lowest drive
	PIO_DRIVER_LINE25_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE25_HIGH_DRIVE = 0x1
	// Position of LINE26 field.
	PIO_DRIVER_LINE26_Pos = 0x1a
	// Bit mask of LINE26 field.
	PIO_DRIVER_LINE26_Msk = 0x4000000
	// Bit LINE26.
	PIO_DRIVER_LINE26 = 0x4000000
	// Lowest drive
	PIO_DRIVER_LINE26_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE26_HIGH_DRIVE = 0x1
	// Position of LINE27 field.
	PIO_DRIVER_LINE27_Pos = 0x1b
	// Bit mask of LINE27 field.
	PIO_DRIVER_LINE27_Msk = 0x8000000
	// Bit LINE27.
	PIO_DRIVER_LINE27 = 0x8000000
	// Lowest drive
	PIO_DRIVER_LINE27_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE27_HIGH_DRIVE = 0x1
	// Position of LINE28 field.
	PIO_DRIVER_LINE28_Pos = 0x1c
	// Bit mask of LINE28 field.
	PIO_DRIVER_LINE28_Msk = 0x10000000
	// Bit LINE28.
	PIO_DRIVER_LINE28 = 0x10000000
	// Lowest drive
	PIO_DRIVER_LINE28_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE28_HIGH_DRIVE = 0x1
	// Position of LINE29 field.
	PIO_DRIVER_LINE29_Pos = 0x1d
	// Bit mask of LINE29 field.
	PIO_DRIVER_LINE29_Msk = 0x20000000
	// Bit LINE29.
	PIO_DRIVER_LINE29 = 0x20000000
	// Lowest drive
	PIO_DRIVER_LINE29_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE29_HIGH_DRIVE = 0x1
	// Position of LINE30 field.
	PIO_DRIVER_LINE30_Pos = 0x1e
	// Bit mask of LINE30 field.
	PIO_DRIVER_LINE30_Msk = 0x40000000
	// Bit LINE30.
	PIO_DRIVER_LINE30 = 0x40000000
	// Lowest drive
	PIO_DRIVER_LINE30_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE30_HIGH_DRIVE = 0x1
	// Position of LINE31 field.
	PIO_DRIVER_LINE31_Pos = 0x1f
	// Bit mask of LINE31 field.
	PIO_DRIVER_LINE31_Msk = 0x80000000
	// Bit LINE31.
	PIO_DRIVER_LINE31 = 0x80000000
	// Lowest drive
	PIO_DRIVER_LINE31_LOW_DRIVE = 0x0
	// Highest drive
	PIO_DRIVER_LINE31_HIGH_DRIVE = 0x1

	// PCMR: Parallel Capture Mode Register
	// Position of PCEN field.
	PIO_PCMR_PCEN_Pos = 0x0
	// Bit mask of PCEN field.
	PIO_PCMR_PCEN_Msk = 0x1
	// Bit PCEN.
	PIO_PCMR_PCEN = 0x1
	// Position of DSIZE field.
	PIO_PCMR_DSIZE_Pos = 0x4
	// Bit mask of DSIZE field.
	PIO_PCMR_DSIZE_Msk = 0x30
	// The reception data in the PIO_PCRHR is a byte (8-bit)
	PIO_PCMR_DSIZE_BYTE = 0x0
	// The reception data in the PIO_PCRHR is a half-word (16-bit)
	PIO_PCMR_DSIZE_HALFWORD = 0x1
	// The reception data in the PIO_PCRHR is a word (32-bit)
	PIO_PCMR_DSIZE_WORD = 0x2
	// Position of ALWYS field.
	PIO_PCMR_ALWYS_Pos = 0x9
	// Bit mask of ALWYS field.
	PIO_PCMR_ALWYS_Msk = 0x200
	// Bit ALWYS.
	PIO_PCMR_ALWYS = 0x200
	// Position of HALFS field.
	PIO_PCMR_HALFS_Pos = 0xa
	// Bit mask of HALFS field.
	PIO_PCMR_HALFS_Msk = 0x400
	// Bit HALFS.
	PIO_PCMR_HALFS = 0x400
	// Position of FRSTS field.
	PIO_PCMR_FRSTS_Pos = 0xb
	// Bit mask of FRSTS field.
	PIO_PCMR_FRSTS_Msk = 0x800
	// Bit FRSTS.
	PIO_PCMR_FRSTS = 0x800

	// PCIER: Parallel Capture Interrupt Enable Register
	// Position of DRDY field.
	PIO_PCIER_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PIO_PCIER_DRDY_Msk = 0x1
	// Bit DRDY.
	PIO_PCIER_DRDY = 0x1
	// Position of OVRE field.
	PIO_PCIER_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PIO_PCIER_OVRE_Msk = 0x2
	// Bit OVRE.
	PIO_PCIER_OVRE = 0x2
	// Position of ENDRX field.
	PIO_PCIER_ENDRX_Pos = 0x2
	// Bit mask of ENDRX field.
	PIO_PCIER_ENDRX_Msk = 0x4
	// Bit ENDRX.
	PIO_PCIER_ENDRX = 0x4
	// Position of RXBUFF field.
	PIO_PCIER_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	PIO_PCIER_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	PIO_PCIER_RXBUFF = 0x8

	// PCIDR: Parallel Capture Interrupt Disable Register
	// Position of DRDY field.
	PIO_PCIDR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PIO_PCIDR_DRDY_Msk = 0x1
	// Bit DRDY.
	PIO_PCIDR_DRDY = 0x1
	// Position of OVRE field.
	PIO_PCIDR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PIO_PCIDR_OVRE_Msk = 0x2
	// Bit OVRE.
	PIO_PCIDR_OVRE = 0x2
	// Position of ENDRX field.
	PIO_PCIDR_ENDRX_Pos = 0x2
	// Bit mask of ENDRX field.
	PIO_PCIDR_ENDRX_Msk = 0x4
	// Bit ENDRX.
	PIO_PCIDR_ENDRX = 0x4
	// Position of RXBUFF field.
	PIO_PCIDR_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	PIO_PCIDR_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	PIO_PCIDR_RXBUFF = 0x8

	// PCIMR: Parallel Capture Interrupt Mask Register
	// Position of DRDY field.
	PIO_PCIMR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PIO_PCIMR_DRDY_Msk = 0x1
	// Bit DRDY.
	PIO_PCIMR_DRDY = 0x1
	// Position of OVRE field.
	PIO_PCIMR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PIO_PCIMR_OVRE_Msk = 0x2
	// Bit OVRE.
	PIO_PCIMR_OVRE = 0x2
	// Position of ENDRX field.
	PIO_PCIMR_ENDRX_Pos = 0x2
	// Bit mask of ENDRX field.
	PIO_PCIMR_ENDRX_Msk = 0x4
	// Bit ENDRX.
	PIO_PCIMR_ENDRX = 0x4
	// Position of RXBUFF field.
	PIO_PCIMR_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	PIO_PCIMR_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	PIO_PCIMR_RXBUFF = 0x8

	// PCISR: Parallel Capture Interrupt Status Register
	// Position of DRDY field.
	PIO_PCISR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PIO_PCISR_DRDY_Msk = 0x1
	// Bit DRDY.
	PIO_PCISR_DRDY = 0x1
	// Position of OVRE field.
	PIO_PCISR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PIO_PCISR_OVRE_Msk = 0x2
	// Bit OVRE.
	PIO_PCISR_OVRE = 0x2

	// PCRHR: Parallel Capture Reception Holding Register
	// Position of RDATA field.
	PIO_PCRHR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	PIO_PCRHR_RDATA_Msk = 0xffffffff
)

// Constants for PMC: Power Management Controller
const (
	// SCER: System Clock Enable Register
	// Position of USBCLK field.
	PMC_SCER_USBCLK_Pos = 0x5
	// Bit mask of USBCLK field.
	PMC_SCER_USBCLK_Msk = 0x20
	// Bit USBCLK.
	PMC_SCER_USBCLK = 0x20
	// Position of PCK0 field.
	PMC_SCER_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_SCER_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_SCER_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_SCER_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_SCER_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_SCER_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_SCER_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_SCER_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_SCER_PCK2 = 0x400
	// Position of PCK3 field.
	PMC_SCER_PCK3_Pos = 0xb
	// Bit mask of PCK3 field.
	PMC_SCER_PCK3_Msk = 0x800
	// Bit PCK3.
	PMC_SCER_PCK3 = 0x800
	// Position of PCK4 field.
	PMC_SCER_PCK4_Pos = 0xc
	// Bit mask of PCK4 field.
	PMC_SCER_PCK4_Msk = 0x1000
	// Bit PCK4.
	PMC_SCER_PCK4 = 0x1000
	// Position of PCK5 field.
	PMC_SCER_PCK5_Pos = 0xd
	// Bit mask of PCK5 field.
	PMC_SCER_PCK5_Msk = 0x2000
	// Bit PCK5.
	PMC_SCER_PCK5 = 0x2000
	// Position of PCK6 field.
	PMC_SCER_PCK6_Pos = 0xe
	// Bit mask of PCK6 field.
	PMC_SCER_PCK6_Msk = 0x4000
	// Bit PCK6.
	PMC_SCER_PCK6 = 0x4000

	// SCDR: System Clock Disable Register
	// Position of USBCLK field.
	PMC_SCDR_USBCLK_Pos = 0x5
	// Bit mask of USBCLK field.
	PMC_SCDR_USBCLK_Msk = 0x20
	// Bit USBCLK.
	PMC_SCDR_USBCLK = 0x20
	// Position of PCK0 field.
	PMC_SCDR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_SCDR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_SCDR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_SCDR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_SCDR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_SCDR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_SCDR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_SCDR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_SCDR_PCK2 = 0x400
	// Position of PCK3 field.
	PMC_SCDR_PCK3_Pos = 0xb
	// Bit mask of PCK3 field.
	PMC_SCDR_PCK3_Msk = 0x800
	// Bit PCK3.
	PMC_SCDR_PCK3 = 0x800
	// Position of PCK4 field.
	PMC_SCDR_PCK4_Pos = 0xc
	// Bit mask of PCK4 field.
	PMC_SCDR_PCK4_Msk = 0x1000
	// Bit PCK4.
	PMC_SCDR_PCK4 = 0x1000
	// Position of PCK5 field.
	PMC_SCDR_PCK5_Pos = 0xd
	// Bit mask of PCK5 field.
	PMC_SCDR_PCK5_Msk = 0x2000
	// Bit PCK5.
	PMC_SCDR_PCK5 = 0x2000
	// Position of PCK6 field.
	PMC_SCDR_PCK6_Pos = 0xe
	// Bit mask of PCK6 field.
	PMC_SCDR_PCK6_Msk = 0x4000
	// Bit PCK6.
	PMC_SCDR_PCK6 = 0x4000

	// SCSR: System Clock Status Register
	// Position of HCLKS field.
	PMC_SCSR_HCLKS_Pos = 0x0
	// Bit mask of HCLKS field.
	PMC_SCSR_HCLKS_Msk = 0x1
	// Bit HCLKS.
	PMC_SCSR_HCLKS = 0x1
	// Position of USBCLK field.
	PMC_SCSR_USBCLK_Pos = 0x5
	// Bit mask of USBCLK field.
	PMC_SCSR_USBCLK_Msk = 0x20
	// Bit USBCLK.
	PMC_SCSR_USBCLK = 0x20
	// Position of PCK0 field.
	PMC_SCSR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_SCSR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_SCSR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_SCSR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_SCSR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_SCSR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_SCSR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_SCSR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_SCSR_PCK2 = 0x400
	// Position of PCK3 field.
	PMC_SCSR_PCK3_Pos = 0xb
	// Bit mask of PCK3 field.
	PMC_SCSR_PCK3_Msk = 0x800
	// Bit PCK3.
	PMC_SCSR_PCK3 = 0x800
	// Position of PCK4 field.
	PMC_SCSR_PCK4_Pos = 0xc
	// Bit mask of PCK4 field.
	PMC_SCSR_PCK4_Msk = 0x1000
	// Bit PCK4.
	PMC_SCSR_PCK4 = 0x1000
	// Position of PCK5 field.
	PMC_SCSR_PCK5_Pos = 0xd
	// Bit mask of PCK5 field.
	PMC_SCSR_PCK5_Msk = 0x2000
	// Bit PCK5.
	PMC_SCSR_PCK5 = 0x2000
	// Position of PCK6 field.
	PMC_SCSR_PCK6_Pos = 0xe
	// Bit mask of PCK6 field.
	PMC_SCSR_PCK6_Msk = 0x4000
	// Bit PCK6.
	PMC_SCSR_PCK6 = 0x4000

	// PCER0: Peripheral Clock Enable Register 0
	// Position of PID7 field.
	PMC_PCER0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PCER0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PCER0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PCER0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PCER0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PCER0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PCER0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PCER0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PCER0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PCER0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PCER0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PCER0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PCER0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PCER0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PCER0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PCER0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PCER0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PCER0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PCER0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PCER0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PCER0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PCER0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PCER0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PCER0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PCER0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PCER0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PCER0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PCER0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PCER0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PCER0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PCER0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PCER0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PCER0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PCER0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PCER0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PCER0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PCER0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PCER0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PCER0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PCER0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PCER0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PCER0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PCER0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PCER0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PCER0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PCER0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PCER0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PCER0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PCER0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PCER0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PCER0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PCER0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PCER0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PCER0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PCER0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PCER0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PCER0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PCER0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PCER0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PCER0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PCER0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PCER0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PCER0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PCER0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PCER0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PCER0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PCER0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PCER0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PCER0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PCER0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PCER0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PCER0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PCER0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PCER0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PCER0_PID31 = 0x80000000

	// PCDR0: Peripheral Clock Disable Register 0
	// Position of PID7 field.
	PMC_PCDR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PCDR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PCDR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PCDR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PCDR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PCDR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PCDR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PCDR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PCDR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PCDR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PCDR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PCDR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PCDR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PCDR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PCDR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PCDR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PCDR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PCDR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PCDR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PCDR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PCDR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PCDR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PCDR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PCDR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PCDR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PCDR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PCDR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PCDR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PCDR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PCDR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PCDR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PCDR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PCDR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PCDR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PCDR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PCDR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PCDR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PCDR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PCDR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PCDR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PCDR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PCDR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PCDR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PCDR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PCDR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PCDR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PCDR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PCDR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PCDR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PCDR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PCDR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PCDR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PCDR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PCDR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PCDR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PCDR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PCDR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PCDR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PCDR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PCDR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PCDR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PCDR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PCDR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PCDR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PCDR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PCDR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PCDR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PCDR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PCDR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PCDR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PCDR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PCDR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PCDR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PCDR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PCDR0_PID31 = 0x80000000

	// PCSR0: Peripheral Clock Status Register 0
	// Position of PID7 field.
	PMC_PCSR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PCSR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PCSR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PCSR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PCSR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PCSR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PCSR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PCSR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PCSR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PCSR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PCSR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PCSR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PCSR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PCSR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PCSR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PCSR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PCSR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PCSR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PCSR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PCSR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PCSR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PCSR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PCSR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PCSR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PCSR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PCSR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PCSR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PCSR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PCSR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PCSR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PCSR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PCSR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PCSR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PCSR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PCSR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PCSR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PCSR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PCSR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PCSR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PCSR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PCSR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PCSR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PCSR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PCSR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PCSR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PCSR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PCSR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PCSR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PCSR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PCSR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PCSR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PCSR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PCSR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PCSR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PCSR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PCSR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PCSR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PCSR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PCSR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PCSR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PCSR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PCSR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PCSR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PCSR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PCSR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PCSR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PCSR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PCSR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PCSR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PCSR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PCSR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PCSR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PCSR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PCSR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PCSR0_PID31 = 0x80000000

	// CKGR_UCKR: UTMI Clock Register
	// Position of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Pos = 0x10
	// Bit mask of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Msk = 0x10000
	// Bit UPLLEN.
	PMC_CKGR_UCKR_UPLLEN = 0x10000
	// Position of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Pos = 0x14
	// Bit mask of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Msk = 0xf00000

	// CKGR_MOR: Main Oscillator Register
	// Position of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Pos = 0x0
	// Bit mask of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Msk = 0x1
	// Bit MOSCXTEN.
	PMC_CKGR_MOR_MOSCXTEN = 0x1
	// Position of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Pos = 0x1
	// Bit mask of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Msk = 0x2
	// Bit MOSCXTBY.
	PMC_CKGR_MOR_MOSCXTBY = 0x2
	// Position of WAITMODE field.
	PMC_CKGR_MOR_WAITMODE_Pos = 0x2
	// Bit mask of WAITMODE field.
	PMC_CKGR_MOR_WAITMODE_Msk = 0x4
	// Bit WAITMODE.
	PMC_CKGR_MOR_WAITMODE = 0x4
	// Position of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Pos = 0x3
	// Bit mask of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Msk = 0x8
	// Bit MOSCRCEN.
	PMC_CKGR_MOR_MOSCRCEN = 0x8
	// Position of MOSCRCF field.
	PMC_CKGR_MOR_MOSCRCF_Pos = 0x4
	// Bit mask of MOSCRCF field.
	PMC_CKGR_MOR_MOSCRCF_Msk = 0x70
	// The RC oscillator frequency is at 4 MHz
	PMC_CKGR_MOR_MOSCRCF__4_MHZ = 0x0
	// The RC oscillator frequency is at 8 MHz
	PMC_CKGR_MOR_MOSCRCF__8_MHZ = 0x1
	// The RC oscillator frequency is at 12 MHz
	PMC_CKGR_MOR_MOSCRCF__12_MHZ = 0x2
	// Position of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Pos = 0x8
	// Bit mask of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Msk = 0xff00
	// Position of KEY field.
	PMC_CKGR_MOR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	PMC_CKGR_MOR_KEY_Msk = 0xff0000
	// Writing any other value in this field aborts the write operation.Always reads as 0.
	PMC_CKGR_MOR_KEY_PASSWD = 0x37
	// Position of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Pos = 0x18
	// Bit mask of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Msk = 0x1000000
	// Bit MOSCSEL.
	PMC_CKGR_MOR_MOSCSEL = 0x1000000
	// Position of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Pos = 0x19
	// Bit mask of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Msk = 0x2000000
	// Bit CFDEN.
	PMC_CKGR_MOR_CFDEN = 0x2000000
	// Position of XT32KFME field.
	PMC_CKGR_MOR_XT32KFME_Pos = 0x1a
	// Bit mask of XT32KFME field.
	PMC_CKGR_MOR_XT32KFME_Msk = 0x4000000
	// Bit XT32KFME.
	PMC_CKGR_MOR_XT32KFME = 0x4000000

	// CKGR_MCFR: Main Clock Frequency Register
	// Position of MAINF field.
	PMC_CKGR_MCFR_MAINF_Pos = 0x0
	// Bit mask of MAINF field.
	PMC_CKGR_MCFR_MAINF_Msk = 0xffff
	// Position of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Pos = 0x10
	// Bit mask of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Msk = 0x10000
	// Bit MAINFRDY.
	PMC_CKGR_MCFR_MAINFRDY = 0x10000
	// Position of RCMEAS field.
	PMC_CKGR_MCFR_RCMEAS_Pos = 0x14
	// Bit mask of RCMEAS field.
	PMC_CKGR_MCFR_RCMEAS_Msk = 0x100000
	// Bit RCMEAS.
	PMC_CKGR_MCFR_RCMEAS = 0x100000
	// Position of CCSS field.
	PMC_CKGR_MCFR_CCSS_Pos = 0x18
	// Bit mask of CCSS field.
	PMC_CKGR_MCFR_CCSS_Msk = 0x1000000
	// Bit CCSS.
	PMC_CKGR_MCFR_CCSS = 0x1000000

	// CKGR_PLLAR: PLLA Register
	// Position of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Msk = 0xff
	// Divider output is 0 and PLLA is disabled.
	PMC_CKGR_PLLAR_DIVA__0 = 0x0
	// Divider is bypassed (divide by 1) and PLLA is enabled.
	PMC_CKGR_PLLAR_DIVA_BYPASS = 0x1
	// Position of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Pos = 0x8
	// Bit mask of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Msk = 0x3f00
	// Position of MULA field.
	PMC_CKGR_PLLAR_MULA_Pos = 0x10
	// Bit mask of MULA field.
	PMC_CKGR_PLLAR_MULA_Msk = 0x7ff0000
	// Position of ONE field.
	PMC_CKGR_PLLAR_ONE_Pos = 0x1d
	// Bit mask of ONE field.
	PMC_CKGR_PLLAR_ONE_Msk = 0x20000000
	// Bit ONE.
	PMC_CKGR_PLLAR_ONE = 0x20000000

	// MCKR: Master Clock Register
	// Position of CSS field.
	PMC_MCKR_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_MCKR_CSS_Msk = 0x3
	// Slow Clock is selected
	PMC_MCKR_CSS_SLOW_CLK = 0x0
	// Main Clock is selected
	PMC_MCKR_CSS_MAIN_CLK = 0x1
	// PLLA Clock is selected
	PMC_MCKR_CSS_PLLA_CLK = 0x2
	// Divided UPLL Clock is selected
	PMC_MCKR_CSS_UPLL_CLK = 0x3
	// Position of PRES field.
	PMC_MCKR_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_MCKR_PRES_Msk = 0x70
	// Selected clock
	PMC_MCKR_PRES_CLK_1 = 0x0
	// Selected clock divided by 2
	PMC_MCKR_PRES_CLK_2 = 0x1
	// Selected clock divided by 4
	PMC_MCKR_PRES_CLK_4 = 0x2
	// Selected clock divided by 8
	PMC_MCKR_PRES_CLK_8 = 0x3
	// Selected clock divided by 16
	PMC_MCKR_PRES_CLK_16 = 0x4
	// Selected clock divided by 32
	PMC_MCKR_PRES_CLK_32 = 0x5
	// Selected clock divided by 64
	PMC_MCKR_PRES_CLK_64 = 0x6
	// Selected clock divided by 3
	PMC_MCKR_PRES_CLK_3 = 0x7
	// Position of MDIV field.
	PMC_MCKR_MDIV_Pos = 0x8
	// Bit mask of MDIV field.
	PMC_MCKR_MDIV_Msk = 0x300
	// Master Clock is Prescaler Output Clock divided by 1.
	PMC_MCKR_MDIV_EQ_PCK = 0x0
	// Master Clock is Prescaler Output Clock divided by 2.
	PMC_MCKR_MDIV_PCK_DIV2 = 0x1
	// Master Clock is Prescaler Output Clock divided by 4.
	PMC_MCKR_MDIV_PCK_DIV4 = 0x2
	// Master Clock is Prescaler Output Clock divided by 3.
	PMC_MCKR_MDIV_PCK_DIV3 = 0x3
	// Position of UPLLDIV2 field.
	PMC_MCKR_UPLLDIV2_Pos = 0xd
	// Bit mask of UPLLDIV2 field.
	PMC_MCKR_UPLLDIV2_Msk = 0x2000
	// Bit UPLLDIV2.
	PMC_MCKR_UPLLDIV2 = 0x2000

	// USB: USB Clock Register
	// Position of USBS field.
	PMC_USB_USBS_Pos = 0x0
	// Bit mask of USBS field.
	PMC_USB_USBS_Msk = 0x1
	// Bit USBS.
	PMC_USB_USBS = 0x1
	// Position of USBDIV field.
	PMC_USB_USBDIV_Pos = 0x8
	// Bit mask of USBDIV field.
	PMC_USB_USBDIV_Msk = 0xf00

	// PCK: Programmable Clock Register
	// Position of CSS field.
	PMC_PCK_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PCK_CSS_Msk = 0x7
	// SLCK is selected
	PMC_PCK_CSS_SLOW_CLK = 0x0
	// MAINCK is selected
	PMC_PCK_CSS_MAIN_CLK = 0x1
	// PLLACK is selected
	PMC_PCK_CSS_PLLA_CLK = 0x2
	// UPLLCKDIV is selected
	PMC_PCK_CSS_UPLL_CLK = 0x3
	// MCK is selected
	PMC_PCK_CSS_MCK = 0x4
	// Position of PRES field.
	PMC_PCK_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_PCK_PRES_Msk = 0xff0

	// IER: Interrupt Enable Register
	// Position of MOSCXTS field.
	PMC_IER_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_IER_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_IER_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_IER_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_IER_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_IER_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_IER_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_IER_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_IER_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_IER_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_IER_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_IER_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_IER_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_IER_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_IER_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_IER_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_IER_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_IER_PCKRDY1 = 0x200
	// Position of PCKRDY2 field.
	PMC_IER_PCKRDY2_Pos = 0xa
	// Bit mask of PCKRDY2 field.
	PMC_IER_PCKRDY2_Msk = 0x400
	// Bit PCKRDY2.
	PMC_IER_PCKRDY2 = 0x400
	// Position of PCKRDY3 field.
	PMC_IER_PCKRDY3_Pos = 0xb
	// Bit mask of PCKRDY3 field.
	PMC_IER_PCKRDY3_Msk = 0x800
	// Bit PCKRDY3.
	PMC_IER_PCKRDY3 = 0x800
	// Position of PCKRDY4 field.
	PMC_IER_PCKRDY4_Pos = 0xc
	// Bit mask of PCKRDY4 field.
	PMC_IER_PCKRDY4_Msk = 0x1000
	// Bit PCKRDY4.
	PMC_IER_PCKRDY4 = 0x1000
	// Position of PCKRDY5 field.
	PMC_IER_PCKRDY5_Pos = 0xd
	// Bit mask of PCKRDY5 field.
	PMC_IER_PCKRDY5_Msk = 0x2000
	// Bit PCKRDY5.
	PMC_IER_PCKRDY5 = 0x2000
	// Position of PCKRDY6 field.
	PMC_IER_PCKRDY6_Pos = 0xe
	// Bit mask of PCKRDY6 field.
	PMC_IER_PCKRDY6_Msk = 0x4000
	// Bit PCKRDY6.
	PMC_IER_PCKRDY6 = 0x4000
	// Position of MOSCSELS field.
	PMC_IER_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_IER_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_IER_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_IER_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_IER_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_IER_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_IER_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_IER_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_IER_CFDEV = 0x40000
	// Position of XT32KERR field.
	PMC_IER_XT32KERR_Pos = 0x15
	// Bit mask of XT32KERR field.
	PMC_IER_XT32KERR_Msk = 0x200000
	// Bit XT32KERR.
	PMC_IER_XT32KERR = 0x200000

	// IDR: Interrupt Disable Register
	// Position of MOSCXTS field.
	PMC_IDR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_IDR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_IDR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_IDR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_IDR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_IDR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_IDR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_IDR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_IDR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_IDR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_IDR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_IDR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_IDR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_IDR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_IDR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_IDR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_IDR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_IDR_PCKRDY1 = 0x200
	// Position of PCKRDY2 field.
	PMC_IDR_PCKRDY2_Pos = 0xa
	// Bit mask of PCKRDY2 field.
	PMC_IDR_PCKRDY2_Msk = 0x400
	// Bit PCKRDY2.
	PMC_IDR_PCKRDY2 = 0x400
	// Position of PCKRDY3 field.
	PMC_IDR_PCKRDY3_Pos = 0xb
	// Bit mask of PCKRDY3 field.
	PMC_IDR_PCKRDY3_Msk = 0x800
	// Bit PCKRDY3.
	PMC_IDR_PCKRDY3 = 0x800
	// Position of PCKRDY4 field.
	PMC_IDR_PCKRDY4_Pos = 0xc
	// Bit mask of PCKRDY4 field.
	PMC_IDR_PCKRDY4_Msk = 0x1000
	// Bit PCKRDY4.
	PMC_IDR_PCKRDY4 = 0x1000
	// Position of PCKRDY5 field.
	PMC_IDR_PCKRDY5_Pos = 0xd
	// Bit mask of PCKRDY5 field.
	PMC_IDR_PCKRDY5_Msk = 0x2000
	// Bit PCKRDY5.
	PMC_IDR_PCKRDY5 = 0x2000
	// Position of PCKRDY6 field.
	PMC_IDR_PCKRDY6_Pos = 0xe
	// Bit mask of PCKRDY6 field.
	PMC_IDR_PCKRDY6_Msk = 0x4000
	// Bit PCKRDY6.
	PMC_IDR_PCKRDY6 = 0x4000
	// Position of MOSCSELS field.
	PMC_IDR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_IDR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_IDR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_IDR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_IDR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_IDR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_IDR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_IDR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_IDR_CFDEV = 0x40000
	// Position of XT32KERR field.
	PMC_IDR_XT32KERR_Pos = 0x15
	// Bit mask of XT32KERR field.
	PMC_IDR_XT32KERR_Msk = 0x200000
	// Bit XT32KERR.
	PMC_IDR_XT32KERR = 0x200000

	// SR: Status Register
	// Position of MOSCXTS field.
	PMC_SR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_SR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_SR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_SR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_SR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_SR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_SR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_SR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_SR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_SR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_SR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_SR_LOCKU = 0x40
	// Position of OSCSELS field.
	PMC_SR_OSCSELS_Pos = 0x7
	// Bit mask of OSCSELS field.
	PMC_SR_OSCSELS_Msk = 0x80
	// Bit OSCSELS.
	PMC_SR_OSCSELS = 0x80
	// Position of PCKRDY0 field.
	PMC_SR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_SR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_SR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_SR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_SR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_SR_PCKRDY1 = 0x200
	// Position of PCKRDY2 field.
	PMC_SR_PCKRDY2_Pos = 0xa
	// Bit mask of PCKRDY2 field.
	PMC_SR_PCKRDY2_Msk = 0x400
	// Bit PCKRDY2.
	PMC_SR_PCKRDY2 = 0x400
	// Position of PCKRDY3 field.
	PMC_SR_PCKRDY3_Pos = 0xb
	// Bit mask of PCKRDY3 field.
	PMC_SR_PCKRDY3_Msk = 0x800
	// Bit PCKRDY3.
	PMC_SR_PCKRDY3 = 0x800
	// Position of PCKRDY4 field.
	PMC_SR_PCKRDY4_Pos = 0xc
	// Bit mask of PCKRDY4 field.
	PMC_SR_PCKRDY4_Msk = 0x1000
	// Bit PCKRDY4.
	PMC_SR_PCKRDY4 = 0x1000
	// Position of PCKRDY5 field.
	PMC_SR_PCKRDY5_Pos = 0xd
	// Bit mask of PCKRDY5 field.
	PMC_SR_PCKRDY5_Msk = 0x2000
	// Bit PCKRDY5.
	PMC_SR_PCKRDY5 = 0x2000
	// Position of PCKRDY6 field.
	PMC_SR_PCKRDY6_Pos = 0xe
	// Bit mask of PCKRDY6 field.
	PMC_SR_PCKRDY6_Msk = 0x4000
	// Bit PCKRDY6.
	PMC_SR_PCKRDY6 = 0x4000
	// Position of MOSCSELS field.
	PMC_SR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_SR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_SR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_SR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_SR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_SR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_SR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_SR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_SR_CFDEV = 0x40000
	// Position of CFDS field.
	PMC_SR_CFDS_Pos = 0x13
	// Bit mask of CFDS field.
	PMC_SR_CFDS_Msk = 0x80000
	// Bit CFDS.
	PMC_SR_CFDS = 0x80000
	// Position of FOS field.
	PMC_SR_FOS_Pos = 0x14
	// Bit mask of FOS field.
	PMC_SR_FOS_Msk = 0x100000
	// Bit FOS.
	PMC_SR_FOS = 0x100000
	// Position of XT32KERR field.
	PMC_SR_XT32KERR_Pos = 0x15
	// Bit mask of XT32KERR field.
	PMC_SR_XT32KERR_Msk = 0x200000
	// Bit XT32KERR.
	PMC_SR_XT32KERR = 0x200000

	// IMR: Interrupt Mask Register
	// Position of MOSCXTS field.
	PMC_IMR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_IMR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_IMR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_IMR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_IMR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_IMR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_IMR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_IMR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_IMR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_IMR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_IMR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_IMR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_IMR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_IMR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_IMR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_IMR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_IMR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_IMR_PCKRDY1 = 0x200
	// Position of PCKRDY2 field.
	PMC_IMR_PCKRDY2_Pos = 0xa
	// Bit mask of PCKRDY2 field.
	PMC_IMR_PCKRDY2_Msk = 0x400
	// Bit PCKRDY2.
	PMC_IMR_PCKRDY2 = 0x400
	// Position of PCKRDY3 field.
	PMC_IMR_PCKRDY3_Pos = 0xb
	// Bit mask of PCKRDY3 field.
	PMC_IMR_PCKRDY3_Msk = 0x800
	// Bit PCKRDY3.
	PMC_IMR_PCKRDY3 = 0x800
	// Position of PCKRDY4 field.
	PMC_IMR_PCKRDY4_Pos = 0xc
	// Bit mask of PCKRDY4 field.
	PMC_IMR_PCKRDY4_Msk = 0x1000
	// Bit PCKRDY4.
	PMC_IMR_PCKRDY4 = 0x1000
	// Position of PCKRDY5 field.
	PMC_IMR_PCKRDY5_Pos = 0xd
	// Bit mask of PCKRDY5 field.
	PMC_IMR_PCKRDY5_Msk = 0x2000
	// Bit PCKRDY5.
	PMC_IMR_PCKRDY5 = 0x2000
	// Position of PCKRDY6 field.
	PMC_IMR_PCKRDY6_Pos = 0xe
	// Bit mask of PCKRDY6 field.
	PMC_IMR_PCKRDY6_Msk = 0x4000
	// Bit PCKRDY6.
	PMC_IMR_PCKRDY6 = 0x4000
	// Position of MOSCSELS field.
	PMC_IMR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_IMR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_IMR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_IMR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_IMR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_IMR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_IMR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_IMR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_IMR_CFDEV = 0x40000
	// Position of XT32KERR field.
	PMC_IMR_XT32KERR_Pos = 0x15
	// Bit mask of XT32KERR field.
	PMC_IMR_XT32KERR_Msk = 0x200000
	// Bit XT32KERR.
	PMC_IMR_XT32KERR = 0x200000

	// FSMR: Fast Startup Mode Register
	// Position of FSTT0 field.
	PMC_FSMR_FSTT0_Pos = 0x0
	// Bit mask of FSTT0 field.
	PMC_FSMR_FSTT0_Msk = 0x1
	// Bit FSTT0.
	PMC_FSMR_FSTT0 = 0x1
	// Position of FSTT1 field.
	PMC_FSMR_FSTT1_Pos = 0x1
	// Bit mask of FSTT1 field.
	PMC_FSMR_FSTT1_Msk = 0x2
	// Bit FSTT1.
	PMC_FSMR_FSTT1 = 0x2
	// Position of FSTT2 field.
	PMC_FSMR_FSTT2_Pos = 0x2
	// Bit mask of FSTT2 field.
	PMC_FSMR_FSTT2_Msk = 0x4
	// Bit FSTT2.
	PMC_FSMR_FSTT2 = 0x4
	// Position of FSTT3 field.
	PMC_FSMR_FSTT3_Pos = 0x3
	// Bit mask of FSTT3 field.
	PMC_FSMR_FSTT3_Msk = 0x8
	// Bit FSTT3.
	PMC_FSMR_FSTT3 = 0x8
	// Position of FSTT4 field.
	PMC_FSMR_FSTT4_Pos = 0x4
	// Bit mask of FSTT4 field.
	PMC_FSMR_FSTT4_Msk = 0x10
	// Bit FSTT4.
	PMC_FSMR_FSTT4 = 0x10
	// Position of FSTT5 field.
	PMC_FSMR_FSTT5_Pos = 0x5
	// Bit mask of FSTT5 field.
	PMC_FSMR_FSTT5_Msk = 0x20
	// Bit FSTT5.
	PMC_FSMR_FSTT5 = 0x20
	// Position of FSTT6 field.
	PMC_FSMR_FSTT6_Pos = 0x6
	// Bit mask of FSTT6 field.
	PMC_FSMR_FSTT6_Msk = 0x40
	// Bit FSTT6.
	PMC_FSMR_FSTT6 = 0x40
	// Position of FSTT7 field.
	PMC_FSMR_FSTT7_Pos = 0x7
	// Bit mask of FSTT7 field.
	PMC_FSMR_FSTT7_Msk = 0x80
	// Bit FSTT7.
	PMC_FSMR_FSTT7 = 0x80
	// Position of FSTT8 field.
	PMC_FSMR_FSTT8_Pos = 0x8
	// Bit mask of FSTT8 field.
	PMC_FSMR_FSTT8_Msk = 0x100
	// Bit FSTT8.
	PMC_FSMR_FSTT8 = 0x100
	// Position of FSTT9 field.
	PMC_FSMR_FSTT9_Pos = 0x9
	// Bit mask of FSTT9 field.
	PMC_FSMR_FSTT9_Msk = 0x200
	// Bit FSTT9.
	PMC_FSMR_FSTT9 = 0x200
	// Position of FSTT10 field.
	PMC_FSMR_FSTT10_Pos = 0xa
	// Bit mask of FSTT10 field.
	PMC_FSMR_FSTT10_Msk = 0x400
	// Bit FSTT10.
	PMC_FSMR_FSTT10 = 0x400
	// Position of FSTT11 field.
	PMC_FSMR_FSTT11_Pos = 0xb
	// Bit mask of FSTT11 field.
	PMC_FSMR_FSTT11_Msk = 0x800
	// Bit FSTT11.
	PMC_FSMR_FSTT11 = 0x800
	// Position of FSTT12 field.
	PMC_FSMR_FSTT12_Pos = 0xc
	// Bit mask of FSTT12 field.
	PMC_FSMR_FSTT12_Msk = 0x1000
	// Bit FSTT12.
	PMC_FSMR_FSTT12 = 0x1000
	// Position of FSTT13 field.
	PMC_FSMR_FSTT13_Pos = 0xd
	// Bit mask of FSTT13 field.
	PMC_FSMR_FSTT13_Msk = 0x2000
	// Bit FSTT13.
	PMC_FSMR_FSTT13 = 0x2000
	// Position of FSTT14 field.
	PMC_FSMR_FSTT14_Pos = 0xe
	// Bit mask of FSTT14 field.
	PMC_FSMR_FSTT14_Msk = 0x4000
	// Bit FSTT14.
	PMC_FSMR_FSTT14 = 0x4000
	// Position of FSTT15 field.
	PMC_FSMR_FSTT15_Pos = 0xf
	// Bit mask of FSTT15 field.
	PMC_FSMR_FSTT15_Msk = 0x8000
	// Bit FSTT15.
	PMC_FSMR_FSTT15 = 0x8000
	// Position of RTTAL field.
	PMC_FSMR_RTTAL_Pos = 0x10
	// Bit mask of RTTAL field.
	PMC_FSMR_RTTAL_Msk = 0x10000
	// Bit RTTAL.
	PMC_FSMR_RTTAL = 0x10000
	// Position of RTCAL field.
	PMC_FSMR_RTCAL_Pos = 0x11
	// Bit mask of RTCAL field.
	PMC_FSMR_RTCAL_Msk = 0x20000
	// Bit RTCAL.
	PMC_FSMR_RTCAL = 0x20000
	// Position of USBAL field.
	PMC_FSMR_USBAL_Pos = 0x12
	// Bit mask of USBAL field.
	PMC_FSMR_USBAL_Msk = 0x40000
	// Bit USBAL.
	PMC_FSMR_USBAL = 0x40000
	// Position of LPM field.
	PMC_FSMR_LPM_Pos = 0x14
	// Bit mask of LPM field.
	PMC_FSMR_LPM_Msk = 0x100000
	// Bit LPM.
	PMC_FSMR_LPM = 0x100000
	// Position of FLPM field.
	PMC_FSMR_FLPM_Pos = 0x15
	// Bit mask of FLPM field.
	PMC_FSMR_FLPM_Msk = 0x600000
	// Flash is in Standby Mode when system enters Wait Mode
	PMC_FSMR_FLPM_FLASH_STANDBY = 0x0
	// Flash is in Deep-power-down mode when system enters Wait Mode
	PMC_FSMR_FLPM_FLASH_DEEP_POWERDOWN = 0x1
	// Idle mode
	PMC_FSMR_FLPM_FLASH_IDLE = 0x2
	// Position of FFLPM field.
	PMC_FSMR_FFLPM_Pos = 0x17
	// Bit mask of FFLPM field.
	PMC_FSMR_FFLPM_Msk = 0x800000
	// Bit FFLPM.
	PMC_FSMR_FFLPM = 0x800000

	// FSPR: Fast Startup Polarity Register
	// Position of FSTP0 field.
	PMC_FSPR_FSTP0_Pos = 0x0
	// Bit mask of FSTP0 field.
	PMC_FSPR_FSTP0_Msk = 0x1
	// Bit FSTP0.
	PMC_FSPR_FSTP0 = 0x1
	// Position of FSTP1 field.
	PMC_FSPR_FSTP1_Pos = 0x1
	// Bit mask of FSTP1 field.
	PMC_FSPR_FSTP1_Msk = 0x2
	// Bit FSTP1.
	PMC_FSPR_FSTP1 = 0x2
	// Position of FSTP2 field.
	PMC_FSPR_FSTP2_Pos = 0x2
	// Bit mask of FSTP2 field.
	PMC_FSPR_FSTP2_Msk = 0x4
	// Bit FSTP2.
	PMC_FSPR_FSTP2 = 0x4
	// Position of FSTP3 field.
	PMC_FSPR_FSTP3_Pos = 0x3
	// Bit mask of FSTP3 field.
	PMC_FSPR_FSTP3_Msk = 0x8
	// Bit FSTP3.
	PMC_FSPR_FSTP3 = 0x8
	// Position of FSTP4 field.
	PMC_FSPR_FSTP4_Pos = 0x4
	// Bit mask of FSTP4 field.
	PMC_FSPR_FSTP4_Msk = 0x10
	// Bit FSTP4.
	PMC_FSPR_FSTP4 = 0x10
	// Position of FSTP5 field.
	PMC_FSPR_FSTP5_Pos = 0x5
	// Bit mask of FSTP5 field.
	PMC_FSPR_FSTP5_Msk = 0x20
	// Bit FSTP5.
	PMC_FSPR_FSTP5 = 0x20
	// Position of FSTP6 field.
	PMC_FSPR_FSTP6_Pos = 0x6
	// Bit mask of FSTP6 field.
	PMC_FSPR_FSTP6_Msk = 0x40
	// Bit FSTP6.
	PMC_FSPR_FSTP6 = 0x40
	// Position of FSTP7 field.
	PMC_FSPR_FSTP7_Pos = 0x7
	// Bit mask of FSTP7 field.
	PMC_FSPR_FSTP7_Msk = 0x80
	// Bit FSTP7.
	PMC_FSPR_FSTP7 = 0x80
	// Position of FSTP8 field.
	PMC_FSPR_FSTP8_Pos = 0x8
	// Bit mask of FSTP8 field.
	PMC_FSPR_FSTP8_Msk = 0x100
	// Bit FSTP8.
	PMC_FSPR_FSTP8 = 0x100
	// Position of FSTP9 field.
	PMC_FSPR_FSTP9_Pos = 0x9
	// Bit mask of FSTP9 field.
	PMC_FSPR_FSTP9_Msk = 0x200
	// Bit FSTP9.
	PMC_FSPR_FSTP9 = 0x200
	// Position of FSTP10 field.
	PMC_FSPR_FSTP10_Pos = 0xa
	// Bit mask of FSTP10 field.
	PMC_FSPR_FSTP10_Msk = 0x400
	// Bit FSTP10.
	PMC_FSPR_FSTP10 = 0x400
	// Position of FSTP11 field.
	PMC_FSPR_FSTP11_Pos = 0xb
	// Bit mask of FSTP11 field.
	PMC_FSPR_FSTP11_Msk = 0x800
	// Bit FSTP11.
	PMC_FSPR_FSTP11 = 0x800
	// Position of FSTP12 field.
	PMC_FSPR_FSTP12_Pos = 0xc
	// Bit mask of FSTP12 field.
	PMC_FSPR_FSTP12_Msk = 0x1000
	// Bit FSTP12.
	PMC_FSPR_FSTP12 = 0x1000
	// Position of FSTP13 field.
	PMC_FSPR_FSTP13_Pos = 0xd
	// Bit mask of FSTP13 field.
	PMC_FSPR_FSTP13_Msk = 0x2000
	// Bit FSTP13.
	PMC_FSPR_FSTP13 = 0x2000
	// Position of FSTP14 field.
	PMC_FSPR_FSTP14_Pos = 0xe
	// Bit mask of FSTP14 field.
	PMC_FSPR_FSTP14_Msk = 0x4000
	// Bit FSTP14.
	PMC_FSPR_FSTP14 = 0x4000
	// Position of FSTP15 field.
	PMC_FSPR_FSTP15_Pos = 0xf
	// Bit mask of FSTP15 field.
	PMC_FSPR_FSTP15_Msk = 0x8000
	// Bit FSTP15.
	PMC_FSPR_FSTP15 = 0x8000

	// FOCR: Fault Output Clear Register
	// Position of FOCLR field.
	PMC_FOCR_FOCLR_Pos = 0x0
	// Bit mask of FOCLR field.
	PMC_FOCR_FOCLR_Msk = 0x1
	// Bit FOCLR.
	PMC_FOCR_FOCLR = 0x1

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	PMC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PMC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PMC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PMC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PMC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit. Always reads as 0.
	PMC_WPMR_WPKEY_PASSWD = 0x504d43

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	PMC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PMC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PMC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PMC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PMC_WPSR_WPVSRC_Msk = 0xffff00

	// PCER1: Peripheral Clock Enable Register 1
	// Position of PID32 field.
	PMC_PCER1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PCER1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PCER1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PCER1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PCER1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PCER1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PCER1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PCER1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PCER1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PCER1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PCER1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PCER1_PID35 = 0x8
	// Position of PID37 field.
	PMC_PCER1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PCER1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PCER1_PID37 = 0x20
	// Position of PID39 field.
	PMC_PCER1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PCER1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PCER1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PCER1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PCER1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PCER1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PCER1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PCER1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PCER1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PCER1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PCER1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PCER1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PCER1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PCER1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PCER1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PCER1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PCER1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PCER1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PCER1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PCER1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PCER1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PCER1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PCER1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PCER1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PCER1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PCER1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PCER1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PCER1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PCER1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PCER1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PCER1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PCER1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PCER1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PCER1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PCER1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PCER1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PCER1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PCER1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PCER1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_PCER1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_PCER1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_PCER1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_PCER1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_PCER1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_PCER1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_PCER1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PCER1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PCER1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PCER1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PCER1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PCER1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PCER1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PCER1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PCER1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PCER1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PCER1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PCER1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PCER1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PCER1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PCER1_PID60 = 0x10000000

	// PCDR1: Peripheral Clock Disable Register 1
	// Position of PID32 field.
	PMC_PCDR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PCDR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PCDR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PCDR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PCDR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PCDR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PCDR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PCDR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PCDR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PCDR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PCDR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PCDR1_PID35 = 0x8
	// Position of PID37 field.
	PMC_PCDR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PCDR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PCDR1_PID37 = 0x20
	// Position of PID39 field.
	PMC_PCDR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PCDR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PCDR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PCDR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PCDR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PCDR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PCDR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PCDR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PCDR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PCDR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PCDR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PCDR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PCDR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PCDR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PCDR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PCDR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PCDR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PCDR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PCDR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PCDR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PCDR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PCDR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PCDR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PCDR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PCDR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PCDR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PCDR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PCDR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PCDR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PCDR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PCDR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PCDR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PCDR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PCDR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PCDR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PCDR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PCDR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PCDR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PCDR1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_PCDR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_PCDR1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_PCDR1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_PCDR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_PCDR1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_PCDR1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_PCDR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PCDR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PCDR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PCDR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PCDR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PCDR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PCDR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PCDR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PCDR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PCDR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PCDR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PCDR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PCDR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PCDR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PCDR1_PID60 = 0x10000000

	// PCSR1: Peripheral Clock Status Register 1
	// Position of PID32 field.
	PMC_PCSR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PCSR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PCSR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PCSR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PCSR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PCSR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PCSR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PCSR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PCSR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PCSR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PCSR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PCSR1_PID35 = 0x8
	// Position of PID37 field.
	PMC_PCSR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PCSR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PCSR1_PID37 = 0x20
	// Position of PID39 field.
	PMC_PCSR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PCSR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PCSR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PCSR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PCSR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PCSR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PCSR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PCSR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PCSR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PCSR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PCSR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PCSR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PCSR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PCSR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PCSR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PCSR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PCSR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PCSR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PCSR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PCSR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PCSR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PCSR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PCSR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PCSR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PCSR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PCSR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PCSR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PCSR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PCSR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PCSR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PCSR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PCSR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PCSR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PCSR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PCSR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PCSR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PCSR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PCSR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PCSR1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_PCSR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_PCSR1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_PCSR1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_PCSR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_PCSR1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_PCSR1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_PCSR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PCSR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PCSR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PCSR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PCSR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PCSR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PCSR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PCSR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PCSR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PCSR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PCSR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PCSR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PCSR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PCSR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PCSR1_PID60 = 0x10000000

	// PCR: Peripheral Control Register
	// Position of PID field.
	PMC_PCR_PID_Pos = 0x0
	// Bit mask of PID field.
	PMC_PCR_PID_Msk = 0x7f
	// Position of GCLKCSS field.
	PMC_PCR_GCLKCSS_Pos = 0x8
	// Bit mask of GCLKCSS field.
	PMC_PCR_GCLKCSS_Msk = 0x700
	// Slow clock is selected
	PMC_PCR_GCLKCSS_SLOW_CLK = 0x0
	// Main clock is selected
	PMC_PCR_GCLKCSS_MAIN_CLK = 0x1
	// PLLACK is selected
	PMC_PCR_GCLKCSS_PLLA_CLK = 0x2
	// UPLL Clock is selected
	PMC_PCR_GCLKCSS_UPLL_CLK = 0x3
	// Master Clock is selected
	PMC_PCR_GCLKCSS_MCK_CLK = 0x4
	// Position of CMD field.
	PMC_PCR_CMD_Pos = 0xc
	// Bit mask of CMD field.
	PMC_PCR_CMD_Msk = 0x1000
	// Bit CMD.
	PMC_PCR_CMD = 0x1000
	// Position of GCLKDIV field.
	PMC_PCR_GCLKDIV_Pos = 0x14
	// Bit mask of GCLKDIV field.
	PMC_PCR_GCLKDIV_Msk = 0xff00000
	// Position of EN field.
	PMC_PCR_EN_Pos = 0x1c
	// Bit mask of EN field.
	PMC_PCR_EN_Msk = 0x10000000
	// Bit EN.
	PMC_PCR_EN = 0x10000000
	// Position of GCLKEN field.
	PMC_PCR_GCLKEN_Pos = 0x1d
	// Bit mask of GCLKEN field.
	PMC_PCR_GCLKEN_Msk = 0x20000000
	// Bit GCLKEN.
	PMC_PCR_GCLKEN = 0x20000000

	// OCR: Oscillator Calibration Register
	// Position of CAL4 field.
	PMC_OCR_CAL4_Pos = 0x0
	// Bit mask of CAL4 field.
	PMC_OCR_CAL4_Msk = 0x7f
	// Position of SEL4 field.
	PMC_OCR_SEL4_Pos = 0x7
	// Bit mask of SEL4 field.
	PMC_OCR_SEL4_Msk = 0x80
	// Bit SEL4.
	PMC_OCR_SEL4 = 0x80
	// Position of CAL8 field.
	PMC_OCR_CAL8_Pos = 0x8
	// Bit mask of CAL8 field.
	PMC_OCR_CAL8_Msk = 0x7f00
	// Position of SEL8 field.
	PMC_OCR_SEL8_Pos = 0xf
	// Bit mask of SEL8 field.
	PMC_OCR_SEL8_Msk = 0x8000
	// Bit SEL8.
	PMC_OCR_SEL8 = 0x8000
	// Position of CAL12 field.
	PMC_OCR_CAL12_Pos = 0x10
	// Bit mask of CAL12 field.
	PMC_OCR_CAL12_Msk = 0x7f0000
	// Position of SEL12 field.
	PMC_OCR_SEL12_Pos = 0x17
	// Bit mask of SEL12 field.
	PMC_OCR_SEL12_Msk = 0x800000
	// Bit SEL12.
	PMC_OCR_SEL12 = 0x800000

	// SLPWK_ER0: SleepWalking Enable Register 0
	// Position of PID7 field.
	PMC_SLPWK_ER0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_SLPWK_ER0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_SLPWK_ER0_PID7 = 0x80
	// Position of PID8 field.
	PMC_SLPWK_ER0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_SLPWK_ER0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_SLPWK_ER0_PID8 = 0x100
	// Position of PID9 field.
	PMC_SLPWK_ER0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_SLPWK_ER0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_SLPWK_ER0_PID9 = 0x200
	// Position of PID10 field.
	PMC_SLPWK_ER0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_SLPWK_ER0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_SLPWK_ER0_PID10 = 0x400
	// Position of PID11 field.
	PMC_SLPWK_ER0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_SLPWK_ER0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_SLPWK_ER0_PID11 = 0x800
	// Position of PID12 field.
	PMC_SLPWK_ER0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_SLPWK_ER0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_SLPWK_ER0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_SLPWK_ER0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_SLPWK_ER0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_SLPWK_ER0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_SLPWK_ER0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_SLPWK_ER0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_SLPWK_ER0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_SLPWK_ER0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_SLPWK_ER0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_SLPWK_ER0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_SLPWK_ER0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_SLPWK_ER0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_SLPWK_ER0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_SLPWK_ER0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_SLPWK_ER0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_SLPWK_ER0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_SLPWK_ER0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_SLPWK_ER0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_SLPWK_ER0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_SLPWK_ER0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_SLPWK_ER0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_SLPWK_ER0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_SLPWK_ER0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_SLPWK_ER0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_SLPWK_ER0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_SLPWK_ER0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_SLPWK_ER0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_SLPWK_ER0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_SLPWK_ER0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_SLPWK_ER0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_SLPWK_ER0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_SLPWK_ER0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_SLPWK_ER0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_SLPWK_ER0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_SLPWK_ER0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_SLPWK_ER0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_SLPWK_ER0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_SLPWK_ER0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_SLPWK_ER0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_SLPWK_ER0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_SLPWK_ER0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_SLPWK_ER0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_SLPWK_ER0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_SLPWK_ER0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_SLPWK_ER0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_SLPWK_ER0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_SLPWK_ER0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_SLPWK_ER0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_SLPWK_ER0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_SLPWK_ER0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_SLPWK_ER0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_SLPWK_ER0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_SLPWK_ER0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_SLPWK_ER0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_SLPWK_ER0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_SLPWK_ER0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_SLPWK_ER0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_SLPWK_ER0_PID31 = 0x80000000

	// SLPWK_DR0: SleepWalking Disable Register 0
	// Position of PID7 field.
	PMC_SLPWK_DR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_SLPWK_DR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_SLPWK_DR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_SLPWK_DR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_SLPWK_DR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_SLPWK_DR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_SLPWK_DR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_SLPWK_DR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_SLPWK_DR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_SLPWK_DR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_SLPWK_DR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_SLPWK_DR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_SLPWK_DR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_SLPWK_DR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_SLPWK_DR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_SLPWK_DR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_SLPWK_DR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_SLPWK_DR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_SLPWK_DR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_SLPWK_DR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_SLPWK_DR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_SLPWK_DR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_SLPWK_DR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_SLPWK_DR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_SLPWK_DR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_SLPWK_DR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_SLPWK_DR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_SLPWK_DR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_SLPWK_DR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_SLPWK_DR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_SLPWK_DR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_SLPWK_DR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_SLPWK_DR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_SLPWK_DR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_SLPWK_DR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_SLPWK_DR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_SLPWK_DR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_SLPWK_DR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_SLPWK_DR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_SLPWK_DR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_SLPWK_DR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_SLPWK_DR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_SLPWK_DR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_SLPWK_DR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_SLPWK_DR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_SLPWK_DR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_SLPWK_DR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_SLPWK_DR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_SLPWK_DR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_SLPWK_DR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_SLPWK_DR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_SLPWK_DR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_SLPWK_DR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_SLPWK_DR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_SLPWK_DR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_SLPWK_DR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_SLPWK_DR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_SLPWK_DR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_SLPWK_DR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_SLPWK_DR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_SLPWK_DR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_SLPWK_DR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_SLPWK_DR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_SLPWK_DR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_SLPWK_DR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_SLPWK_DR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_SLPWK_DR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_SLPWK_DR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_SLPWK_DR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_SLPWK_DR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_SLPWK_DR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_SLPWK_DR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_SLPWK_DR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_SLPWK_DR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_SLPWK_DR0_PID31 = 0x80000000

	// SLPWK_SR0: SleepWalking Status Register 0
	// Position of PID7 field.
	PMC_SLPWK_SR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_SLPWK_SR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_SLPWK_SR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_SLPWK_SR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_SLPWK_SR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_SLPWK_SR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_SLPWK_SR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_SLPWK_SR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_SLPWK_SR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_SLPWK_SR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_SLPWK_SR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_SLPWK_SR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_SLPWK_SR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_SLPWK_SR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_SLPWK_SR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_SLPWK_SR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_SLPWK_SR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_SLPWK_SR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_SLPWK_SR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_SLPWK_SR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_SLPWK_SR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_SLPWK_SR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_SLPWK_SR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_SLPWK_SR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_SLPWK_SR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_SLPWK_SR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_SLPWK_SR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_SLPWK_SR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_SLPWK_SR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_SLPWK_SR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_SLPWK_SR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_SLPWK_SR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_SLPWK_SR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_SLPWK_SR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_SLPWK_SR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_SLPWK_SR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_SLPWK_SR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_SLPWK_SR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_SLPWK_SR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_SLPWK_SR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_SLPWK_SR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_SLPWK_SR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_SLPWK_SR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_SLPWK_SR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_SLPWK_SR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_SLPWK_SR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_SLPWK_SR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_SLPWK_SR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_SLPWK_SR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_SLPWK_SR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_SLPWK_SR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_SLPWK_SR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_SLPWK_SR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_SLPWK_SR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_SLPWK_SR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_SLPWK_SR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_SLPWK_SR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_SLPWK_SR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_SLPWK_SR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_SLPWK_SR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_SLPWK_SR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_SLPWK_SR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_SLPWK_SR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_SLPWK_SR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_SLPWK_SR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_SLPWK_SR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_SLPWK_SR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_SLPWK_SR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_SLPWK_SR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_SLPWK_SR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_SLPWK_SR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_SLPWK_SR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_SLPWK_SR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_SLPWK_SR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_SLPWK_SR0_PID31 = 0x80000000

	// SLPWK_ASR0: SleepWalking Activity Status Register 0
	// Position of PID7 field.
	PMC_SLPWK_ASR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_SLPWK_ASR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_SLPWK_ASR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_SLPWK_ASR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_SLPWK_ASR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_SLPWK_ASR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_SLPWK_ASR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_SLPWK_ASR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_SLPWK_ASR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_SLPWK_ASR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_SLPWK_ASR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_SLPWK_ASR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_SLPWK_ASR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_SLPWK_ASR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_SLPWK_ASR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_SLPWK_ASR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_SLPWK_ASR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_SLPWK_ASR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_SLPWK_ASR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_SLPWK_ASR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_SLPWK_ASR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_SLPWK_ASR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_SLPWK_ASR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_SLPWK_ASR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_SLPWK_ASR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_SLPWK_ASR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_SLPWK_ASR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_SLPWK_ASR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_SLPWK_ASR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_SLPWK_ASR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_SLPWK_ASR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_SLPWK_ASR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_SLPWK_ASR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_SLPWK_ASR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_SLPWK_ASR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_SLPWK_ASR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_SLPWK_ASR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_SLPWK_ASR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_SLPWK_ASR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_SLPWK_ASR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_SLPWK_ASR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_SLPWK_ASR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_SLPWK_ASR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_SLPWK_ASR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_SLPWK_ASR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_SLPWK_ASR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_SLPWK_ASR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_SLPWK_ASR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_SLPWK_ASR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_SLPWK_ASR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_SLPWK_ASR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_SLPWK_ASR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_SLPWK_ASR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_SLPWK_ASR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_SLPWK_ASR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_SLPWK_ASR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_SLPWK_ASR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_SLPWK_ASR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_SLPWK_ASR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_SLPWK_ASR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_SLPWK_ASR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_SLPWK_ASR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_SLPWK_ASR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_SLPWK_ASR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_SLPWK_ASR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_SLPWK_ASR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_SLPWK_ASR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_SLPWK_ASR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_SLPWK_ASR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_SLPWK_ASR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_SLPWK_ASR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_SLPWK_ASR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_SLPWK_ASR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_SLPWK_ASR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_SLPWK_ASR0_PID31 = 0x80000000

	// PMMR: PLL Maximum Multiplier Value Register
	// Position of PLLA_MMAX field.
	PMC_PMMR_PLLA_MMAX_Pos = 0x0
	// Bit mask of PLLA_MMAX field.
	PMC_PMMR_PLLA_MMAX_Msk = 0x7ff

	// SLPWK_ER1: SleepWalking Enable Register 1
	// Position of PID32 field.
	PMC_SLPWK_ER1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_SLPWK_ER1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_SLPWK_ER1_PID32 = 0x1
	// Position of PID33 field.
	PMC_SLPWK_ER1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_SLPWK_ER1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_SLPWK_ER1_PID33 = 0x2
	// Position of PID34 field.
	PMC_SLPWK_ER1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_SLPWK_ER1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_SLPWK_ER1_PID34 = 0x4
	// Position of PID35 field.
	PMC_SLPWK_ER1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_SLPWK_ER1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_SLPWK_ER1_PID35 = 0x8
	// Position of PID37 field.
	PMC_SLPWK_ER1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_SLPWK_ER1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_SLPWK_ER1_PID37 = 0x20
	// Position of PID39 field.
	PMC_SLPWK_ER1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_SLPWK_ER1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_SLPWK_ER1_PID39 = 0x80
	// Position of PID40 field.
	PMC_SLPWK_ER1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_SLPWK_ER1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_SLPWK_ER1_PID40 = 0x100
	// Position of PID41 field.
	PMC_SLPWK_ER1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_SLPWK_ER1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_SLPWK_ER1_PID41 = 0x200
	// Position of PID42 field.
	PMC_SLPWK_ER1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_SLPWK_ER1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_SLPWK_ER1_PID42 = 0x400
	// Position of PID43 field.
	PMC_SLPWK_ER1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_SLPWK_ER1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_SLPWK_ER1_PID43 = 0x800
	// Position of PID44 field.
	PMC_SLPWK_ER1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_SLPWK_ER1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_SLPWK_ER1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_SLPWK_ER1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_SLPWK_ER1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_SLPWK_ER1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_SLPWK_ER1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_SLPWK_ER1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_SLPWK_ER1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_SLPWK_ER1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_SLPWK_ER1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_SLPWK_ER1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_SLPWK_ER1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_SLPWK_ER1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_SLPWK_ER1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_SLPWK_ER1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_SLPWK_ER1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_SLPWK_ER1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_SLPWK_ER1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_SLPWK_ER1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_SLPWK_ER1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_SLPWK_ER1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_SLPWK_ER1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_SLPWK_ER1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_SLPWK_ER1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_SLPWK_ER1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_SLPWK_ER1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_SLPWK_ER1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_SLPWK_ER1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_SLPWK_ER1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_SLPWK_ER1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_SLPWK_ER1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_SLPWK_ER1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_SLPWK_ER1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_SLPWK_ER1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_SLPWK_ER1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_SLPWK_ER1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_SLPWK_ER1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_SLPWK_ER1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_SLPWK_ER1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_SLPWK_ER1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_SLPWK_ER1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_SLPWK_ER1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_SLPWK_ER1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_SLPWK_ER1_PID60 = 0x10000000

	// SLPWK_DR1: SleepWalking Disable Register 1
	// Position of PID32 field.
	PMC_SLPWK_DR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_SLPWK_DR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_SLPWK_DR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_SLPWK_DR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_SLPWK_DR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_SLPWK_DR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_SLPWK_DR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_SLPWK_DR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_SLPWK_DR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_SLPWK_DR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_SLPWK_DR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_SLPWK_DR1_PID35 = 0x8
	// Position of PID37 field.
	PMC_SLPWK_DR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_SLPWK_DR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_SLPWK_DR1_PID37 = 0x20
	// Position of PID39 field.
	PMC_SLPWK_DR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_SLPWK_DR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_SLPWK_DR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_SLPWK_DR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_SLPWK_DR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_SLPWK_DR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_SLPWK_DR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_SLPWK_DR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_SLPWK_DR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_SLPWK_DR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_SLPWK_DR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_SLPWK_DR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_SLPWK_DR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_SLPWK_DR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_SLPWK_DR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_SLPWK_DR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_SLPWK_DR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_SLPWK_DR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_SLPWK_DR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_SLPWK_DR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_SLPWK_DR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_SLPWK_DR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_SLPWK_DR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_SLPWK_DR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_SLPWK_DR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_SLPWK_DR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_SLPWK_DR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_SLPWK_DR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_SLPWK_DR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_SLPWK_DR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_SLPWK_DR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_SLPWK_DR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_SLPWK_DR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_SLPWK_DR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_SLPWK_DR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_SLPWK_DR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_SLPWK_DR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_SLPWK_DR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_SLPWK_DR1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_SLPWK_DR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_SLPWK_DR1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_SLPWK_DR1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_SLPWK_DR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_SLPWK_DR1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_SLPWK_DR1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_SLPWK_DR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_SLPWK_DR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_SLPWK_DR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_SLPWK_DR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_SLPWK_DR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_SLPWK_DR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_SLPWK_DR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_SLPWK_DR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_SLPWK_DR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_SLPWK_DR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_SLPWK_DR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_SLPWK_DR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_SLPWK_DR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_SLPWK_DR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_SLPWK_DR1_PID60 = 0x10000000

	// SLPWK_SR1: SleepWalking Status Register 1
	// Position of PID32 field.
	PMC_SLPWK_SR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_SLPWK_SR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_SLPWK_SR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_SLPWK_SR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_SLPWK_SR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_SLPWK_SR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_SLPWK_SR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_SLPWK_SR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_SLPWK_SR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_SLPWK_SR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_SLPWK_SR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_SLPWK_SR1_PID35 = 0x8
	// Position of PID37 field.
	PMC_SLPWK_SR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_SLPWK_SR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_SLPWK_SR1_PID37 = 0x20
	// Position of PID39 field.
	PMC_SLPWK_SR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_SLPWK_SR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_SLPWK_SR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_SLPWK_SR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_SLPWK_SR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_SLPWK_SR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_SLPWK_SR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_SLPWK_SR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_SLPWK_SR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_SLPWK_SR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_SLPWK_SR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_SLPWK_SR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_SLPWK_SR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_SLPWK_SR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_SLPWK_SR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_SLPWK_SR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_SLPWK_SR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_SLPWK_SR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_SLPWK_SR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_SLPWK_SR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_SLPWK_SR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_SLPWK_SR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_SLPWK_SR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_SLPWK_SR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_SLPWK_SR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_SLPWK_SR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_SLPWK_SR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_SLPWK_SR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_SLPWK_SR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_SLPWK_SR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_SLPWK_SR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_SLPWK_SR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_SLPWK_SR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_SLPWK_SR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_SLPWK_SR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_SLPWK_SR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_SLPWK_SR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_SLPWK_SR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_SLPWK_SR1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_SLPWK_SR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_SLPWK_SR1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_SLPWK_SR1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_SLPWK_SR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_SLPWK_SR1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_SLPWK_SR1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_SLPWK_SR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_SLPWK_SR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_SLPWK_SR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_SLPWK_SR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_SLPWK_SR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_SLPWK_SR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_SLPWK_SR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_SLPWK_SR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_SLPWK_SR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_SLPWK_SR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_SLPWK_SR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_SLPWK_SR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_SLPWK_SR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_SLPWK_SR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_SLPWK_SR1_PID60 = 0x10000000

	// SLPWK_ASR1: SleepWalking Activity Status Register 1
	// Position of PID32 field.
	PMC_SLPWK_ASR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_SLPWK_ASR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_SLPWK_ASR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_SLPWK_ASR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_SLPWK_ASR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_SLPWK_ASR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_SLPWK_ASR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_SLPWK_ASR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_SLPWK_ASR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_SLPWK_ASR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_SLPWK_ASR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_SLPWK_ASR1_PID35 = 0x8
	// Position of PID37 field.
	PMC_SLPWK_ASR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_SLPWK_ASR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_SLPWK_ASR1_PID37 = 0x20
	// Position of PID39 field.
	PMC_SLPWK_ASR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_SLPWK_ASR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_SLPWK_ASR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_SLPWK_ASR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_SLPWK_ASR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_SLPWK_ASR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_SLPWK_ASR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_SLPWK_ASR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_SLPWK_ASR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_SLPWK_ASR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_SLPWK_ASR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_SLPWK_ASR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_SLPWK_ASR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_SLPWK_ASR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_SLPWK_ASR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_SLPWK_ASR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_SLPWK_ASR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_SLPWK_ASR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_SLPWK_ASR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_SLPWK_ASR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_SLPWK_ASR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_SLPWK_ASR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_SLPWK_ASR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_SLPWK_ASR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_SLPWK_ASR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_SLPWK_ASR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_SLPWK_ASR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_SLPWK_ASR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_SLPWK_ASR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_SLPWK_ASR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_SLPWK_ASR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_SLPWK_ASR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_SLPWK_ASR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_SLPWK_ASR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_SLPWK_ASR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_SLPWK_ASR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_SLPWK_ASR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_SLPWK_ASR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_SLPWK_ASR1_PID51 = 0x80000
	// Position of PID52 field.
	PMC_SLPWK_ASR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	PMC_SLPWK_ASR1_PID52_Msk = 0x100000
	// Bit PID52.
	PMC_SLPWK_ASR1_PID52 = 0x100000
	// Position of PID53 field.
	PMC_SLPWK_ASR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	PMC_SLPWK_ASR1_PID53_Msk = 0x200000
	// Bit PID53.
	PMC_SLPWK_ASR1_PID53 = 0x200000
	// Position of PID56 field.
	PMC_SLPWK_ASR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_SLPWK_ASR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_SLPWK_ASR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_SLPWK_ASR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_SLPWK_ASR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_SLPWK_ASR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_SLPWK_ASR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_SLPWK_ASR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_SLPWK_ASR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_SLPWK_ASR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_SLPWK_ASR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_SLPWK_ASR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_SLPWK_ASR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_SLPWK_ASR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_SLPWK_ASR1_PID60 = 0x10000000

	// SLPWK_AIPR: SleepWalking Activity In Progress Register
	// Position of AIP field.
	PMC_SLPWK_AIPR_AIP_Pos = 0x0
	// Bit mask of AIP field.
	PMC_SLPWK_AIPR_AIP_Msk = 0x1
	// Bit AIP.
	PMC_SLPWK_AIPR_AIP = 0x1
)

// Constants for PWM0: Pulse Width Modulation Controller
const (
	// CLK: PWM Clock Register
	// Position of DIVA field.
	PWM_CLK_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PWM_CLK_DIVA_Msk = 0xff
	// CLKA clock is turned off
	PWM_CLK_DIVA_CLKA_POFF = 0x0
	// CLKA clock is clock selected by PREA
	PWM_CLK_DIVA_PREA = 0x1
	// Position of PREA field.
	PWM_CLK_PREA_Pos = 0x8
	// Bit mask of PREA field.
	PWM_CLK_PREA_Msk = 0xf00
	// Peripheral clock
	PWM_CLK_PREA_CLK = 0x0
	// Peripheral clock/2
	PWM_CLK_PREA_CLK_DIV2 = 0x1
	// Peripheral clock/4
	PWM_CLK_PREA_CLK_DIV4 = 0x2
	// Peripheral clock/8
	PWM_CLK_PREA_CLK_DIV8 = 0x3
	// Peripheral clock/16
	PWM_CLK_PREA_CLK_DIV16 = 0x4
	// Peripheral clock/32
	PWM_CLK_PREA_CLK_DIV32 = 0x5
	// Peripheral clock/64
	PWM_CLK_PREA_CLK_DIV64 = 0x6
	// Peripheral clock/128
	PWM_CLK_PREA_CLK_DIV128 = 0x7
	// Peripheral clock/256
	PWM_CLK_PREA_CLK_DIV256 = 0x8
	// Peripheral clock/512
	PWM_CLK_PREA_CLK_DIV512 = 0x9
	// Peripheral clock/1024
	PWM_CLK_PREA_CLK_DIV1024 = 0xa
	// Position of DIVB field.
	PWM_CLK_DIVB_Pos = 0x10
	// Bit mask of DIVB field.
	PWM_CLK_DIVB_Msk = 0xff0000
	// CLKB clock is turned off
	PWM_CLK_DIVB_CLKB_POFF = 0x0
	// CLKB clock is clock selected by PREB
	PWM_CLK_DIVB_PREB = 0x1
	// Position of PREB field.
	PWM_CLK_PREB_Pos = 0x18
	// Bit mask of PREB field.
	PWM_CLK_PREB_Msk = 0xf000000
	// Peripheral clock
	PWM_CLK_PREB_CLK = 0x0
	// Peripheral clock/2
	PWM_CLK_PREB_CLK_DIV2 = 0x1
	// Peripheral clock/4
	PWM_CLK_PREB_CLK_DIV4 = 0x2
	// Peripheral clock/8
	PWM_CLK_PREB_CLK_DIV8 = 0x3
	// Peripheral clock/16
	PWM_CLK_PREB_CLK_DIV16 = 0x4
	// Peripheral clock/32
	PWM_CLK_PREB_CLK_DIV32 = 0x5
	// Peripheral clock/64
	PWM_CLK_PREB_CLK_DIV64 = 0x6
	// Peripheral clock/128
	PWM_CLK_PREB_CLK_DIV128 = 0x7
	// Peripheral clock/256
	PWM_CLK_PREB_CLK_DIV256 = 0x8
	// Peripheral clock/512
	PWM_CLK_PREB_CLK_DIV512 = 0x9
	// Peripheral clock/1024
	PWM_CLK_PREB_CLK_DIV1024 = 0xa

	// ENA: PWM Enable Register
	// Position of CHID0 field.
	PWM_ENA_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ENA_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ENA_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ENA_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ENA_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ENA_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ENA_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ENA_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ENA_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ENA_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ENA_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ENA_CHID3 = 0x8

	// DIS: PWM Disable Register
	// Position of CHID0 field.
	PWM_DIS_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_DIS_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_DIS_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_DIS_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_DIS_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_DIS_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_DIS_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_DIS_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_DIS_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_DIS_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_DIS_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_DIS_CHID3 = 0x8

	// SR: PWM Status Register
	// Position of CHID0 field.
	PWM_SR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_SR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_SR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_SR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_SR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_SR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_SR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_SR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_SR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_SR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_SR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_SR_CHID3 = 0x8

	// IER1: PWM Interrupt Enable Register 1
	// Position of CHID0 field.
	PWM_IER1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IER1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IER1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IER1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IER1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IER1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IER1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IER1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IER1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IER1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IER1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IER1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IER1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IER1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IER1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IER1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IER1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IER1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IER1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IER1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IER1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IER1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IER1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IER1_FCHID3 = 0x80000

	// IDR1: PWM Interrupt Disable Register 1
	// Position of CHID0 field.
	PWM_IDR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IDR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IDR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IDR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IDR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IDR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IDR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IDR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IDR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IDR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IDR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IDR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IDR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IDR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IDR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IDR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IDR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IDR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IDR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IDR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IDR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IDR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IDR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IDR1_FCHID3 = 0x80000

	// IMR1: PWM Interrupt Mask Register 1
	// Position of CHID0 field.
	PWM_IMR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IMR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IMR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IMR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IMR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IMR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IMR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IMR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IMR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IMR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IMR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IMR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IMR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IMR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IMR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IMR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IMR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IMR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IMR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IMR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IMR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IMR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IMR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IMR1_FCHID3 = 0x80000

	// ISR1: PWM Interrupt Status Register 1
	// Position of CHID0 field.
	PWM_ISR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ISR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ISR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ISR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ISR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ISR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ISR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ISR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ISR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ISR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ISR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ISR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_ISR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_ISR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_ISR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_ISR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_ISR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_ISR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_ISR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_ISR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_ISR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_ISR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_ISR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_ISR1_FCHID3 = 0x80000

	// SCM: PWM Sync Channels Mode Register
	// Position of SYNC0 field.
	PWM_SCM_SYNC0_Pos = 0x0
	// Bit mask of SYNC0 field.
	PWM_SCM_SYNC0_Msk = 0x1
	// Bit SYNC0.
	PWM_SCM_SYNC0 = 0x1
	// Position of SYNC1 field.
	PWM_SCM_SYNC1_Pos = 0x1
	// Bit mask of SYNC1 field.
	PWM_SCM_SYNC1_Msk = 0x2
	// Bit SYNC1.
	PWM_SCM_SYNC1 = 0x2
	// Position of SYNC2 field.
	PWM_SCM_SYNC2_Pos = 0x2
	// Bit mask of SYNC2 field.
	PWM_SCM_SYNC2_Msk = 0x4
	// Bit SYNC2.
	PWM_SCM_SYNC2 = 0x4
	// Position of SYNC3 field.
	PWM_SCM_SYNC3_Pos = 0x3
	// Bit mask of SYNC3 field.
	PWM_SCM_SYNC3_Msk = 0x8
	// Bit SYNC3.
	PWM_SCM_SYNC3 = 0x8
	// Position of UPDM field.
	PWM_SCM_UPDM_Pos = 0x10
	// Bit mask of UPDM field.
	PWM_SCM_UPDM_Msk = 0x30000
	// Manual write of double buffer registers and manual update of synchronous channels
	PWM_SCM_UPDM_MODE0 = 0x0
	// Manual write of double buffer registers and automatic update of synchronous channels
	PWM_SCM_UPDM_MODE1 = 0x1
	// Automatic write of duty-cycle update registers by the DMA Controller and automatic update of synchronous channels
	PWM_SCM_UPDM_MODE2 = 0x2
	// Position of PTRM field.
	PWM_SCM_PTRM_Pos = 0x14
	// Bit mask of PTRM field.
	PWM_SCM_PTRM_Msk = 0x100000
	// Bit PTRM.
	PWM_SCM_PTRM = 0x100000
	// Position of PTRCS field.
	PWM_SCM_PTRCS_Pos = 0x15
	// Bit mask of PTRCS field.
	PWM_SCM_PTRCS_Msk = 0xe00000

	// DMAR: PWM DMA Register
	// Position of DMADUTY field.
	PWM_DMAR_DMADUTY_Pos = 0x0
	// Bit mask of DMADUTY field.
	PWM_DMAR_DMADUTY_Msk = 0xffffff

	// SCUC: PWM Sync Channels Update Control Register
	// Position of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Pos = 0x0
	// Bit mask of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Msk = 0x1
	// Bit UPDULOCK.
	PWM_SCUC_UPDULOCK = 0x1

	// SCUP: PWM Sync Channels Update Period Register
	// Position of UPR field.
	PWM_SCUP_UPR_Pos = 0x0
	// Bit mask of UPR field.
	PWM_SCUP_UPR_Msk = 0xf
	// Position of UPRCNT field.
	PWM_SCUP_UPRCNT_Pos = 0x4
	// Bit mask of UPRCNT field.
	PWM_SCUP_UPRCNT_Msk = 0xf0

	// SCUPUPD: PWM Sync Channels Update Period Update Register
	// Position of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Pos = 0x0
	// Bit mask of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Msk = 0xf

	// IER2: PWM Interrupt Enable Register 2
	// Position of WRDY field.
	PWM_IER2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IER2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IER2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IER2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IER2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IER2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IER2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IER2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IER2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IER2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IER2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IER2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IER2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IER2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IER2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IER2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IER2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IER2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IER2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IER2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IER2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IER2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IER2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IER2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IER2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IER2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IER2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IER2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IER2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IER2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IER2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IER2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IER2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IER2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IER2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IER2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IER2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IER2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IER2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IER2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IER2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IER2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IER2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IER2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IER2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IER2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IER2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IER2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IER2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IER2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IER2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IER2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IER2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IER2_CMPU7 = 0x800000

	// IDR2: PWM Interrupt Disable Register 2
	// Position of WRDY field.
	PWM_IDR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IDR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IDR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IDR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IDR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IDR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IDR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IDR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IDR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IDR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IDR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IDR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IDR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IDR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IDR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IDR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IDR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IDR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IDR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IDR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IDR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IDR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IDR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IDR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IDR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IDR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IDR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IDR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IDR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IDR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IDR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IDR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IDR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IDR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IDR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IDR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IDR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IDR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IDR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IDR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IDR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IDR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IDR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IDR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IDR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IDR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IDR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IDR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IDR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IDR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IDR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IDR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IDR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IDR2_CMPU7 = 0x800000

	// IMR2: PWM Interrupt Mask Register 2
	// Position of WRDY field.
	PWM_IMR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IMR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IMR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IMR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IMR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IMR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IMR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IMR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IMR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IMR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IMR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IMR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IMR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IMR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IMR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IMR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IMR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IMR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IMR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IMR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IMR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IMR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IMR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IMR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IMR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IMR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IMR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IMR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IMR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IMR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IMR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IMR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IMR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IMR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IMR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IMR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IMR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IMR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IMR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IMR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IMR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IMR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IMR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IMR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IMR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IMR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IMR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IMR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IMR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IMR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IMR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IMR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IMR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IMR2_CMPU7 = 0x800000

	// ISR2: PWM Interrupt Status Register 2
	// Position of WRDY field.
	PWM_ISR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_ISR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_ISR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_ISR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_ISR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_ISR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_ISR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_ISR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_ISR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_ISR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_ISR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_ISR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_ISR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_ISR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_ISR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_ISR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_ISR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_ISR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_ISR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_ISR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_ISR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_ISR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_ISR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_ISR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_ISR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_ISR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_ISR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_ISR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_ISR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_ISR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_ISR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_ISR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_ISR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_ISR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_ISR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_ISR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_ISR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_ISR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_ISR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_ISR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_ISR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_ISR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_ISR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_ISR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_ISR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_ISR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_ISR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_ISR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_ISR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_ISR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_ISR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_ISR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_ISR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_ISR2_CMPU7 = 0x800000

	// OOV: PWM Output Override Value Register
	// Position of OOVH0 field.
	PWM_OOV_OOVH0_Pos = 0x0
	// Bit mask of OOVH0 field.
	PWM_OOV_OOVH0_Msk = 0x1
	// Bit OOVH0.
	PWM_OOV_OOVH0 = 0x1
	// Position of OOVH1 field.
	PWM_OOV_OOVH1_Pos = 0x1
	// Bit mask of OOVH1 field.
	PWM_OOV_OOVH1_Msk = 0x2
	// Bit OOVH1.
	PWM_OOV_OOVH1 = 0x2
	// Position of OOVH2 field.
	PWM_OOV_OOVH2_Pos = 0x2
	// Bit mask of OOVH2 field.
	PWM_OOV_OOVH2_Msk = 0x4
	// Bit OOVH2.
	PWM_OOV_OOVH2 = 0x4
	// Position of OOVH3 field.
	PWM_OOV_OOVH3_Pos = 0x3
	// Bit mask of OOVH3 field.
	PWM_OOV_OOVH3_Msk = 0x8
	// Bit OOVH3.
	PWM_OOV_OOVH3 = 0x8
	// Position of OOVL0 field.
	PWM_OOV_OOVL0_Pos = 0x10
	// Bit mask of OOVL0 field.
	PWM_OOV_OOVL0_Msk = 0x10000
	// Bit OOVL0.
	PWM_OOV_OOVL0 = 0x10000
	// Position of OOVL1 field.
	PWM_OOV_OOVL1_Pos = 0x11
	// Bit mask of OOVL1 field.
	PWM_OOV_OOVL1_Msk = 0x20000
	// Bit OOVL1.
	PWM_OOV_OOVL1 = 0x20000
	// Position of OOVL2 field.
	PWM_OOV_OOVL2_Pos = 0x12
	// Bit mask of OOVL2 field.
	PWM_OOV_OOVL2_Msk = 0x40000
	// Bit OOVL2.
	PWM_OOV_OOVL2 = 0x40000
	// Position of OOVL3 field.
	PWM_OOV_OOVL3_Pos = 0x13
	// Bit mask of OOVL3 field.
	PWM_OOV_OOVL3_Msk = 0x80000
	// Bit OOVL3.
	PWM_OOV_OOVL3 = 0x80000

	// OS: PWM Output Selection Register
	// Position of OSH0 field.
	PWM_OS_OSH0_Pos = 0x0
	// Bit mask of OSH0 field.
	PWM_OS_OSH0_Msk = 0x1
	// Bit OSH0.
	PWM_OS_OSH0 = 0x1
	// Position of OSH1 field.
	PWM_OS_OSH1_Pos = 0x1
	// Bit mask of OSH1 field.
	PWM_OS_OSH1_Msk = 0x2
	// Bit OSH1.
	PWM_OS_OSH1 = 0x2
	// Position of OSH2 field.
	PWM_OS_OSH2_Pos = 0x2
	// Bit mask of OSH2 field.
	PWM_OS_OSH2_Msk = 0x4
	// Bit OSH2.
	PWM_OS_OSH2 = 0x4
	// Position of OSH3 field.
	PWM_OS_OSH3_Pos = 0x3
	// Bit mask of OSH3 field.
	PWM_OS_OSH3_Msk = 0x8
	// Bit OSH3.
	PWM_OS_OSH3 = 0x8
	// Position of OSL0 field.
	PWM_OS_OSL0_Pos = 0x10
	// Bit mask of OSL0 field.
	PWM_OS_OSL0_Msk = 0x10000
	// Bit OSL0.
	PWM_OS_OSL0 = 0x10000
	// Position of OSL1 field.
	PWM_OS_OSL1_Pos = 0x11
	// Bit mask of OSL1 field.
	PWM_OS_OSL1_Msk = 0x20000
	// Bit OSL1.
	PWM_OS_OSL1 = 0x20000
	// Position of OSL2 field.
	PWM_OS_OSL2_Pos = 0x12
	// Bit mask of OSL2 field.
	PWM_OS_OSL2_Msk = 0x40000
	// Bit OSL2.
	PWM_OS_OSL2 = 0x40000
	// Position of OSL3 field.
	PWM_OS_OSL3_Pos = 0x13
	// Bit mask of OSL3 field.
	PWM_OS_OSL3_Msk = 0x80000
	// Bit OSL3.
	PWM_OS_OSL3 = 0x80000

	// OSS: PWM Output Selection Set Register
	// Position of OSSH0 field.
	PWM_OSS_OSSH0_Pos = 0x0
	// Bit mask of OSSH0 field.
	PWM_OSS_OSSH0_Msk = 0x1
	// Bit OSSH0.
	PWM_OSS_OSSH0 = 0x1
	// Position of OSSH1 field.
	PWM_OSS_OSSH1_Pos = 0x1
	// Bit mask of OSSH1 field.
	PWM_OSS_OSSH1_Msk = 0x2
	// Bit OSSH1.
	PWM_OSS_OSSH1 = 0x2
	// Position of OSSH2 field.
	PWM_OSS_OSSH2_Pos = 0x2
	// Bit mask of OSSH2 field.
	PWM_OSS_OSSH2_Msk = 0x4
	// Bit OSSH2.
	PWM_OSS_OSSH2 = 0x4
	// Position of OSSH3 field.
	PWM_OSS_OSSH3_Pos = 0x3
	// Bit mask of OSSH3 field.
	PWM_OSS_OSSH3_Msk = 0x8
	// Bit OSSH3.
	PWM_OSS_OSSH3 = 0x8
	// Position of OSSL0 field.
	PWM_OSS_OSSL0_Pos = 0x10
	// Bit mask of OSSL0 field.
	PWM_OSS_OSSL0_Msk = 0x10000
	// Bit OSSL0.
	PWM_OSS_OSSL0 = 0x10000
	// Position of OSSL1 field.
	PWM_OSS_OSSL1_Pos = 0x11
	// Bit mask of OSSL1 field.
	PWM_OSS_OSSL1_Msk = 0x20000
	// Bit OSSL1.
	PWM_OSS_OSSL1 = 0x20000
	// Position of OSSL2 field.
	PWM_OSS_OSSL2_Pos = 0x12
	// Bit mask of OSSL2 field.
	PWM_OSS_OSSL2_Msk = 0x40000
	// Bit OSSL2.
	PWM_OSS_OSSL2 = 0x40000
	// Position of OSSL3 field.
	PWM_OSS_OSSL3_Pos = 0x13
	// Bit mask of OSSL3 field.
	PWM_OSS_OSSL3_Msk = 0x80000
	// Bit OSSL3.
	PWM_OSS_OSSL3 = 0x80000

	// OSC: PWM Output Selection Clear Register
	// Position of OSCH0 field.
	PWM_OSC_OSCH0_Pos = 0x0
	// Bit mask of OSCH0 field.
	PWM_OSC_OSCH0_Msk = 0x1
	// Bit OSCH0.
	PWM_OSC_OSCH0 = 0x1
	// Position of OSCH1 field.
	PWM_OSC_OSCH1_Pos = 0x1
	// Bit mask of OSCH1 field.
	PWM_OSC_OSCH1_Msk = 0x2
	// Bit OSCH1.
	PWM_OSC_OSCH1 = 0x2
	// Position of OSCH2 field.
	PWM_OSC_OSCH2_Pos = 0x2
	// Bit mask of OSCH2 field.
	PWM_OSC_OSCH2_Msk = 0x4
	// Bit OSCH2.
	PWM_OSC_OSCH2 = 0x4
	// Position of OSCH3 field.
	PWM_OSC_OSCH3_Pos = 0x3
	// Bit mask of OSCH3 field.
	PWM_OSC_OSCH3_Msk = 0x8
	// Bit OSCH3.
	PWM_OSC_OSCH3 = 0x8
	// Position of OSCL0 field.
	PWM_OSC_OSCL0_Pos = 0x10
	// Bit mask of OSCL0 field.
	PWM_OSC_OSCL0_Msk = 0x10000
	// Bit OSCL0.
	PWM_OSC_OSCL0 = 0x10000
	// Position of OSCL1 field.
	PWM_OSC_OSCL1_Pos = 0x11
	// Bit mask of OSCL1 field.
	PWM_OSC_OSCL1_Msk = 0x20000
	// Bit OSCL1.
	PWM_OSC_OSCL1 = 0x20000
	// Position of OSCL2 field.
	PWM_OSC_OSCL2_Pos = 0x12
	// Bit mask of OSCL2 field.
	PWM_OSC_OSCL2_Msk = 0x40000
	// Bit OSCL2.
	PWM_OSC_OSCL2 = 0x40000
	// Position of OSCL3 field.
	PWM_OSC_OSCL3_Pos = 0x13
	// Bit mask of OSCL3 field.
	PWM_OSC_OSCL3_Msk = 0x80000
	// Bit OSCL3.
	PWM_OSC_OSCL3 = 0x80000

	// OSSUPD: PWM Output Selection Set Update Register
	// Position of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Pos = 0x0
	// Bit mask of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Msk = 0x1
	// Bit OSSUPH0.
	PWM_OSSUPD_OSSUPH0 = 0x1
	// Position of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Pos = 0x1
	// Bit mask of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Msk = 0x2
	// Bit OSSUPH1.
	PWM_OSSUPD_OSSUPH1 = 0x2
	// Position of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Pos = 0x2
	// Bit mask of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Msk = 0x4
	// Bit OSSUPH2.
	PWM_OSSUPD_OSSUPH2 = 0x4
	// Position of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Pos = 0x3
	// Bit mask of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Msk = 0x8
	// Bit OSSUPH3.
	PWM_OSSUPD_OSSUPH3 = 0x8
	// Position of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Pos = 0x10
	// Bit mask of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Msk = 0x10000
	// Bit OSSUPL0.
	PWM_OSSUPD_OSSUPL0 = 0x10000
	// Position of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Pos = 0x11
	// Bit mask of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Msk = 0x20000
	// Bit OSSUPL1.
	PWM_OSSUPD_OSSUPL1 = 0x20000
	// Position of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Pos = 0x12
	// Bit mask of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Msk = 0x40000
	// Bit OSSUPL2.
	PWM_OSSUPD_OSSUPL2 = 0x40000
	// Position of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Pos = 0x13
	// Bit mask of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Msk = 0x80000
	// Bit OSSUPL3.
	PWM_OSSUPD_OSSUPL3 = 0x80000

	// OSCUPD: PWM Output Selection Clear Update Register
	// Position of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Pos = 0x0
	// Bit mask of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Msk = 0x1
	// Bit OSCUPH0.
	PWM_OSCUPD_OSCUPH0 = 0x1
	// Position of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Pos = 0x1
	// Bit mask of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Msk = 0x2
	// Bit OSCUPH1.
	PWM_OSCUPD_OSCUPH1 = 0x2
	// Position of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Pos = 0x2
	// Bit mask of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Msk = 0x4
	// Bit OSCUPH2.
	PWM_OSCUPD_OSCUPH2 = 0x4
	// Position of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Pos = 0x3
	// Bit mask of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Msk = 0x8
	// Bit OSCUPH3.
	PWM_OSCUPD_OSCUPH3 = 0x8
	// Position of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Pos = 0x10
	// Bit mask of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Msk = 0x10000
	// Bit OSCUPL0.
	PWM_OSCUPD_OSCUPL0 = 0x10000
	// Position of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Pos = 0x11
	// Bit mask of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Msk = 0x20000
	// Bit OSCUPL1.
	PWM_OSCUPD_OSCUPL1 = 0x20000
	// Position of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Pos = 0x12
	// Bit mask of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Msk = 0x40000
	// Bit OSCUPL2.
	PWM_OSCUPD_OSCUPL2 = 0x40000
	// Position of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Pos = 0x13
	// Bit mask of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Msk = 0x80000
	// Bit OSCUPL3.
	PWM_OSCUPD_OSCUPL3 = 0x80000

	// FMR: PWM Fault Mode Register
	// Position of FPOL field.
	PWM_FMR_FPOL_Pos = 0x0
	// Bit mask of FPOL field.
	PWM_FMR_FPOL_Msk = 0xff
	// Position of FMOD field.
	PWM_FMR_FMOD_Pos = 0x8
	// Bit mask of FMOD field.
	PWM_FMR_FMOD_Msk = 0xff00
	// Position of FFIL field.
	PWM_FMR_FFIL_Pos = 0x10
	// Bit mask of FFIL field.
	PWM_FMR_FFIL_Msk = 0xff0000

	// FSR: PWM Fault Status Register
	// Position of FIV field.
	PWM_FSR_FIV_Pos = 0x0
	// Bit mask of FIV field.
	PWM_FSR_FIV_Msk = 0xff
	// Position of FS field.
	PWM_FSR_FS_Pos = 0x8
	// Bit mask of FS field.
	PWM_FSR_FS_Msk = 0xff00

	// FCR: PWM Fault Clear Register
	// Position of FCLR field.
	PWM_FCR_FCLR_Pos = 0x0
	// Bit mask of FCLR field.
	PWM_FCR_FCLR_Msk = 0xff

	// FPV1: PWM Fault Protection Value Register 1
	// Position of FPVH0 field.
	PWM_FPV1_FPVH0_Pos = 0x0
	// Bit mask of FPVH0 field.
	PWM_FPV1_FPVH0_Msk = 0x1
	// Bit FPVH0.
	PWM_FPV1_FPVH0 = 0x1
	// Position of FPVH1 field.
	PWM_FPV1_FPVH1_Pos = 0x1
	// Bit mask of FPVH1 field.
	PWM_FPV1_FPVH1_Msk = 0x2
	// Bit FPVH1.
	PWM_FPV1_FPVH1 = 0x2
	// Position of FPVH2 field.
	PWM_FPV1_FPVH2_Pos = 0x2
	// Bit mask of FPVH2 field.
	PWM_FPV1_FPVH2_Msk = 0x4
	// Bit FPVH2.
	PWM_FPV1_FPVH2 = 0x4
	// Position of FPVH3 field.
	PWM_FPV1_FPVH3_Pos = 0x3
	// Bit mask of FPVH3 field.
	PWM_FPV1_FPVH3_Msk = 0x8
	// Bit FPVH3.
	PWM_FPV1_FPVH3 = 0x8
	// Position of FPVL0 field.
	PWM_FPV1_FPVL0_Pos = 0x10
	// Bit mask of FPVL0 field.
	PWM_FPV1_FPVL0_Msk = 0x10000
	// Bit FPVL0.
	PWM_FPV1_FPVL0 = 0x10000
	// Position of FPVL1 field.
	PWM_FPV1_FPVL1_Pos = 0x11
	// Bit mask of FPVL1 field.
	PWM_FPV1_FPVL1_Msk = 0x20000
	// Bit FPVL1.
	PWM_FPV1_FPVL1 = 0x20000
	// Position of FPVL2 field.
	PWM_FPV1_FPVL2_Pos = 0x12
	// Bit mask of FPVL2 field.
	PWM_FPV1_FPVL2_Msk = 0x40000
	// Bit FPVL2.
	PWM_FPV1_FPVL2 = 0x40000
	// Position of FPVL3 field.
	PWM_FPV1_FPVL3_Pos = 0x13
	// Bit mask of FPVL3 field.
	PWM_FPV1_FPVL3_Msk = 0x80000
	// Bit FPVL3.
	PWM_FPV1_FPVL3 = 0x80000

	// FPE: PWM Fault Protection Enable Register
	// Position of FPE0 field.
	PWM_FPE_FPE0_Pos = 0x0
	// Bit mask of FPE0 field.
	PWM_FPE_FPE0_Msk = 0xff
	// Position of FPE1 field.
	PWM_FPE_FPE1_Pos = 0x8
	// Bit mask of FPE1 field.
	PWM_FPE_FPE1_Msk = 0xff00
	// Position of FPE2 field.
	PWM_FPE_FPE2_Pos = 0x10
	// Bit mask of FPE2 field.
	PWM_FPE_FPE2_Msk = 0xff0000
	// Position of FPE3 field.
	PWM_FPE_FPE3_Pos = 0x18
	// Bit mask of FPE3 field.
	PWM_FPE_FPE3_Msk = 0xff000000

	// ELMR: PWM Event Line 0 Mode Register 0
	// Position of CSEL0 field.
	PWM_ELMR_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	PWM_ELMR_CSEL0_Msk = 0x1
	// Bit CSEL0.
	PWM_ELMR_CSEL0 = 0x1
	// Position of CSEL1 field.
	PWM_ELMR_CSEL1_Pos = 0x1
	// Bit mask of CSEL1 field.
	PWM_ELMR_CSEL1_Msk = 0x2
	// Bit CSEL1.
	PWM_ELMR_CSEL1 = 0x2
	// Position of CSEL2 field.
	PWM_ELMR_CSEL2_Pos = 0x2
	// Bit mask of CSEL2 field.
	PWM_ELMR_CSEL2_Msk = 0x4
	// Bit CSEL2.
	PWM_ELMR_CSEL2 = 0x4
	// Position of CSEL3 field.
	PWM_ELMR_CSEL3_Pos = 0x3
	// Bit mask of CSEL3 field.
	PWM_ELMR_CSEL3_Msk = 0x8
	// Bit CSEL3.
	PWM_ELMR_CSEL3 = 0x8
	// Position of CSEL4 field.
	PWM_ELMR_CSEL4_Pos = 0x4
	// Bit mask of CSEL4 field.
	PWM_ELMR_CSEL4_Msk = 0x10
	// Bit CSEL4.
	PWM_ELMR_CSEL4 = 0x10
	// Position of CSEL5 field.
	PWM_ELMR_CSEL5_Pos = 0x5
	// Bit mask of CSEL5 field.
	PWM_ELMR_CSEL5_Msk = 0x20
	// Bit CSEL5.
	PWM_ELMR_CSEL5 = 0x20
	// Position of CSEL6 field.
	PWM_ELMR_CSEL6_Pos = 0x6
	// Bit mask of CSEL6 field.
	PWM_ELMR_CSEL6_Msk = 0x40
	// Bit CSEL6.
	PWM_ELMR_CSEL6 = 0x40
	// Position of CSEL7 field.
	PWM_ELMR_CSEL7_Pos = 0x7
	// Bit mask of CSEL7 field.
	PWM_ELMR_CSEL7_Msk = 0x80
	// Bit CSEL7.
	PWM_ELMR_CSEL7 = 0x80

	// SSPR: PWM Spread Spectrum Register
	// Position of SPRD field.
	PWM_SSPR_SPRD_Pos = 0x0
	// Bit mask of SPRD field.
	PWM_SSPR_SPRD_Msk = 0xffffff
	// Position of SPRDM field.
	PWM_SSPR_SPRDM_Pos = 0x18
	// Bit mask of SPRDM field.
	PWM_SSPR_SPRDM_Msk = 0x1000000
	// Bit SPRDM.
	PWM_SSPR_SPRDM = 0x1000000

	// SSPUP: PWM Spread Spectrum Update Register
	// Position of SPRDUP field.
	PWM_SSPUP_SPRDUP_Pos = 0x0
	// Bit mask of SPRDUP field.
	PWM_SSPUP_SPRDUP_Msk = 0xffffff

	// SMMR: PWM Stepper Motor Mode Register
	// Position of GCEN0 field.
	PWM_SMMR_GCEN0_Pos = 0x0
	// Bit mask of GCEN0 field.
	PWM_SMMR_GCEN0_Msk = 0x1
	// Bit GCEN0.
	PWM_SMMR_GCEN0 = 0x1
	// Position of GCEN1 field.
	PWM_SMMR_GCEN1_Pos = 0x1
	// Bit mask of GCEN1 field.
	PWM_SMMR_GCEN1_Msk = 0x2
	// Bit GCEN1.
	PWM_SMMR_GCEN1 = 0x2
	// Position of DOWN0 field.
	PWM_SMMR_DOWN0_Pos = 0x10
	// Bit mask of DOWN0 field.
	PWM_SMMR_DOWN0_Msk = 0x10000
	// Bit DOWN0.
	PWM_SMMR_DOWN0 = 0x10000
	// Position of DOWN1 field.
	PWM_SMMR_DOWN1_Pos = 0x11
	// Bit mask of DOWN1 field.
	PWM_SMMR_DOWN1_Msk = 0x20000
	// Bit DOWN1.
	PWM_SMMR_DOWN1 = 0x20000

	// FPV2: PWM Fault Protection Value 2 Register
	// Position of FPZH0 field.
	PWM_FPV2_FPZH0_Pos = 0x0
	// Bit mask of FPZH0 field.
	PWM_FPV2_FPZH0_Msk = 0x1
	// Bit FPZH0.
	PWM_FPV2_FPZH0 = 0x1
	// Position of FPZH1 field.
	PWM_FPV2_FPZH1_Pos = 0x1
	// Bit mask of FPZH1 field.
	PWM_FPV2_FPZH1_Msk = 0x2
	// Bit FPZH1.
	PWM_FPV2_FPZH1 = 0x2
	// Position of FPZH2 field.
	PWM_FPV2_FPZH2_Pos = 0x2
	// Bit mask of FPZH2 field.
	PWM_FPV2_FPZH2_Msk = 0x4
	// Bit FPZH2.
	PWM_FPV2_FPZH2 = 0x4
	// Position of FPZH3 field.
	PWM_FPV2_FPZH3_Pos = 0x3
	// Bit mask of FPZH3 field.
	PWM_FPV2_FPZH3_Msk = 0x8
	// Bit FPZH3.
	PWM_FPV2_FPZH3 = 0x8
	// Position of FPZL0 field.
	PWM_FPV2_FPZL0_Pos = 0x10
	// Bit mask of FPZL0 field.
	PWM_FPV2_FPZL0_Msk = 0x10000
	// Bit FPZL0.
	PWM_FPV2_FPZL0 = 0x10000
	// Position of FPZL1 field.
	PWM_FPV2_FPZL1_Pos = 0x11
	// Bit mask of FPZL1 field.
	PWM_FPV2_FPZL1_Msk = 0x20000
	// Bit FPZL1.
	PWM_FPV2_FPZL1 = 0x20000
	// Position of FPZL2 field.
	PWM_FPV2_FPZL2_Pos = 0x12
	// Bit mask of FPZL2 field.
	PWM_FPV2_FPZL2_Msk = 0x40000
	// Bit FPZL2.
	PWM_FPV2_FPZL2 = 0x40000
	// Position of FPZL3 field.
	PWM_FPV2_FPZL3_Pos = 0x13
	// Bit mask of FPZL3 field.
	PWM_FPV2_FPZL3_Msk = 0x80000
	// Bit FPZL3.
	PWM_FPV2_FPZL3 = 0x80000

	// WPCR: PWM Write Protection Control Register
	// Position of WPCMD field.
	PWM_WPCR_WPCMD_Pos = 0x0
	// Bit mask of WPCMD field.
	PWM_WPCR_WPCMD_Msk = 0x3
	// Disables the software write protection of the register groups of which the bit WPRGx is at '1'.
	PWM_WPCR_WPCMD_DISABLE_SW_PROT = 0x0
	// Enables the software write protection of the register groups of which the bit WPRGx is at '1'.
	PWM_WPCR_WPCMD_ENABLE_SW_PROT = 0x1
	// Enables the hardware write protection of the register groups of which the bit WPRGx is at '1'. Only a hardware reset of the PWM controller can disable the hardware write protection. Moreover, to meet security requirements, the PIO lines associated with the PWM can not be configured through the PIO interface.
	PWM_WPCR_WPCMD_ENABLE_HW_PROT = 0x2
	// Position of WPRG0 field.
	PWM_WPCR_WPRG0_Pos = 0x2
	// Bit mask of WPRG0 field.
	PWM_WPCR_WPRG0_Msk = 0x4
	// Bit WPRG0.
	PWM_WPCR_WPRG0 = 0x4
	// Position of WPRG1 field.
	PWM_WPCR_WPRG1_Pos = 0x3
	// Bit mask of WPRG1 field.
	PWM_WPCR_WPRG1_Msk = 0x8
	// Bit WPRG1.
	PWM_WPCR_WPRG1 = 0x8
	// Position of WPRG2 field.
	PWM_WPCR_WPRG2_Pos = 0x4
	// Bit mask of WPRG2 field.
	PWM_WPCR_WPRG2_Msk = 0x10
	// Bit WPRG2.
	PWM_WPCR_WPRG2 = 0x10
	// Position of WPRG3 field.
	PWM_WPCR_WPRG3_Pos = 0x5
	// Bit mask of WPRG3 field.
	PWM_WPCR_WPRG3_Msk = 0x20
	// Bit WPRG3.
	PWM_WPCR_WPRG3 = 0x20
	// Position of WPRG4 field.
	PWM_WPCR_WPRG4_Pos = 0x6
	// Bit mask of WPRG4 field.
	PWM_WPCR_WPRG4_Msk = 0x40
	// Bit WPRG4.
	PWM_WPCR_WPRG4 = 0x40
	// Position of WPRG5 field.
	PWM_WPCR_WPRG5_Pos = 0x7
	// Bit mask of WPRG5 field.
	PWM_WPCR_WPRG5_Msk = 0x80
	// Bit WPRG5.
	PWM_WPCR_WPRG5 = 0x80
	// Position of WPKEY field.
	PWM_WPCR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PWM_WPCR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPCMD field.Always reads as 0
	PWM_WPCR_WPKEY_PASSWD = 0x50574d

	// WPSR: PWM Write Protection Status Register
	// Position of WPSWS0 field.
	PWM_WPSR_WPSWS0_Pos = 0x0
	// Bit mask of WPSWS0 field.
	PWM_WPSR_WPSWS0_Msk = 0x1
	// Bit WPSWS0.
	PWM_WPSR_WPSWS0 = 0x1
	// Position of WPSWS1 field.
	PWM_WPSR_WPSWS1_Pos = 0x1
	// Bit mask of WPSWS1 field.
	PWM_WPSR_WPSWS1_Msk = 0x2
	// Bit WPSWS1.
	PWM_WPSR_WPSWS1 = 0x2
	// Position of WPSWS2 field.
	PWM_WPSR_WPSWS2_Pos = 0x2
	// Bit mask of WPSWS2 field.
	PWM_WPSR_WPSWS2_Msk = 0x4
	// Bit WPSWS2.
	PWM_WPSR_WPSWS2 = 0x4
	// Position of WPSWS3 field.
	PWM_WPSR_WPSWS3_Pos = 0x3
	// Bit mask of WPSWS3 field.
	PWM_WPSR_WPSWS3_Msk = 0x8
	// Bit WPSWS3.
	PWM_WPSR_WPSWS3 = 0x8
	// Position of WPSWS4 field.
	PWM_WPSR_WPSWS4_Pos = 0x4
	// Bit mask of WPSWS4 field.
	PWM_WPSR_WPSWS4_Msk = 0x10
	// Bit WPSWS4.
	PWM_WPSR_WPSWS4 = 0x10
	// Position of WPSWS5 field.
	PWM_WPSR_WPSWS5_Pos = 0x5
	// Bit mask of WPSWS5 field.
	PWM_WPSR_WPSWS5_Msk = 0x20
	// Bit WPSWS5.
	PWM_WPSR_WPSWS5 = 0x20
	// Position of WPVS field.
	PWM_WPSR_WPVS_Pos = 0x7
	// Bit mask of WPVS field.
	PWM_WPSR_WPVS_Msk = 0x80
	// Bit WPVS.
	PWM_WPSR_WPVS = 0x80
	// Position of WPHWS0 field.
	PWM_WPSR_WPHWS0_Pos = 0x8
	// Bit mask of WPHWS0 field.
	PWM_WPSR_WPHWS0_Msk = 0x100
	// Bit WPHWS0.
	PWM_WPSR_WPHWS0 = 0x100
	// Position of WPHWS1 field.
	PWM_WPSR_WPHWS1_Pos = 0x9
	// Bit mask of WPHWS1 field.
	PWM_WPSR_WPHWS1_Msk = 0x200
	// Bit WPHWS1.
	PWM_WPSR_WPHWS1 = 0x200
	// Position of WPHWS2 field.
	PWM_WPSR_WPHWS2_Pos = 0xa
	// Bit mask of WPHWS2 field.
	PWM_WPSR_WPHWS2_Msk = 0x400
	// Bit WPHWS2.
	PWM_WPSR_WPHWS2 = 0x400
	// Position of WPHWS3 field.
	PWM_WPSR_WPHWS3_Pos = 0xb
	// Bit mask of WPHWS3 field.
	PWM_WPSR_WPHWS3_Msk = 0x800
	// Bit WPHWS3.
	PWM_WPSR_WPHWS3 = 0x800
	// Position of WPHWS4 field.
	PWM_WPSR_WPHWS4_Pos = 0xc
	// Bit mask of WPHWS4 field.
	PWM_WPSR_WPHWS4_Msk = 0x1000
	// Bit WPHWS4.
	PWM_WPSR_WPHWS4 = 0x1000
	// Position of WPHWS5 field.
	PWM_WPSR_WPHWS5_Pos = 0xd
	// Bit mask of WPHWS5 field.
	PWM_WPSR_WPHWS5_Msk = 0x2000
	// Bit WPHWS5.
	PWM_WPSR_WPHWS5 = 0x2000
	// Position of WPVSRC field.
	PWM_WPSR_WPVSRC_Pos = 0x10
	// Bit mask of WPVSRC field.
	PWM_WPSR_WPVSRC_Msk = 0xffff0000

	// PWM_CMP.CMPV: PWM Comparison 0 Value Register
	// Position of CV field.
	PWM_PWM_CMP_CMPV_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_PWM_CMP_CMPV_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_PWM_CMP_CMPV_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_PWM_CMP_CMPV_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_PWM_CMP_CMPV_CVM = 0x1000000

	// PWM_CMP.CMPVUPD: PWM Comparison 0 Value Update Register
	// Position of CVUPD field.
	PWM_PWM_CMP_CMPVUPD_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_PWM_CMP_CMPVUPD_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_PWM_CMP_CMPVUPD_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_PWM_CMP_CMPVUPD_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_PWM_CMP_CMPVUPD_CVMUPD = 0x1000000

	// PWM_CMP.CMPM: PWM Comparison 0 Mode Register
	// Position of CEN field.
	PWM_PWM_CMP_CMPM_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_PWM_CMP_CMPM_CEN_Msk = 0x1
	// Bit CEN.
	PWM_PWM_CMP_CMPM_CEN = 0x1
	// Position of CTR field.
	PWM_PWM_CMP_CMPM_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_PWM_CMP_CMPM_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_PWM_CMP_CMPM_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_PWM_CMP_CMPM_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_PWM_CMP_CMPM_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_PWM_CMP_CMPM_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_PWM_CMP_CMPM_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_PWM_CMP_CMPM_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_PWM_CMP_CMPM_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_PWM_CMP_CMPM_CUPRCNT_Msk = 0xf00000

	// PWM_CMP.CMPMUPD: PWM Comparison 0 Mode Update Register
	// Position of CENUPD field.
	PWM_PWM_CMP_CMPMUPD_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_PWM_CMP_CMPMUPD_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_PWM_CMP_CMPMUPD_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_PWM_CMP_CMPMUPD_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_PWM_CMP_CMPMUPD_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_PWM_CMP_CMPMUPD_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_PWM_CMP_CMPMUPD_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_PWM_CMP_CMPMUPD_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_PWM_CMP_CMPMUPD_CUPRUPD_Msk = 0xf0000

	// PWM_CH_NUM.CMR: PWM Channel Mode Register (ch_num = 0)
	// Position of CPRE field.
	PWM_PWM_CH_NUM_CMR_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_PWM_CH_NUM_CMR_CPRE_Msk = 0xf
	// Peripheral clock
	PWM_PWM_CH_NUM_CMR_CPRE_MCK = 0x0
	// Peripheral clock/2
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_2 = 0x1
	// Peripheral clock/4
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_4 = 0x2
	// Peripheral clock/8
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_8 = 0x3
	// Peripheral clock/16
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_16 = 0x4
	// Peripheral clock/32
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_32 = 0x5
	// Peripheral clock/64
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_64 = 0x6
	// Peripheral clock/128
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_128 = 0x7
	// Peripheral clock/256
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_256 = 0x8
	// Peripheral clock/512
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_512 = 0x9
	// Peripheral clock/1024
	PWM_PWM_CH_NUM_CMR_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_PWM_CH_NUM_CMR_CPRE_CLKA = 0xb
	// Clock B
	PWM_PWM_CH_NUM_CMR_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_PWM_CH_NUM_CMR_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_PWM_CH_NUM_CMR_CALG_Msk = 0x100
	// Bit CALG.
	PWM_PWM_CH_NUM_CMR_CALG = 0x100
	// Position of CPOL field.
	PWM_PWM_CH_NUM_CMR_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_PWM_CH_NUM_CMR_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_PWM_CH_NUM_CMR_CPOL = 0x200
	// Position of CES field.
	PWM_PWM_CH_NUM_CMR_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_PWM_CH_NUM_CMR_CES_Msk = 0x400
	// Bit CES.
	PWM_PWM_CH_NUM_CMR_CES = 0x400
	// Position of UPDS field.
	PWM_PWM_CH_NUM_CMR_UPDS_Pos = 0xb
	// Bit mask of UPDS field.
	PWM_PWM_CH_NUM_CMR_UPDS_Msk = 0x800
	// Bit UPDS.
	PWM_PWM_CH_NUM_CMR_UPDS = 0x800
	// Position of DPOLI field.
	PWM_PWM_CH_NUM_CMR_DPOLI_Pos = 0xc
	// Bit mask of DPOLI field.
	PWM_PWM_CH_NUM_CMR_DPOLI_Msk = 0x1000
	// Bit DPOLI.
	PWM_PWM_CH_NUM_CMR_DPOLI = 0x1000
	// Position of TCTS field.
	PWM_PWM_CH_NUM_CMR_TCTS_Pos = 0xd
	// Bit mask of TCTS field.
	PWM_PWM_CH_NUM_CMR_TCTS_Msk = 0x2000
	// Bit TCTS.
	PWM_PWM_CH_NUM_CMR_TCTS = 0x2000
	// Position of DTE field.
	PWM_PWM_CH_NUM_CMR_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_PWM_CH_NUM_CMR_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_PWM_CH_NUM_CMR_DTE = 0x10000
	// Position of DTHI field.
	PWM_PWM_CH_NUM_CMR_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_PWM_CH_NUM_CMR_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_PWM_CH_NUM_CMR_DTHI = 0x20000
	// Position of DTLI field.
	PWM_PWM_CH_NUM_CMR_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_PWM_CH_NUM_CMR_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_PWM_CH_NUM_CMR_DTLI = 0x40000
	// Position of PPM field.
	PWM_PWM_CH_NUM_CMR_PPM_Pos = 0x13
	// Bit mask of PPM field.
	PWM_PWM_CH_NUM_CMR_PPM_Msk = 0x80000
	// Bit PPM.
	PWM_PWM_CH_NUM_CMR_PPM = 0x80000

	// PWM_CH_NUM.CDTY: PWM Channel Duty Cycle Register (ch_num = 0)
	// Position of CDTY field.
	PWM_PWM_CH_NUM_CDTY_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_PWM_CH_NUM_CDTY_CDTY_Msk = 0xffffff

	// PWM_CH_NUM.CDTYUPD: PWM Channel Duty Cycle Update Register (ch_num = 0)
	// Position of CDTYUPD field.
	PWM_PWM_CH_NUM_CDTYUPD_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_PWM_CH_NUM_CDTYUPD_CDTYUPD_Msk = 0xffffff

	// PWM_CH_NUM.CPRD: PWM Channel Period Register (ch_num = 0)
	// Position of CPRD field.
	PWM_PWM_CH_NUM_CPRD_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_PWM_CH_NUM_CPRD_CPRD_Msk = 0xffffff

	// PWM_CH_NUM.CPRDUPD: PWM Channel Period Update Register (ch_num = 0)
	// Position of CPRDUPD field.
	PWM_PWM_CH_NUM_CPRDUPD_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_PWM_CH_NUM_CPRDUPD_CPRDUPD_Msk = 0xffffff

	// PWM_CH_NUM.CCNT: PWM Channel Counter Register (ch_num = 0)
	// Position of CNT field.
	PWM_PWM_CH_NUM_CCNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_PWM_CH_NUM_CCNT_CNT_Msk = 0xffffff

	// PWM_CH_NUM.DT: PWM Channel Dead Time Register (ch_num = 0)
	// Position of DTH field.
	PWM_PWM_CH_NUM_DT_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_PWM_CH_NUM_DT_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_PWM_CH_NUM_DT_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_PWM_CH_NUM_DT_DTL_Msk = 0xffff0000

	// PWM_CH_NUM.DTUPD: PWM Channel Dead Time Update Register (ch_num = 0)
	// Position of DTHUPD field.
	PWM_PWM_CH_NUM_DTUPD_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_PWM_CH_NUM_DTUPD_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_PWM_CH_NUM_DTUPD_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_PWM_CH_NUM_DTUPD_DTLUPD_Msk = 0xffff0000

	// CMUPD0: PWM Channel Mode Update Register (ch_num = 0)
	// Position of CPOLUP field.
	PWM_CMUPD0_CPOLUP_Pos = 0x9
	// Bit mask of CPOLUP field.
	PWM_CMUPD0_CPOLUP_Msk = 0x200
	// Bit CPOLUP.
	PWM_CMUPD0_CPOLUP = 0x200
	// Position of CPOLINVUP field.
	PWM_CMUPD0_CPOLINVUP_Pos = 0xd
	// Bit mask of CPOLINVUP field.
	PWM_CMUPD0_CPOLINVUP_Msk = 0x2000
	// Bit CPOLINVUP.
	PWM_CMUPD0_CPOLINVUP = 0x2000

	// CMUPD1: PWM Channel Mode Update Register (ch_num = 1)
	// Position of CPOLUP field.
	PWM_CMUPD1_CPOLUP_Pos = 0x9
	// Bit mask of CPOLUP field.
	PWM_CMUPD1_CPOLUP_Msk = 0x200
	// Bit CPOLUP.
	PWM_CMUPD1_CPOLUP = 0x200
	// Position of CPOLINVUP field.
	PWM_CMUPD1_CPOLINVUP_Pos = 0xd
	// Bit mask of CPOLINVUP field.
	PWM_CMUPD1_CPOLINVUP_Msk = 0x2000
	// Bit CPOLINVUP.
	PWM_CMUPD1_CPOLINVUP = 0x2000

	// ETRG1: PWM External Trigger Register (trg_num = 1)
	// Position of MAXCNT field.
	PWM_ETRG1_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	PWM_ETRG1_MAXCNT_Msk = 0xffffff
	// Position of TRGMODE field.
	PWM_ETRG1_TRGMODE_Pos = 0x18
	// Bit mask of TRGMODE field.
	PWM_ETRG1_TRGMODE_Msk = 0x3000000
	// External trigger is not enabled.
	PWM_ETRG1_TRGMODE_OFF = 0x0
	// External PWM Reset Mode
	PWM_ETRG1_TRGMODE_MODE1 = 0x1
	// External PWM Start Mode
	PWM_ETRG1_TRGMODE_MODE2 = 0x2
	// Cycle-by-cycle Duty Mode
	PWM_ETRG1_TRGMODE_MODE3 = 0x3
	// Position of TRGEDGE field.
	PWM_ETRG1_TRGEDGE_Pos = 0x1c
	// Bit mask of TRGEDGE field.
	PWM_ETRG1_TRGEDGE_Msk = 0x10000000
	// Bit TRGEDGE.
	PWM_ETRG1_TRGEDGE = 0x10000000
	// TRGMODE = 1: TRGINx event detection on falling edge.TRGMODE = 2, 3: TRGINx active level is 0
	PWM_ETRG1_TRGEDGE_FALLING_ZERO = 0x0
	// TRGMODE = 1: TRGINx event detection on rising edge.TRGMODE = 2, 3: TRGINx active level is 1
	PWM_ETRG1_TRGEDGE_RISING_ONE = 0x1
	// Position of TRGFILT field.
	PWM_ETRG1_TRGFILT_Pos = 0x1d
	// Bit mask of TRGFILT field.
	PWM_ETRG1_TRGFILT_Msk = 0x20000000
	// Bit TRGFILT.
	PWM_ETRG1_TRGFILT = 0x20000000
	// Position of TRGSRC field.
	PWM_ETRG1_TRGSRC_Pos = 0x1e
	// Bit mask of TRGSRC field.
	PWM_ETRG1_TRGSRC_Msk = 0x40000000
	// Bit TRGSRC.
	PWM_ETRG1_TRGSRC = 0x40000000
	// Position of RFEN field.
	PWM_ETRG1_RFEN_Pos = 0x1f
	// Bit mask of RFEN field.
	PWM_ETRG1_RFEN_Msk = 0x80000000
	// Bit RFEN.
	PWM_ETRG1_RFEN = 0x80000000

	// LEBR1: PWM Leading-Edge Blanking Register (trg_num = 1)
	// Position of LEBDELAY field.
	PWM_LEBR1_LEBDELAY_Pos = 0x0
	// Bit mask of LEBDELAY field.
	PWM_LEBR1_LEBDELAY_Msk = 0x7f
	// Position of PWMLFEN field.
	PWM_LEBR1_PWMLFEN_Pos = 0x10
	// Bit mask of PWMLFEN field.
	PWM_LEBR1_PWMLFEN_Msk = 0x10000
	// Bit PWMLFEN.
	PWM_LEBR1_PWMLFEN = 0x10000
	// Position of PWMLREN field.
	PWM_LEBR1_PWMLREN_Pos = 0x11
	// Bit mask of PWMLREN field.
	PWM_LEBR1_PWMLREN_Msk = 0x20000
	// Bit PWMLREN.
	PWM_LEBR1_PWMLREN = 0x20000
	// Position of PWMHFEN field.
	PWM_LEBR1_PWMHFEN_Pos = 0x12
	// Bit mask of PWMHFEN field.
	PWM_LEBR1_PWMHFEN_Msk = 0x40000
	// Bit PWMHFEN.
	PWM_LEBR1_PWMHFEN = 0x40000
	// Position of PWMHREN field.
	PWM_LEBR1_PWMHREN_Pos = 0x13
	// Bit mask of PWMHREN field.
	PWM_LEBR1_PWMHREN_Msk = 0x80000
	// Bit PWMHREN.
	PWM_LEBR1_PWMHREN = 0x80000

	// CMUPD2: PWM Channel Mode Update Register (ch_num = 2)
	// Position of CPOLUP field.
	PWM_CMUPD2_CPOLUP_Pos = 0x9
	// Bit mask of CPOLUP field.
	PWM_CMUPD2_CPOLUP_Msk = 0x200
	// Bit CPOLUP.
	PWM_CMUPD2_CPOLUP = 0x200
	// Position of CPOLINVUP field.
	PWM_CMUPD2_CPOLINVUP_Pos = 0xd
	// Bit mask of CPOLINVUP field.
	PWM_CMUPD2_CPOLINVUP_Msk = 0x2000
	// Bit CPOLINVUP.
	PWM_CMUPD2_CPOLINVUP = 0x2000

	// ETRG2: PWM External Trigger Register (trg_num = 2)
	// Position of MAXCNT field.
	PWM_ETRG2_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	PWM_ETRG2_MAXCNT_Msk = 0xffffff
	// Position of TRGMODE field.
	PWM_ETRG2_TRGMODE_Pos = 0x18
	// Bit mask of TRGMODE field.
	PWM_ETRG2_TRGMODE_Msk = 0x3000000
	// External trigger is not enabled.
	PWM_ETRG2_TRGMODE_OFF = 0x0
	// External PWM Reset Mode
	PWM_ETRG2_TRGMODE_MODE1 = 0x1
	// External PWM Start Mode
	PWM_ETRG2_TRGMODE_MODE2 = 0x2
	// Cycle-by-cycle Duty Mode
	PWM_ETRG2_TRGMODE_MODE3 = 0x3
	// Position of TRGEDGE field.
	PWM_ETRG2_TRGEDGE_Pos = 0x1c
	// Bit mask of TRGEDGE field.
	PWM_ETRG2_TRGEDGE_Msk = 0x10000000
	// Bit TRGEDGE.
	PWM_ETRG2_TRGEDGE = 0x10000000
	// TRGMODE = 1: TRGINx event detection on falling edge.TRGMODE = 2, 3: TRGINx active level is 0
	PWM_ETRG2_TRGEDGE_FALLING_ZERO = 0x0
	// TRGMODE = 1: TRGINx event detection on rising edge.TRGMODE = 2, 3: TRGINx active level is 1
	PWM_ETRG2_TRGEDGE_RISING_ONE = 0x1
	// Position of TRGFILT field.
	PWM_ETRG2_TRGFILT_Pos = 0x1d
	// Bit mask of TRGFILT field.
	PWM_ETRG2_TRGFILT_Msk = 0x20000000
	// Bit TRGFILT.
	PWM_ETRG2_TRGFILT = 0x20000000
	// Position of TRGSRC field.
	PWM_ETRG2_TRGSRC_Pos = 0x1e
	// Bit mask of TRGSRC field.
	PWM_ETRG2_TRGSRC_Msk = 0x40000000
	// Bit TRGSRC.
	PWM_ETRG2_TRGSRC = 0x40000000
	// Position of RFEN field.
	PWM_ETRG2_RFEN_Pos = 0x1f
	// Bit mask of RFEN field.
	PWM_ETRG2_RFEN_Msk = 0x80000000
	// Bit RFEN.
	PWM_ETRG2_RFEN = 0x80000000

	// LEBR2: PWM Leading-Edge Blanking Register (trg_num = 2)
	// Position of LEBDELAY field.
	PWM_LEBR2_LEBDELAY_Pos = 0x0
	// Bit mask of LEBDELAY field.
	PWM_LEBR2_LEBDELAY_Msk = 0x7f
	// Position of PWMLFEN field.
	PWM_LEBR2_PWMLFEN_Pos = 0x10
	// Bit mask of PWMLFEN field.
	PWM_LEBR2_PWMLFEN_Msk = 0x10000
	// Bit PWMLFEN.
	PWM_LEBR2_PWMLFEN = 0x10000
	// Position of PWMLREN field.
	PWM_LEBR2_PWMLREN_Pos = 0x11
	// Bit mask of PWMLREN field.
	PWM_LEBR2_PWMLREN_Msk = 0x20000
	// Bit PWMLREN.
	PWM_LEBR2_PWMLREN = 0x20000
	// Position of PWMHFEN field.
	PWM_LEBR2_PWMHFEN_Pos = 0x12
	// Bit mask of PWMHFEN field.
	PWM_LEBR2_PWMHFEN_Msk = 0x40000
	// Bit PWMHFEN.
	PWM_LEBR2_PWMHFEN = 0x40000
	// Position of PWMHREN field.
	PWM_LEBR2_PWMHREN_Pos = 0x13
	// Bit mask of PWMHREN field.
	PWM_LEBR2_PWMHREN_Msk = 0x80000
	// Bit PWMHREN.
	PWM_LEBR2_PWMHREN = 0x80000

	// CMUPD3: PWM Channel Mode Update Register (ch_num = 3)
	// Position of CPOLUP field.
	PWM_CMUPD3_CPOLUP_Pos = 0x9
	// Bit mask of CPOLUP field.
	PWM_CMUPD3_CPOLUP_Msk = 0x200
	// Bit CPOLUP.
	PWM_CMUPD3_CPOLUP = 0x200
	// Position of CPOLINVUP field.
	PWM_CMUPD3_CPOLINVUP_Pos = 0xd
	// Bit mask of CPOLINVUP field.
	PWM_CMUPD3_CPOLINVUP_Msk = 0x2000
	// Bit CPOLINVUP.
	PWM_CMUPD3_CPOLINVUP = 0x2000
)

// Constants for QSPI: Quad Serial Peripheral Interface
const (
	// CR: Control Register
	// Position of QSPIEN field.
	QSPI_CR_QSPIEN_Pos = 0x0
	// Bit mask of QSPIEN field.
	QSPI_CR_QSPIEN_Msk = 0x1
	// Bit QSPIEN.
	QSPI_CR_QSPIEN = 0x1
	// Position of QSPIDIS field.
	QSPI_CR_QSPIDIS_Pos = 0x1
	// Bit mask of QSPIDIS field.
	QSPI_CR_QSPIDIS_Msk = 0x2
	// Bit QSPIDIS.
	QSPI_CR_QSPIDIS = 0x2
	// Position of SWRST field.
	QSPI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	QSPI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	QSPI_CR_SWRST = 0x80
	// Position of LASTXFER field.
	QSPI_CR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	QSPI_CR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	QSPI_CR_LASTXFER = 0x1000000

	// MR: Mode Register
	// Position of SMM field.
	QSPI_MR_SMM_Pos = 0x0
	// Bit mask of SMM field.
	QSPI_MR_SMM_Msk = 0x1
	// Bit SMM.
	QSPI_MR_SMM = 0x1
	// The QSPI is in SPI mode.
	QSPI_MR_SMM_SPI = 0x0
	// The QSPI is in Serial Memory mode.
	QSPI_MR_SMM_MEMORY = 0x1
	// Position of LLB field.
	QSPI_MR_LLB_Pos = 0x1
	// Bit mask of LLB field.
	QSPI_MR_LLB_Msk = 0x2
	// Bit LLB.
	QSPI_MR_LLB = 0x2
	// Local loopback path disabled.
	QSPI_MR_LLB_DISABLED = 0x0
	// Local loopback path enabled.
	QSPI_MR_LLB_ENABLED = 0x1
	// Position of WDRBT field.
	QSPI_MR_WDRBT_Pos = 0x2
	// Bit mask of WDRBT field.
	QSPI_MR_WDRBT_Msk = 0x4
	// Bit WDRBT.
	QSPI_MR_WDRBT = 0x4
	// No effect. In SPI mode, a transfer can be initiated whatever the state of the QSPI_RDR is.
	QSPI_MR_WDRBT_DISABLED = 0x0
	// In SPI mode, a transfer can start only if the QSPI_RDR is empty, i.e., does not contain any unread data. This mode prevents overrun error in reception.
	QSPI_MR_WDRBT_ENABLED = 0x1
	// Position of CSMODE field.
	QSPI_MR_CSMODE_Pos = 0x4
	// Bit mask of CSMODE field.
	QSPI_MR_CSMODE_Msk = 0x30
	// The chip select is deasserted if QSPI_TDR.TD has not been reloaded before the end of the current transfer.
	QSPI_MR_CSMODE_NOT_RELOADED = 0x0
	// The chip select is deasserted when the bit LASTXFER is written at 1 and the character written in QSPI_TDR.TD has been transferred.
	QSPI_MR_CSMODE_LASTXFER = 0x1
	// The chip select is deasserted systematically after each transfer.
	QSPI_MR_CSMODE_SYSTEMATICALLY = 0x2
	// Position of NBBITS field.
	QSPI_MR_NBBITS_Pos = 0x8
	// Bit mask of NBBITS field.
	QSPI_MR_NBBITS_Msk = 0xf00
	// 8 bits for transfer
	QSPI_MR_NBBITS__8_BIT = 0x0
	// 16 bits for transfer
	QSPI_MR_NBBITS__16_BIT = 0x8
	// Position of DLYBCT field.
	QSPI_MR_DLYBCT_Pos = 0x10
	// Bit mask of DLYBCT field.
	QSPI_MR_DLYBCT_Msk = 0xff0000
	// Position of DLYCS field.
	QSPI_MR_DLYCS_Pos = 0x18
	// Bit mask of DLYCS field.
	QSPI_MR_DLYCS_Msk = 0xff000000

	// RDR: Receive Data Register
	// Position of RD field.
	QSPI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	QSPI_RDR_RD_Msk = 0xffff

	// TDR: Transmit Data Register
	// Position of TD field.
	QSPI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	QSPI_TDR_TD_Msk = 0xffff

	// SR: Status Register
	// Position of RDRF field.
	QSPI_SR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	QSPI_SR_RDRF_Msk = 0x1
	// Bit RDRF.
	QSPI_SR_RDRF = 0x1
	// Position of TDRE field.
	QSPI_SR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	QSPI_SR_TDRE_Msk = 0x2
	// Bit TDRE.
	QSPI_SR_TDRE = 0x2
	// Position of TXEMPTY field.
	QSPI_SR_TXEMPTY_Pos = 0x2
	// Bit mask of TXEMPTY field.
	QSPI_SR_TXEMPTY_Msk = 0x4
	// Bit TXEMPTY.
	QSPI_SR_TXEMPTY = 0x4
	// Position of OVRES field.
	QSPI_SR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	QSPI_SR_OVRES_Msk = 0x8
	// Bit OVRES.
	QSPI_SR_OVRES = 0x8
	// Position of CSR field.
	QSPI_SR_CSR_Pos = 0x8
	// Bit mask of CSR field.
	QSPI_SR_CSR_Msk = 0x100
	// Bit CSR.
	QSPI_SR_CSR = 0x100
	// Position of CSS field.
	QSPI_SR_CSS_Pos = 0x9
	// Bit mask of CSS field.
	QSPI_SR_CSS_Msk = 0x200
	// Bit CSS.
	QSPI_SR_CSS = 0x200
	// Position of INSTRE field.
	QSPI_SR_INSTRE_Pos = 0xa
	// Bit mask of INSTRE field.
	QSPI_SR_INSTRE_Msk = 0x400
	// Bit INSTRE.
	QSPI_SR_INSTRE = 0x400
	// Position of QSPIENS field.
	QSPI_SR_QSPIENS_Pos = 0x18
	// Bit mask of QSPIENS field.
	QSPI_SR_QSPIENS_Msk = 0x1000000
	// Bit QSPIENS.
	QSPI_SR_QSPIENS = 0x1000000

	// IER: Interrupt Enable Register
	// Position of RDRF field.
	QSPI_IER_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	QSPI_IER_RDRF_Msk = 0x1
	// Bit RDRF.
	QSPI_IER_RDRF = 0x1
	// Position of TDRE field.
	QSPI_IER_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	QSPI_IER_TDRE_Msk = 0x2
	// Bit TDRE.
	QSPI_IER_TDRE = 0x2
	// Position of TXEMPTY field.
	QSPI_IER_TXEMPTY_Pos = 0x2
	// Bit mask of TXEMPTY field.
	QSPI_IER_TXEMPTY_Msk = 0x4
	// Bit TXEMPTY.
	QSPI_IER_TXEMPTY = 0x4
	// Position of OVRES field.
	QSPI_IER_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	QSPI_IER_OVRES_Msk = 0x8
	// Bit OVRES.
	QSPI_IER_OVRES = 0x8
	// Position of CSR field.
	QSPI_IER_CSR_Pos = 0x8
	// Bit mask of CSR field.
	QSPI_IER_CSR_Msk = 0x100
	// Bit CSR.
	QSPI_IER_CSR = 0x100
	// Position of CSS field.
	QSPI_IER_CSS_Pos = 0x9
	// Bit mask of CSS field.
	QSPI_IER_CSS_Msk = 0x200
	// Bit CSS.
	QSPI_IER_CSS = 0x200
	// Position of INSTRE field.
	QSPI_IER_INSTRE_Pos = 0xa
	// Bit mask of INSTRE field.
	QSPI_IER_INSTRE_Msk = 0x400
	// Bit INSTRE.
	QSPI_IER_INSTRE = 0x400

	// IDR: Interrupt Disable Register
	// Position of RDRF field.
	QSPI_IDR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	QSPI_IDR_RDRF_Msk = 0x1
	// Bit RDRF.
	QSPI_IDR_RDRF = 0x1
	// Position of TDRE field.
	QSPI_IDR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	QSPI_IDR_TDRE_Msk = 0x2
	// Bit TDRE.
	QSPI_IDR_TDRE = 0x2
	// Position of TXEMPTY field.
	QSPI_IDR_TXEMPTY_Pos = 0x2
	// Bit mask of TXEMPTY field.
	QSPI_IDR_TXEMPTY_Msk = 0x4
	// Bit TXEMPTY.
	QSPI_IDR_TXEMPTY = 0x4
	// Position of OVRES field.
	QSPI_IDR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	QSPI_IDR_OVRES_Msk = 0x8
	// Bit OVRES.
	QSPI_IDR_OVRES = 0x8
	// Position of CSR field.
	QSPI_IDR_CSR_Pos = 0x8
	// Bit mask of CSR field.
	QSPI_IDR_CSR_Msk = 0x100
	// Bit CSR.
	QSPI_IDR_CSR = 0x100
	// Position of CSS field.
	QSPI_IDR_CSS_Pos = 0x9
	// Bit mask of CSS field.
	QSPI_IDR_CSS_Msk = 0x200
	// Bit CSS.
	QSPI_IDR_CSS = 0x200
	// Position of INSTRE field.
	QSPI_IDR_INSTRE_Pos = 0xa
	// Bit mask of INSTRE field.
	QSPI_IDR_INSTRE_Msk = 0x400
	// Bit INSTRE.
	QSPI_IDR_INSTRE = 0x400

	// IMR: Interrupt Mask Register
	// Position of RDRF field.
	QSPI_IMR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	QSPI_IMR_RDRF_Msk = 0x1
	// Bit RDRF.
	QSPI_IMR_RDRF = 0x1
	// Position of TDRE field.
	QSPI_IMR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	QSPI_IMR_TDRE_Msk = 0x2
	// Bit TDRE.
	QSPI_IMR_TDRE = 0x2
	// Position of TXEMPTY field.
	QSPI_IMR_TXEMPTY_Pos = 0x2
	// Bit mask of TXEMPTY field.
	QSPI_IMR_TXEMPTY_Msk = 0x4
	// Bit TXEMPTY.
	QSPI_IMR_TXEMPTY = 0x4
	// Position of OVRES field.
	QSPI_IMR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	QSPI_IMR_OVRES_Msk = 0x8
	// Bit OVRES.
	QSPI_IMR_OVRES = 0x8
	// Position of CSR field.
	QSPI_IMR_CSR_Pos = 0x8
	// Bit mask of CSR field.
	QSPI_IMR_CSR_Msk = 0x100
	// Bit CSR.
	QSPI_IMR_CSR = 0x100
	// Position of CSS field.
	QSPI_IMR_CSS_Pos = 0x9
	// Bit mask of CSS field.
	QSPI_IMR_CSS_Msk = 0x200
	// Bit CSS.
	QSPI_IMR_CSS = 0x200
	// Position of INSTRE field.
	QSPI_IMR_INSTRE_Pos = 0xa
	// Bit mask of INSTRE field.
	QSPI_IMR_INSTRE_Msk = 0x400
	// Bit INSTRE.
	QSPI_IMR_INSTRE = 0x400

	// SCR: Serial Clock Register
	// Position of CPOL field.
	QSPI_SCR_CPOL_Pos = 0x0
	// Bit mask of CPOL field.
	QSPI_SCR_CPOL_Msk = 0x1
	// Bit CPOL.
	QSPI_SCR_CPOL = 0x1
	// Position of CPHA field.
	QSPI_SCR_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	QSPI_SCR_CPHA_Msk = 0x2
	// Bit CPHA.
	QSPI_SCR_CPHA = 0x2
	// Position of SCBR field.
	QSPI_SCR_SCBR_Pos = 0x8
	// Bit mask of SCBR field.
	QSPI_SCR_SCBR_Msk = 0xff00
	// Position of DLYBS field.
	QSPI_SCR_DLYBS_Pos = 0x10
	// Bit mask of DLYBS field.
	QSPI_SCR_DLYBS_Msk = 0xff0000

	// IAR: Instruction Address Register
	// Position of ADDR field.
	QSPI_IAR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	QSPI_IAR_ADDR_Msk = 0xffffffff

	// ICR: Instruction Code Register
	// Position of INST field.
	QSPI_ICR_INST_Pos = 0x0
	// Bit mask of INST field.
	QSPI_ICR_INST_Msk = 0xff
	// Position of OPT field.
	QSPI_ICR_OPT_Pos = 0x10
	// Bit mask of OPT field.
	QSPI_ICR_OPT_Msk = 0xff0000

	// IFR: Instruction Frame Register
	// Position of WIDTH field.
	QSPI_IFR_WIDTH_Pos = 0x0
	// Bit mask of WIDTH field.
	QSPI_IFR_WIDTH_Msk = 0x7
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Single-bit SPI
	QSPI_IFR_WIDTH_SINGLE_BIT_SPI = 0x0
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Dual SPI
	QSPI_IFR_WIDTH_DUAL_OUTPUT = 0x1
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Quad SPI
	QSPI_IFR_WIDTH_QUAD_OUTPUT = 0x2
	// Instruction: Single-bit SPI / Address-Option: Dual SPI / Data: Dual SPI
	QSPI_IFR_WIDTH_DUAL_IO = 0x3
	// Instruction: Single-bit SPI / Address-Option: Quad SPI / Data: Quad SPI
	QSPI_IFR_WIDTH_QUAD_IO = 0x4
	// Instruction: Dual SPI / Address-Option: Dual SPI / Data: Dual SPI
	QSPI_IFR_WIDTH_DUAL_CMD = 0x5
	// Instruction: Quad SPI / Address-Option: Quad SPI / Data: Quad SPI
	QSPI_IFR_WIDTH_QUAD_CMD = 0x6
	// Position of INSTEN field.
	QSPI_IFR_INSTEN_Pos = 0x4
	// Bit mask of INSTEN field.
	QSPI_IFR_INSTEN_Msk = 0x10
	// Bit INSTEN.
	QSPI_IFR_INSTEN = 0x10
	// Position of ADDREN field.
	QSPI_IFR_ADDREN_Pos = 0x5
	// Bit mask of ADDREN field.
	QSPI_IFR_ADDREN_Msk = 0x20
	// Bit ADDREN.
	QSPI_IFR_ADDREN = 0x20
	// Position of OPTEN field.
	QSPI_IFR_OPTEN_Pos = 0x6
	// Bit mask of OPTEN field.
	QSPI_IFR_OPTEN_Msk = 0x40
	// Bit OPTEN.
	QSPI_IFR_OPTEN = 0x40
	// Position of DATAEN field.
	QSPI_IFR_DATAEN_Pos = 0x7
	// Bit mask of DATAEN field.
	QSPI_IFR_DATAEN_Msk = 0x80
	// Bit DATAEN.
	QSPI_IFR_DATAEN = 0x80
	// Position of OPTL field.
	QSPI_IFR_OPTL_Pos = 0x8
	// Bit mask of OPTL field.
	QSPI_IFR_OPTL_Msk = 0x300
	// The option code is 1 bit long.
	QSPI_IFR_OPTL_OPTION_1BIT = 0x0
	// The option code is 2 bits long.
	QSPI_IFR_OPTL_OPTION_2BIT = 0x1
	// The option code is 4 bits long.
	QSPI_IFR_OPTL_OPTION_4BIT = 0x2
	// The option code is 8 bits long.
	QSPI_IFR_OPTL_OPTION_8BIT = 0x3
	// Position of ADDRL field.
	QSPI_IFR_ADDRL_Pos = 0xa
	// Bit mask of ADDRL field.
	QSPI_IFR_ADDRL_Msk = 0x400
	// Bit ADDRL.
	QSPI_IFR_ADDRL = 0x400
	// The address is 24 bits long.
	QSPI_IFR_ADDRL__24_BIT = 0x0
	// The address is 32 bits long.
	QSPI_IFR_ADDRL__32_BIT = 0x1
	// Position of TFRTYP field.
	QSPI_IFR_TFRTYP_Pos = 0xc
	// Bit mask of TFRTYP field.
	QSPI_IFR_TFRTYP_Msk = 0x3000
	// Read transfer from the serial memory.Scrambling is not performed.Read at random location (fetch) in the serial Flash memory is not possible.
	QSPI_IFR_TFRTYP_TRSFR_READ = 0x0
	// Read data transfer from the serial memory.If enabled, scrambling is performed.Read at random location (fetch) in the serial Flash memory is possible.
	QSPI_IFR_TFRTYP_TRSFR_READ_MEMORY = 0x1
	// Write transfer into the serial memory.Scrambling is not performed.
	QSPI_IFR_TFRTYP_TRSFR_WRITE = 0x2
	// Write data transfer into the serial memory.If enabled, scrambling is performed.
	QSPI_IFR_TFRTYP_TRSFR_WRITE_MEMORY = 0x3
	// Position of CRM field.
	QSPI_IFR_CRM_Pos = 0xe
	// Bit mask of CRM field.
	QSPI_IFR_CRM_Msk = 0x4000
	// Bit CRM.
	QSPI_IFR_CRM = 0x4000
	// The Continuous Read mode is disabled.
	QSPI_IFR_CRM_DISABLED = 0x0
	// The Continuous Read mode is enabled.
	QSPI_IFR_CRM_ENABLED = 0x1
	// Position of NBDUM field.
	QSPI_IFR_NBDUM_Pos = 0x10
	// Bit mask of NBDUM field.
	QSPI_IFR_NBDUM_Msk = 0x1f0000

	// SMR: Scrambling Mode Register
	// Position of SCREN field.
	QSPI_SMR_SCREN_Pos = 0x0
	// Bit mask of SCREN field.
	QSPI_SMR_SCREN_Msk = 0x1
	// Bit SCREN.
	QSPI_SMR_SCREN = 0x1
	// The scrambling/unscrambling is disabled.
	QSPI_SMR_SCREN_DISABLED = 0x0
	// The scrambling/unscrambling is enabled.
	QSPI_SMR_SCREN_ENABLED = 0x1
	// Position of RVDIS field.
	QSPI_SMR_RVDIS_Pos = 0x1
	// Bit mask of RVDIS field.
	QSPI_SMR_RVDIS_Msk = 0x2
	// Bit RVDIS.
	QSPI_SMR_RVDIS = 0x2

	// SKR: Scrambling Key Register
	// Position of USRK field.
	QSPI_SKR_USRK_Pos = 0x0
	// Bit mask of USRK field.
	QSPI_SKR_USRK_Msk = 0xffffffff

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	QSPI_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	QSPI_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	QSPI_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	QSPI_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	QSPI_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit. Always reads as 0.
	QSPI_WPMR_WPKEY_PASSWD = 0x515350

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	QSPI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	QSPI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	QSPI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	QSPI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	QSPI_WPSR_WPVSRC_Msk = 0xff00
)

// Constants for RSTC: Reset Controller
const (
	// CR: Control Register
	// Position of PROCRST field.
	RSTC_CR_PROCRST_Pos = 0x0
	// Bit mask of PROCRST field.
	RSTC_CR_PROCRST_Msk = 0x1
	// Bit PROCRST.
	RSTC_CR_PROCRST = 0x1
	// Position of EXTRST field.
	RSTC_CR_EXTRST_Pos = 0x3
	// Bit mask of EXTRST field.
	RSTC_CR_EXTRST_Msk = 0x8
	// Bit EXTRST.
	RSTC_CR_EXTRST = 0x8
	// Position of KEY field.
	RSTC_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	RSTC_CR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.
	RSTC_CR_KEY_PASSWD = 0xa5

	// SR: Status Register
	// Position of URSTS field.
	RSTC_SR_URSTS_Pos = 0x0
	// Bit mask of URSTS field.
	RSTC_SR_URSTS_Msk = 0x1
	// Bit URSTS.
	RSTC_SR_URSTS = 0x1
	// Position of RSTTYP field.
	RSTC_SR_RSTTYP_Pos = 0x8
	// Bit mask of RSTTYP field.
	RSTC_SR_RSTTYP_Msk = 0x700
	// First power-up reset
	RSTC_SR_RSTTYP_GENERAL_RST = 0x0
	// Return from Backup Mode
	RSTC_SR_RSTTYP_BACKUP_RST = 0x1
	// Watchdog fault occurred
	RSTC_SR_RSTTYP_WDT_RST = 0x2
	// Processor reset required by the software
	RSTC_SR_RSTTYP_SOFT_RST = 0x3
	// NRST pin detected low
	RSTC_SR_RSTTYP_USER_RST = 0x4
	// Position of NRSTL field.
	RSTC_SR_NRSTL_Pos = 0x10
	// Bit mask of NRSTL field.
	RSTC_SR_NRSTL_Msk = 0x10000
	// Bit NRSTL.
	RSTC_SR_NRSTL = 0x10000
	// Position of SRCMP field.
	RSTC_SR_SRCMP_Pos = 0x11
	// Bit mask of SRCMP field.
	RSTC_SR_SRCMP_Msk = 0x20000
	// Bit SRCMP.
	RSTC_SR_SRCMP = 0x20000

	// MR: Mode Register
	// Position of URSTEN field.
	RSTC_MR_URSTEN_Pos = 0x0
	// Bit mask of URSTEN field.
	RSTC_MR_URSTEN_Msk = 0x1
	// Bit URSTEN.
	RSTC_MR_URSTEN = 0x1
	// Position of URSTIEN field.
	RSTC_MR_URSTIEN_Pos = 0x4
	// Bit mask of URSTIEN field.
	RSTC_MR_URSTIEN_Msk = 0x10
	// Bit URSTIEN.
	RSTC_MR_URSTIEN = 0x10
	// Position of ERSTL field.
	RSTC_MR_ERSTL_Pos = 0x8
	// Bit mask of ERSTL field.
	RSTC_MR_ERSTL_Msk = 0xf00
	// Position of KEY field.
	RSTC_MR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	RSTC_MR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.Always reads as 0.
	RSTC_MR_KEY_PASSWD = 0xa5
)

// Constants for RSWDT: Reinforced Safety Watchdog Timer
const (
	// CR: Control Register
	// Position of WDRSTT field.
	RSWDT_CR_WDRSTT_Pos = 0x0
	// Bit mask of WDRSTT field.
	RSWDT_CR_WDRSTT_Msk = 0x1
	// Bit WDRSTT.
	RSWDT_CR_WDRSTT = 0x1
	// Position of KEY field.
	RSWDT_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	RSWDT_CR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.
	RSWDT_CR_KEY_PASSWD = 0xc4

	// MR: Mode Register
	// Position of WDV field.
	RSWDT_MR_WDV_Pos = 0x0
	// Bit mask of WDV field.
	RSWDT_MR_WDV_Msk = 0xfff
	// Position of WDFIEN field.
	RSWDT_MR_WDFIEN_Pos = 0xc
	// Bit mask of WDFIEN field.
	RSWDT_MR_WDFIEN_Msk = 0x1000
	// Bit WDFIEN.
	RSWDT_MR_WDFIEN = 0x1000
	// Position of WDRSTEN field.
	RSWDT_MR_WDRSTEN_Pos = 0xd
	// Bit mask of WDRSTEN field.
	RSWDT_MR_WDRSTEN_Msk = 0x2000
	// Bit WDRSTEN.
	RSWDT_MR_WDRSTEN = 0x2000
	// Position of WDDIS field.
	RSWDT_MR_WDDIS_Pos = 0xf
	// Bit mask of WDDIS field.
	RSWDT_MR_WDDIS_Msk = 0x8000
	// Bit WDDIS.
	RSWDT_MR_WDDIS = 0x8000
	// Position of ALLONES field.
	RSWDT_MR_ALLONES_Pos = 0x10
	// Bit mask of ALLONES field.
	RSWDT_MR_ALLONES_Msk = 0xfff0000
	// Position of WDDBGHLT field.
	RSWDT_MR_WDDBGHLT_Pos = 0x1c
	// Bit mask of WDDBGHLT field.
	RSWDT_MR_WDDBGHLT_Msk = 0x10000000
	// Bit WDDBGHLT.
	RSWDT_MR_WDDBGHLT = 0x10000000
	// Position of WDIDLEHLT field.
	RSWDT_MR_WDIDLEHLT_Pos = 0x1d
	// Bit mask of WDIDLEHLT field.
	RSWDT_MR_WDIDLEHLT_Msk = 0x20000000
	// Bit WDIDLEHLT.
	RSWDT_MR_WDIDLEHLT = 0x20000000

	// SR: Status Register
	// Position of WDUNF field.
	RSWDT_SR_WDUNF_Pos = 0x0
	// Bit mask of WDUNF field.
	RSWDT_SR_WDUNF_Msk = 0x1
	// Bit WDUNF.
	RSWDT_SR_WDUNF = 0x1
)

// Constants for RTC: Real-time Clock
const (
	// CR: Control Register
	// Position of UPDTIM field.
	RTC_CR_UPDTIM_Pos = 0x0
	// Bit mask of UPDTIM field.
	RTC_CR_UPDTIM_Msk = 0x1
	// Bit UPDTIM.
	RTC_CR_UPDTIM = 0x1
	// Position of UPDCAL field.
	RTC_CR_UPDCAL_Pos = 0x1
	// Bit mask of UPDCAL field.
	RTC_CR_UPDCAL_Msk = 0x2
	// Bit UPDCAL.
	RTC_CR_UPDCAL = 0x2
	// Position of TIMEVSEL field.
	RTC_CR_TIMEVSEL_Pos = 0x8
	// Bit mask of TIMEVSEL field.
	RTC_CR_TIMEVSEL_Msk = 0x300
	// Minute change
	RTC_CR_TIMEVSEL_MINUTE = 0x0
	// Hour change
	RTC_CR_TIMEVSEL_HOUR = 0x1
	// Every day at midnight
	RTC_CR_TIMEVSEL_MIDNIGHT = 0x2
	// Every day at noon
	RTC_CR_TIMEVSEL_NOON = 0x3
	// Position of CALEVSEL field.
	RTC_CR_CALEVSEL_Pos = 0x10
	// Bit mask of CALEVSEL field.
	RTC_CR_CALEVSEL_Msk = 0x30000
	// Week change (every Monday at time 00:00:00)
	RTC_CR_CALEVSEL_WEEK = 0x0
	// Month change (every 01 of each month at time 00:00:00)
	RTC_CR_CALEVSEL_MONTH = 0x1
	// Year change (every January 1 at time 00:00:00)
	RTC_CR_CALEVSEL_YEAR = 0x2

	// MR: Mode Register
	// Position of HRMOD field.
	RTC_MR_HRMOD_Pos = 0x0
	// Bit mask of HRMOD field.
	RTC_MR_HRMOD_Msk = 0x1
	// Bit HRMOD.
	RTC_MR_HRMOD = 0x1
	// Position of PERSIAN field.
	RTC_MR_PERSIAN_Pos = 0x1
	// Bit mask of PERSIAN field.
	RTC_MR_PERSIAN_Msk = 0x2
	// Bit PERSIAN.
	RTC_MR_PERSIAN = 0x2
	// Position of NEGPPM field.
	RTC_MR_NEGPPM_Pos = 0x4
	// Bit mask of NEGPPM field.
	RTC_MR_NEGPPM_Msk = 0x10
	// Bit NEGPPM.
	RTC_MR_NEGPPM = 0x10
	// Position of CORRECTION field.
	RTC_MR_CORRECTION_Pos = 0x8
	// Bit mask of CORRECTION field.
	RTC_MR_CORRECTION_Msk = 0x7f00
	// Position of HIGHPPM field.
	RTC_MR_HIGHPPM_Pos = 0xf
	// Bit mask of HIGHPPM field.
	RTC_MR_HIGHPPM_Msk = 0x8000
	// Bit HIGHPPM.
	RTC_MR_HIGHPPM = 0x8000
	// Position of OUT0 field.
	RTC_MR_OUT0_Pos = 0x10
	// Bit mask of OUT0 field.
	RTC_MR_OUT0_Msk = 0x70000
	// No waveform, stuck at '0'
	RTC_MR_OUT0_NO_WAVE = 0x0
	// 1 Hz square wave
	RTC_MR_OUT0_FREQ1HZ = 0x1
	// 32 Hz square wave
	RTC_MR_OUT0_FREQ32HZ = 0x2
	// 64 Hz square wave
	RTC_MR_OUT0_FREQ64HZ = 0x3
	// 512 Hz square wave
	RTC_MR_OUT0_FREQ512HZ = 0x4
	// Output toggles when alarm flag rises
	RTC_MR_OUT0_ALARM_TOGGLE = 0x5
	// Output is a copy of the alarm flag
	RTC_MR_OUT0_ALARM_FLAG = 0x6
	// Duty cycle programmable pulse
	RTC_MR_OUT0_PROG_PULSE = 0x7
	// Position of OUT1 field.
	RTC_MR_OUT1_Pos = 0x14
	// Bit mask of OUT1 field.
	RTC_MR_OUT1_Msk = 0x700000
	// No waveform, stuck at '0'
	RTC_MR_OUT1_NO_WAVE = 0x0
	// 1 Hz square wave
	RTC_MR_OUT1_FREQ1HZ = 0x1
	// 32 Hz square wave
	RTC_MR_OUT1_FREQ32HZ = 0x2
	// 64 Hz square wave
	RTC_MR_OUT1_FREQ64HZ = 0x3
	// 512 Hz square wave
	RTC_MR_OUT1_FREQ512HZ = 0x4
	// Output toggles when alarm flag rises
	RTC_MR_OUT1_ALARM_TOGGLE = 0x5
	// Output is a copy of the alarm flag
	RTC_MR_OUT1_ALARM_FLAG = 0x6
	// Duty cycle programmable pulse
	RTC_MR_OUT1_PROG_PULSE = 0x7
	// Position of THIGH field.
	RTC_MR_THIGH_Pos = 0x18
	// Bit mask of THIGH field.
	RTC_MR_THIGH_Msk = 0x7000000
	// 31.2 ms
	RTC_MR_THIGH_H_31MS = 0x0
	// 15.6 ms
	RTC_MR_THIGH_H_16MS = 0x1
	// 3.91 ms
	RTC_MR_THIGH_H_4MS = 0x2
	// 976 us
	RTC_MR_THIGH_H_976US = 0x3
	// 488 us
	RTC_MR_THIGH_H_488US = 0x4
	// 122 us
	RTC_MR_THIGH_H_122US = 0x5
	// 30.5 us
	RTC_MR_THIGH_H_30US = 0x6
	// 15.2 us
	RTC_MR_THIGH_H_15US = 0x7
	// Position of TPERIOD field.
	RTC_MR_TPERIOD_Pos = 0x1c
	// Bit mask of TPERIOD field.
	RTC_MR_TPERIOD_Msk = 0x30000000
	// 1 second
	RTC_MR_TPERIOD_P_1S = 0x0
	// 500 ms
	RTC_MR_TPERIOD_P_500MS = 0x1
	// 250 ms
	RTC_MR_TPERIOD_P_250MS = 0x2
	// 125 ms
	RTC_MR_TPERIOD_P_125MS = 0x3

	// TIMR: Time Register
	// Position of SEC field.
	RTC_TIMR_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_TIMR_SEC_Msk = 0x7f
	// Position of MIN field.
	RTC_TIMR_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_TIMR_MIN_Msk = 0x7f00
	// Position of HOUR field.
	RTC_TIMR_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_TIMR_HOUR_Msk = 0x3f0000
	// Position of AMPM field.
	RTC_TIMR_AMPM_Pos = 0x16
	// Bit mask of AMPM field.
	RTC_TIMR_AMPM_Msk = 0x400000
	// Bit AMPM.
	RTC_TIMR_AMPM = 0x400000

	// CALR: Calendar Register
	// Position of CENT field.
	RTC_CALR_CENT_Pos = 0x0
	// Bit mask of CENT field.
	RTC_CALR_CENT_Msk = 0x7f
	// Position of YEAR field.
	RTC_CALR_YEAR_Pos = 0x8
	// Bit mask of YEAR field.
	RTC_CALR_YEAR_Msk = 0xff00
	// Position of MONTH field.
	RTC_CALR_MONTH_Pos = 0x10
	// Bit mask of MONTH field.
	RTC_CALR_MONTH_Msk = 0x1f0000
	// Position of DAY field.
	RTC_CALR_DAY_Pos = 0x15
	// Bit mask of DAY field.
	RTC_CALR_DAY_Msk = 0xe00000
	// Position of DATE field.
	RTC_CALR_DATE_Pos = 0x18
	// Bit mask of DATE field.
	RTC_CALR_DATE_Msk = 0x3f000000

	// TIMALR: Time Alarm Register
	// Position of SEC field.
	RTC_TIMALR_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_TIMALR_SEC_Msk = 0x7f
	// Position of SECEN field.
	RTC_TIMALR_SECEN_Pos = 0x7
	// Bit mask of SECEN field.
	RTC_TIMALR_SECEN_Msk = 0x80
	// Bit SECEN.
	RTC_TIMALR_SECEN = 0x80
	// Position of MIN field.
	RTC_TIMALR_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_TIMALR_MIN_Msk = 0x7f00
	// Position of MINEN field.
	RTC_TIMALR_MINEN_Pos = 0xf
	// Bit mask of MINEN field.
	RTC_TIMALR_MINEN_Msk = 0x8000
	// Bit MINEN.
	RTC_TIMALR_MINEN = 0x8000
	// Position of HOUR field.
	RTC_TIMALR_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_TIMALR_HOUR_Msk = 0x3f0000
	// Position of AMPM field.
	RTC_TIMALR_AMPM_Pos = 0x16
	// Bit mask of AMPM field.
	RTC_TIMALR_AMPM_Msk = 0x400000
	// Bit AMPM.
	RTC_TIMALR_AMPM = 0x400000
	// Position of HOUREN field.
	RTC_TIMALR_HOUREN_Pos = 0x17
	// Bit mask of HOUREN field.
	RTC_TIMALR_HOUREN_Msk = 0x800000
	// Bit HOUREN.
	RTC_TIMALR_HOUREN = 0x800000

	// CALALR: Calendar Alarm Register
	// Position of MONTH field.
	RTC_CALALR_MONTH_Pos = 0x10
	// Bit mask of MONTH field.
	RTC_CALALR_MONTH_Msk = 0x1f0000
	// Position of MTHEN field.
	RTC_CALALR_MTHEN_Pos = 0x17
	// Bit mask of MTHEN field.
	RTC_CALALR_MTHEN_Msk = 0x800000
	// Bit MTHEN.
	RTC_CALALR_MTHEN = 0x800000
	// Position of DATE field.
	RTC_CALALR_DATE_Pos = 0x18
	// Bit mask of DATE field.
	RTC_CALALR_DATE_Msk = 0x3f000000
	// Position of DATEEN field.
	RTC_CALALR_DATEEN_Pos = 0x1f
	// Bit mask of DATEEN field.
	RTC_CALALR_DATEEN_Msk = 0x80000000
	// Bit DATEEN.
	RTC_CALALR_DATEEN = 0x80000000

	// SR: Status Register
	// Position of ACKUPD field.
	RTC_SR_ACKUPD_Pos = 0x0
	// Bit mask of ACKUPD field.
	RTC_SR_ACKUPD_Msk = 0x1
	// Bit ACKUPD.
	RTC_SR_ACKUPD = 0x1
	// Time and calendar registers cannot be updated.
	RTC_SR_ACKUPD_FREERUN = 0x0
	// Time and calendar registers can be updated.
	RTC_SR_ACKUPD_UPDATE = 0x1
	// Position of ALARM field.
	RTC_SR_ALARM_Pos = 0x1
	// Bit mask of ALARM field.
	RTC_SR_ALARM_Msk = 0x2
	// Bit ALARM.
	RTC_SR_ALARM = 0x2
	// No alarm matching condition occurred.
	RTC_SR_ALARM_NO_ALARMEVENT = 0x0
	// An alarm matching condition has occurred.
	RTC_SR_ALARM_ALARMEVENT = 0x1
	// Position of SEC field.
	RTC_SR_SEC_Pos = 0x2
	// Bit mask of SEC field.
	RTC_SR_SEC_Msk = 0x4
	// Bit SEC.
	RTC_SR_SEC = 0x4
	// No second event has occurred since the last clear.
	RTC_SR_SEC_NO_SECEVENT = 0x0
	// At least one second event has occurred since the last clear.
	RTC_SR_SEC_SECEVENT = 0x1
	// Position of TIMEV field.
	RTC_SR_TIMEV_Pos = 0x3
	// Bit mask of TIMEV field.
	RTC_SR_TIMEV_Msk = 0x8
	// Bit TIMEV.
	RTC_SR_TIMEV = 0x8
	// No time event has occurred since the last clear.
	RTC_SR_TIMEV_NO_TIMEVENT = 0x0
	// At least one time event has occurred since the last clear.
	RTC_SR_TIMEV_TIMEVENT = 0x1
	// Position of CALEV field.
	RTC_SR_CALEV_Pos = 0x4
	// Bit mask of CALEV field.
	RTC_SR_CALEV_Msk = 0x10
	// Bit CALEV.
	RTC_SR_CALEV = 0x10
	// No calendar event has occurred since the last clear.
	RTC_SR_CALEV_NO_CALEVENT = 0x0
	// At least one calendar event has occurred since the last clear.
	RTC_SR_CALEV_CALEVENT = 0x1
	// Position of TDERR field.
	RTC_SR_TDERR_Pos = 0x5
	// Bit mask of TDERR field.
	RTC_SR_TDERR_Msk = 0x20
	// Bit TDERR.
	RTC_SR_TDERR = 0x20
	// The internal free running counters are carrying valid values since the last read of the Status Register (RTC_SR).
	RTC_SR_TDERR_CORRECT = 0x0
	// The internal free running counters have been corrupted (invalid date or time, non-BCD values) since the last read and/or they are still invalid.
	RTC_SR_TDERR_ERR_TIMEDATE = 0x1

	// SCCR: Status Clear Command Register
	// Position of ACKCLR field.
	RTC_SCCR_ACKCLR_Pos = 0x0
	// Bit mask of ACKCLR field.
	RTC_SCCR_ACKCLR_Msk = 0x1
	// Bit ACKCLR.
	RTC_SCCR_ACKCLR = 0x1
	// Position of ALRCLR field.
	RTC_SCCR_ALRCLR_Pos = 0x1
	// Bit mask of ALRCLR field.
	RTC_SCCR_ALRCLR_Msk = 0x2
	// Bit ALRCLR.
	RTC_SCCR_ALRCLR = 0x2
	// Position of SECCLR field.
	RTC_SCCR_SECCLR_Pos = 0x2
	// Bit mask of SECCLR field.
	RTC_SCCR_SECCLR_Msk = 0x4
	// Bit SECCLR.
	RTC_SCCR_SECCLR = 0x4
	// Position of TIMCLR field.
	RTC_SCCR_TIMCLR_Pos = 0x3
	// Bit mask of TIMCLR field.
	RTC_SCCR_TIMCLR_Msk = 0x8
	// Bit TIMCLR.
	RTC_SCCR_TIMCLR = 0x8
	// Position of CALCLR field.
	RTC_SCCR_CALCLR_Pos = 0x4
	// Bit mask of CALCLR field.
	RTC_SCCR_CALCLR_Msk = 0x10
	// Bit CALCLR.
	RTC_SCCR_CALCLR = 0x10
	// Position of TDERRCLR field.
	RTC_SCCR_TDERRCLR_Pos = 0x5
	// Bit mask of TDERRCLR field.
	RTC_SCCR_TDERRCLR_Msk = 0x20
	// Bit TDERRCLR.
	RTC_SCCR_TDERRCLR = 0x20

	// IER: Interrupt Enable Register
	// Position of ACKEN field.
	RTC_IER_ACKEN_Pos = 0x0
	// Bit mask of ACKEN field.
	RTC_IER_ACKEN_Msk = 0x1
	// Bit ACKEN.
	RTC_IER_ACKEN = 0x1
	// Position of ALREN field.
	RTC_IER_ALREN_Pos = 0x1
	// Bit mask of ALREN field.
	RTC_IER_ALREN_Msk = 0x2
	// Bit ALREN.
	RTC_IER_ALREN = 0x2
	// Position of SECEN field.
	RTC_IER_SECEN_Pos = 0x2
	// Bit mask of SECEN field.
	RTC_IER_SECEN_Msk = 0x4
	// Bit SECEN.
	RTC_IER_SECEN = 0x4
	// Position of TIMEN field.
	RTC_IER_TIMEN_Pos = 0x3
	// Bit mask of TIMEN field.
	RTC_IER_TIMEN_Msk = 0x8
	// Bit TIMEN.
	RTC_IER_TIMEN = 0x8
	// Position of CALEN field.
	RTC_IER_CALEN_Pos = 0x4
	// Bit mask of CALEN field.
	RTC_IER_CALEN_Msk = 0x10
	// Bit CALEN.
	RTC_IER_CALEN = 0x10
	// Position of TDERREN field.
	RTC_IER_TDERREN_Pos = 0x5
	// Bit mask of TDERREN field.
	RTC_IER_TDERREN_Msk = 0x20
	// Bit TDERREN.
	RTC_IER_TDERREN = 0x20

	// IDR: Interrupt Disable Register
	// Position of ACKDIS field.
	RTC_IDR_ACKDIS_Pos = 0x0
	// Bit mask of ACKDIS field.
	RTC_IDR_ACKDIS_Msk = 0x1
	// Bit ACKDIS.
	RTC_IDR_ACKDIS = 0x1
	// Position of ALRDIS field.
	RTC_IDR_ALRDIS_Pos = 0x1
	// Bit mask of ALRDIS field.
	RTC_IDR_ALRDIS_Msk = 0x2
	// Bit ALRDIS.
	RTC_IDR_ALRDIS = 0x2
	// Position of SECDIS field.
	RTC_IDR_SECDIS_Pos = 0x2
	// Bit mask of SECDIS field.
	RTC_IDR_SECDIS_Msk = 0x4
	// Bit SECDIS.
	RTC_IDR_SECDIS = 0x4
	// Position of TIMDIS field.
	RTC_IDR_TIMDIS_Pos = 0x3
	// Bit mask of TIMDIS field.
	RTC_IDR_TIMDIS_Msk = 0x8
	// Bit TIMDIS.
	RTC_IDR_TIMDIS = 0x8
	// Position of CALDIS field.
	RTC_IDR_CALDIS_Pos = 0x4
	// Bit mask of CALDIS field.
	RTC_IDR_CALDIS_Msk = 0x10
	// Bit CALDIS.
	RTC_IDR_CALDIS = 0x10
	// Position of TDERRDIS field.
	RTC_IDR_TDERRDIS_Pos = 0x5
	// Bit mask of TDERRDIS field.
	RTC_IDR_TDERRDIS_Msk = 0x20
	// Bit TDERRDIS.
	RTC_IDR_TDERRDIS = 0x20

	// IMR: Interrupt Mask Register
	// Position of ACK field.
	RTC_IMR_ACK_Pos = 0x0
	// Bit mask of ACK field.
	RTC_IMR_ACK_Msk = 0x1
	// Bit ACK.
	RTC_IMR_ACK = 0x1
	// Position of ALR field.
	RTC_IMR_ALR_Pos = 0x1
	// Bit mask of ALR field.
	RTC_IMR_ALR_Msk = 0x2
	// Bit ALR.
	RTC_IMR_ALR = 0x2
	// Position of SEC field.
	RTC_IMR_SEC_Pos = 0x2
	// Bit mask of SEC field.
	RTC_IMR_SEC_Msk = 0x4
	// Bit SEC.
	RTC_IMR_SEC = 0x4
	// Position of TIM field.
	RTC_IMR_TIM_Pos = 0x3
	// Bit mask of TIM field.
	RTC_IMR_TIM_Msk = 0x8
	// Bit TIM.
	RTC_IMR_TIM = 0x8
	// Position of CAL field.
	RTC_IMR_CAL_Pos = 0x4
	// Bit mask of CAL field.
	RTC_IMR_CAL_Msk = 0x10
	// Bit CAL.
	RTC_IMR_CAL = 0x10
	// Position of TDERR field.
	RTC_IMR_TDERR_Pos = 0x5
	// Bit mask of TDERR field.
	RTC_IMR_TDERR_Msk = 0x20
	// Bit TDERR.
	RTC_IMR_TDERR = 0x20

	// VER: Valid Entry Register
	// Position of NVTIM field.
	RTC_VER_NVTIM_Pos = 0x0
	// Bit mask of NVTIM field.
	RTC_VER_NVTIM_Msk = 0x1
	// Bit NVTIM.
	RTC_VER_NVTIM = 0x1
	// Position of NVCAL field.
	RTC_VER_NVCAL_Pos = 0x1
	// Bit mask of NVCAL field.
	RTC_VER_NVCAL_Msk = 0x2
	// Bit NVCAL.
	RTC_VER_NVCAL = 0x2
	// Position of NVTIMALR field.
	RTC_VER_NVTIMALR_Pos = 0x2
	// Bit mask of NVTIMALR field.
	RTC_VER_NVTIMALR_Msk = 0x4
	// Bit NVTIMALR.
	RTC_VER_NVTIMALR = 0x4
	// Position of NVCALALR field.
	RTC_VER_NVCALALR_Pos = 0x3
	// Bit mask of NVCALALR field.
	RTC_VER_NVCALALR_Msk = 0x8
	// Bit NVCALALR.
	RTC_VER_NVCALALR = 0x8
)

// Constants for RTT: Real-time Timer
const (
	// MR: Mode Register
	// Position of RTPRES field.
	RTT_MR_RTPRES_Pos = 0x0
	// Bit mask of RTPRES field.
	RTT_MR_RTPRES_Msk = 0xffff
	// Position of ALMIEN field.
	RTT_MR_ALMIEN_Pos = 0x10
	// Bit mask of ALMIEN field.
	RTT_MR_ALMIEN_Msk = 0x10000
	// Bit ALMIEN.
	RTT_MR_ALMIEN = 0x10000
	// Position of RTTINCIEN field.
	RTT_MR_RTTINCIEN_Pos = 0x11
	// Bit mask of RTTINCIEN field.
	RTT_MR_RTTINCIEN_Msk = 0x20000
	// Bit RTTINCIEN.
	RTT_MR_RTTINCIEN = 0x20000
	// Position of RTTRST field.
	RTT_MR_RTTRST_Pos = 0x12
	// Bit mask of RTTRST field.
	RTT_MR_RTTRST_Msk = 0x40000
	// Bit RTTRST.
	RTT_MR_RTTRST = 0x40000
	// Position of RTTDIS field.
	RTT_MR_RTTDIS_Pos = 0x14
	// Bit mask of RTTDIS field.
	RTT_MR_RTTDIS_Msk = 0x100000
	// Bit RTTDIS.
	RTT_MR_RTTDIS = 0x100000
	// Position of RTC1HZ field.
	RTT_MR_RTC1HZ_Pos = 0x18
	// Bit mask of RTC1HZ field.
	RTT_MR_RTC1HZ_Msk = 0x1000000
	// Bit RTC1HZ.
	RTT_MR_RTC1HZ = 0x1000000

	// AR: Alarm Register
	// Position of ALMV field.
	RTT_AR_ALMV_Pos = 0x0
	// Bit mask of ALMV field.
	RTT_AR_ALMV_Msk = 0xffffffff

	// VR: Value Register
	// Position of CRTV field.
	RTT_VR_CRTV_Pos = 0x0
	// Bit mask of CRTV field.
	RTT_VR_CRTV_Msk = 0xffffffff

	// SR: Status Register
	// Position of ALMS field.
	RTT_SR_ALMS_Pos = 0x0
	// Bit mask of ALMS field.
	RTT_SR_ALMS_Msk = 0x1
	// Bit ALMS.
	RTT_SR_ALMS = 0x1
	// Position of RTTINC field.
	RTT_SR_RTTINC_Pos = 0x1
	// Bit mask of RTTINC field.
	RTT_SR_RTTINC_Msk = 0x2
	// Bit RTTINC.
	RTT_SR_RTTINC = 0x2
)

// Constants for SSC: Synchronous Serial Controller
const (
	// CR: Control Register
	// Position of RXEN field.
	SSC_CR_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	SSC_CR_RXEN_Msk = 0x1
	// Bit RXEN.
	SSC_CR_RXEN = 0x1
	// Position of RXDIS field.
	SSC_CR_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	SSC_CR_RXDIS_Msk = 0x2
	// Bit RXDIS.
	SSC_CR_RXDIS = 0x2
	// Position of TXEN field.
	SSC_CR_TXEN_Pos = 0x8
	// Bit mask of TXEN field.
	SSC_CR_TXEN_Msk = 0x100
	// Bit TXEN.
	SSC_CR_TXEN = 0x100
	// Position of TXDIS field.
	SSC_CR_TXDIS_Pos = 0x9
	// Bit mask of TXDIS field.
	SSC_CR_TXDIS_Msk = 0x200
	// Bit TXDIS.
	SSC_CR_TXDIS = 0x200
	// Position of SWRST field.
	SSC_CR_SWRST_Pos = 0xf
	// Bit mask of SWRST field.
	SSC_CR_SWRST_Msk = 0x8000
	// Bit SWRST.
	SSC_CR_SWRST = 0x8000

	// CMR: Clock Mode Register
	// Position of DIV field.
	SSC_CMR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SSC_CMR_DIV_Msk = 0xfff

	// RCMR: Receive Clock Mode Register
	// Position of CKS field.
	SSC_RCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_RCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_RCMR_CKS_MCK = 0x0
	// TK Clock signal
	SSC_RCMR_CKS_TK = 0x1
	// RK pin
	SSC_RCMR_CKS_RK = 0x2
	// Position of CKO field.
	SSC_RCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_RCMR_CKO_Msk = 0x1c
	// None, RK pin is an input
	SSC_RCMR_CKO_NONE = 0x0
	// Continuous Receive Clock, RK pin is an output
	SSC_RCMR_CKO_CONTINUOUS = 0x1
	// Receive Clock only during data transfers, RK pin is an output
	SSC_RCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_RCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_RCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_RCMR_CKI = 0x20
	// Position of CKG field.
	SSC_RCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_RCMR_CKG_Msk = 0xc0
	// None
	SSC_RCMR_CKG_CONTINUOUS = 0x0
	// Receive Clock enabled only if RF Low
	SSC_RCMR_CKG_EN_RF_LOW = 0x1
	// Receive Clock enabled only if RF High
	SSC_RCMR_CKG_EN_RF_HIGH = 0x2
	// Position of START field.
	SSC_RCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_RCMR_START_Msk = 0xf00
	// Continuous, as soon as the receiver is enabled, and immediately after the end of transfer of the previous data.
	SSC_RCMR_START_CONTINUOUS = 0x0
	// Transmit start
	SSC_RCMR_START_TRANSMIT = 0x1
	// Detection of a low level on RF signal
	SSC_RCMR_START_RF_LOW = 0x2
	// Detection of a high level on RF signal
	SSC_RCMR_START_RF_HIGH = 0x3
	// Detection of a falling edge on RF signal
	SSC_RCMR_START_RF_FALLING = 0x4
	// Detection of a rising edge on RF signal
	SSC_RCMR_START_RF_RISING = 0x5
	// Detection of any level change on RF signal
	SSC_RCMR_START_RF_LEVEL = 0x6
	// Detection of any edge on RF signal
	SSC_RCMR_START_RF_EDGE = 0x7
	// Compare 0
	SSC_RCMR_START_CMP_0 = 0x8
	// Position of STOP field.
	SSC_RCMR_STOP_Pos = 0xc
	// Bit mask of STOP field.
	SSC_RCMR_STOP_Msk = 0x1000
	// Bit STOP.
	SSC_RCMR_STOP = 0x1000
	// Position of STTDLY field.
	SSC_RCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_RCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_RCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_RCMR_PERIOD_Msk = 0xff000000

	// RFMR: Receive Frame Mode Register
	// Position of DATLEN field.
	SSC_RFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_RFMR_DATLEN_Msk = 0x1f
	// Position of LOOP field.
	SSC_RFMR_LOOP_Pos = 0x5
	// Bit mask of LOOP field.
	SSC_RFMR_LOOP_Msk = 0x20
	// Bit LOOP.
	SSC_RFMR_LOOP = 0x20
	// Position of MSBF field.
	SSC_RFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_RFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_RFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_RFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_RFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_RFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_RFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_RFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_RFMR_FSOS_Msk = 0x700000
	// None, RF pin is an input
	SSC_RFMR_FSOS_NONE = 0x0
	// Negative Pulse, RF pin is an output
	SSC_RFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse, RF pin is an output
	SSC_RFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer, RF pin is an output
	SSC_RFMR_FSOS_LOW = 0x3
	// Driven High during data transfer, RF pin is an output
	SSC_RFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer, RF pin is an output
	SSC_RFMR_FSOS_TOGGLING = 0x5
	// Position of FSEDGE field.
	SSC_RFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_RFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_RFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_RFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_RFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Msk = 0xf0000000

	// TCMR: Transmit Clock Mode Register
	// Position of CKS field.
	SSC_TCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_TCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_TCMR_CKS_MCK = 0x0
	// RK Clock signal
	SSC_TCMR_CKS_RK = 0x1
	// TK pin
	SSC_TCMR_CKS_TK = 0x2
	// Position of CKO field.
	SSC_TCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_TCMR_CKO_Msk = 0x1c
	// None, TK pin is an input
	SSC_TCMR_CKO_NONE = 0x0
	// Continuous Transmit Clock, TK pin is an output
	SSC_TCMR_CKO_CONTINUOUS = 0x1
	// Transmit Clock only during data transfers, TK pin is an output
	SSC_TCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_TCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_TCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_TCMR_CKI = 0x20
	// Position of CKG field.
	SSC_TCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_TCMR_CKG_Msk = 0xc0
	// None
	SSC_TCMR_CKG_CONTINUOUS = 0x0
	// Transmit Clock enabled only if TF Low
	SSC_TCMR_CKG_EN_TF_LOW = 0x1
	// Transmit Clock enabled only if TF High
	SSC_TCMR_CKG_EN_TF_HIGH = 0x2
	// Position of START field.
	SSC_TCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_TCMR_START_Msk = 0xf00
	// Continuous, as soon as a word is written in the SSC_THR (if Transmit is enabled), and immediately after the end of transfer of the previous data
	SSC_TCMR_START_CONTINUOUS = 0x0
	// Receive start
	SSC_TCMR_START_RECEIVE = 0x1
	// Detection of a low level on TF signal
	SSC_TCMR_START_TF_LOW = 0x2
	// Detection of a high level on TF signal
	SSC_TCMR_START_TF_HIGH = 0x3
	// Detection of a falling edge on TF signal
	SSC_TCMR_START_TF_FALLING = 0x4
	// Detection of a rising edge on TF signal
	SSC_TCMR_START_TF_RISING = 0x5
	// Detection of any level change on TF signal
	SSC_TCMR_START_TF_LEVEL = 0x6
	// Detection of any edge on TF signal
	SSC_TCMR_START_TF_EDGE = 0x7
	// Position of STTDLY field.
	SSC_TCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_TCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_TCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_TCMR_PERIOD_Msk = 0xff000000

	// TFMR: Transmit Frame Mode Register
	// Position of DATLEN field.
	SSC_TFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_TFMR_DATLEN_Msk = 0x1f
	// Position of DATDEF field.
	SSC_TFMR_DATDEF_Pos = 0x5
	// Bit mask of DATDEF field.
	SSC_TFMR_DATDEF_Msk = 0x20
	// Bit DATDEF.
	SSC_TFMR_DATDEF = 0x20
	// Position of MSBF field.
	SSC_TFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_TFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_TFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_TFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_TFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_TFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_TFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_TFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_TFMR_FSOS_Msk = 0x700000
	// None, TF pin is an input
	SSC_TFMR_FSOS_NONE = 0x0
	// Negative Pulse, TF pin is an output
	SSC_TFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse, TF pin is an output
	SSC_TFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer
	SSC_TFMR_FSOS_LOW = 0x3
	// Driven High during data transfer
	SSC_TFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer
	SSC_TFMR_FSOS_TOGGLING = 0x5
	// Position of FSDEN field.
	SSC_TFMR_FSDEN_Pos = 0x17
	// Bit mask of FSDEN field.
	SSC_TFMR_FSDEN_Msk = 0x800000
	// Bit FSDEN.
	SSC_TFMR_FSDEN = 0x800000
	// Position of FSEDGE field.
	SSC_TFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_TFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_TFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_TFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_TFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Msk = 0xf0000000

	// RHR: Receive Holding Register
	// Position of RDAT field.
	SSC_RHR_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SSC_RHR_RDAT_Msk = 0xffffffff

	// THR: Transmit Holding Register
	// Position of TDAT field.
	SSC_THR_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SSC_THR_TDAT_Msk = 0xffffffff

	// RSHR: Receive Sync. Holding Register
	// Position of RSDAT field.
	SSC_RSHR_RSDAT_Pos = 0x0
	// Bit mask of RSDAT field.
	SSC_RSHR_RSDAT_Msk = 0xffff

	// TSHR: Transmit Sync. Holding Register
	// Position of TSDAT field.
	SSC_TSHR_TSDAT_Pos = 0x0
	// Bit mask of TSDAT field.
	SSC_TSHR_TSDAT_Msk = 0xffff

	// RC0R: Receive Compare 0 Register
	// Position of CP0 field.
	SSC_RC0R_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SSC_RC0R_CP0_Msk = 0xffff

	// RC1R: Receive Compare 1 Register
	// Position of CP1 field.
	SSC_RC1R_CP1_Pos = 0x0
	// Bit mask of CP1 field.
	SSC_RC1R_CP1_Msk = 0xffff

	// SR: Status Register
	// Position of TXRDY field.
	SSC_SR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_SR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_SR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_SR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_SR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_SR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_SR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_SR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_SR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_SR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_SR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_SR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_SR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_SR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_SR_CP0 = 0x100
	// Position of CP1 field.
	SSC_SR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_SR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_SR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_SR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_SR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_SR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_SR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_SR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_SR_RXSYN = 0x800
	// Position of TXEN field.
	SSC_SR_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SSC_SR_TXEN_Msk = 0x10000
	// Bit TXEN.
	SSC_SR_TXEN = 0x10000
	// Position of RXEN field.
	SSC_SR_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SSC_SR_RXEN_Msk = 0x20000
	// Bit RXEN.
	SSC_SR_RXEN = 0x20000

	// IER: Interrupt Enable Register
	// Position of TXRDY field.
	SSC_IER_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IER_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IER_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IER_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IER_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IER_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IER_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IER_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IER_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IER_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IER_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IER_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IER_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IER_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IER_CP0 = 0x100
	// Position of CP1 field.
	SSC_IER_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IER_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IER_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IER_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IER_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IER_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IER_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IER_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IER_RXSYN = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXRDY field.
	SSC_IDR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IDR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IDR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IDR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IDR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IDR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IDR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IDR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IDR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IDR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IDR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IDR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IDR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IDR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IDR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IDR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IDR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IDR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IDR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IDR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IDR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IDR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IDR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IDR_RXSYN = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXRDY field.
	SSC_IMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IMR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IMR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IMR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IMR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IMR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IMR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IMR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IMR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IMR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IMR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IMR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IMR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IMR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IMR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IMR_RXSYN = 0x800

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	SSC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	SSC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	SSC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	SSC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	SSC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0.
	SSC_WPMR_WPKEY_PASSWD = 0x535343

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	SSC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	SSC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	SSC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	SSC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	SSC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for SUPC: Supply Controller
const (
	// CR: Supply Controller Control Register
	// Position of VROFF field.
	SUPC_CR_VROFF_Pos = 0x2
	// Bit mask of VROFF field.
	SUPC_CR_VROFF_Msk = 0x4
	// Bit VROFF.
	SUPC_CR_VROFF = 0x4
	// No effect.
	SUPC_CR_VROFF_NO_EFFECT = 0x0
	// If KEY is correct, VROFF asserts the vddcore_nreset and stops the voltage regulator.
	SUPC_CR_VROFF_STOP_VREG = 0x1
	// Position of XTALSEL field.
	SUPC_CR_XTALSEL_Pos = 0x3
	// Bit mask of XTALSEL field.
	SUPC_CR_XTALSEL_Msk = 0x8
	// Bit XTALSEL.
	SUPC_CR_XTALSEL = 0x8
	// No effect.
	SUPC_CR_XTALSEL_NO_EFFECT = 0x0
	// If KEY is correct, XTALSEL switches the slow clock on the crystal oscillator output.
	SUPC_CR_XTALSEL_CRYSTAL_SEL = 0x1
	// Position of KEY field.
	SUPC_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SUPC_CR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.
	SUPC_CR_KEY_PASSWD = 0xa5

	// SMMR: Supply Controller Supply Monitor Mode Register
	// Position of SMTH field.
	SUPC_SMMR_SMTH_Pos = 0x0
	// Bit mask of SMTH field.
	SUPC_SMMR_SMTH_Msk = 0xf
	// Position of SMSMPL field.
	SUPC_SMMR_SMSMPL_Pos = 0x8
	// Bit mask of SMSMPL field.
	SUPC_SMMR_SMSMPL_Msk = 0x700
	// Supply Monitor disabled
	SUPC_SMMR_SMSMPL_SMD = 0x0
	// Continuous Supply Monitor
	SUPC_SMMR_SMSMPL_CSM = 0x1
	// Supply Monitor enabled one SLCK period every 32 SLCK periods
	SUPC_SMMR_SMSMPL__32SLCK = 0x2
	// Supply Monitor enabled one SLCK period every 256 SLCK periods
	SUPC_SMMR_SMSMPL__256SLCK = 0x3
	// Supply Monitor enabled one SLCK period every 2,048 SLCK periods
	SUPC_SMMR_SMSMPL__2048SLCK = 0x4
	// Position of SMRSTEN field.
	SUPC_SMMR_SMRSTEN_Pos = 0xc
	// Bit mask of SMRSTEN field.
	SUPC_SMMR_SMRSTEN_Msk = 0x1000
	// Bit SMRSTEN.
	SUPC_SMMR_SMRSTEN = 0x1000
	// The core reset signal vddcore_nreset is not affected when a supply monitor detection occurs.
	SUPC_SMMR_SMRSTEN_NOT_ENABLE = 0x0
	// The core reset signal, vddcore_nreset is asserted when a supply monitor detection occurs.
	SUPC_SMMR_SMRSTEN_ENABLE = 0x1
	// Position of SMIEN field.
	SUPC_SMMR_SMIEN_Pos = 0xd
	// Bit mask of SMIEN field.
	SUPC_SMMR_SMIEN_Msk = 0x2000
	// Bit SMIEN.
	SUPC_SMMR_SMIEN = 0x2000
	// The SUPC interrupt signal is not affected when a supply monitor detection occurs.
	SUPC_SMMR_SMIEN_NOT_ENABLE = 0x0
	// The SUPC interrupt signal is asserted when a supply monitor detection occurs.
	SUPC_SMMR_SMIEN_ENABLE = 0x1

	// MR: Supply Controller Mode Register
	// Position of BODRSTEN field.
	SUPC_MR_BODRSTEN_Pos = 0xc
	// Bit mask of BODRSTEN field.
	SUPC_MR_BODRSTEN_Msk = 0x1000
	// Bit BODRSTEN.
	SUPC_MR_BODRSTEN = 0x1000
	// The core reset signal vddcore_nreset is not affected when a brownout detection occurs.
	SUPC_MR_BODRSTEN_NOT_ENABLE = 0x0
	// The core reset signal, vddcore_nreset is asserted when a brownout detection occurs.
	SUPC_MR_BODRSTEN_ENABLE = 0x1
	// Position of BODDIS field.
	SUPC_MR_BODDIS_Pos = 0xd
	// Bit mask of BODDIS field.
	SUPC_MR_BODDIS_Msk = 0x2000
	// Bit BODDIS.
	SUPC_MR_BODDIS = 0x2000
	// The core brownout detector is enabled.
	SUPC_MR_BODDIS_ENABLE = 0x0
	// The core brownout detector is disabled.
	SUPC_MR_BODDIS_DISABLE = 0x1
	// Position of ONREG field.
	SUPC_MR_ONREG_Pos = 0xe
	// Bit mask of ONREG field.
	SUPC_MR_ONREG_Msk = 0x4000
	// Bit ONREG.
	SUPC_MR_ONREG = 0x4000
	// Internal voltage regulator is not used (external power supply is used).
	SUPC_MR_ONREG_ONREG_UNUSED = 0x0
	// Internal voltage regulator is used.
	SUPC_MR_ONREG_ONREG_USED = 0x1
	// Position of BKUPRETON field.
	SUPC_MR_BKUPRETON_Pos = 0x11
	// Bit mask of BKUPRETON field.
	SUPC_MR_BKUPRETON_Msk = 0x20000
	// Bit BKUPRETON.
	SUPC_MR_BKUPRETON = 0x20000
	// Position of OSCBYPASS field.
	SUPC_MR_OSCBYPASS_Pos = 0x14
	// Bit mask of OSCBYPASS field.
	SUPC_MR_OSCBYPASS_Msk = 0x100000
	// Bit OSCBYPASS.
	SUPC_MR_OSCBYPASS = 0x100000
	// No effect. Clock selection depends on the value of XTALSEL (SUPC_CR).
	SUPC_MR_OSCBYPASS_NO_EFFECT = 0x0
	// The 32 kHz crystal oscillator is bypassed if XTALSEL (SUPC_CR) is set. OSCBYPASS must be set prior to setting XTALSEL.
	SUPC_MR_OSCBYPASS_BYPASS = 0x1
	// Position of KEY field.
	SUPC_MR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SUPC_MR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.
	SUPC_MR_KEY_PASSWD = 0xa5

	// WUMR: Supply Controller Wake-up Mode Register
	// Position of SMEN field.
	SUPC_WUMR_SMEN_Pos = 0x1
	// Bit mask of SMEN field.
	SUPC_WUMR_SMEN_Msk = 0x2
	// Bit SMEN.
	SUPC_WUMR_SMEN = 0x2
	// The supply monitor detection has no wake-up effect.
	SUPC_WUMR_SMEN_NOT_ENABLE = 0x0
	// The supply monitor detection forces the wake-up of the core power supply.
	SUPC_WUMR_SMEN_ENABLE = 0x1
	// Position of RTTEN field.
	SUPC_WUMR_RTTEN_Pos = 0x2
	// Bit mask of RTTEN field.
	SUPC_WUMR_RTTEN_Msk = 0x4
	// Bit RTTEN.
	SUPC_WUMR_RTTEN = 0x4
	// The RTT alarm signal has no wake-up effect.
	SUPC_WUMR_RTTEN_NOT_ENABLE = 0x0
	// The RTT alarm signal forces the wake-up of the core power supply.
	SUPC_WUMR_RTTEN_ENABLE = 0x1
	// Position of RTCEN field.
	SUPC_WUMR_RTCEN_Pos = 0x3
	// Bit mask of RTCEN field.
	SUPC_WUMR_RTCEN_Msk = 0x8
	// Bit RTCEN.
	SUPC_WUMR_RTCEN = 0x8
	// The RTC alarm signal has no wake-up effect.
	SUPC_WUMR_RTCEN_NOT_ENABLE = 0x0
	// The RTC alarm signal forces the wake-up of the core power supply.
	SUPC_WUMR_RTCEN_ENABLE = 0x1
	// Position of LPDBCEN0 field.
	SUPC_WUMR_LPDBCEN0_Pos = 0x5
	// Bit mask of LPDBCEN0 field.
	SUPC_WUMR_LPDBCEN0_Msk = 0x20
	// Bit LPDBCEN0.
	SUPC_WUMR_LPDBCEN0 = 0x20
	// The WKUP0 input pin is not connected to the low-power debouncer.
	SUPC_WUMR_LPDBCEN0_NOT_ENABLE = 0x0
	// The WKUP0 input pin is connected to the low-power debouncer and forces a system wake-up.
	SUPC_WUMR_LPDBCEN0_ENABLE = 0x1
	// Position of LPDBCEN1 field.
	SUPC_WUMR_LPDBCEN1_Pos = 0x6
	// Bit mask of LPDBCEN1 field.
	SUPC_WUMR_LPDBCEN1_Msk = 0x40
	// Bit LPDBCEN1.
	SUPC_WUMR_LPDBCEN1 = 0x40
	// The WKUP1 input pin is not connected to the low-power debouncer.
	SUPC_WUMR_LPDBCEN1_NOT_ENABLE = 0x0
	// The WKUP1 input pin is connected to the low-power debouncer and forces a system wake-up.
	SUPC_WUMR_LPDBCEN1_ENABLE = 0x1
	// Position of LPDBCCLR field.
	SUPC_WUMR_LPDBCCLR_Pos = 0x7
	// Bit mask of LPDBCCLR field.
	SUPC_WUMR_LPDBCCLR_Msk = 0x80
	// Bit LPDBCCLR.
	SUPC_WUMR_LPDBCCLR = 0x80
	// A low-power debounce event does not create an immediate clear on the first half of GPBR registers.
	SUPC_WUMR_LPDBCCLR_NOT_ENABLE = 0x0
	// A low-power debounce event on WKUP0 or WKUP1 generates an immediate clear on the first half of GPBR registers.
	SUPC_WUMR_LPDBCCLR_ENABLE = 0x1
	// Position of WKUPDBC field.
	SUPC_WUMR_WKUPDBC_Pos = 0xc
	// Bit mask of WKUPDBC field.
	SUPC_WUMR_WKUPDBC_Msk = 0x7000
	// Immediate, no debouncing, detected active at least on one Slow Clock edge.
	SUPC_WUMR_WKUPDBC_IMMEDIATE = 0x0
	// WKUPx shall be in its active state for at least 3 SLCK periods
	SUPC_WUMR_WKUPDBC__3_SLCK = 0x1
	// WKUPx shall be in its active state for at least 32 SLCK periods
	SUPC_WUMR_WKUPDBC__32_SLCK = 0x2
	// WKUPx shall be in its active state for at least 512 SLCK periods
	SUPC_WUMR_WKUPDBC__512_SLCK = 0x3
	// WKUPx shall be in its active state for at least 4,096 SLCK periods
	SUPC_WUMR_WKUPDBC__4096_SLCK = 0x4
	// WKUPx shall be in its active state for at least 32,768 SLCK periods
	SUPC_WUMR_WKUPDBC__32768_SLCK = 0x5
	// Position of LPDBC field.
	SUPC_WUMR_LPDBC_Pos = 0x10
	// Bit mask of LPDBC field.
	SUPC_WUMR_LPDBC_Msk = 0x70000
	// Disable the low-power debouncers.
	SUPC_WUMR_LPDBC_DISABLE = 0x0
	// WKUP0/1 in active state for at least 2 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__2_RTCOUT = 0x1
	// WKUP0/1 in active state for at least 3 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__3_RTCOUT = 0x2
	// WKUP0/1 in active state for at least 4 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__4_RTCOUT = 0x3
	// WKUP0/1 in active state for at least 5 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__5_RTCOUT = 0x4
	// WKUP0/1 in active state for at least 6 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__6_RTCOUT = 0x5
	// WKUP0/1 in active state for at least 7 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__7_RTCOUT = 0x6
	// WKUP0/1 in active state for at least 8 RTCOUTx clock periods
	SUPC_WUMR_LPDBC__8_RTCOUT = 0x7

	// WUIR: Supply Controller Wake-up Inputs Register
	// Position of WKUPEN0 field.
	SUPC_WUIR_WKUPEN0_Pos = 0x0
	// Bit mask of WKUPEN0 field.
	SUPC_WUIR_WKUPEN0_Msk = 0x1
	// Bit WKUPEN0.
	SUPC_WUIR_WKUPEN0 = 0x1
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN0_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN0_ENABLE = 0x1
	// Position of WKUPEN1 field.
	SUPC_WUIR_WKUPEN1_Pos = 0x1
	// Bit mask of WKUPEN1 field.
	SUPC_WUIR_WKUPEN1_Msk = 0x2
	// Bit WKUPEN1.
	SUPC_WUIR_WKUPEN1 = 0x2
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN1_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN1_ENABLE = 0x1
	// Position of WKUPEN2 field.
	SUPC_WUIR_WKUPEN2_Pos = 0x2
	// Bit mask of WKUPEN2 field.
	SUPC_WUIR_WKUPEN2_Msk = 0x4
	// Bit WKUPEN2.
	SUPC_WUIR_WKUPEN2 = 0x4
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN2_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN2_ENABLE = 0x1
	// Position of WKUPEN3 field.
	SUPC_WUIR_WKUPEN3_Pos = 0x3
	// Bit mask of WKUPEN3 field.
	SUPC_WUIR_WKUPEN3_Msk = 0x8
	// Bit WKUPEN3.
	SUPC_WUIR_WKUPEN3 = 0x8
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN3_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN3_ENABLE = 0x1
	// Position of WKUPEN4 field.
	SUPC_WUIR_WKUPEN4_Pos = 0x4
	// Bit mask of WKUPEN4 field.
	SUPC_WUIR_WKUPEN4_Msk = 0x10
	// Bit WKUPEN4.
	SUPC_WUIR_WKUPEN4 = 0x10
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN4_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN4_ENABLE = 0x1
	// Position of WKUPEN5 field.
	SUPC_WUIR_WKUPEN5_Pos = 0x5
	// Bit mask of WKUPEN5 field.
	SUPC_WUIR_WKUPEN5_Msk = 0x20
	// Bit WKUPEN5.
	SUPC_WUIR_WKUPEN5 = 0x20
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN5_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN5_ENABLE = 0x1
	// Position of WKUPEN6 field.
	SUPC_WUIR_WKUPEN6_Pos = 0x6
	// Bit mask of WKUPEN6 field.
	SUPC_WUIR_WKUPEN6_Msk = 0x40
	// Bit WKUPEN6.
	SUPC_WUIR_WKUPEN6 = 0x40
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN6_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN6_ENABLE = 0x1
	// Position of WKUPEN7 field.
	SUPC_WUIR_WKUPEN7_Pos = 0x7
	// Bit mask of WKUPEN7 field.
	SUPC_WUIR_WKUPEN7_Msk = 0x80
	// Bit WKUPEN7.
	SUPC_WUIR_WKUPEN7 = 0x80
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN7_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN7_ENABLE = 0x1
	// Position of WKUPEN8 field.
	SUPC_WUIR_WKUPEN8_Pos = 0x8
	// Bit mask of WKUPEN8 field.
	SUPC_WUIR_WKUPEN8_Msk = 0x100
	// Bit WKUPEN8.
	SUPC_WUIR_WKUPEN8 = 0x100
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN8_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN8_ENABLE = 0x1
	// Position of WKUPEN9 field.
	SUPC_WUIR_WKUPEN9_Pos = 0x9
	// Bit mask of WKUPEN9 field.
	SUPC_WUIR_WKUPEN9_Msk = 0x200
	// Bit WKUPEN9.
	SUPC_WUIR_WKUPEN9 = 0x200
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN9_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN9_ENABLE = 0x1
	// Position of WKUPEN10 field.
	SUPC_WUIR_WKUPEN10_Pos = 0xa
	// Bit mask of WKUPEN10 field.
	SUPC_WUIR_WKUPEN10_Msk = 0x400
	// Bit WKUPEN10.
	SUPC_WUIR_WKUPEN10 = 0x400
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN10_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN10_ENABLE = 0x1
	// Position of WKUPEN11 field.
	SUPC_WUIR_WKUPEN11_Pos = 0xb
	// Bit mask of WKUPEN11 field.
	SUPC_WUIR_WKUPEN11_Msk = 0x800
	// Bit WKUPEN11.
	SUPC_WUIR_WKUPEN11 = 0x800
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN11_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN11_ENABLE = 0x1
	// Position of WKUPEN12 field.
	SUPC_WUIR_WKUPEN12_Pos = 0xc
	// Bit mask of WKUPEN12 field.
	SUPC_WUIR_WKUPEN12_Msk = 0x1000
	// Bit WKUPEN12.
	SUPC_WUIR_WKUPEN12 = 0x1000
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN12_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN12_ENABLE = 0x1
	// Position of WKUPEN13 field.
	SUPC_WUIR_WKUPEN13_Pos = 0xd
	// Bit mask of WKUPEN13 field.
	SUPC_WUIR_WKUPEN13_Msk = 0x2000
	// Bit WKUPEN13.
	SUPC_WUIR_WKUPEN13 = 0x2000
	// The corresponding wake-up input has no wake-up effect.
	SUPC_WUIR_WKUPEN13_DISABLE = 0x0
	// The corresponding wake-up input is enabled for a wake-up of the core power supply.
	SUPC_WUIR_WKUPEN13_ENABLE = 0x1
	// Position of WKUPT0 field.
	SUPC_WUIR_WKUPT0_Pos = 0x10
	// Bit mask of WKUPT0 field.
	SUPC_WUIR_WKUPT0_Msk = 0x10000
	// Bit WKUPT0.
	SUPC_WUIR_WKUPT0 = 0x10000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT0_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT0_HIGH = 0x1
	// Position of WKUPT1 field.
	SUPC_WUIR_WKUPT1_Pos = 0x11
	// Bit mask of WKUPT1 field.
	SUPC_WUIR_WKUPT1_Msk = 0x20000
	// Bit WKUPT1.
	SUPC_WUIR_WKUPT1 = 0x20000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT1_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT1_HIGH = 0x1
	// Position of WKUPT2 field.
	SUPC_WUIR_WKUPT2_Pos = 0x12
	// Bit mask of WKUPT2 field.
	SUPC_WUIR_WKUPT2_Msk = 0x40000
	// Bit WKUPT2.
	SUPC_WUIR_WKUPT2 = 0x40000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT2_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT2_HIGH = 0x1
	// Position of WKUPT3 field.
	SUPC_WUIR_WKUPT3_Pos = 0x13
	// Bit mask of WKUPT3 field.
	SUPC_WUIR_WKUPT3_Msk = 0x80000
	// Bit WKUPT3.
	SUPC_WUIR_WKUPT3 = 0x80000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT3_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT3_HIGH = 0x1
	// Position of WKUPT4 field.
	SUPC_WUIR_WKUPT4_Pos = 0x14
	// Bit mask of WKUPT4 field.
	SUPC_WUIR_WKUPT4_Msk = 0x100000
	// Bit WKUPT4.
	SUPC_WUIR_WKUPT4 = 0x100000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT4_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT4_HIGH = 0x1
	// Position of WKUPT5 field.
	SUPC_WUIR_WKUPT5_Pos = 0x15
	// Bit mask of WKUPT5 field.
	SUPC_WUIR_WKUPT5_Msk = 0x200000
	// Bit WKUPT5.
	SUPC_WUIR_WKUPT5 = 0x200000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT5_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT5_HIGH = 0x1
	// Position of WKUPT6 field.
	SUPC_WUIR_WKUPT6_Pos = 0x16
	// Bit mask of WKUPT6 field.
	SUPC_WUIR_WKUPT6_Msk = 0x400000
	// Bit WKUPT6.
	SUPC_WUIR_WKUPT6 = 0x400000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT6_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT6_HIGH = 0x1
	// Position of WKUPT7 field.
	SUPC_WUIR_WKUPT7_Pos = 0x17
	// Bit mask of WKUPT7 field.
	SUPC_WUIR_WKUPT7_Msk = 0x800000
	// Bit WKUPT7.
	SUPC_WUIR_WKUPT7 = 0x800000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT7_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT7_HIGH = 0x1
	// Position of WKUPT8 field.
	SUPC_WUIR_WKUPT8_Pos = 0x18
	// Bit mask of WKUPT8 field.
	SUPC_WUIR_WKUPT8_Msk = 0x1000000
	// Bit WKUPT8.
	SUPC_WUIR_WKUPT8 = 0x1000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT8_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT8_HIGH = 0x1
	// Position of WKUPT9 field.
	SUPC_WUIR_WKUPT9_Pos = 0x19
	// Bit mask of WKUPT9 field.
	SUPC_WUIR_WKUPT9_Msk = 0x2000000
	// Bit WKUPT9.
	SUPC_WUIR_WKUPT9 = 0x2000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT9_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT9_HIGH = 0x1
	// Position of WKUPT10 field.
	SUPC_WUIR_WKUPT10_Pos = 0x1a
	// Bit mask of WKUPT10 field.
	SUPC_WUIR_WKUPT10_Msk = 0x4000000
	// Bit WKUPT10.
	SUPC_WUIR_WKUPT10 = 0x4000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT10_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT10_HIGH = 0x1
	// Position of WKUPT11 field.
	SUPC_WUIR_WKUPT11_Pos = 0x1b
	// Bit mask of WKUPT11 field.
	SUPC_WUIR_WKUPT11_Msk = 0x8000000
	// Bit WKUPT11.
	SUPC_WUIR_WKUPT11 = 0x8000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT11_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT11_HIGH = 0x1
	// Position of WKUPT12 field.
	SUPC_WUIR_WKUPT12_Pos = 0x1c
	// Bit mask of WKUPT12 field.
	SUPC_WUIR_WKUPT12_Msk = 0x10000000
	// Bit WKUPT12.
	SUPC_WUIR_WKUPT12 = 0x10000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT12_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT12_HIGH = 0x1
	// Position of WKUPT13 field.
	SUPC_WUIR_WKUPT13_Pos = 0x1d
	// Bit mask of WKUPT13 field.
	SUPC_WUIR_WKUPT13_Msk = 0x20000000
	// Bit WKUPT13.
	SUPC_WUIR_WKUPT13 = 0x20000000
	// A falling edge followed by a low level for a period defined by WKUPDBC on the corre-sponding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT13_LOW = 0x0
	// A rising edge followed by a high level for a period defined by WKUPDBC on the cor-responding wake-up input forces the wake-up of the core power supply.
	SUPC_WUIR_WKUPT13_HIGH = 0x1

	// SR: Supply Controller Status Register
	// Position of WKUPS field.
	SUPC_SR_WKUPS_Pos = 0x1
	// Bit mask of WKUPS field.
	SUPC_SR_WKUPS_Msk = 0x2
	// Bit WKUPS.
	SUPC_SR_WKUPS = 0x2
	// No wake-up due to the assertion of the WKUP pins has occurred since the last read of SUPC_SR.
	SUPC_SR_WKUPS_NO = 0x0
	// At least one wake-up due to the assertion of the WKUP pins has occurred since the last read of SUPC_SR.
	SUPC_SR_WKUPS_PRESENT = 0x1
	// Position of SMWS field.
	SUPC_SR_SMWS_Pos = 0x2
	// Bit mask of SMWS field.
	SUPC_SR_SMWS_Msk = 0x4
	// Bit SMWS.
	SUPC_SR_SMWS = 0x4
	// No wake-up due to a supply monitor detection has occurred since the last read of SUPC_SR.
	SUPC_SR_SMWS_NO = 0x0
	// At least one wake-up due to a supply monitor detection has occurred since the last read of SUPC_SR.
	SUPC_SR_SMWS_PRESENT = 0x1
	// Position of BODRSTS field.
	SUPC_SR_BODRSTS_Pos = 0x3
	// Bit mask of BODRSTS field.
	SUPC_SR_BODRSTS_Msk = 0x8
	// Bit BODRSTS.
	SUPC_SR_BODRSTS = 0x8
	// No core brownout rising edge event has been detected since the last read of the SUPC_SR.
	SUPC_SR_BODRSTS_NO = 0x0
	// At least one brownout output rising edge event has been detected since the last read of the SUPC_SR.
	SUPC_SR_BODRSTS_PRESENT = 0x1
	// Position of SMRSTS field.
	SUPC_SR_SMRSTS_Pos = 0x4
	// Bit mask of SMRSTS field.
	SUPC_SR_SMRSTS_Msk = 0x10
	// Bit SMRSTS.
	SUPC_SR_SMRSTS = 0x10
	// No supply monitor detection has generated a core reset since the last read of the SUPC_SR.
	SUPC_SR_SMRSTS_NO = 0x0
	// At least one supply monitor detection has generated a core reset since the last read of the SUPC_SR.
	SUPC_SR_SMRSTS_PRESENT = 0x1
	// Position of SMS field.
	SUPC_SR_SMS_Pos = 0x5
	// Bit mask of SMS field.
	SUPC_SR_SMS_Msk = 0x20
	// Bit SMS.
	SUPC_SR_SMS = 0x20
	// No supply monitor detection since the last read of SUPC_SR.
	SUPC_SR_SMS_NO = 0x0
	// At least one supply monitor detection since the last read of SUPC_SR.
	SUPC_SR_SMS_PRESENT = 0x1
	// Position of SMOS field.
	SUPC_SR_SMOS_Pos = 0x6
	// Bit mask of SMOS field.
	SUPC_SR_SMOS_Msk = 0x40
	// Bit SMOS.
	SUPC_SR_SMOS = 0x40
	// The supply monitor detected VDDIO higher than its threshold at its last measurement.
	SUPC_SR_SMOS_HIGH = 0x0
	// The supply monitor detected VDDIO lower than its threshold at its last measurement.
	SUPC_SR_SMOS_LOW = 0x1
	// Position of OSCSEL field.
	SUPC_SR_OSCSEL_Pos = 0x7
	// Bit mask of OSCSEL field.
	SUPC_SR_OSCSEL_Msk = 0x80
	// Bit OSCSEL.
	SUPC_SR_OSCSEL = 0x80
	// The slow clock, SLCK, is generated by the embedded 32 kHz RC oscillator.
	SUPC_SR_OSCSEL_RC = 0x0
	// The slow clock, SLCK, is generated by the 32 kHz crystal oscillator.
	SUPC_SR_OSCSEL_CRYST = 0x1
	// Position of LPDBCS0 field.
	SUPC_SR_LPDBCS0_Pos = 0xd
	// Bit mask of LPDBCS0 field.
	SUPC_SR_LPDBCS0_Msk = 0x2000
	// Bit LPDBCS0.
	SUPC_SR_LPDBCS0 = 0x2000
	// No wake-up due to the assertion of the WKUP0 pin has occurred since the last read of SUPC_SR.
	SUPC_SR_LPDBCS0_NO = 0x0
	// At least one wake-up due to the assertion of the WKUP0 pin has occurred since the last read of SUPC_SR.
	SUPC_SR_LPDBCS0_PRESENT = 0x1
	// Position of LPDBCS1 field.
	SUPC_SR_LPDBCS1_Pos = 0xe
	// Bit mask of LPDBCS1 field.
	SUPC_SR_LPDBCS1_Msk = 0x4000
	// Bit LPDBCS1.
	SUPC_SR_LPDBCS1 = 0x4000
	// No wake-up due to the assertion of the WKUP1 pin has occurred since the last read of SUPC_SR.
	SUPC_SR_LPDBCS1_NO = 0x0
	// At least one wake-up due to the assertion of the WKUP1 pin has occurred since the last read of SUPC_SR.
	SUPC_SR_LPDBCS1_PRESENT = 0x1
	// Position of WKUPIS0 field.
	SUPC_SR_WKUPIS0_Pos = 0x10
	// Bit mask of WKUPIS0 field.
	SUPC_SR_WKUPIS0_Msk = 0x10000
	// Bit WKUPIS0.
	SUPC_SR_WKUPIS0 = 0x10000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS0_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS0_EN = 0x1
	// Position of WKUPIS1 field.
	SUPC_SR_WKUPIS1_Pos = 0x11
	// Bit mask of WKUPIS1 field.
	SUPC_SR_WKUPIS1_Msk = 0x20000
	// Bit WKUPIS1.
	SUPC_SR_WKUPIS1 = 0x20000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS1_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS1_EN = 0x1
	// Position of WKUPIS2 field.
	SUPC_SR_WKUPIS2_Pos = 0x12
	// Bit mask of WKUPIS2 field.
	SUPC_SR_WKUPIS2_Msk = 0x40000
	// Bit WKUPIS2.
	SUPC_SR_WKUPIS2 = 0x40000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS2_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS2_EN = 0x1
	// Position of WKUPIS3 field.
	SUPC_SR_WKUPIS3_Pos = 0x13
	// Bit mask of WKUPIS3 field.
	SUPC_SR_WKUPIS3_Msk = 0x80000
	// Bit WKUPIS3.
	SUPC_SR_WKUPIS3 = 0x80000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS3_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS3_EN = 0x1
	// Position of WKUPIS4 field.
	SUPC_SR_WKUPIS4_Pos = 0x14
	// Bit mask of WKUPIS4 field.
	SUPC_SR_WKUPIS4_Msk = 0x100000
	// Bit WKUPIS4.
	SUPC_SR_WKUPIS4 = 0x100000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS4_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS4_EN = 0x1
	// Position of WKUPIS5 field.
	SUPC_SR_WKUPIS5_Pos = 0x15
	// Bit mask of WKUPIS5 field.
	SUPC_SR_WKUPIS5_Msk = 0x200000
	// Bit WKUPIS5.
	SUPC_SR_WKUPIS5 = 0x200000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS5_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS5_EN = 0x1
	// Position of WKUPIS6 field.
	SUPC_SR_WKUPIS6_Pos = 0x16
	// Bit mask of WKUPIS6 field.
	SUPC_SR_WKUPIS6_Msk = 0x400000
	// Bit WKUPIS6.
	SUPC_SR_WKUPIS6 = 0x400000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS6_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS6_EN = 0x1
	// Position of WKUPIS7 field.
	SUPC_SR_WKUPIS7_Pos = 0x17
	// Bit mask of WKUPIS7 field.
	SUPC_SR_WKUPIS7_Msk = 0x800000
	// Bit WKUPIS7.
	SUPC_SR_WKUPIS7 = 0x800000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS7_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS7_EN = 0x1
	// Position of WKUPIS8 field.
	SUPC_SR_WKUPIS8_Pos = 0x18
	// Bit mask of WKUPIS8 field.
	SUPC_SR_WKUPIS8_Msk = 0x1000000
	// Bit WKUPIS8.
	SUPC_SR_WKUPIS8 = 0x1000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS8_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS8_EN = 0x1
	// Position of WKUPIS9 field.
	SUPC_SR_WKUPIS9_Pos = 0x19
	// Bit mask of WKUPIS9 field.
	SUPC_SR_WKUPIS9_Msk = 0x2000000
	// Bit WKUPIS9.
	SUPC_SR_WKUPIS9 = 0x2000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS9_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS9_EN = 0x1
	// Position of WKUPIS10 field.
	SUPC_SR_WKUPIS10_Pos = 0x1a
	// Bit mask of WKUPIS10 field.
	SUPC_SR_WKUPIS10_Msk = 0x4000000
	// Bit WKUPIS10.
	SUPC_SR_WKUPIS10 = 0x4000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS10_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS10_EN = 0x1
	// Position of WKUPIS11 field.
	SUPC_SR_WKUPIS11_Pos = 0x1b
	// Bit mask of WKUPIS11 field.
	SUPC_SR_WKUPIS11_Msk = 0x8000000
	// Bit WKUPIS11.
	SUPC_SR_WKUPIS11 = 0x8000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS11_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS11_EN = 0x1
	// Position of WKUPIS12 field.
	SUPC_SR_WKUPIS12_Pos = 0x1c
	// Bit mask of WKUPIS12 field.
	SUPC_SR_WKUPIS12_Msk = 0x10000000
	// Bit WKUPIS12.
	SUPC_SR_WKUPIS12 = 0x10000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS12_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS12_EN = 0x1
	// Position of WKUPIS13 field.
	SUPC_SR_WKUPIS13_Pos = 0x1d
	// Bit mask of WKUPIS13 field.
	SUPC_SR_WKUPIS13_Msk = 0x20000000
	// Bit WKUPIS13.
	SUPC_SR_WKUPIS13 = 0x20000000
	// The corresponding wake-up input is disabled, or was inactive at the time the debouncer triggered a wake-up event.
	SUPC_SR_WKUPIS13_DIS = 0x0
	// The corresponding wake-up input was active at the time the debouncer triggered a wake-up event since the last read of SUPC_SR.
	SUPC_SR_WKUPIS13_EN = 0x1
)

// Constants for TC0: Timer Counter
const (
	// TC_CHANNEL.CCR: Channel Control Register (channel = 0)
	// Position of CLKEN field.
	TC_TC_CHANNEL_CCR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_TC_CHANNEL_CCR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_TC_CHANNEL_CCR_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_TC_CHANNEL_CCR_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_TC_CHANNEL_CCR_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_TC_CHANNEL_CCR_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_TC_CHANNEL_CCR_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_TC_CHANNEL_CCR_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_TC_CHANNEL_CCR_SWTRG = 0x4

	// TC_CHANNEL.CMR: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_TC_CHANNEL_CMR_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_TC_CHANNEL_CMR_TCCLKS_Msk = 0x7
	// Clock selected: internal PCK6 clock signal (from PMC)
	TC_TC_CHANNEL_CMR_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: internal MCK/8 clock signal (from PMC)
	TC_TC_CHANNEL_CMR_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: internal MCK/32 clock signal (from PMC)
	TC_TC_CHANNEL_CMR_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: internal MCK/128 clock signal (from PMC)
	TC_TC_CHANNEL_CMR_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: internal SLCK clock signal (from PMC)
	TC_TC_CHANNEL_CMR_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_TC_CHANNEL_CMR_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_TC_CHANNEL_CMR_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_TC_CHANNEL_CMR_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_TC_CHANNEL_CMR_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_TC_CHANNEL_CMR_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_TC_CHANNEL_CMR_CLKI = 0x8
	// Position of BURST field.
	TC_TC_CHANNEL_CMR_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_TC_CHANNEL_CMR_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_TC_CHANNEL_CMR_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_TC_CHANNEL_CMR_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_TC_CHANNEL_CMR_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_TC_CHANNEL_CMR_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_TC_CHANNEL_CMR_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_TC_CHANNEL_CMR_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_TC_CHANNEL_CMR_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_TC_CHANNEL_CMR_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_TC_CHANNEL_CMR_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_TC_CHANNEL_CMR_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_TC_CHANNEL_CMR_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_TC_CHANNEL_CMR_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_TC_CHANNEL_CMR_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_TC_CHANNEL_CMR_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_TC_CHANNEL_CMR_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_TC_CHANNEL_CMR_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_TC_CHANNEL_CMR_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_TC_CHANNEL_CMR_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_TC_CHANNEL_CMR_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_TC_CHANNEL_CMR_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_TC_CHANNEL_CMR_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_TC_CHANNEL_CMR_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_TC_CHANNEL_CMR_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_TC_CHANNEL_CMR_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_TC_CHANNEL_CMR_WAVE = 0x8000
	// Position of LDRA field.
	TC_TC_CHANNEL_CMR_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_TC_CHANNEL_CMR_LDRA_Msk = 0x30000
	// None
	TC_TC_CHANNEL_CMR_LDRA_NONE = 0x0
	// Rising edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRA_RISING = 0x1
	// Falling edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRA_FALLING = 0x2
	// Each edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_TC_CHANNEL_CMR_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_TC_CHANNEL_CMR_LDRB_Msk = 0xc0000
	// None
	TC_TC_CHANNEL_CMR_LDRB_NONE = 0x0
	// Rising edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRB_RISING = 0x1
	// Falling edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRB_FALLING = 0x2
	// Each edge of TIOAx
	TC_TC_CHANNEL_CMR_LDRB_EDGE = 0x3
	// Position of SBSMPLR field.
	TC_TC_CHANNEL_CMR_SBSMPLR_Pos = 0x14
	// Bit mask of SBSMPLR field.
	TC_TC_CHANNEL_CMR_SBSMPLR_Msk = 0x700000
	// Load a Capture Register each selected edge
	TC_TC_CHANNEL_CMR_SBSMPLR_ONE = 0x0
	// Load a Capture Register every 2 selected edges
	TC_TC_CHANNEL_CMR_SBSMPLR_HALF = 0x1
	// Load a Capture Register every 4 selected edges
	TC_TC_CHANNEL_CMR_SBSMPLR_FOURTH = 0x2
	// Load a Capture Register every 8 selected edges
	TC_TC_CHANNEL_CMR_SBSMPLR_EIGHTH = 0x3
	// Load a Capture Register every 16 selected edges
	TC_TC_CHANNEL_CMR_SBSMPLR_SIXTEENTH = 0x4

	// TC_CHANNEL.SMMR: Stepper Motor Mode Register (channel = 0)
	// Position of GCEN field.
	TC_TC_CHANNEL_SMMR_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_TC_CHANNEL_SMMR_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_TC_CHANNEL_SMMR_GCEN = 0x1
	// Position of DOWN field.
	TC_TC_CHANNEL_SMMR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_TC_CHANNEL_SMMR_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_TC_CHANNEL_SMMR_DOWN = 0x2

	// TC_CHANNEL.RAB: Register AB (channel = 0)
	// Position of RAB field.
	TC_TC_CHANNEL_RAB_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_TC_CHANNEL_RAB_RAB_Msk = 0xffffffff

	// TC_CHANNEL.CV: Counter Value (channel = 0)
	// Position of CV field.
	TC_TC_CHANNEL_CV_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_TC_CHANNEL_CV_CV_Msk = 0xffffffff

	// TC_CHANNEL.RA: Register A (channel = 0)
	// Position of RA field.
	TC_TC_CHANNEL_RA_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_TC_CHANNEL_RA_RA_Msk = 0xffffffff

	// TC_CHANNEL.RB: Register B (channel = 0)
	// Position of RB field.
	TC_TC_CHANNEL_RB_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_TC_CHANNEL_RB_RB_Msk = 0xffffffff

	// TC_CHANNEL.RC: Register C (channel = 0)
	// Position of RC field.
	TC_TC_CHANNEL_RC_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_TC_CHANNEL_RC_RC_Msk = 0xffffffff

	// TC_CHANNEL.SR: Status Register (channel = 0)
	// Position of COVFS field.
	TC_TC_CHANNEL_SR_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_TC_CHANNEL_SR_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_TC_CHANNEL_SR_COVFS = 0x1
	// Position of LOVRS field.
	TC_TC_CHANNEL_SR_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_TC_CHANNEL_SR_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_TC_CHANNEL_SR_LOVRS = 0x2
	// Position of CPAS field.
	TC_TC_CHANNEL_SR_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_TC_CHANNEL_SR_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_TC_CHANNEL_SR_CPAS = 0x4
	// Position of CPBS field.
	TC_TC_CHANNEL_SR_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_TC_CHANNEL_SR_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_TC_CHANNEL_SR_CPBS = 0x8
	// Position of CPCS field.
	TC_TC_CHANNEL_SR_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_TC_CHANNEL_SR_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_TC_CHANNEL_SR_CPCS = 0x10
	// Position of LDRAS field.
	TC_TC_CHANNEL_SR_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_TC_CHANNEL_SR_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_TC_CHANNEL_SR_LDRAS = 0x20
	// Position of LDRBS field.
	TC_TC_CHANNEL_SR_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_TC_CHANNEL_SR_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_TC_CHANNEL_SR_LDRBS = 0x40
	// Position of ETRGS field.
	TC_TC_CHANNEL_SR_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_TC_CHANNEL_SR_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_TC_CHANNEL_SR_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_TC_CHANNEL_SR_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_TC_CHANNEL_SR_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_TC_CHANNEL_SR_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_TC_CHANNEL_SR_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_TC_CHANNEL_SR_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_TC_CHANNEL_SR_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_TC_CHANNEL_SR_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_TC_CHANNEL_SR_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_TC_CHANNEL_SR_MTIOB = 0x40000

	// TC_CHANNEL.IER: Interrupt Enable Register (channel = 0)
	// Position of COVFS field.
	TC_TC_CHANNEL_IER_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_TC_CHANNEL_IER_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_TC_CHANNEL_IER_COVFS = 0x1
	// Position of LOVRS field.
	TC_TC_CHANNEL_IER_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_TC_CHANNEL_IER_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_TC_CHANNEL_IER_LOVRS = 0x2
	// Position of CPAS field.
	TC_TC_CHANNEL_IER_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_TC_CHANNEL_IER_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_TC_CHANNEL_IER_CPAS = 0x4
	// Position of CPBS field.
	TC_TC_CHANNEL_IER_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_TC_CHANNEL_IER_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_TC_CHANNEL_IER_CPBS = 0x8
	// Position of CPCS field.
	TC_TC_CHANNEL_IER_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_TC_CHANNEL_IER_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_TC_CHANNEL_IER_CPCS = 0x10
	// Position of LDRAS field.
	TC_TC_CHANNEL_IER_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_TC_CHANNEL_IER_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_TC_CHANNEL_IER_LDRAS = 0x20
	// Position of LDRBS field.
	TC_TC_CHANNEL_IER_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_TC_CHANNEL_IER_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_TC_CHANNEL_IER_LDRBS = 0x40
	// Position of ETRGS field.
	TC_TC_CHANNEL_IER_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_TC_CHANNEL_IER_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_TC_CHANNEL_IER_ETRGS = 0x80

	// TC_CHANNEL.IDR: Interrupt Disable Register (channel = 0)
	// Position of COVFS field.
	TC_TC_CHANNEL_IDR_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_TC_CHANNEL_IDR_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_TC_CHANNEL_IDR_COVFS = 0x1
	// Position of LOVRS field.
	TC_TC_CHANNEL_IDR_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_TC_CHANNEL_IDR_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_TC_CHANNEL_IDR_LOVRS = 0x2
	// Position of CPAS field.
	TC_TC_CHANNEL_IDR_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_TC_CHANNEL_IDR_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_TC_CHANNEL_IDR_CPAS = 0x4
	// Position of CPBS field.
	TC_TC_CHANNEL_IDR_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_TC_CHANNEL_IDR_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_TC_CHANNEL_IDR_CPBS = 0x8
	// Position of CPCS field.
	TC_TC_CHANNEL_IDR_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_TC_CHANNEL_IDR_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_TC_CHANNEL_IDR_CPCS = 0x10
	// Position of LDRAS field.
	TC_TC_CHANNEL_IDR_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_TC_CHANNEL_IDR_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_TC_CHANNEL_IDR_LDRAS = 0x20
	// Position of LDRBS field.
	TC_TC_CHANNEL_IDR_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_TC_CHANNEL_IDR_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_TC_CHANNEL_IDR_LDRBS = 0x40
	// Position of ETRGS field.
	TC_TC_CHANNEL_IDR_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_TC_CHANNEL_IDR_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_TC_CHANNEL_IDR_ETRGS = 0x80

	// TC_CHANNEL.IMR: Interrupt Mask Register (channel = 0)
	// Position of COVFS field.
	TC_TC_CHANNEL_IMR_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_TC_CHANNEL_IMR_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_TC_CHANNEL_IMR_COVFS = 0x1
	// Position of LOVRS field.
	TC_TC_CHANNEL_IMR_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_TC_CHANNEL_IMR_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_TC_CHANNEL_IMR_LOVRS = 0x2
	// Position of CPAS field.
	TC_TC_CHANNEL_IMR_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_TC_CHANNEL_IMR_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_TC_CHANNEL_IMR_CPAS = 0x4
	// Position of CPBS field.
	TC_TC_CHANNEL_IMR_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_TC_CHANNEL_IMR_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_TC_CHANNEL_IMR_CPBS = 0x8
	// Position of CPCS field.
	TC_TC_CHANNEL_IMR_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_TC_CHANNEL_IMR_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_TC_CHANNEL_IMR_CPCS = 0x10
	// Position of LDRAS field.
	TC_TC_CHANNEL_IMR_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_TC_CHANNEL_IMR_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_TC_CHANNEL_IMR_LDRAS = 0x20
	// Position of LDRBS field.
	TC_TC_CHANNEL_IMR_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_TC_CHANNEL_IMR_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_TC_CHANNEL_IMR_LDRBS = 0x40
	// Position of ETRGS field.
	TC_TC_CHANNEL_IMR_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_TC_CHANNEL_IMR_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_TC_CHANNEL_IMR_ETRGS = 0x80

	// TC_CHANNEL.EMR: Extended Mode Register (channel = 0)
	// Position of TRIGSRCA field.
	TC_TC_CHANNEL_EMR_TRIGSRCA_Pos = 0x0
	// Bit mask of TRIGSRCA field.
	TC_TC_CHANNEL_EMR_TRIGSRCA_Msk = 0x3
	// The trigger/capture input A is driven by external pin TIOAx
	TC_TC_CHANNEL_EMR_TRIGSRCA_EXTERNAL_TIOAx = 0x0
	// The trigger/capture input A is driven internally by PWMx
	TC_TC_CHANNEL_EMR_TRIGSRCA_PWMx = 0x1
	// Position of TRIGSRCB field.
	TC_TC_CHANNEL_EMR_TRIGSRCB_Pos = 0x4
	// Bit mask of TRIGSRCB field.
	TC_TC_CHANNEL_EMR_TRIGSRCB_Msk = 0x30
	// The trigger/capture input B is driven by external pin TIOBx
	TC_TC_CHANNEL_EMR_TRIGSRCB_EXTERNAL_TIOBx = 0x0
	// For TC0 to TC10: The trigger/capture input B is driven internally by the comparator output (see Figure 7-16) of the PWMx.For TC11: The trigger/capture input B is driven internally by the GTSUCOMP signal of the Ethernet MAC (GMAC).
	TC_TC_CHANNEL_EMR_TRIGSRCB_PWMx = 0x1
	// Position of NODIVCLK field.
	TC_TC_CHANNEL_EMR_NODIVCLK_Pos = 0x8
	// Bit mask of NODIVCLK field.
	TC_TC_CHANNEL_EMR_NODIVCLK_Msk = 0x100
	// Bit NODIVCLK.
	TC_TC_CHANNEL_EMR_NODIVCLK = 0x100

	// BCR: Block Control Register
	// Position of SYNC field.
	TC_BCR_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	TC_BCR_SYNC_Msk = 0x1
	// Bit SYNC.
	TC_BCR_SYNC = 0x1

	// BMR: Block Mode Register
	// Position of TC0XC0S field.
	TC_BMR_TC0XC0S_Pos = 0x0
	// Bit mask of TC0XC0S field.
	TC_BMR_TC0XC0S_Msk = 0x3
	// Signal connected to XC0: TCLK0
	TC_BMR_TC0XC0S_TCLK0 = 0x0
	// Signal connected to XC0: TIOA1
	TC_BMR_TC0XC0S_TIOA1 = 0x2
	// Signal connected to XC0: TIOA2
	TC_BMR_TC0XC0S_TIOA2 = 0x3
	// Position of TC1XC1S field.
	TC_BMR_TC1XC1S_Pos = 0x2
	// Bit mask of TC1XC1S field.
	TC_BMR_TC1XC1S_Msk = 0xc
	// Signal connected to XC1: TCLK1
	TC_BMR_TC1XC1S_TCLK1 = 0x0
	// Signal connected to XC1: TIOA0
	TC_BMR_TC1XC1S_TIOA0 = 0x2
	// Signal connected to XC1: TIOA2
	TC_BMR_TC1XC1S_TIOA2 = 0x3
	// Position of TC2XC2S field.
	TC_BMR_TC2XC2S_Pos = 0x4
	// Bit mask of TC2XC2S field.
	TC_BMR_TC2XC2S_Msk = 0x30
	// Signal connected to XC2: TCLK2
	TC_BMR_TC2XC2S_TCLK2 = 0x0
	// Signal connected to XC2: TIOA0
	TC_BMR_TC2XC2S_TIOA0 = 0x2
	// Signal connected to XC2: TIOA1
	TC_BMR_TC2XC2S_TIOA1 = 0x3
	// Position of QDEN field.
	TC_BMR_QDEN_Pos = 0x8
	// Bit mask of QDEN field.
	TC_BMR_QDEN_Msk = 0x100
	// Bit QDEN.
	TC_BMR_QDEN = 0x100
	// Position of POSEN field.
	TC_BMR_POSEN_Pos = 0x9
	// Bit mask of POSEN field.
	TC_BMR_POSEN_Msk = 0x200
	// Bit POSEN.
	TC_BMR_POSEN = 0x200
	// Position of SPEEDEN field.
	TC_BMR_SPEEDEN_Pos = 0xa
	// Bit mask of SPEEDEN field.
	TC_BMR_SPEEDEN_Msk = 0x400
	// Bit SPEEDEN.
	TC_BMR_SPEEDEN = 0x400
	// Position of QDTRANS field.
	TC_BMR_QDTRANS_Pos = 0xb
	// Bit mask of QDTRANS field.
	TC_BMR_QDTRANS_Msk = 0x800
	// Bit QDTRANS.
	TC_BMR_QDTRANS = 0x800
	// Position of EDGPHA field.
	TC_BMR_EDGPHA_Pos = 0xc
	// Bit mask of EDGPHA field.
	TC_BMR_EDGPHA_Msk = 0x1000
	// Bit EDGPHA.
	TC_BMR_EDGPHA = 0x1000
	// Position of INVA field.
	TC_BMR_INVA_Pos = 0xd
	// Bit mask of INVA field.
	TC_BMR_INVA_Msk = 0x2000
	// Bit INVA.
	TC_BMR_INVA = 0x2000
	// Position of INVB field.
	TC_BMR_INVB_Pos = 0xe
	// Bit mask of INVB field.
	TC_BMR_INVB_Msk = 0x4000
	// Bit INVB.
	TC_BMR_INVB = 0x4000
	// Position of INVIDX field.
	TC_BMR_INVIDX_Pos = 0xf
	// Bit mask of INVIDX field.
	TC_BMR_INVIDX_Msk = 0x8000
	// Bit INVIDX.
	TC_BMR_INVIDX = 0x8000
	// Position of SWAP field.
	TC_BMR_SWAP_Pos = 0x10
	// Bit mask of SWAP field.
	TC_BMR_SWAP_Msk = 0x10000
	// Bit SWAP.
	TC_BMR_SWAP = 0x10000
	// Position of IDXPHB field.
	TC_BMR_IDXPHB_Pos = 0x11
	// Bit mask of IDXPHB field.
	TC_BMR_IDXPHB_Msk = 0x20000
	// Bit IDXPHB.
	TC_BMR_IDXPHB = 0x20000
	// Position of MAXFILT field.
	TC_BMR_MAXFILT_Pos = 0x14
	// Bit mask of MAXFILT field.
	TC_BMR_MAXFILT_Msk = 0x3f00000

	// QIER: QDEC Interrupt Enable Register
	// Position of IDX field.
	TC_QIER_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIER_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIER_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIER_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIER_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIER_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIER_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIER_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIER_QERR = 0x4

	// QIDR: QDEC Interrupt Disable Register
	// Position of IDX field.
	TC_QIDR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIDR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIDR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIDR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIDR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIDR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIDR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIDR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIDR_QERR = 0x4

	// QIMR: QDEC Interrupt Mask Register
	// Position of IDX field.
	TC_QIMR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIMR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIMR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIMR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIMR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIMR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIMR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIMR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIMR_QERR = 0x4

	// QISR: QDEC Interrupt Status Register
	// Position of IDX field.
	TC_QISR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QISR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QISR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QISR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QISR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QISR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QISR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QISR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QISR_QERR = 0x4
	// Position of DIR field.
	TC_QISR_DIR_Pos = 0x8
	// Bit mask of DIR field.
	TC_QISR_DIR_Msk = 0x100
	// Bit DIR.
	TC_QISR_DIR = 0x100

	// FMR: Fault Mode Register
	// Position of ENCF0 field.
	TC_FMR_ENCF0_Pos = 0x0
	// Bit mask of ENCF0 field.
	TC_FMR_ENCF0_Msk = 0x1
	// Bit ENCF0.
	TC_FMR_ENCF0 = 0x1
	// Position of ENCF1 field.
	TC_FMR_ENCF1_Pos = 0x1
	// Bit mask of ENCF1 field.
	TC_FMR_ENCF1_Msk = 0x2
	// Bit ENCF1.
	TC_FMR_ENCF1 = 0x2

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	TC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	TC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	TC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	TC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	TC_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0.
	TC_WPMR_WPKEY_PASSWD = 0x54494d
)

// Constants for TRNG: True Random Number Generator
const (
	// CR: Control Register
	// Position of ENABLE field.
	TRNG_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TRNG_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	TRNG_CR_ENABLE = 0x1
	// Position of KEY field.
	TRNG_CR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TRNG_CR_KEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation.
	TRNG_CR_KEY_PASSWD = 0x524e47

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	TRNG_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IER_DATRDY = 0x1

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	TRNG_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IDR_DATRDY = 0x1

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	TRNG_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IMR_DATRDY = 0x1

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	TRNG_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_ISR_DATRDY = 0x1

	// ODATA: Output Data Register
	// Position of ODATA field.
	TRNG_ODATA_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	TRNG_ODATA_ODATA_Msk = 0xffffffff
)

// Constants for TWIHS0: Two-wire Interface High Speed
const (
	// CR: Control Register
	// Position of START field.
	TWIHS_CR_START_Pos = 0x0
	// Bit mask of START field.
	TWIHS_CR_START_Msk = 0x1
	// Bit START.
	TWIHS_CR_START = 0x1
	// Position of STOP field.
	TWIHS_CR_STOP_Pos = 0x1
	// Bit mask of STOP field.
	TWIHS_CR_STOP_Msk = 0x2
	// Bit STOP.
	TWIHS_CR_STOP = 0x2
	// Position of MSEN field.
	TWIHS_CR_MSEN_Pos = 0x2
	// Bit mask of MSEN field.
	TWIHS_CR_MSEN_Msk = 0x4
	// Bit MSEN.
	TWIHS_CR_MSEN = 0x4
	// Position of MSDIS field.
	TWIHS_CR_MSDIS_Pos = 0x3
	// Bit mask of MSDIS field.
	TWIHS_CR_MSDIS_Msk = 0x8
	// Bit MSDIS.
	TWIHS_CR_MSDIS = 0x8
	// Position of SVEN field.
	TWIHS_CR_SVEN_Pos = 0x4
	// Bit mask of SVEN field.
	TWIHS_CR_SVEN_Msk = 0x10
	// Bit SVEN.
	TWIHS_CR_SVEN = 0x10
	// Position of SVDIS field.
	TWIHS_CR_SVDIS_Pos = 0x5
	// Bit mask of SVDIS field.
	TWIHS_CR_SVDIS_Msk = 0x20
	// Bit SVDIS.
	TWIHS_CR_SVDIS = 0x20
	// Position of QUICK field.
	TWIHS_CR_QUICK_Pos = 0x6
	// Bit mask of QUICK field.
	TWIHS_CR_QUICK_Msk = 0x40
	// Bit QUICK.
	TWIHS_CR_QUICK = 0x40
	// Position of SWRST field.
	TWIHS_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	TWIHS_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	TWIHS_CR_SWRST = 0x80
	// Position of HSEN field.
	TWIHS_CR_HSEN_Pos = 0x8
	// Bit mask of HSEN field.
	TWIHS_CR_HSEN_Msk = 0x100
	// Bit HSEN.
	TWIHS_CR_HSEN = 0x100
	// Position of HSDIS field.
	TWIHS_CR_HSDIS_Pos = 0x9
	// Bit mask of HSDIS field.
	TWIHS_CR_HSDIS_Msk = 0x200
	// Bit HSDIS.
	TWIHS_CR_HSDIS = 0x200
	// Position of SMBEN field.
	TWIHS_CR_SMBEN_Pos = 0xa
	// Bit mask of SMBEN field.
	TWIHS_CR_SMBEN_Msk = 0x400
	// Bit SMBEN.
	TWIHS_CR_SMBEN = 0x400
	// Position of SMBDIS field.
	TWIHS_CR_SMBDIS_Pos = 0xb
	// Bit mask of SMBDIS field.
	TWIHS_CR_SMBDIS_Msk = 0x800
	// Bit SMBDIS.
	TWIHS_CR_SMBDIS = 0x800
	// Position of PECEN field.
	TWIHS_CR_PECEN_Pos = 0xc
	// Bit mask of PECEN field.
	TWIHS_CR_PECEN_Msk = 0x1000
	// Bit PECEN.
	TWIHS_CR_PECEN = 0x1000
	// Position of PECDIS field.
	TWIHS_CR_PECDIS_Pos = 0xd
	// Bit mask of PECDIS field.
	TWIHS_CR_PECDIS_Msk = 0x2000
	// Bit PECDIS.
	TWIHS_CR_PECDIS = 0x2000
	// Position of PECRQ field.
	TWIHS_CR_PECRQ_Pos = 0xe
	// Bit mask of PECRQ field.
	TWIHS_CR_PECRQ_Msk = 0x4000
	// Bit PECRQ.
	TWIHS_CR_PECRQ = 0x4000
	// Position of CLEAR field.
	TWIHS_CR_CLEAR_Pos = 0xf
	// Bit mask of CLEAR field.
	TWIHS_CR_CLEAR_Msk = 0x8000
	// Bit CLEAR.
	TWIHS_CR_CLEAR = 0x8000
	// Position of ACMEN field.
	TWIHS_CR_ACMEN_Pos = 0x10
	// Bit mask of ACMEN field.
	TWIHS_CR_ACMEN_Msk = 0x10000
	// Bit ACMEN.
	TWIHS_CR_ACMEN = 0x10000
	// Position of ACMDIS field.
	TWIHS_CR_ACMDIS_Pos = 0x11
	// Bit mask of ACMDIS field.
	TWIHS_CR_ACMDIS_Msk = 0x20000
	// Bit ACMDIS.
	TWIHS_CR_ACMDIS = 0x20000
	// Position of THRCLR field.
	TWIHS_CR_THRCLR_Pos = 0x18
	// Bit mask of THRCLR field.
	TWIHS_CR_THRCLR_Msk = 0x1000000
	// Bit THRCLR.
	TWIHS_CR_THRCLR = 0x1000000
	// Position of LOCKCLR field.
	TWIHS_CR_LOCKCLR_Pos = 0x1a
	// Bit mask of LOCKCLR field.
	TWIHS_CR_LOCKCLR_Msk = 0x4000000
	// Bit LOCKCLR.
	TWIHS_CR_LOCKCLR = 0x4000000
	// Position of FIFOEN field.
	TWIHS_CR_FIFOEN_Pos = 0x1c
	// Bit mask of FIFOEN field.
	TWIHS_CR_FIFOEN_Msk = 0x10000000
	// Bit FIFOEN.
	TWIHS_CR_FIFOEN = 0x10000000
	// Position of FIFODIS field.
	TWIHS_CR_FIFODIS_Pos = 0x1d
	// Bit mask of FIFODIS field.
	TWIHS_CR_FIFODIS_Msk = 0x20000000
	// Bit FIFODIS.
	TWIHS_CR_FIFODIS = 0x20000000

	// MMR: Master Mode Register
	// Position of IADRSZ field.
	TWIHS_MMR_IADRSZ_Pos = 0x8
	// Bit mask of IADRSZ field.
	TWIHS_MMR_IADRSZ_Msk = 0x300
	// No internal device address
	TWIHS_MMR_IADRSZ_NONE = 0x0
	// One-byte internal device address
	TWIHS_MMR_IADRSZ__1_BYTE = 0x1
	// Two-byte internal device address
	TWIHS_MMR_IADRSZ__2_BYTE = 0x2
	// Three-byte internal device address
	TWIHS_MMR_IADRSZ__3_BYTE = 0x3
	// Position of MREAD field.
	TWIHS_MMR_MREAD_Pos = 0xc
	// Bit mask of MREAD field.
	TWIHS_MMR_MREAD_Msk = 0x1000
	// Bit MREAD.
	TWIHS_MMR_MREAD = 0x1000
	// Position of DADR field.
	TWIHS_MMR_DADR_Pos = 0x10
	// Bit mask of DADR field.
	TWIHS_MMR_DADR_Msk = 0x7f0000

	// SMR: Slave Mode Register
	// Position of NACKEN field.
	TWIHS_SMR_NACKEN_Pos = 0x0
	// Bit mask of NACKEN field.
	TWIHS_SMR_NACKEN_Msk = 0x1
	// Bit NACKEN.
	TWIHS_SMR_NACKEN = 0x1
	// Position of SMDA field.
	TWIHS_SMR_SMDA_Pos = 0x2
	// Bit mask of SMDA field.
	TWIHS_SMR_SMDA_Msk = 0x4
	// Bit SMDA.
	TWIHS_SMR_SMDA = 0x4
	// Position of SMHH field.
	TWIHS_SMR_SMHH_Pos = 0x3
	// Bit mask of SMHH field.
	TWIHS_SMR_SMHH_Msk = 0x8
	// Bit SMHH.
	TWIHS_SMR_SMHH = 0x8
	// Position of SCLWSDIS field.
	TWIHS_SMR_SCLWSDIS_Pos = 0x6
	// Bit mask of SCLWSDIS field.
	TWIHS_SMR_SCLWSDIS_Msk = 0x40
	// Bit SCLWSDIS.
	TWIHS_SMR_SCLWSDIS = 0x40
	// Position of MASK field.
	TWIHS_SMR_MASK_Pos = 0x8
	// Bit mask of MASK field.
	TWIHS_SMR_MASK_Msk = 0x7f00
	// Position of SADR field.
	TWIHS_SMR_SADR_Pos = 0x10
	// Bit mask of SADR field.
	TWIHS_SMR_SADR_Msk = 0x7f0000
	// Position of SADR1EN field.
	TWIHS_SMR_SADR1EN_Pos = 0x1c
	// Bit mask of SADR1EN field.
	TWIHS_SMR_SADR1EN_Msk = 0x10000000
	// Bit SADR1EN.
	TWIHS_SMR_SADR1EN = 0x10000000
	// Position of SADR2EN field.
	TWIHS_SMR_SADR2EN_Pos = 0x1d
	// Bit mask of SADR2EN field.
	TWIHS_SMR_SADR2EN_Msk = 0x20000000
	// Bit SADR2EN.
	TWIHS_SMR_SADR2EN = 0x20000000
	// Position of SADR3EN field.
	TWIHS_SMR_SADR3EN_Pos = 0x1e
	// Bit mask of SADR3EN field.
	TWIHS_SMR_SADR3EN_Msk = 0x40000000
	// Bit SADR3EN.
	TWIHS_SMR_SADR3EN = 0x40000000
	// Position of DATAMEN field.
	TWIHS_SMR_DATAMEN_Pos = 0x1f
	// Bit mask of DATAMEN field.
	TWIHS_SMR_DATAMEN_Msk = 0x80000000
	// Bit DATAMEN.
	TWIHS_SMR_DATAMEN = 0x80000000

	// IADR: Internal Address Register
	// Position of IADR field.
	TWIHS_IADR_IADR_Pos = 0x0
	// Bit mask of IADR field.
	TWIHS_IADR_IADR_Msk = 0xffffff

	// CWGR: Clock Waveform Generator Register
	// Position of CLDIV field.
	TWIHS_CWGR_CLDIV_Pos = 0x0
	// Bit mask of CLDIV field.
	TWIHS_CWGR_CLDIV_Msk = 0xff
	// Position of CHDIV field.
	TWIHS_CWGR_CHDIV_Pos = 0x8
	// Bit mask of CHDIV field.
	TWIHS_CWGR_CHDIV_Msk = 0xff00
	// Position of CKDIV field.
	TWIHS_CWGR_CKDIV_Pos = 0x10
	// Bit mask of CKDIV field.
	TWIHS_CWGR_CKDIV_Msk = 0x70000
	// Position of HOLD field.
	TWIHS_CWGR_HOLD_Pos = 0x18
	// Bit mask of HOLD field.
	TWIHS_CWGR_HOLD_Msk = 0x3f000000

	// SR: Status Register
	// Position of TXCOMP field.
	TWIHS_SR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWIHS_SR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWIHS_SR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWIHS_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWIHS_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWIHS_SR_RXRDY = 0x2
	// Position of TXRDY field.
	TWIHS_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWIHS_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWIHS_SR_TXRDY = 0x4
	// Position of SVREAD field.
	TWIHS_SR_SVREAD_Pos = 0x3
	// Bit mask of SVREAD field.
	TWIHS_SR_SVREAD_Msk = 0x8
	// Bit SVREAD.
	TWIHS_SR_SVREAD = 0x8
	// Position of SVACC field.
	TWIHS_SR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWIHS_SR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWIHS_SR_SVACC = 0x10
	// Position of GACC field.
	TWIHS_SR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWIHS_SR_GACC_Msk = 0x20
	// Bit GACC.
	TWIHS_SR_GACC = 0x20
	// Position of OVRE field.
	TWIHS_SR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWIHS_SR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWIHS_SR_OVRE = 0x40
	// Position of UNRE field.
	TWIHS_SR_UNRE_Pos = 0x7
	// Bit mask of UNRE field.
	TWIHS_SR_UNRE_Msk = 0x80
	// Bit UNRE.
	TWIHS_SR_UNRE = 0x80
	// Position of NACK field.
	TWIHS_SR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWIHS_SR_NACK_Msk = 0x100
	// Bit NACK.
	TWIHS_SR_NACK = 0x100
	// Position of ARBLST field.
	TWIHS_SR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWIHS_SR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWIHS_SR_ARBLST = 0x200
	// Position of SCLWS field.
	TWIHS_SR_SCLWS_Pos = 0xa
	// Bit mask of SCLWS field.
	TWIHS_SR_SCLWS_Msk = 0x400
	// Bit SCLWS.
	TWIHS_SR_SCLWS = 0x400
	// Position of EOSACC field.
	TWIHS_SR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWIHS_SR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWIHS_SR_EOSACC = 0x800
	// Position of MCACK field.
	TWIHS_SR_MCACK_Pos = 0x10
	// Bit mask of MCACK field.
	TWIHS_SR_MCACK_Msk = 0x10000
	// Bit MCACK.
	TWIHS_SR_MCACK = 0x10000
	// Position of TOUT field.
	TWIHS_SR_TOUT_Pos = 0x12
	// Bit mask of TOUT field.
	TWIHS_SR_TOUT_Msk = 0x40000
	// Bit TOUT.
	TWIHS_SR_TOUT = 0x40000
	// Position of PECERR field.
	TWIHS_SR_PECERR_Pos = 0x13
	// Bit mask of PECERR field.
	TWIHS_SR_PECERR_Msk = 0x80000
	// Bit PECERR.
	TWIHS_SR_PECERR = 0x80000
	// Position of SMBDAM field.
	TWIHS_SR_SMBDAM_Pos = 0x14
	// Bit mask of SMBDAM field.
	TWIHS_SR_SMBDAM_Msk = 0x100000
	// Bit SMBDAM.
	TWIHS_SR_SMBDAM = 0x100000
	// Position of SMBHHM field.
	TWIHS_SR_SMBHHM_Pos = 0x15
	// Bit mask of SMBHHM field.
	TWIHS_SR_SMBHHM_Msk = 0x200000
	// Bit SMBHHM.
	TWIHS_SR_SMBHHM = 0x200000
	// Position of SCL field.
	TWIHS_SR_SCL_Pos = 0x18
	// Bit mask of SCL field.
	TWIHS_SR_SCL_Msk = 0x1000000
	// Bit SCL.
	TWIHS_SR_SCL = 0x1000000
	// Position of SDA field.
	TWIHS_SR_SDA_Pos = 0x19
	// Bit mask of SDA field.
	TWIHS_SR_SDA_Msk = 0x2000000
	// Bit SDA.
	TWIHS_SR_SDA = 0x2000000

	// IER: Interrupt Enable Register
	// Position of TXCOMP field.
	TWIHS_IER_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWIHS_IER_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWIHS_IER_TXCOMP = 0x1
	// Position of RXRDY field.
	TWIHS_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWIHS_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWIHS_IER_RXRDY = 0x2
	// Position of TXRDY field.
	TWIHS_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWIHS_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWIHS_IER_TXRDY = 0x4
	// Position of SVACC field.
	TWIHS_IER_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWIHS_IER_SVACC_Msk = 0x10
	// Bit SVACC.
	TWIHS_IER_SVACC = 0x10
	// Position of GACC field.
	TWIHS_IER_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWIHS_IER_GACC_Msk = 0x20
	// Bit GACC.
	TWIHS_IER_GACC = 0x20
	// Position of OVRE field.
	TWIHS_IER_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWIHS_IER_OVRE_Msk = 0x40
	// Bit OVRE.
	TWIHS_IER_OVRE = 0x40
	// Position of UNRE field.
	TWIHS_IER_UNRE_Pos = 0x7
	// Bit mask of UNRE field.
	TWIHS_IER_UNRE_Msk = 0x80
	// Bit UNRE.
	TWIHS_IER_UNRE = 0x80
	// Position of NACK field.
	TWIHS_IER_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWIHS_IER_NACK_Msk = 0x100
	// Bit NACK.
	TWIHS_IER_NACK = 0x100
	// Position of ARBLST field.
	TWIHS_IER_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWIHS_IER_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWIHS_IER_ARBLST = 0x200
	// Position of SCL_WS field.
	TWIHS_IER_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWIHS_IER_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWIHS_IER_SCL_WS = 0x400
	// Position of EOSACC field.
	TWIHS_IER_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWIHS_IER_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWIHS_IER_EOSACC = 0x800
	// Position of MCACK field.
	TWIHS_IER_MCACK_Pos = 0x10
	// Bit mask of MCACK field.
	TWIHS_IER_MCACK_Msk = 0x10000
	// Bit MCACK.
	TWIHS_IER_MCACK = 0x10000
	// Position of TOUT field.
	TWIHS_IER_TOUT_Pos = 0x12
	// Bit mask of TOUT field.
	TWIHS_IER_TOUT_Msk = 0x40000
	// Bit TOUT.
	TWIHS_IER_TOUT = 0x40000
	// Position of PECERR field.
	TWIHS_IER_PECERR_Pos = 0x13
	// Bit mask of PECERR field.
	TWIHS_IER_PECERR_Msk = 0x80000
	// Bit PECERR.
	TWIHS_IER_PECERR = 0x80000
	// Position of SMBDAM field.
	TWIHS_IER_SMBDAM_Pos = 0x14
	// Bit mask of SMBDAM field.
	TWIHS_IER_SMBDAM_Msk = 0x100000
	// Bit SMBDAM.
	TWIHS_IER_SMBDAM = 0x100000
	// Position of SMBHHM field.
	TWIHS_IER_SMBHHM_Pos = 0x15
	// Bit mask of SMBHHM field.
	TWIHS_IER_SMBHHM_Msk = 0x200000
	// Bit SMBHHM.
	TWIHS_IER_SMBHHM = 0x200000

	// IDR: Interrupt Disable Register
	// Position of TXCOMP field.
	TWIHS_IDR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWIHS_IDR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWIHS_IDR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWIHS_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWIHS_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWIHS_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	TWIHS_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWIHS_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWIHS_IDR_TXRDY = 0x4
	// Position of SVACC field.
	TWIHS_IDR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWIHS_IDR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWIHS_IDR_SVACC = 0x10
	// Position of GACC field.
	TWIHS_IDR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWIHS_IDR_GACC_Msk = 0x20
	// Bit GACC.
	TWIHS_IDR_GACC = 0x20
	// Position of OVRE field.
	TWIHS_IDR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWIHS_IDR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWIHS_IDR_OVRE = 0x40
	// Position of UNRE field.
	TWIHS_IDR_UNRE_Pos = 0x7
	// Bit mask of UNRE field.
	TWIHS_IDR_UNRE_Msk = 0x80
	// Bit UNRE.
	TWIHS_IDR_UNRE = 0x80
	// Position of NACK field.
	TWIHS_IDR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWIHS_IDR_NACK_Msk = 0x100
	// Bit NACK.
	TWIHS_IDR_NACK = 0x100
	// Position of ARBLST field.
	TWIHS_IDR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWIHS_IDR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWIHS_IDR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWIHS_IDR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWIHS_IDR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWIHS_IDR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWIHS_IDR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWIHS_IDR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWIHS_IDR_EOSACC = 0x800
	// Position of MCACK field.
	TWIHS_IDR_MCACK_Pos = 0x10
	// Bit mask of MCACK field.
	TWIHS_IDR_MCACK_Msk = 0x10000
	// Bit MCACK.
	TWIHS_IDR_MCACK = 0x10000
	// Position of TOUT field.
	TWIHS_IDR_TOUT_Pos = 0x12
	// Bit mask of TOUT field.
	TWIHS_IDR_TOUT_Msk = 0x40000
	// Bit TOUT.
	TWIHS_IDR_TOUT = 0x40000
	// Position of PECERR field.
	TWIHS_IDR_PECERR_Pos = 0x13
	// Bit mask of PECERR field.
	TWIHS_IDR_PECERR_Msk = 0x80000
	// Bit PECERR.
	TWIHS_IDR_PECERR = 0x80000
	// Position of SMBDAM field.
	TWIHS_IDR_SMBDAM_Pos = 0x14
	// Bit mask of SMBDAM field.
	TWIHS_IDR_SMBDAM_Msk = 0x100000
	// Bit SMBDAM.
	TWIHS_IDR_SMBDAM = 0x100000
	// Position of SMBHHM field.
	TWIHS_IDR_SMBHHM_Pos = 0x15
	// Bit mask of SMBHHM field.
	TWIHS_IDR_SMBHHM_Msk = 0x200000
	// Bit SMBHHM.
	TWIHS_IDR_SMBHHM = 0x200000

	// IMR: Interrupt Mask Register
	// Position of TXCOMP field.
	TWIHS_IMR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWIHS_IMR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWIHS_IMR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWIHS_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWIHS_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWIHS_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	TWIHS_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWIHS_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWIHS_IMR_TXRDY = 0x4
	// Position of SVACC field.
	TWIHS_IMR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWIHS_IMR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWIHS_IMR_SVACC = 0x10
	// Position of GACC field.
	TWIHS_IMR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWIHS_IMR_GACC_Msk = 0x20
	// Bit GACC.
	TWIHS_IMR_GACC = 0x20
	// Position of OVRE field.
	TWIHS_IMR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWIHS_IMR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWIHS_IMR_OVRE = 0x40
	// Position of UNRE field.
	TWIHS_IMR_UNRE_Pos = 0x7
	// Bit mask of UNRE field.
	TWIHS_IMR_UNRE_Msk = 0x80
	// Bit UNRE.
	TWIHS_IMR_UNRE = 0x80
	// Position of NACK field.
	TWIHS_IMR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWIHS_IMR_NACK_Msk = 0x100
	// Bit NACK.
	TWIHS_IMR_NACK = 0x100
	// Position of ARBLST field.
	TWIHS_IMR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWIHS_IMR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWIHS_IMR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWIHS_IMR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWIHS_IMR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWIHS_IMR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWIHS_IMR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWIHS_IMR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWIHS_IMR_EOSACC = 0x800
	// Position of MCACK field.
	TWIHS_IMR_MCACK_Pos = 0x10
	// Bit mask of MCACK field.
	TWIHS_IMR_MCACK_Msk = 0x10000
	// Bit MCACK.
	TWIHS_IMR_MCACK = 0x10000
	// Position of TOUT field.
	TWIHS_IMR_TOUT_Pos = 0x12
	// Bit mask of TOUT field.
	TWIHS_IMR_TOUT_Msk = 0x40000
	// Bit TOUT.
	TWIHS_IMR_TOUT = 0x40000
	// Position of PECERR field.
	TWIHS_IMR_PECERR_Pos = 0x13
	// Bit mask of PECERR field.
	TWIHS_IMR_PECERR_Msk = 0x80000
	// Bit PECERR.
	TWIHS_IMR_PECERR = 0x80000
	// Position of SMBDAM field.
	TWIHS_IMR_SMBDAM_Pos = 0x14
	// Bit mask of SMBDAM field.
	TWIHS_IMR_SMBDAM_Msk = 0x100000
	// Bit SMBDAM.
	TWIHS_IMR_SMBDAM = 0x100000
	// Position of SMBHHM field.
	TWIHS_IMR_SMBHHM_Pos = 0x15
	// Bit mask of SMBHHM field.
	TWIHS_IMR_SMBHHM_Msk = 0x200000
	// Bit SMBHHM.
	TWIHS_IMR_SMBHHM = 0x200000

	// RHR: Receive Holding Register
	// Position of RXDATA field.
	TWIHS_RHR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	TWIHS_RHR_RXDATA_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXDATA field.
	TWIHS_THR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	TWIHS_THR_TXDATA_Msk = 0xff

	// SMBTR: SMBus Timing Register
	// Position of PRESC field.
	TWIHS_SMBTR_PRESC_Pos = 0x0
	// Bit mask of PRESC field.
	TWIHS_SMBTR_PRESC_Msk = 0xf
	// Position of TLOWS field.
	TWIHS_SMBTR_TLOWS_Pos = 0x8
	// Bit mask of TLOWS field.
	TWIHS_SMBTR_TLOWS_Msk = 0xff00
	// Position of TLOWM field.
	TWIHS_SMBTR_TLOWM_Pos = 0x10
	// Bit mask of TLOWM field.
	TWIHS_SMBTR_TLOWM_Msk = 0xff0000
	// Position of THMAX field.
	TWIHS_SMBTR_THMAX_Pos = 0x18
	// Bit mask of THMAX field.
	TWIHS_SMBTR_THMAX_Msk = 0xff000000

	// FILTR: Filter Register
	// Position of FILT field.
	TWIHS_FILTR_FILT_Pos = 0x0
	// Bit mask of FILT field.
	TWIHS_FILTR_FILT_Msk = 0x1
	// Bit FILT.
	TWIHS_FILTR_FILT = 0x1
	// Position of PADFEN field.
	TWIHS_FILTR_PADFEN_Pos = 0x1
	// Bit mask of PADFEN field.
	TWIHS_FILTR_PADFEN_Msk = 0x2
	// Bit PADFEN.
	TWIHS_FILTR_PADFEN = 0x2
	// Position of PADFCFG field.
	TWIHS_FILTR_PADFCFG_Pos = 0x2
	// Bit mask of PADFCFG field.
	TWIHS_FILTR_PADFCFG_Msk = 0x4
	// Bit PADFCFG.
	TWIHS_FILTR_PADFCFG = 0x4
	// Position of THRES field.
	TWIHS_FILTR_THRES_Pos = 0x8
	// Bit mask of THRES field.
	TWIHS_FILTR_THRES_Msk = 0x700

	// SWMR: SleepWalking Matching Register
	// Position of SADR1 field.
	TWIHS_SWMR_SADR1_Pos = 0x0
	// Bit mask of SADR1 field.
	TWIHS_SWMR_SADR1_Msk = 0x7f
	// Position of SADR2 field.
	TWIHS_SWMR_SADR2_Pos = 0x8
	// Bit mask of SADR2 field.
	TWIHS_SWMR_SADR2_Msk = 0x7f00
	// Position of SADR3 field.
	TWIHS_SWMR_SADR3_Pos = 0x10
	// Bit mask of SADR3 field.
	TWIHS_SWMR_SADR3_Msk = 0x7f0000
	// Position of DATAM field.
	TWIHS_SWMR_DATAM_Pos = 0x18
	// Bit mask of DATAM field.
	TWIHS_SWMR_DATAM_Msk = 0xff000000

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	TWIHS_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	TWIHS_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	TWIHS_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	TWIHS_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	TWIHS_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit.Always reads as 0
	TWIHS_WPMR_WPKEY_PASSWD = 0x545749

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	TWIHS_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	TWIHS_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	TWIHS_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	TWIHS_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	TWIHS_WPSR_WPVSRC_Msk = 0xffffff00
)

// Constants for UART0: Universal Asynchronous Receiver Transmitter
const (
	// CR: Control Register
	// Position of RSTRX field.
	UART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	UART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	UART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	UART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	UART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	UART_CR_RSTTX = 0x8
	// Position of RXEN field.
	UART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	UART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	UART_CR_RXEN = 0x10
	// Position of RXDIS field.
	UART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	UART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	UART_CR_RXDIS = 0x20
	// Position of TXEN field.
	UART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	UART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	UART_CR_TXEN = 0x40
	// Position of TXDIS field.
	UART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	UART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	UART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	UART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	UART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	UART_CR_RSTSTA = 0x100
	// Position of REQCLR field.
	UART_CR_REQCLR_Pos = 0xc
	// Bit mask of REQCLR field.
	UART_CR_REQCLR_Msk = 0x1000
	// Bit REQCLR.
	UART_CR_REQCLR = 0x1000

	// MR: Mode Register
	// Position of FILTER field.
	UART_MR_FILTER_Pos = 0x4
	// Bit mask of FILTER field.
	UART_MR_FILTER_Msk = 0x10
	// Bit FILTER.
	UART_MR_FILTER = 0x10
	// UART does not filter the receive line.
	UART_MR_FILTER_DISABLED = 0x0
	// UART filters the receive line using a three-sample filter (16x-bit clock) (2 over 3 majority).
	UART_MR_FILTER_ENABLED = 0x1
	// Position of PAR field.
	UART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	UART_MR_PAR_Msk = 0xe00
	// Even Parity
	UART_MR_PAR_EVEN = 0x0
	// Odd Parity
	UART_MR_PAR_ODD = 0x1
	// Space: parity forced to 0
	UART_MR_PAR_SPACE = 0x2
	// Mark: parity forced to 1
	UART_MR_PAR_MARK = 0x3
	// No parity
	UART_MR_PAR_NO = 0x4
	// Position of BRSRCCK field.
	UART_MR_BRSRCCK_Pos = 0xc
	// Bit mask of BRSRCCK field.
	UART_MR_BRSRCCK_Msk = 0x1000
	// Bit BRSRCCK.
	UART_MR_BRSRCCK = 0x1000
	// The baud rate is driven by the peripheral clock
	UART_MR_BRSRCCK_PERIPH_CLK = 0x0
	// The baud rate is driven by a PMC programmable clock PCK (see section Power Management Controller (PMC)).
	UART_MR_BRSRCCK_PMC_PCK = 0x1
	// Position of CHMODE field.
	UART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	UART_MR_CHMODE_Msk = 0xc000
	// Normal mode
	UART_MR_CHMODE_NORMAL = 0x0
	// Automatic echo
	UART_MR_CHMODE_AUTOMATIC = 0x1
	// Local loopback
	UART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote loopback
	UART_MR_CHMODE_REMOTE_LOOPBACK = 0x3

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	UART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IER_TXRDY = 0x2
	// Position of OVRE field.
	UART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IER_OVRE = 0x20
	// Position of FRAME field.
	UART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IER_FRAME = 0x40
	// Position of PARE field.
	UART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IER_PARE_Msk = 0x80
	// Bit PARE.
	UART_IER_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IER_TXEMPTY = 0x200
	// Position of CMP field.
	UART_IER_CMP_Pos = 0xf
	// Bit mask of CMP field.
	UART_IER_CMP_Msk = 0x8000
	// Bit CMP.
	UART_IER_CMP = 0x8000

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	UART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IDR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IDR_OVRE = 0x20
	// Position of FRAME field.
	UART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IDR_FRAME = 0x40
	// Position of PARE field.
	UART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IDR_TXEMPTY = 0x200
	// Position of CMP field.
	UART_IDR_CMP_Pos = 0xf
	// Bit mask of CMP field.
	UART_IDR_CMP_Msk = 0x8000
	// Bit CMP.
	UART_IDR_CMP = 0x8000

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	UART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IMR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IMR_OVRE = 0x20
	// Position of FRAME field.
	UART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IMR_FRAME = 0x40
	// Position of PARE field.
	UART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IMR_TXEMPTY = 0x200
	// Position of CMP field.
	UART_IMR_CMP_Pos = 0xf
	// Bit mask of CMP field.
	UART_IMR_CMP_Msk = 0x8000
	// Bit CMP.
	UART_IMR_CMP = 0x8000

	// SR: Status Register
	// Position of RXRDY field.
	UART_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_SR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_SR_TXRDY = 0x2
	// Position of OVRE field.
	UART_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_SR_OVRE = 0x20
	// Position of FRAME field.
	UART_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_SR_FRAME = 0x40
	// Position of PARE field.
	UART_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_SR_PARE_Msk = 0x80
	// Bit PARE.
	UART_SR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_SR_TXEMPTY = 0x200
	// Position of CMP field.
	UART_SR_CMP_Pos = 0xf
	// Bit mask of CMP field.
	UART_SR_CMP_Msk = 0x8000
	// Bit CMP.
	UART_SR_CMP = 0x8000

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	UART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	UART_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	UART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	UART_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	UART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	UART_BRGR_CD_Msk = 0xffff

	// CMPR: Comparison Register
	// Position of VAL1 field.
	UART_CMPR_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	UART_CMPR_VAL1_Msk = 0xff
	// Position of CMPMODE field.
	UART_CMPR_CMPMODE_Pos = 0xc
	// Bit mask of CMPMODE field.
	UART_CMPR_CMPMODE_Msk = 0x1000
	// Bit CMPMODE.
	UART_CMPR_CMPMODE = 0x1000
	// Any character is received and comparison function drives CMP flag.
	UART_CMPR_CMPMODE_FLAG_ONLY = 0x0
	// Comparison condition must be met to start reception.
	UART_CMPR_CMPMODE_START_CONDITION = 0x1
	// Position of CMPPAR field.
	UART_CMPR_CMPPAR_Pos = 0xe
	// Bit mask of CMPPAR field.
	UART_CMPR_CMPPAR_Msk = 0x4000
	// Bit CMPPAR.
	UART_CMPR_CMPPAR = 0x4000
	// Position of VAL2 field.
	UART_CMPR_VAL2_Pos = 0x10
	// Bit mask of VAL2 field.
	UART_CMPR_VAL2_Msk = 0xff0000

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	UART_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	UART_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	UART_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	UART_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	UART_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation.Always reads as 0.
	UART_WPMR_WPKEY_PASSWD = 0x554152
)

// Constants for USART0: Universal Synchronous Asynchronous Receiver Transmitter
const (
	// US_CR: Control Register
	// Position of RSTRX field.
	USART_US_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_US_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_US_CR_RSTRX = 0x4
	// Position of RSTTX field.
	USART_US_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_US_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_US_CR_RSTTX = 0x8
	// Position of RXEN field.
	USART_US_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_US_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_US_CR_RXEN = 0x10
	// Position of RXDIS field.
	USART_US_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_US_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_US_CR_RXDIS = 0x20
	// Position of TXEN field.
	USART_US_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_US_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_US_CR_TXEN = 0x40
	// Position of TXDIS field.
	USART_US_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_US_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_US_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_US_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_US_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_US_CR_RSTSTA = 0x100
	// Position of STTBRK field.
	USART_US_CR_STTBRK_Pos = 0x9
	// Bit mask of STTBRK field.
	USART_US_CR_STTBRK_Msk = 0x200
	// Bit STTBRK.
	USART_US_CR_STTBRK = 0x200
	// Position of STPBRK field.
	USART_US_CR_STPBRK_Pos = 0xa
	// Bit mask of STPBRK field.
	USART_US_CR_STPBRK_Msk = 0x400
	// Bit STPBRK.
	USART_US_CR_STPBRK = 0x400
	// Position of STTTO field.
	USART_US_CR_STTTO_Pos = 0xb
	// Bit mask of STTTO field.
	USART_US_CR_STTTO_Msk = 0x800
	// Bit STTTO.
	USART_US_CR_STTTO = 0x800
	// Position of SENDA field.
	USART_US_CR_SENDA_Pos = 0xc
	// Bit mask of SENDA field.
	USART_US_CR_SENDA_Msk = 0x1000
	// Bit SENDA.
	USART_US_CR_SENDA = 0x1000
	// Position of RSTIT field.
	USART_US_CR_RSTIT_Pos = 0xd
	// Bit mask of RSTIT field.
	USART_US_CR_RSTIT_Msk = 0x2000
	// Bit RSTIT.
	USART_US_CR_RSTIT = 0x2000
	// Position of RSTNACK field.
	USART_US_CR_RSTNACK_Pos = 0xe
	// Bit mask of RSTNACK field.
	USART_US_CR_RSTNACK_Msk = 0x4000
	// Bit RSTNACK.
	USART_US_CR_RSTNACK = 0x4000
	// Position of RETTO field.
	USART_US_CR_RETTO_Pos = 0xf
	// Bit mask of RETTO field.
	USART_US_CR_RETTO_Msk = 0x8000
	// Bit RETTO.
	USART_US_CR_RETTO = 0x8000
	// Position of DTREN field.
	USART_US_CR_DTREN_Pos = 0x10
	// Bit mask of DTREN field.
	USART_US_CR_DTREN_Msk = 0x10000
	// Bit DTREN.
	USART_US_CR_DTREN = 0x10000
	// Position of DTRDIS field.
	USART_US_CR_DTRDIS_Pos = 0x11
	// Bit mask of DTRDIS field.
	USART_US_CR_DTRDIS_Msk = 0x20000
	// Bit DTRDIS.
	USART_US_CR_DTRDIS = 0x20000
	// Position of RTSEN field.
	USART_US_CR_RTSEN_Pos = 0x12
	// Bit mask of RTSEN field.
	USART_US_CR_RTSEN_Msk = 0x40000
	// Bit RTSEN.
	USART_US_CR_RTSEN = 0x40000
	// Position of RTSDIS field.
	USART_US_CR_RTSDIS_Pos = 0x13
	// Bit mask of RTSDIS field.
	USART_US_CR_RTSDIS_Msk = 0x80000
	// Bit RTSDIS.
	USART_US_CR_RTSDIS = 0x80000
	// Position of LINABT field.
	USART_US_CR_LINABT_Pos = 0x14
	// Bit mask of LINABT field.
	USART_US_CR_LINABT_Msk = 0x100000
	// Bit LINABT.
	USART_US_CR_LINABT = 0x100000
	// Position of LINWKUP field.
	USART_US_CR_LINWKUP_Pos = 0x15
	// Bit mask of LINWKUP field.
	USART_US_CR_LINWKUP_Msk = 0x200000
	// Bit LINWKUP.
	USART_US_CR_LINWKUP = 0x200000

	// US_MR: Mode Register
	// Position of USART_MODE field.
	USART_US_MR_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_US_MR_USART_MODE_Msk = 0xf
	// Normal mode
	USART_US_MR_USART_MODE_NORMAL = 0x0
	// RS485
	USART_US_MR_USART_MODE_RS485 = 0x1
	// Hardware Handshaking
	USART_US_MR_USART_MODE_HW_HANDSHAKING = 0x2
	// Modem
	USART_US_MR_USART_MODE_MODEM = 0x3
	// IS07816 Protocol: T = 0
	USART_US_MR_USART_MODE_IS07816_T_0 = 0x4
	// IS07816 Protocol: T = 1
	USART_US_MR_USART_MODE_IS07816_T_1 = 0x6
	// IrDA
	USART_US_MR_USART_MODE_IRDA = 0x8
	// LON
	USART_US_MR_USART_MODE_LON = 0x9
	// SPI master
	USART_US_MR_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_US_MR_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_US_MR_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_US_MR_USCLKS_Msk = 0x30
	// Peripheral clock is selected
	USART_US_MR_USCLKS_MCK = 0x0
	// Peripheral clock divided (DIV=DIV=8) is selected
	USART_US_MR_USCLKS_DIV = 0x1
	// PMC programmable clock (PCK) is selected. If the SCK pin is driven (CLKO = 1), the CD field must be greater than 1.
	USART_US_MR_USCLKS_PCK = 0x2
	// Serial clock (SCK) is selected
	USART_US_MR_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_US_MR_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_US_MR_CHRL_Msk = 0xc0
	// Character length is 5 bits
	USART_US_MR_CHRL__5_BIT = 0x0
	// Character length is 6 bits
	USART_US_MR_CHRL__6_BIT = 0x1
	// Character length is 7 bits
	USART_US_MR_CHRL__7_BIT = 0x2
	// Character length is 8 bits
	USART_US_MR_CHRL__8_BIT = 0x3
	// Position of SYNC field.
	USART_US_MR_SYNC_Pos = 0x8
	// Bit mask of SYNC field.
	USART_US_MR_SYNC_Msk = 0x100
	// Bit SYNC.
	USART_US_MR_SYNC = 0x100
	// Position of PAR field.
	USART_US_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	USART_US_MR_PAR_Msk = 0xe00
	// Even parity
	USART_US_MR_PAR_EVEN = 0x0
	// Odd parity
	USART_US_MR_PAR_ODD = 0x1
	// Parity forced to 0 (Space)
	USART_US_MR_PAR_SPACE = 0x2
	// Parity forced to 1 (Mark)
	USART_US_MR_PAR_MARK = 0x3
	// No parity
	USART_US_MR_PAR_NO = 0x4
	// Multidrop mode
	USART_US_MR_PAR_MULTIDROP = 0x6
	// Position of NBSTOP field.
	USART_US_MR_NBSTOP_Pos = 0xc
	// Bit mask of NBSTOP field.
	USART_US_MR_NBSTOP_Msk = 0x3000
	// 1 stop bit
	USART_US_MR_NBSTOP__1_BIT = 0x0
	// 1.5 stop bit (SYNC = 0) or reserved (SYNC = 1)
	USART_US_MR_NBSTOP__1_5_BIT = 0x1
	// 2 stop bits
	USART_US_MR_NBSTOP__2_BIT = 0x2
	// Position of CHMODE field.
	USART_US_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	USART_US_MR_CHMODE_Msk = 0xc000
	// Normal mode
	USART_US_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo. Receiver input is connected to the TXD pin.
	USART_US_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback. Transmitter output is connected to the Receiver Input.
	USART_US_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback. RXD pin is internally connected to the TXD pin.
	USART_US_MR_CHMODE_REMOTE_LOOPBACK = 0x3
	// Position of MSBF field.
	USART_US_MR_MSBF_Pos = 0x10
	// Bit mask of MSBF field.
	USART_US_MR_MSBF_Msk = 0x10000
	// Bit MSBF.
	USART_US_MR_MSBF = 0x10000
	// Position of MODE9 field.
	USART_US_MR_MODE9_Pos = 0x11
	// Bit mask of MODE9 field.
	USART_US_MR_MODE9_Msk = 0x20000
	// Bit MODE9.
	USART_US_MR_MODE9 = 0x20000
	// Position of CLKO field.
	USART_US_MR_CLKO_Pos = 0x12
	// Bit mask of CLKO field.
	USART_US_MR_CLKO_Msk = 0x40000
	// Bit CLKO.
	USART_US_MR_CLKO = 0x40000
	// Position of OVER field.
	USART_US_MR_OVER_Pos = 0x13
	// Bit mask of OVER field.
	USART_US_MR_OVER_Msk = 0x80000
	// Bit OVER.
	USART_US_MR_OVER = 0x80000
	// Position of INACK field.
	USART_US_MR_INACK_Pos = 0x14
	// Bit mask of INACK field.
	USART_US_MR_INACK_Msk = 0x100000
	// Bit INACK.
	USART_US_MR_INACK = 0x100000
	// Position of DSNACK field.
	USART_US_MR_DSNACK_Pos = 0x15
	// Bit mask of DSNACK field.
	USART_US_MR_DSNACK_Msk = 0x200000
	// Bit DSNACK.
	USART_US_MR_DSNACK = 0x200000
	// Position of VAR_SYNC field.
	USART_US_MR_VAR_SYNC_Pos = 0x16
	// Bit mask of VAR_SYNC field.
	USART_US_MR_VAR_SYNC_Msk = 0x400000
	// Bit VAR_SYNC.
	USART_US_MR_VAR_SYNC = 0x400000
	// Position of INVDATA field.
	USART_US_MR_INVDATA_Pos = 0x17
	// Bit mask of INVDATA field.
	USART_US_MR_INVDATA_Msk = 0x800000
	// Bit INVDATA.
	USART_US_MR_INVDATA = 0x800000
	// Position of MAX_ITERATION field.
	USART_US_MR_MAX_ITERATION_Pos = 0x18
	// Bit mask of MAX_ITERATION field.
	USART_US_MR_MAX_ITERATION_Msk = 0x7000000
	// Position of FILTER field.
	USART_US_MR_FILTER_Pos = 0x1c
	// Bit mask of FILTER field.
	USART_US_MR_FILTER_Msk = 0x10000000
	// Bit FILTER.
	USART_US_MR_FILTER = 0x10000000
	// Position of MAN field.
	USART_US_MR_MAN_Pos = 0x1d
	// Bit mask of MAN field.
	USART_US_MR_MAN_Msk = 0x20000000
	// Bit MAN.
	USART_US_MR_MAN = 0x20000000
	// Position of MODSYNC field.
	USART_US_MR_MODSYNC_Pos = 0x1e
	// Bit mask of MODSYNC field.
	USART_US_MR_MODSYNC_Msk = 0x40000000
	// Bit MODSYNC.
	USART_US_MR_MODSYNC = 0x40000000
	// Position of ONEBIT field.
	USART_US_MR_ONEBIT_Pos = 0x1f
	// Bit mask of ONEBIT field.
	USART_US_MR_ONEBIT_Msk = 0x80000000
	// Bit ONEBIT.
	USART_US_MR_ONEBIT = 0x80000000

	// US_IER: Interrupt Enable Register
	// Position of RXRDY field.
	USART_US_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_US_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_US_IER_RXRDY = 0x1
	// Position of TXRDY field.
	USART_US_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_US_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_US_IER_TXRDY = 0x2
	// Position of RXBRK field.
	USART_US_IER_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_US_IER_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_US_IER_RXBRK = 0x4
	// Position of OVRE field.
	USART_US_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_US_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_US_IER_OVRE = 0x20
	// Position of FRAME field.
	USART_US_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_US_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_US_IER_FRAME = 0x40
	// Position of PARE field.
	USART_US_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_US_IER_PARE_Msk = 0x80
	// Bit PARE.
	USART_US_IER_PARE = 0x80
	// Position of TIMEOUT field.
	USART_US_IER_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_US_IER_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_US_IER_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_US_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_US_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_US_IER_TXEMPTY = 0x200
	// Position of ITER field.
	USART_US_IER_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_US_IER_ITER_Msk = 0x400
	// Bit ITER.
	USART_US_IER_ITER = 0x400
	// Position of NACK field.
	USART_US_IER_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_US_IER_NACK_Msk = 0x2000
	// Bit NACK.
	USART_US_IER_NACK = 0x2000
	// Position of RIIC field.
	USART_US_IER_RIIC_Pos = 0x10
	// Bit mask of RIIC field.
	USART_US_IER_RIIC_Msk = 0x10000
	// Bit RIIC.
	USART_US_IER_RIIC = 0x10000
	// Position of DSRIC field.
	USART_US_IER_DSRIC_Pos = 0x11
	// Bit mask of DSRIC field.
	USART_US_IER_DSRIC_Msk = 0x20000
	// Bit DSRIC.
	USART_US_IER_DSRIC = 0x20000
	// Position of DCDIC field.
	USART_US_IER_DCDIC_Pos = 0x12
	// Bit mask of DCDIC field.
	USART_US_IER_DCDIC_Msk = 0x40000
	// Bit DCDIC.
	USART_US_IER_DCDIC = 0x40000
	// Position of CTSIC field.
	USART_US_IER_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_US_IER_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_US_IER_CTSIC = 0x80000
	// Position of MANE field.
	USART_US_IER_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_US_IER_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_US_IER_MANE = 0x1000000

	// US_IDR: Interrupt Disable Register
	// Position of RXRDY field.
	USART_US_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_US_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_US_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_US_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_US_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_US_IDR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_US_IDR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_US_IDR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_US_IDR_RXBRK = 0x4
	// Position of OVRE field.
	USART_US_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_US_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_US_IDR_OVRE = 0x20
	// Position of FRAME field.
	USART_US_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_US_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_US_IDR_FRAME = 0x40
	// Position of PARE field.
	USART_US_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_US_IDR_PARE_Msk = 0x80
	// Bit PARE.
	USART_US_IDR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_US_IDR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_US_IDR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_US_IDR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_US_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_US_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_US_IDR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_US_IDR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_US_IDR_ITER_Msk = 0x400
	// Bit ITER.
	USART_US_IDR_ITER = 0x400
	// Position of NACK field.
	USART_US_IDR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_US_IDR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_US_IDR_NACK = 0x2000
	// Position of RIIC field.
	USART_US_IDR_RIIC_Pos = 0x10
	// Bit mask of RIIC field.
	USART_US_IDR_RIIC_Msk = 0x10000
	// Bit RIIC.
	USART_US_IDR_RIIC = 0x10000
	// Position of DSRIC field.
	USART_US_IDR_DSRIC_Pos = 0x11
	// Bit mask of DSRIC field.
	USART_US_IDR_DSRIC_Msk = 0x20000
	// Bit DSRIC.
	USART_US_IDR_DSRIC = 0x20000
	// Position of DCDIC field.
	USART_US_IDR_DCDIC_Pos = 0x12
	// Bit mask of DCDIC field.
	USART_US_IDR_DCDIC_Msk = 0x40000
	// Bit DCDIC.
	USART_US_IDR_DCDIC = 0x40000
	// Position of CTSIC field.
	USART_US_IDR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_US_IDR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_US_IDR_CTSIC = 0x80000
	// Position of MANE field.
	USART_US_IDR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_US_IDR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_US_IDR_MANE = 0x1000000

	// US_IMR: Interrupt Mask Register
	// Position of RXRDY field.
	USART_US_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_US_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_US_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_US_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_US_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_US_IMR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_US_IMR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_US_IMR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_US_IMR_RXBRK = 0x4
	// Position of OVRE field.
	USART_US_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_US_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_US_IMR_OVRE = 0x20
	// Position of FRAME field.
	USART_US_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_US_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_US_IMR_FRAME = 0x40
	// Position of PARE field.
	USART_US_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_US_IMR_PARE_Msk = 0x80
	// Bit PARE.
	USART_US_IMR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_US_IMR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_US_IMR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_US_IMR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_US_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_US_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_US_IMR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_US_IMR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_US_IMR_ITER_Msk = 0x400
	// Bit ITER.
	USART_US_IMR_ITER = 0x400
	// Position of NACK field.
	USART_US_IMR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_US_IMR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_US_IMR_NACK = 0x2000
	// Position of RIIC field.
	USART_US_IMR_RIIC_Pos = 0x10
	// Bit mask of RIIC field.
	USART_US_IMR_RIIC_Msk = 0x10000
	// Bit RIIC.
	USART_US_IMR_RIIC = 0x10000
	// Position of DSRIC field.
	USART_US_IMR_DSRIC_Pos = 0x11
	// Bit mask of DSRIC field.
	USART_US_IMR_DSRIC_Msk = 0x20000
	// Bit DSRIC.
	USART_US_IMR_DSRIC = 0x20000
	// Position of DCDIC field.
	USART_US_IMR_DCDIC_Pos = 0x12
	// Bit mask of DCDIC field.
	USART_US_IMR_DCDIC_Msk = 0x40000
	// Bit DCDIC.
	USART_US_IMR_DCDIC = 0x40000
	// Position of CTSIC field.
	USART_US_IMR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_US_IMR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_US_IMR_CTSIC = 0x80000
	// Position of MANE field.
	USART_US_IMR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_US_IMR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_US_IMR_MANE = 0x1000000

	// US_CSR: Channel Status Register
	// Position of RXRDY field.
	USART_US_CSR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_US_CSR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_US_CSR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_US_CSR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_US_CSR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_US_CSR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_US_CSR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_US_CSR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_US_CSR_RXBRK = 0x4
	// Position of OVRE field.
	USART_US_CSR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_US_CSR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_US_CSR_OVRE = 0x20
	// Position of FRAME field.
	USART_US_CSR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_US_CSR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_US_CSR_FRAME = 0x40
	// Position of PARE field.
	USART_US_CSR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_US_CSR_PARE_Msk = 0x80
	// Bit PARE.
	USART_US_CSR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_US_CSR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_US_CSR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_US_CSR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_US_CSR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_US_CSR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_US_CSR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_US_CSR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_US_CSR_ITER_Msk = 0x400
	// Bit ITER.
	USART_US_CSR_ITER = 0x400
	// Position of NACK field.
	USART_US_CSR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_US_CSR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_US_CSR_NACK = 0x2000
	// Position of RIIC field.
	USART_US_CSR_RIIC_Pos = 0x10
	// Bit mask of RIIC field.
	USART_US_CSR_RIIC_Msk = 0x10000
	// Bit RIIC.
	USART_US_CSR_RIIC = 0x10000
	// Position of DSRIC field.
	USART_US_CSR_DSRIC_Pos = 0x11
	// Bit mask of DSRIC field.
	USART_US_CSR_DSRIC_Msk = 0x20000
	// Bit DSRIC.
	USART_US_CSR_DSRIC = 0x20000
	// Position of DCDIC field.
	USART_US_CSR_DCDIC_Pos = 0x12
	// Bit mask of DCDIC field.
	USART_US_CSR_DCDIC_Msk = 0x40000
	// Bit DCDIC.
	USART_US_CSR_DCDIC = 0x40000
	// Position of CTSIC field.
	USART_US_CSR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_US_CSR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_US_CSR_CTSIC = 0x80000
	// Position of RI field.
	USART_US_CSR_RI_Pos = 0x14
	// Bit mask of RI field.
	USART_US_CSR_RI_Msk = 0x100000
	// Bit RI.
	USART_US_CSR_RI = 0x100000
	// Position of DSR field.
	USART_US_CSR_DSR_Pos = 0x15
	// Bit mask of DSR field.
	USART_US_CSR_DSR_Msk = 0x200000
	// Bit DSR.
	USART_US_CSR_DSR = 0x200000
	// Position of DCD field.
	USART_US_CSR_DCD_Pos = 0x16
	// Bit mask of DCD field.
	USART_US_CSR_DCD_Msk = 0x400000
	// Bit DCD.
	USART_US_CSR_DCD = 0x400000
	// Position of CTS field.
	USART_US_CSR_CTS_Pos = 0x17
	// Bit mask of CTS field.
	USART_US_CSR_CTS_Msk = 0x800000
	// Bit CTS.
	USART_US_CSR_CTS = 0x800000
	// Position of MANERR field.
	USART_US_CSR_MANERR_Pos = 0x18
	// Bit mask of MANERR field.
	USART_US_CSR_MANERR_Msk = 0x1000000
	// Bit MANERR.
	USART_US_CSR_MANERR = 0x1000000

	// US_RHR: Receive Holding Register
	// Position of RXCHR field.
	USART_US_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	USART_US_RHR_RXCHR_Msk = 0x1ff
	// Position of RXSYNH field.
	USART_US_RHR_RXSYNH_Pos = 0xf
	// Bit mask of RXSYNH field.
	USART_US_RHR_RXSYNH_Msk = 0x8000
	// Bit RXSYNH.
	USART_US_RHR_RXSYNH = 0x8000

	// US_THR: Transmit Holding Register
	// Position of TXCHR field.
	USART_US_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	USART_US_THR_TXCHR_Msk = 0x1ff
	// Position of TXSYNH field.
	USART_US_THR_TXSYNH_Pos = 0xf
	// Bit mask of TXSYNH field.
	USART_US_THR_TXSYNH_Msk = 0x8000
	// Bit TXSYNH.
	USART_US_THR_TXSYNH = 0x8000

	// US_BRGR: Baud Rate Generator Register
	// Position of CD field.
	USART_US_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	USART_US_BRGR_CD_Msk = 0xffff
	// Position of FP field.
	USART_US_BRGR_FP_Pos = 0x10
	// Bit mask of FP field.
	USART_US_BRGR_FP_Msk = 0x70000

	// US_RTOR: Receiver Time-out Register
	// Position of TO field.
	USART_US_RTOR_TO_Pos = 0x0
	// Bit mask of TO field.
	USART_US_RTOR_TO_Msk = 0x1ffff

	// US_TTGR: Transmitter Timeguard Register
	// Position of TG field.
	USART_US_TTGR_TG_Pos = 0x0
	// Bit mask of TG field.
	USART_US_TTGR_TG_Msk = 0xff

	// US_FIDI: FI DI Ratio Register
	// Position of FI_DI_RATIO field.
	USART_US_FIDI_FI_DI_RATIO_Pos = 0x0
	// Bit mask of FI_DI_RATIO field.
	USART_US_FIDI_FI_DI_RATIO_Msk = 0xffff

	// US_NER: Number of Errors Register
	// Position of NB_ERRORS field.
	USART_US_NER_NB_ERRORS_Pos = 0x0
	// Bit mask of NB_ERRORS field.
	USART_US_NER_NB_ERRORS_Msk = 0xff

	// US_IF: IrDA Filter Register
	// Position of IRDA_FILTER field.
	USART_US_IF_IRDA_FILTER_Pos = 0x0
	// Bit mask of IRDA_FILTER field.
	USART_US_IF_IRDA_FILTER_Msk = 0xff

	// US_MAN: Manchester Configuration Register
	// Position of TX_PL field.
	USART_US_MAN_TX_PL_Pos = 0x0
	// Bit mask of TX_PL field.
	USART_US_MAN_TX_PL_Msk = 0xf
	// Position of TX_PP field.
	USART_US_MAN_TX_PP_Pos = 0x8
	// Bit mask of TX_PP field.
	USART_US_MAN_TX_PP_Msk = 0x300
	// The preamble is composed of '1's
	USART_US_MAN_TX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_US_MAN_TX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_US_MAN_TX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_US_MAN_TX_PP_ONE_ZERO = 0x3
	// Position of TX_MPOL field.
	USART_US_MAN_TX_MPOL_Pos = 0xc
	// Bit mask of TX_MPOL field.
	USART_US_MAN_TX_MPOL_Msk = 0x1000
	// Bit TX_MPOL.
	USART_US_MAN_TX_MPOL = 0x1000
	// Position of RX_PL field.
	USART_US_MAN_RX_PL_Pos = 0x10
	// Bit mask of RX_PL field.
	USART_US_MAN_RX_PL_Msk = 0xf0000
	// Position of RX_PP field.
	USART_US_MAN_RX_PP_Pos = 0x18
	// Bit mask of RX_PP field.
	USART_US_MAN_RX_PP_Msk = 0x3000000
	// The preamble is composed of '1's
	USART_US_MAN_RX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_US_MAN_RX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_US_MAN_RX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_US_MAN_RX_PP_ONE_ZERO = 0x3
	// Position of RX_MPOL field.
	USART_US_MAN_RX_MPOL_Pos = 0x1c
	// Bit mask of RX_MPOL field.
	USART_US_MAN_RX_MPOL_Msk = 0x10000000
	// Bit RX_MPOL.
	USART_US_MAN_RX_MPOL = 0x10000000
	// Position of ONE field.
	USART_US_MAN_ONE_Pos = 0x1d
	// Bit mask of ONE field.
	USART_US_MAN_ONE_Msk = 0x20000000
	// Bit ONE.
	USART_US_MAN_ONE = 0x20000000
	// Position of DRIFT field.
	USART_US_MAN_DRIFT_Pos = 0x1e
	// Bit mask of DRIFT field.
	USART_US_MAN_DRIFT_Msk = 0x40000000
	// Bit DRIFT.
	USART_US_MAN_DRIFT = 0x40000000
	// Position of RXIDLEV field.
	USART_US_MAN_RXIDLEV_Pos = 0x1f
	// Bit mask of RXIDLEV field.
	USART_US_MAN_RXIDLEV_Msk = 0x80000000
	// Bit RXIDLEV.
	USART_US_MAN_RXIDLEV = 0x80000000

	// US_LINMR: LIN Mode Register
	// Position of NACT field.
	USART_US_LINMR_NACT_Pos = 0x0
	// Bit mask of NACT field.
	USART_US_LINMR_NACT_Msk = 0x3
	// The USART transmits the response.
	USART_US_LINMR_NACT_PUBLISH = 0x0
	// The USART receives the response.
	USART_US_LINMR_NACT_SUBSCRIBE = 0x1
	// The USART does not transmit and does not receive the response.
	USART_US_LINMR_NACT_IGNORE = 0x2
	// Position of PARDIS field.
	USART_US_LINMR_PARDIS_Pos = 0x2
	// Bit mask of PARDIS field.
	USART_US_LINMR_PARDIS_Msk = 0x4
	// Bit PARDIS.
	USART_US_LINMR_PARDIS = 0x4
	// Position of CHKDIS field.
	USART_US_LINMR_CHKDIS_Pos = 0x3
	// Bit mask of CHKDIS field.
	USART_US_LINMR_CHKDIS_Msk = 0x8
	// Bit CHKDIS.
	USART_US_LINMR_CHKDIS = 0x8
	// Position of CHKTYP field.
	USART_US_LINMR_CHKTYP_Pos = 0x4
	// Bit mask of CHKTYP field.
	USART_US_LINMR_CHKTYP_Msk = 0x10
	// Bit CHKTYP.
	USART_US_LINMR_CHKTYP = 0x10
	// Position of DLM field.
	USART_US_LINMR_DLM_Pos = 0x5
	// Bit mask of DLM field.
	USART_US_LINMR_DLM_Msk = 0x20
	// Bit DLM.
	USART_US_LINMR_DLM = 0x20
	// Position of FSDIS field.
	USART_US_LINMR_FSDIS_Pos = 0x6
	// Bit mask of FSDIS field.
	USART_US_LINMR_FSDIS_Msk = 0x40
	// Bit FSDIS.
	USART_US_LINMR_FSDIS = 0x40
	// Position of WKUPTYP field.
	USART_US_LINMR_WKUPTYP_Pos = 0x7
	// Bit mask of WKUPTYP field.
	USART_US_LINMR_WKUPTYP_Msk = 0x80
	// Bit WKUPTYP.
	USART_US_LINMR_WKUPTYP = 0x80
	// Position of DLC field.
	USART_US_LINMR_DLC_Pos = 0x8
	// Bit mask of DLC field.
	USART_US_LINMR_DLC_Msk = 0xff00
	// Position of PDCM field.
	USART_US_LINMR_PDCM_Pos = 0x10
	// Bit mask of PDCM field.
	USART_US_LINMR_PDCM_Msk = 0x10000
	// Bit PDCM.
	USART_US_LINMR_PDCM = 0x10000
	// Position of SYNCDIS field.
	USART_US_LINMR_SYNCDIS_Pos = 0x11
	// Bit mask of SYNCDIS field.
	USART_US_LINMR_SYNCDIS_Msk = 0x20000
	// Bit SYNCDIS.
	USART_US_LINMR_SYNCDIS = 0x20000

	// US_LINIR: LIN Identifier Register
	// Position of IDCHR field.
	USART_US_LINIR_IDCHR_Pos = 0x0
	// Bit mask of IDCHR field.
	USART_US_LINIR_IDCHR_Msk = 0xff

	// US_LINBRR: LIN Baud Rate Register
	// Position of LINCD field.
	USART_US_LINBRR_LINCD_Pos = 0x0
	// Bit mask of LINCD field.
	USART_US_LINBRR_LINCD_Msk = 0xffff
	// Position of LINFP field.
	USART_US_LINBRR_LINFP_Pos = 0x10
	// Bit mask of LINFP field.
	USART_US_LINBRR_LINFP_Msk = 0x70000

	// US_LONMR: LON Mode Register
	// Position of COMMT field.
	USART_US_LONMR_COMMT_Pos = 0x0
	// Bit mask of COMMT field.
	USART_US_LONMR_COMMT_Msk = 0x1
	// Bit COMMT.
	USART_US_LONMR_COMMT = 0x1
	// Position of COLDET field.
	USART_US_LONMR_COLDET_Pos = 0x1
	// Bit mask of COLDET field.
	USART_US_LONMR_COLDET_Msk = 0x2
	// Bit COLDET.
	USART_US_LONMR_COLDET = 0x2
	// Position of TCOL field.
	USART_US_LONMR_TCOL_Pos = 0x2
	// Bit mask of TCOL field.
	USART_US_LONMR_TCOL_Msk = 0x4
	// Bit TCOL.
	USART_US_LONMR_TCOL = 0x4
	// Position of CDTAIL field.
	USART_US_LONMR_CDTAIL_Pos = 0x3
	// Bit mask of CDTAIL field.
	USART_US_LONMR_CDTAIL_Msk = 0x8
	// Bit CDTAIL.
	USART_US_LONMR_CDTAIL = 0x8
	// Position of DMAM field.
	USART_US_LONMR_DMAM_Pos = 0x4
	// Bit mask of DMAM field.
	USART_US_LONMR_DMAM_Msk = 0x10
	// Bit DMAM.
	USART_US_LONMR_DMAM = 0x10
	// Position of LCDS field.
	USART_US_LONMR_LCDS_Pos = 0x5
	// Bit mask of LCDS field.
	USART_US_LONMR_LCDS_Msk = 0x20
	// Bit LCDS.
	USART_US_LONMR_LCDS = 0x20
	// Position of EOFS field.
	USART_US_LONMR_EOFS_Pos = 0x10
	// Bit mask of EOFS field.
	USART_US_LONMR_EOFS_Msk = 0xff0000

	// US_LONPR: LON Preamble Register
	// Position of LONPL field.
	USART_US_LONPR_LONPL_Pos = 0x0
	// Bit mask of LONPL field.
	USART_US_LONPR_LONPL_Msk = 0x3fff

	// US_LONDL: LON Data Length Register
	// Position of LONDL field.
	USART_US_LONDL_LONDL_Pos = 0x0
	// Bit mask of LONDL field.
	USART_US_LONDL_LONDL_Msk = 0xff

	// US_LONL2HDR: LON L2HDR Register
	// Position of BLI field.
	USART_US_LONL2HDR_BLI_Pos = 0x0
	// Bit mask of BLI field.
	USART_US_LONL2HDR_BLI_Msk = 0x3f
	// Position of ALTP field.
	USART_US_LONL2HDR_ALTP_Pos = 0x6
	// Bit mask of ALTP field.
	USART_US_LONL2HDR_ALTP_Msk = 0x40
	// Bit ALTP.
	USART_US_LONL2HDR_ALTP = 0x40
	// Position of PB field.
	USART_US_LONL2HDR_PB_Pos = 0x7
	// Bit mask of PB field.
	USART_US_LONL2HDR_PB_Msk = 0x80
	// Bit PB.
	USART_US_LONL2HDR_PB = 0x80

	// US_LONBL: LON Backlog Register
	// Position of LONBL field.
	USART_US_LONBL_LONBL_Pos = 0x0
	// Bit mask of LONBL field.
	USART_US_LONBL_LONBL_Msk = 0x3f

	// US_LONB1TX: LON Beta1 Tx Register
	// Position of BETA1TX field.
	USART_US_LONB1TX_BETA1TX_Pos = 0x0
	// Bit mask of BETA1TX field.
	USART_US_LONB1TX_BETA1TX_Msk = 0xffffff

	// US_LONB1RX: LON Beta1 Rx Register
	// Position of BETA1RX field.
	USART_US_LONB1RX_BETA1RX_Pos = 0x0
	// Bit mask of BETA1RX field.
	USART_US_LONB1RX_BETA1RX_Msk = 0xffffff

	// US_LONPRIO: LON Priority Register
	// Position of PSNB field.
	USART_US_LONPRIO_PSNB_Pos = 0x0
	// Bit mask of PSNB field.
	USART_US_LONPRIO_PSNB_Msk = 0x7f
	// Position of NPS field.
	USART_US_LONPRIO_NPS_Pos = 0x8
	// Bit mask of NPS field.
	USART_US_LONPRIO_NPS_Msk = 0x7f00

	// US_IDTTX: LON IDT Tx Register
	// Position of IDTTX field.
	USART_US_IDTTX_IDTTX_Pos = 0x0
	// Bit mask of IDTTX field.
	USART_US_IDTTX_IDTTX_Msk = 0xffffff

	// US_IDTRX: LON IDT Rx Register
	// Position of IDTRX field.
	USART_US_IDTRX_IDTRX_Pos = 0x0
	// Bit mask of IDTRX field.
	USART_US_IDTRX_IDTRX_Msk = 0xffffff

	// US_ICDIFF: IC DIFF Register
	// Position of ICDIFF field.
	USART_US_ICDIFF_ICDIFF_Pos = 0x0
	// Bit mask of ICDIFF field.
	USART_US_ICDIFF_ICDIFF_Msk = 0xf

	// US_WPMR: Write Protection Mode Register
	// Position of WPEN field.
	USART_US_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	USART_US_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	USART_US_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	USART_US_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	USART_US_WPMR_WPKEY_Msk = 0xffffff00
	// Writing any other value in this field aborts the write operation of the WPEN bit. Always reads as 0.
	USART_US_WPMR_WPKEY_PASSWD = 0x555341

	// US_WPSR: Write Protection Status Register
	// Position of WPVS field.
	USART_US_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	USART_US_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	USART_US_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	USART_US_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	USART_US_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for USBHS: USB High-Speed Interface
const (
	// DEVCTRL: Device General Control Register
	// Position of UADD field.
	USBHS_DEVCTRL_UADD_Pos = 0x0
	// Bit mask of UADD field.
	USBHS_DEVCTRL_UADD_Msk = 0x7f
	// Position of ADDEN field.
	USBHS_DEVCTRL_ADDEN_Pos = 0x7
	// Bit mask of ADDEN field.
	USBHS_DEVCTRL_ADDEN_Msk = 0x80
	// Bit ADDEN.
	USBHS_DEVCTRL_ADDEN = 0x80
	// Position of DETACH field.
	USBHS_DEVCTRL_DETACH_Pos = 0x8
	// Bit mask of DETACH field.
	USBHS_DEVCTRL_DETACH_Msk = 0x100
	// Bit DETACH.
	USBHS_DEVCTRL_DETACH = 0x100
	// Position of RMWKUP field.
	USBHS_DEVCTRL_RMWKUP_Pos = 0x9
	// Bit mask of RMWKUP field.
	USBHS_DEVCTRL_RMWKUP_Msk = 0x200
	// Bit RMWKUP.
	USBHS_DEVCTRL_RMWKUP = 0x200
	// Position of SPDCONF field.
	USBHS_DEVCTRL_SPDCONF_Pos = 0xa
	// Bit mask of SPDCONF field.
	USBHS_DEVCTRL_SPDCONF_Msk = 0xc00
	// The peripheral starts in Full-speed mode and performs a high-speed reset to switch to High-speed mode if the host is high-speed-capable.
	USBHS_DEVCTRL_SPDCONF_NORMAL = 0x0
	// For a better consumption, if high speed is not needed.
	USBHS_DEVCTRL_SPDCONF_LOW_POWER = 0x1
	// Position of LS field.
	USBHS_DEVCTRL_LS_Pos = 0xc
	// Bit mask of LS field.
	USBHS_DEVCTRL_LS_Msk = 0x1000
	// Bit LS.
	USBHS_DEVCTRL_LS = 0x1000
	// Position of TSTJ field.
	USBHS_DEVCTRL_TSTJ_Pos = 0xd
	// Bit mask of TSTJ field.
	USBHS_DEVCTRL_TSTJ_Msk = 0x2000
	// Bit TSTJ.
	USBHS_DEVCTRL_TSTJ = 0x2000
	// Position of TSTK field.
	USBHS_DEVCTRL_TSTK_Pos = 0xe
	// Bit mask of TSTK field.
	USBHS_DEVCTRL_TSTK_Msk = 0x4000
	// Bit TSTK.
	USBHS_DEVCTRL_TSTK = 0x4000
	// Position of TSTPCKT field.
	USBHS_DEVCTRL_TSTPCKT_Pos = 0xf
	// Bit mask of TSTPCKT field.
	USBHS_DEVCTRL_TSTPCKT_Msk = 0x8000
	// Bit TSTPCKT.
	USBHS_DEVCTRL_TSTPCKT = 0x8000
	// Position of OPMODE2 field.
	USBHS_DEVCTRL_OPMODE2_Pos = 0x10
	// Bit mask of OPMODE2 field.
	USBHS_DEVCTRL_OPMODE2_Msk = 0x10000
	// Bit OPMODE2.
	USBHS_DEVCTRL_OPMODE2 = 0x10000

	// DEVISR: Device Global Interrupt Status Register
	// Position of SUSP field.
	USBHS_DEVISR_SUSP_Pos = 0x0
	// Bit mask of SUSP field.
	USBHS_DEVISR_SUSP_Msk = 0x1
	// Bit SUSP.
	USBHS_DEVISR_SUSP = 0x1
	// Position of MSOF field.
	USBHS_DEVISR_MSOF_Pos = 0x1
	// Bit mask of MSOF field.
	USBHS_DEVISR_MSOF_Msk = 0x2
	// Bit MSOF.
	USBHS_DEVISR_MSOF = 0x2
	// Position of SOF field.
	USBHS_DEVISR_SOF_Pos = 0x2
	// Bit mask of SOF field.
	USBHS_DEVISR_SOF_Msk = 0x4
	// Bit SOF.
	USBHS_DEVISR_SOF = 0x4
	// Position of EORST field.
	USBHS_DEVISR_EORST_Pos = 0x3
	// Bit mask of EORST field.
	USBHS_DEVISR_EORST_Msk = 0x8
	// Bit EORST.
	USBHS_DEVISR_EORST = 0x8
	// Position of WAKEUP field.
	USBHS_DEVISR_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USBHS_DEVISR_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USBHS_DEVISR_WAKEUP = 0x10
	// Position of EORSM field.
	USBHS_DEVISR_EORSM_Pos = 0x5
	// Bit mask of EORSM field.
	USBHS_DEVISR_EORSM_Msk = 0x20
	// Bit EORSM.
	USBHS_DEVISR_EORSM = 0x20
	// Position of UPRSM field.
	USBHS_DEVISR_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USBHS_DEVISR_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USBHS_DEVISR_UPRSM = 0x40
	// Position of PEP_0 field.
	USBHS_DEVISR_PEP_0_Pos = 0xc
	// Bit mask of PEP_0 field.
	USBHS_DEVISR_PEP_0_Msk = 0x1000
	// Bit PEP_0.
	USBHS_DEVISR_PEP_0 = 0x1000
	// Position of PEP_1 field.
	USBHS_DEVISR_PEP_1_Pos = 0xd
	// Bit mask of PEP_1 field.
	USBHS_DEVISR_PEP_1_Msk = 0x2000
	// Bit PEP_1.
	USBHS_DEVISR_PEP_1 = 0x2000
	// Position of PEP_2 field.
	USBHS_DEVISR_PEP_2_Pos = 0xe
	// Bit mask of PEP_2 field.
	USBHS_DEVISR_PEP_2_Msk = 0x4000
	// Bit PEP_2.
	USBHS_DEVISR_PEP_2 = 0x4000
	// Position of PEP_3 field.
	USBHS_DEVISR_PEP_3_Pos = 0xf
	// Bit mask of PEP_3 field.
	USBHS_DEVISR_PEP_3_Msk = 0x8000
	// Bit PEP_3.
	USBHS_DEVISR_PEP_3 = 0x8000
	// Position of PEP_4 field.
	USBHS_DEVISR_PEP_4_Pos = 0x10
	// Bit mask of PEP_4 field.
	USBHS_DEVISR_PEP_4_Msk = 0x10000
	// Bit PEP_4.
	USBHS_DEVISR_PEP_4 = 0x10000
	// Position of PEP_5 field.
	USBHS_DEVISR_PEP_5_Pos = 0x11
	// Bit mask of PEP_5 field.
	USBHS_DEVISR_PEP_5_Msk = 0x20000
	// Bit PEP_5.
	USBHS_DEVISR_PEP_5 = 0x20000
	// Position of PEP_6 field.
	USBHS_DEVISR_PEP_6_Pos = 0x12
	// Bit mask of PEP_6 field.
	USBHS_DEVISR_PEP_6_Msk = 0x40000
	// Bit PEP_6.
	USBHS_DEVISR_PEP_6 = 0x40000
	// Position of PEP_7 field.
	USBHS_DEVISR_PEP_7_Pos = 0x13
	// Bit mask of PEP_7 field.
	USBHS_DEVISR_PEP_7_Msk = 0x80000
	// Bit PEP_7.
	USBHS_DEVISR_PEP_7 = 0x80000
	// Position of PEP_8 field.
	USBHS_DEVISR_PEP_8_Pos = 0x14
	// Bit mask of PEP_8 field.
	USBHS_DEVISR_PEP_8_Msk = 0x100000
	// Bit PEP_8.
	USBHS_DEVISR_PEP_8 = 0x100000
	// Position of PEP_9 field.
	USBHS_DEVISR_PEP_9_Pos = 0x15
	// Bit mask of PEP_9 field.
	USBHS_DEVISR_PEP_9_Msk = 0x200000
	// Bit PEP_9.
	USBHS_DEVISR_PEP_9 = 0x200000
	// Position of PEP_10 field.
	USBHS_DEVISR_PEP_10_Pos = 0x16
	// Bit mask of PEP_10 field.
	USBHS_DEVISR_PEP_10_Msk = 0x400000
	// Bit PEP_10.
	USBHS_DEVISR_PEP_10 = 0x400000
	// Position of PEP_11 field.
	USBHS_DEVISR_PEP_11_Pos = 0x17
	// Bit mask of PEP_11 field.
	USBHS_DEVISR_PEP_11_Msk = 0x800000
	// Bit PEP_11.
	USBHS_DEVISR_PEP_11 = 0x800000
	// Position of DMA_1 field.
	USBHS_DEVISR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_DEVISR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_DEVISR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_DEVISR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_DEVISR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_DEVISR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_DEVISR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_DEVISR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_DEVISR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_DEVISR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_DEVISR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_DEVISR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_DEVISR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_DEVISR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_DEVISR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_DEVISR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_DEVISR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_DEVISR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_DEVISR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_DEVISR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_DEVISR_DMA_7 = 0x80000000

	// DEVICR: Device Global Interrupt Clear Register
	// Position of SUSPC field.
	USBHS_DEVICR_SUSPC_Pos = 0x0
	// Bit mask of SUSPC field.
	USBHS_DEVICR_SUSPC_Msk = 0x1
	// Bit SUSPC.
	USBHS_DEVICR_SUSPC = 0x1
	// Position of MSOFC field.
	USBHS_DEVICR_MSOFC_Pos = 0x1
	// Bit mask of MSOFC field.
	USBHS_DEVICR_MSOFC_Msk = 0x2
	// Bit MSOFC.
	USBHS_DEVICR_MSOFC = 0x2
	// Position of SOFC field.
	USBHS_DEVICR_SOFC_Pos = 0x2
	// Bit mask of SOFC field.
	USBHS_DEVICR_SOFC_Msk = 0x4
	// Bit SOFC.
	USBHS_DEVICR_SOFC = 0x4
	// Position of EORSTC field.
	USBHS_DEVICR_EORSTC_Pos = 0x3
	// Bit mask of EORSTC field.
	USBHS_DEVICR_EORSTC_Msk = 0x8
	// Bit EORSTC.
	USBHS_DEVICR_EORSTC = 0x8
	// Position of WAKEUPC field.
	USBHS_DEVICR_WAKEUPC_Pos = 0x4
	// Bit mask of WAKEUPC field.
	USBHS_DEVICR_WAKEUPC_Msk = 0x10
	// Bit WAKEUPC.
	USBHS_DEVICR_WAKEUPC = 0x10
	// Position of EORSMC field.
	USBHS_DEVICR_EORSMC_Pos = 0x5
	// Bit mask of EORSMC field.
	USBHS_DEVICR_EORSMC_Msk = 0x20
	// Bit EORSMC.
	USBHS_DEVICR_EORSMC = 0x20
	// Position of UPRSMC field.
	USBHS_DEVICR_UPRSMC_Pos = 0x6
	// Bit mask of UPRSMC field.
	USBHS_DEVICR_UPRSMC_Msk = 0x40
	// Bit UPRSMC.
	USBHS_DEVICR_UPRSMC = 0x40

	// DEVIFR: Device Global Interrupt Set Register
	// Position of SUSPS field.
	USBHS_DEVIFR_SUSPS_Pos = 0x0
	// Bit mask of SUSPS field.
	USBHS_DEVIFR_SUSPS_Msk = 0x1
	// Bit SUSPS.
	USBHS_DEVIFR_SUSPS = 0x1
	// Position of MSOFS field.
	USBHS_DEVIFR_MSOFS_Pos = 0x1
	// Bit mask of MSOFS field.
	USBHS_DEVIFR_MSOFS_Msk = 0x2
	// Bit MSOFS.
	USBHS_DEVIFR_MSOFS = 0x2
	// Position of SOFS field.
	USBHS_DEVIFR_SOFS_Pos = 0x2
	// Bit mask of SOFS field.
	USBHS_DEVIFR_SOFS_Msk = 0x4
	// Bit SOFS.
	USBHS_DEVIFR_SOFS = 0x4
	// Position of EORSTS field.
	USBHS_DEVIFR_EORSTS_Pos = 0x3
	// Bit mask of EORSTS field.
	USBHS_DEVIFR_EORSTS_Msk = 0x8
	// Bit EORSTS.
	USBHS_DEVIFR_EORSTS = 0x8
	// Position of WAKEUPS field.
	USBHS_DEVIFR_WAKEUPS_Pos = 0x4
	// Bit mask of WAKEUPS field.
	USBHS_DEVIFR_WAKEUPS_Msk = 0x10
	// Bit WAKEUPS.
	USBHS_DEVIFR_WAKEUPS = 0x10
	// Position of EORSMS field.
	USBHS_DEVIFR_EORSMS_Pos = 0x5
	// Bit mask of EORSMS field.
	USBHS_DEVIFR_EORSMS_Msk = 0x20
	// Bit EORSMS.
	USBHS_DEVIFR_EORSMS = 0x20
	// Position of UPRSMS field.
	USBHS_DEVIFR_UPRSMS_Pos = 0x6
	// Bit mask of UPRSMS field.
	USBHS_DEVIFR_UPRSMS_Msk = 0x40
	// Bit UPRSMS.
	USBHS_DEVIFR_UPRSMS = 0x40
	// Position of DMA_1 field.
	USBHS_DEVIFR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_DEVIFR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_DEVIFR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_DEVIFR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_DEVIFR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_DEVIFR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_DEVIFR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_DEVIFR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_DEVIFR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_DEVIFR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_DEVIFR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_DEVIFR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_DEVIFR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_DEVIFR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_DEVIFR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_DEVIFR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_DEVIFR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_DEVIFR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_DEVIFR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_DEVIFR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_DEVIFR_DMA_7 = 0x80000000

	// DEVIMR: Device Global Interrupt Mask Register
	// Position of SUSPE field.
	USBHS_DEVIMR_SUSPE_Pos = 0x0
	// Bit mask of SUSPE field.
	USBHS_DEVIMR_SUSPE_Msk = 0x1
	// Bit SUSPE.
	USBHS_DEVIMR_SUSPE = 0x1
	// Position of MSOFE field.
	USBHS_DEVIMR_MSOFE_Pos = 0x1
	// Bit mask of MSOFE field.
	USBHS_DEVIMR_MSOFE_Msk = 0x2
	// Bit MSOFE.
	USBHS_DEVIMR_MSOFE = 0x2
	// Position of SOFE field.
	USBHS_DEVIMR_SOFE_Pos = 0x2
	// Bit mask of SOFE field.
	USBHS_DEVIMR_SOFE_Msk = 0x4
	// Bit SOFE.
	USBHS_DEVIMR_SOFE = 0x4
	// Position of EORSTE field.
	USBHS_DEVIMR_EORSTE_Pos = 0x3
	// Bit mask of EORSTE field.
	USBHS_DEVIMR_EORSTE_Msk = 0x8
	// Bit EORSTE.
	USBHS_DEVIMR_EORSTE = 0x8
	// Position of WAKEUPE field.
	USBHS_DEVIMR_WAKEUPE_Pos = 0x4
	// Bit mask of WAKEUPE field.
	USBHS_DEVIMR_WAKEUPE_Msk = 0x10
	// Bit WAKEUPE.
	USBHS_DEVIMR_WAKEUPE = 0x10
	// Position of EORSME field.
	USBHS_DEVIMR_EORSME_Pos = 0x5
	// Bit mask of EORSME field.
	USBHS_DEVIMR_EORSME_Msk = 0x20
	// Bit EORSME.
	USBHS_DEVIMR_EORSME = 0x20
	// Position of UPRSME field.
	USBHS_DEVIMR_UPRSME_Pos = 0x6
	// Bit mask of UPRSME field.
	USBHS_DEVIMR_UPRSME_Msk = 0x40
	// Bit UPRSME.
	USBHS_DEVIMR_UPRSME = 0x40
	// Position of PEP_0 field.
	USBHS_DEVIMR_PEP_0_Pos = 0xc
	// Bit mask of PEP_0 field.
	USBHS_DEVIMR_PEP_0_Msk = 0x1000
	// Bit PEP_0.
	USBHS_DEVIMR_PEP_0 = 0x1000
	// Position of PEP_1 field.
	USBHS_DEVIMR_PEP_1_Pos = 0xd
	// Bit mask of PEP_1 field.
	USBHS_DEVIMR_PEP_1_Msk = 0x2000
	// Bit PEP_1.
	USBHS_DEVIMR_PEP_1 = 0x2000
	// Position of PEP_2 field.
	USBHS_DEVIMR_PEP_2_Pos = 0xe
	// Bit mask of PEP_2 field.
	USBHS_DEVIMR_PEP_2_Msk = 0x4000
	// Bit PEP_2.
	USBHS_DEVIMR_PEP_2 = 0x4000
	// Position of PEP_3 field.
	USBHS_DEVIMR_PEP_3_Pos = 0xf
	// Bit mask of PEP_3 field.
	USBHS_DEVIMR_PEP_3_Msk = 0x8000
	// Bit PEP_3.
	USBHS_DEVIMR_PEP_3 = 0x8000
	// Position of PEP_4 field.
	USBHS_DEVIMR_PEP_4_Pos = 0x10
	// Bit mask of PEP_4 field.
	USBHS_DEVIMR_PEP_4_Msk = 0x10000
	// Bit PEP_4.
	USBHS_DEVIMR_PEP_4 = 0x10000
	// Position of PEP_5 field.
	USBHS_DEVIMR_PEP_5_Pos = 0x11
	// Bit mask of PEP_5 field.
	USBHS_DEVIMR_PEP_5_Msk = 0x20000
	// Bit PEP_5.
	USBHS_DEVIMR_PEP_5 = 0x20000
	// Position of PEP_6 field.
	USBHS_DEVIMR_PEP_6_Pos = 0x12
	// Bit mask of PEP_6 field.
	USBHS_DEVIMR_PEP_6_Msk = 0x40000
	// Bit PEP_6.
	USBHS_DEVIMR_PEP_6 = 0x40000
	// Position of PEP_7 field.
	USBHS_DEVIMR_PEP_7_Pos = 0x13
	// Bit mask of PEP_7 field.
	USBHS_DEVIMR_PEP_7_Msk = 0x80000
	// Bit PEP_7.
	USBHS_DEVIMR_PEP_7 = 0x80000
	// Position of PEP_8 field.
	USBHS_DEVIMR_PEP_8_Pos = 0x14
	// Bit mask of PEP_8 field.
	USBHS_DEVIMR_PEP_8_Msk = 0x100000
	// Bit PEP_8.
	USBHS_DEVIMR_PEP_8 = 0x100000
	// Position of PEP_9 field.
	USBHS_DEVIMR_PEP_9_Pos = 0x15
	// Bit mask of PEP_9 field.
	USBHS_DEVIMR_PEP_9_Msk = 0x200000
	// Bit PEP_9.
	USBHS_DEVIMR_PEP_9 = 0x200000
	// Position of PEP_10 field.
	USBHS_DEVIMR_PEP_10_Pos = 0x16
	// Bit mask of PEP_10 field.
	USBHS_DEVIMR_PEP_10_Msk = 0x400000
	// Bit PEP_10.
	USBHS_DEVIMR_PEP_10 = 0x400000
	// Position of PEP_11 field.
	USBHS_DEVIMR_PEP_11_Pos = 0x17
	// Bit mask of PEP_11 field.
	USBHS_DEVIMR_PEP_11_Msk = 0x800000
	// Bit PEP_11.
	USBHS_DEVIMR_PEP_11 = 0x800000
	// Position of DMA_1 field.
	USBHS_DEVIMR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_DEVIMR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_DEVIMR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_DEVIMR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_DEVIMR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_DEVIMR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_DEVIMR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_DEVIMR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_DEVIMR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_DEVIMR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_DEVIMR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_DEVIMR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_DEVIMR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_DEVIMR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_DEVIMR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_DEVIMR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_DEVIMR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_DEVIMR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_DEVIMR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_DEVIMR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_DEVIMR_DMA_7 = 0x80000000

	// DEVIDR: Device Global Interrupt Disable Register
	// Position of SUSPEC field.
	USBHS_DEVIDR_SUSPEC_Pos = 0x0
	// Bit mask of SUSPEC field.
	USBHS_DEVIDR_SUSPEC_Msk = 0x1
	// Bit SUSPEC.
	USBHS_DEVIDR_SUSPEC = 0x1
	// Position of MSOFEC field.
	USBHS_DEVIDR_MSOFEC_Pos = 0x1
	// Bit mask of MSOFEC field.
	USBHS_DEVIDR_MSOFEC_Msk = 0x2
	// Bit MSOFEC.
	USBHS_DEVIDR_MSOFEC = 0x2
	// Position of SOFEC field.
	USBHS_DEVIDR_SOFEC_Pos = 0x2
	// Bit mask of SOFEC field.
	USBHS_DEVIDR_SOFEC_Msk = 0x4
	// Bit SOFEC.
	USBHS_DEVIDR_SOFEC = 0x4
	// Position of EORSTEC field.
	USBHS_DEVIDR_EORSTEC_Pos = 0x3
	// Bit mask of EORSTEC field.
	USBHS_DEVIDR_EORSTEC_Msk = 0x8
	// Bit EORSTEC.
	USBHS_DEVIDR_EORSTEC = 0x8
	// Position of WAKEUPEC field.
	USBHS_DEVIDR_WAKEUPEC_Pos = 0x4
	// Bit mask of WAKEUPEC field.
	USBHS_DEVIDR_WAKEUPEC_Msk = 0x10
	// Bit WAKEUPEC.
	USBHS_DEVIDR_WAKEUPEC = 0x10
	// Position of EORSMEC field.
	USBHS_DEVIDR_EORSMEC_Pos = 0x5
	// Bit mask of EORSMEC field.
	USBHS_DEVIDR_EORSMEC_Msk = 0x20
	// Bit EORSMEC.
	USBHS_DEVIDR_EORSMEC = 0x20
	// Position of UPRSMEC field.
	USBHS_DEVIDR_UPRSMEC_Pos = 0x6
	// Bit mask of UPRSMEC field.
	USBHS_DEVIDR_UPRSMEC_Msk = 0x40
	// Bit UPRSMEC.
	USBHS_DEVIDR_UPRSMEC = 0x40
	// Position of PEP_0 field.
	USBHS_DEVIDR_PEP_0_Pos = 0xc
	// Bit mask of PEP_0 field.
	USBHS_DEVIDR_PEP_0_Msk = 0x1000
	// Bit PEP_0.
	USBHS_DEVIDR_PEP_0 = 0x1000
	// Position of PEP_1 field.
	USBHS_DEVIDR_PEP_1_Pos = 0xd
	// Bit mask of PEP_1 field.
	USBHS_DEVIDR_PEP_1_Msk = 0x2000
	// Bit PEP_1.
	USBHS_DEVIDR_PEP_1 = 0x2000
	// Position of PEP_2 field.
	USBHS_DEVIDR_PEP_2_Pos = 0xe
	// Bit mask of PEP_2 field.
	USBHS_DEVIDR_PEP_2_Msk = 0x4000
	// Bit PEP_2.
	USBHS_DEVIDR_PEP_2 = 0x4000
	// Position of PEP_3 field.
	USBHS_DEVIDR_PEP_3_Pos = 0xf
	// Bit mask of PEP_3 field.
	USBHS_DEVIDR_PEP_3_Msk = 0x8000
	// Bit PEP_3.
	USBHS_DEVIDR_PEP_3 = 0x8000
	// Position of PEP_4 field.
	USBHS_DEVIDR_PEP_4_Pos = 0x10
	// Bit mask of PEP_4 field.
	USBHS_DEVIDR_PEP_4_Msk = 0x10000
	// Bit PEP_4.
	USBHS_DEVIDR_PEP_4 = 0x10000
	// Position of PEP_5 field.
	USBHS_DEVIDR_PEP_5_Pos = 0x11
	// Bit mask of PEP_5 field.
	USBHS_DEVIDR_PEP_5_Msk = 0x20000
	// Bit PEP_5.
	USBHS_DEVIDR_PEP_5 = 0x20000
	// Position of PEP_6 field.
	USBHS_DEVIDR_PEP_6_Pos = 0x12
	// Bit mask of PEP_6 field.
	USBHS_DEVIDR_PEP_6_Msk = 0x40000
	// Bit PEP_6.
	USBHS_DEVIDR_PEP_6 = 0x40000
	// Position of PEP_7 field.
	USBHS_DEVIDR_PEP_7_Pos = 0x13
	// Bit mask of PEP_7 field.
	USBHS_DEVIDR_PEP_7_Msk = 0x80000
	// Bit PEP_7.
	USBHS_DEVIDR_PEP_7 = 0x80000
	// Position of PEP_8 field.
	USBHS_DEVIDR_PEP_8_Pos = 0x14
	// Bit mask of PEP_8 field.
	USBHS_DEVIDR_PEP_8_Msk = 0x100000
	// Bit PEP_8.
	USBHS_DEVIDR_PEP_8 = 0x100000
	// Position of PEP_9 field.
	USBHS_DEVIDR_PEP_9_Pos = 0x15
	// Bit mask of PEP_9 field.
	USBHS_DEVIDR_PEP_9_Msk = 0x200000
	// Bit PEP_9.
	USBHS_DEVIDR_PEP_9 = 0x200000
	// Position of PEP_10 field.
	USBHS_DEVIDR_PEP_10_Pos = 0x16
	// Bit mask of PEP_10 field.
	USBHS_DEVIDR_PEP_10_Msk = 0x400000
	// Bit PEP_10.
	USBHS_DEVIDR_PEP_10 = 0x400000
	// Position of PEP_11 field.
	USBHS_DEVIDR_PEP_11_Pos = 0x17
	// Bit mask of PEP_11 field.
	USBHS_DEVIDR_PEP_11_Msk = 0x800000
	// Bit PEP_11.
	USBHS_DEVIDR_PEP_11 = 0x800000
	// Position of DMA_1 field.
	USBHS_DEVIDR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_DEVIDR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_DEVIDR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_DEVIDR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_DEVIDR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_DEVIDR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_DEVIDR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_DEVIDR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_DEVIDR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_DEVIDR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_DEVIDR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_DEVIDR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_DEVIDR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_DEVIDR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_DEVIDR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_DEVIDR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_DEVIDR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_DEVIDR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_DEVIDR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_DEVIDR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_DEVIDR_DMA_7 = 0x80000000

	// DEVIER: Device Global Interrupt Enable Register
	// Position of SUSPES field.
	USBHS_DEVIER_SUSPES_Pos = 0x0
	// Bit mask of SUSPES field.
	USBHS_DEVIER_SUSPES_Msk = 0x1
	// Bit SUSPES.
	USBHS_DEVIER_SUSPES = 0x1
	// Position of MSOFES field.
	USBHS_DEVIER_MSOFES_Pos = 0x1
	// Bit mask of MSOFES field.
	USBHS_DEVIER_MSOFES_Msk = 0x2
	// Bit MSOFES.
	USBHS_DEVIER_MSOFES = 0x2
	// Position of SOFES field.
	USBHS_DEVIER_SOFES_Pos = 0x2
	// Bit mask of SOFES field.
	USBHS_DEVIER_SOFES_Msk = 0x4
	// Bit SOFES.
	USBHS_DEVIER_SOFES = 0x4
	// Position of EORSTES field.
	USBHS_DEVIER_EORSTES_Pos = 0x3
	// Bit mask of EORSTES field.
	USBHS_DEVIER_EORSTES_Msk = 0x8
	// Bit EORSTES.
	USBHS_DEVIER_EORSTES = 0x8
	// Position of WAKEUPES field.
	USBHS_DEVIER_WAKEUPES_Pos = 0x4
	// Bit mask of WAKEUPES field.
	USBHS_DEVIER_WAKEUPES_Msk = 0x10
	// Bit WAKEUPES.
	USBHS_DEVIER_WAKEUPES = 0x10
	// Position of EORSMES field.
	USBHS_DEVIER_EORSMES_Pos = 0x5
	// Bit mask of EORSMES field.
	USBHS_DEVIER_EORSMES_Msk = 0x20
	// Bit EORSMES.
	USBHS_DEVIER_EORSMES = 0x20
	// Position of UPRSMES field.
	USBHS_DEVIER_UPRSMES_Pos = 0x6
	// Bit mask of UPRSMES field.
	USBHS_DEVIER_UPRSMES_Msk = 0x40
	// Bit UPRSMES.
	USBHS_DEVIER_UPRSMES = 0x40
	// Position of PEP_0 field.
	USBHS_DEVIER_PEP_0_Pos = 0xc
	// Bit mask of PEP_0 field.
	USBHS_DEVIER_PEP_0_Msk = 0x1000
	// Bit PEP_0.
	USBHS_DEVIER_PEP_0 = 0x1000
	// Position of PEP_1 field.
	USBHS_DEVIER_PEP_1_Pos = 0xd
	// Bit mask of PEP_1 field.
	USBHS_DEVIER_PEP_1_Msk = 0x2000
	// Bit PEP_1.
	USBHS_DEVIER_PEP_1 = 0x2000
	// Position of PEP_2 field.
	USBHS_DEVIER_PEP_2_Pos = 0xe
	// Bit mask of PEP_2 field.
	USBHS_DEVIER_PEP_2_Msk = 0x4000
	// Bit PEP_2.
	USBHS_DEVIER_PEP_2 = 0x4000
	// Position of PEP_3 field.
	USBHS_DEVIER_PEP_3_Pos = 0xf
	// Bit mask of PEP_3 field.
	USBHS_DEVIER_PEP_3_Msk = 0x8000
	// Bit PEP_3.
	USBHS_DEVIER_PEP_3 = 0x8000
	// Position of PEP_4 field.
	USBHS_DEVIER_PEP_4_Pos = 0x10
	// Bit mask of PEP_4 field.
	USBHS_DEVIER_PEP_4_Msk = 0x10000
	// Bit PEP_4.
	USBHS_DEVIER_PEP_4 = 0x10000
	// Position of PEP_5 field.
	USBHS_DEVIER_PEP_5_Pos = 0x11
	// Bit mask of PEP_5 field.
	USBHS_DEVIER_PEP_5_Msk = 0x20000
	// Bit PEP_5.
	USBHS_DEVIER_PEP_5 = 0x20000
	// Position of PEP_6 field.
	USBHS_DEVIER_PEP_6_Pos = 0x12
	// Bit mask of PEP_6 field.
	USBHS_DEVIER_PEP_6_Msk = 0x40000
	// Bit PEP_6.
	USBHS_DEVIER_PEP_6 = 0x40000
	// Position of PEP_7 field.
	USBHS_DEVIER_PEP_7_Pos = 0x13
	// Bit mask of PEP_7 field.
	USBHS_DEVIER_PEP_7_Msk = 0x80000
	// Bit PEP_7.
	USBHS_DEVIER_PEP_7 = 0x80000
	// Position of PEP_8 field.
	USBHS_DEVIER_PEP_8_Pos = 0x14
	// Bit mask of PEP_8 field.
	USBHS_DEVIER_PEP_8_Msk = 0x100000
	// Bit PEP_8.
	USBHS_DEVIER_PEP_8 = 0x100000
	// Position of PEP_9 field.
	USBHS_DEVIER_PEP_9_Pos = 0x15
	// Bit mask of PEP_9 field.
	USBHS_DEVIER_PEP_9_Msk = 0x200000
	// Bit PEP_9.
	USBHS_DEVIER_PEP_9 = 0x200000
	// Position of PEP_10 field.
	USBHS_DEVIER_PEP_10_Pos = 0x16
	// Bit mask of PEP_10 field.
	USBHS_DEVIER_PEP_10_Msk = 0x400000
	// Bit PEP_10.
	USBHS_DEVIER_PEP_10 = 0x400000
	// Position of PEP_11 field.
	USBHS_DEVIER_PEP_11_Pos = 0x17
	// Bit mask of PEP_11 field.
	USBHS_DEVIER_PEP_11_Msk = 0x800000
	// Bit PEP_11.
	USBHS_DEVIER_PEP_11 = 0x800000
	// Position of DMA_1 field.
	USBHS_DEVIER_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_DEVIER_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_DEVIER_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_DEVIER_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_DEVIER_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_DEVIER_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_DEVIER_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_DEVIER_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_DEVIER_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_DEVIER_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_DEVIER_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_DEVIER_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_DEVIER_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_DEVIER_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_DEVIER_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_DEVIER_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_DEVIER_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_DEVIER_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_DEVIER_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_DEVIER_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_DEVIER_DMA_7 = 0x80000000

	// DEVEPT: Device Endpoint Register
	// Position of EPEN0 field.
	USBHS_DEVEPT_EPEN0_Pos = 0x0
	// Bit mask of EPEN0 field.
	USBHS_DEVEPT_EPEN0_Msk = 0x1
	// Bit EPEN0.
	USBHS_DEVEPT_EPEN0 = 0x1
	// Position of EPEN1 field.
	USBHS_DEVEPT_EPEN1_Pos = 0x1
	// Bit mask of EPEN1 field.
	USBHS_DEVEPT_EPEN1_Msk = 0x2
	// Bit EPEN1.
	USBHS_DEVEPT_EPEN1 = 0x2
	// Position of EPEN2 field.
	USBHS_DEVEPT_EPEN2_Pos = 0x2
	// Bit mask of EPEN2 field.
	USBHS_DEVEPT_EPEN2_Msk = 0x4
	// Bit EPEN2.
	USBHS_DEVEPT_EPEN2 = 0x4
	// Position of EPEN3 field.
	USBHS_DEVEPT_EPEN3_Pos = 0x3
	// Bit mask of EPEN3 field.
	USBHS_DEVEPT_EPEN3_Msk = 0x8
	// Bit EPEN3.
	USBHS_DEVEPT_EPEN3 = 0x8
	// Position of EPEN4 field.
	USBHS_DEVEPT_EPEN4_Pos = 0x4
	// Bit mask of EPEN4 field.
	USBHS_DEVEPT_EPEN4_Msk = 0x10
	// Bit EPEN4.
	USBHS_DEVEPT_EPEN4 = 0x10
	// Position of EPEN5 field.
	USBHS_DEVEPT_EPEN5_Pos = 0x5
	// Bit mask of EPEN5 field.
	USBHS_DEVEPT_EPEN5_Msk = 0x20
	// Bit EPEN5.
	USBHS_DEVEPT_EPEN5 = 0x20
	// Position of EPEN6 field.
	USBHS_DEVEPT_EPEN6_Pos = 0x6
	// Bit mask of EPEN6 field.
	USBHS_DEVEPT_EPEN6_Msk = 0x40
	// Bit EPEN6.
	USBHS_DEVEPT_EPEN6 = 0x40
	// Position of EPEN7 field.
	USBHS_DEVEPT_EPEN7_Pos = 0x7
	// Bit mask of EPEN7 field.
	USBHS_DEVEPT_EPEN7_Msk = 0x80
	// Bit EPEN7.
	USBHS_DEVEPT_EPEN7 = 0x80
	// Position of EPEN8 field.
	USBHS_DEVEPT_EPEN8_Pos = 0x8
	// Bit mask of EPEN8 field.
	USBHS_DEVEPT_EPEN8_Msk = 0x100
	// Bit EPEN8.
	USBHS_DEVEPT_EPEN8 = 0x100
	// Position of EPEN9 field.
	USBHS_DEVEPT_EPEN9_Pos = 0x9
	// Bit mask of EPEN9 field.
	USBHS_DEVEPT_EPEN9_Msk = 0x200
	// Bit EPEN9.
	USBHS_DEVEPT_EPEN9 = 0x200
	// Position of EPRST0 field.
	USBHS_DEVEPT_EPRST0_Pos = 0x10
	// Bit mask of EPRST0 field.
	USBHS_DEVEPT_EPRST0_Msk = 0x10000
	// Bit EPRST0.
	USBHS_DEVEPT_EPRST0 = 0x10000
	// Position of EPRST1 field.
	USBHS_DEVEPT_EPRST1_Pos = 0x11
	// Bit mask of EPRST1 field.
	USBHS_DEVEPT_EPRST1_Msk = 0x20000
	// Bit EPRST1.
	USBHS_DEVEPT_EPRST1 = 0x20000
	// Position of EPRST2 field.
	USBHS_DEVEPT_EPRST2_Pos = 0x12
	// Bit mask of EPRST2 field.
	USBHS_DEVEPT_EPRST2_Msk = 0x40000
	// Bit EPRST2.
	USBHS_DEVEPT_EPRST2 = 0x40000
	// Position of EPRST3 field.
	USBHS_DEVEPT_EPRST3_Pos = 0x13
	// Bit mask of EPRST3 field.
	USBHS_DEVEPT_EPRST3_Msk = 0x80000
	// Bit EPRST3.
	USBHS_DEVEPT_EPRST3 = 0x80000
	// Position of EPRST4 field.
	USBHS_DEVEPT_EPRST4_Pos = 0x14
	// Bit mask of EPRST4 field.
	USBHS_DEVEPT_EPRST4_Msk = 0x100000
	// Bit EPRST4.
	USBHS_DEVEPT_EPRST4 = 0x100000
	// Position of EPRST5 field.
	USBHS_DEVEPT_EPRST5_Pos = 0x15
	// Bit mask of EPRST5 field.
	USBHS_DEVEPT_EPRST5_Msk = 0x200000
	// Bit EPRST5.
	USBHS_DEVEPT_EPRST5 = 0x200000
	// Position of EPRST6 field.
	USBHS_DEVEPT_EPRST6_Pos = 0x16
	// Bit mask of EPRST6 field.
	USBHS_DEVEPT_EPRST6_Msk = 0x400000
	// Bit EPRST6.
	USBHS_DEVEPT_EPRST6 = 0x400000
	// Position of EPRST7 field.
	USBHS_DEVEPT_EPRST7_Pos = 0x17
	// Bit mask of EPRST7 field.
	USBHS_DEVEPT_EPRST7_Msk = 0x800000
	// Bit EPRST7.
	USBHS_DEVEPT_EPRST7 = 0x800000
	// Position of EPRST8 field.
	USBHS_DEVEPT_EPRST8_Pos = 0x18
	// Bit mask of EPRST8 field.
	USBHS_DEVEPT_EPRST8_Msk = 0x1000000
	// Bit EPRST8.
	USBHS_DEVEPT_EPRST8 = 0x1000000
	// Position of EPRST9 field.
	USBHS_DEVEPT_EPRST9_Pos = 0x19
	// Bit mask of EPRST9 field.
	USBHS_DEVEPT_EPRST9_Msk = 0x2000000
	// Bit EPRST9.
	USBHS_DEVEPT_EPRST9 = 0x2000000

	// DEVFNUM: Device Frame Number Register
	// Position of MFNUM field.
	USBHS_DEVFNUM_MFNUM_Pos = 0x0
	// Bit mask of MFNUM field.
	USBHS_DEVFNUM_MFNUM_Msk = 0x7
	// Position of FNUM field.
	USBHS_DEVFNUM_FNUM_Pos = 0x3
	// Bit mask of FNUM field.
	USBHS_DEVFNUM_FNUM_Msk = 0x3ff8
	// Position of FNCERR field.
	USBHS_DEVFNUM_FNCERR_Pos = 0xf
	// Bit mask of FNCERR field.
	USBHS_DEVFNUM_FNCERR_Msk = 0x8000
	// Bit FNCERR.
	USBHS_DEVFNUM_FNCERR = 0x8000

	// DEVEPTCFG: Device Endpoint Configuration Register (n = 0) 0
	// Position of ALLOC field.
	USBHS_DEVEPTCFG_ALLOC_Pos = 0x1
	// Bit mask of ALLOC field.
	USBHS_DEVEPTCFG_ALLOC_Msk = 0x2
	// Bit ALLOC.
	USBHS_DEVEPTCFG_ALLOC = 0x2
	// Position of EPBK field.
	USBHS_DEVEPTCFG_EPBK_Pos = 0x2
	// Bit mask of EPBK field.
	USBHS_DEVEPTCFG_EPBK_Msk = 0xc
	// Single-bank endpoint
	USBHS_DEVEPTCFG_EPBK__1_BANK = 0x0
	// Double-bank endpoint
	USBHS_DEVEPTCFG_EPBK__2_BANK = 0x1
	// Triple-bank endpoint
	USBHS_DEVEPTCFG_EPBK__3_BANK = 0x2
	// Position of EPSIZE field.
	USBHS_DEVEPTCFG_EPSIZE_Pos = 0x4
	// Bit mask of EPSIZE field.
	USBHS_DEVEPTCFG_EPSIZE_Msk = 0x70
	// 8 bytes
	USBHS_DEVEPTCFG_EPSIZE__8_BYTE = 0x0
	// 16 bytes
	USBHS_DEVEPTCFG_EPSIZE__16_BYTE = 0x1
	// 32 bytes
	USBHS_DEVEPTCFG_EPSIZE__32_BYTE = 0x2
	// 64 bytes
	USBHS_DEVEPTCFG_EPSIZE__64_BYTE = 0x3
	// 128 bytes
	USBHS_DEVEPTCFG_EPSIZE__128_BYTE = 0x4
	// 256 bytes
	USBHS_DEVEPTCFG_EPSIZE__256_BYTE = 0x5
	// 512 bytes
	USBHS_DEVEPTCFG_EPSIZE__512_BYTE = 0x6
	// 1024 bytes
	USBHS_DEVEPTCFG_EPSIZE__1024_BYTE = 0x7
	// Position of EPDIR field.
	USBHS_DEVEPTCFG_EPDIR_Pos = 0x8
	// Bit mask of EPDIR field.
	USBHS_DEVEPTCFG_EPDIR_Msk = 0x100
	// Bit EPDIR.
	USBHS_DEVEPTCFG_EPDIR = 0x100
	// The endpoint direction is OUT.
	USBHS_DEVEPTCFG_EPDIR_OUT = 0x0
	// The endpoint direction is IN (nor for control endpoints).
	USBHS_DEVEPTCFG_EPDIR_IN = 0x1
	// Position of AUTOSW field.
	USBHS_DEVEPTCFG_AUTOSW_Pos = 0x9
	// Bit mask of AUTOSW field.
	USBHS_DEVEPTCFG_AUTOSW_Msk = 0x200
	// Bit AUTOSW.
	USBHS_DEVEPTCFG_AUTOSW = 0x200
	// Position of EPTYPE field.
	USBHS_DEVEPTCFG_EPTYPE_Pos = 0xb
	// Bit mask of EPTYPE field.
	USBHS_DEVEPTCFG_EPTYPE_Msk = 0x1800
	// Control
	USBHS_DEVEPTCFG_EPTYPE_CTRL = 0x0
	// Isochronous
	USBHS_DEVEPTCFG_EPTYPE_ISO = 0x1
	// Bulk
	USBHS_DEVEPTCFG_EPTYPE_BLK = 0x2
	// Interrupt
	USBHS_DEVEPTCFG_EPTYPE_INTRPT = 0x3
	// Position of NBTRANS field.
	USBHS_DEVEPTCFG_NBTRANS_Pos = 0xd
	// Bit mask of NBTRANS field.
	USBHS_DEVEPTCFG_NBTRANS_Msk = 0x6000
	// Reserved to endpoint that does not have the high-bandwidth isochronous capability.
	USBHS_DEVEPTCFG_NBTRANS__0_TRANS = 0x0
	// Default value: one transaction per microframe.
	USBHS_DEVEPTCFG_NBTRANS__1_TRANS = 0x1
	// Two transactions per microframe. This endpoint should be configured as double-bank.
	USBHS_DEVEPTCFG_NBTRANS__2_TRANS = 0x2
	// Three transactions per microframe. This endpoint should be configured as triple-bank.
	USBHS_DEVEPTCFG_NBTRANS__3_TRANS = 0x3

	// DEVEPTISR: Device Endpoint Status Register (n = 0) 0
	// Position of TXINI field.
	USBHS_DEVEPTISR_TXINI_Pos = 0x0
	// Bit mask of TXINI field.
	USBHS_DEVEPTISR_TXINI_Msk = 0x1
	// Bit TXINI.
	USBHS_DEVEPTISR_TXINI = 0x1
	// Position of RXOUTI field.
	USBHS_DEVEPTISR_RXOUTI_Pos = 0x1
	// Bit mask of RXOUTI field.
	USBHS_DEVEPTISR_RXOUTI_Msk = 0x2
	// Bit RXOUTI.
	USBHS_DEVEPTISR_RXOUTI = 0x2
	// Position of RXSTPI field.
	USBHS_DEVEPTISR_RXSTPI_Pos = 0x2
	// Bit mask of RXSTPI field.
	USBHS_DEVEPTISR_RXSTPI_Msk = 0x4
	// Bit RXSTPI.
	USBHS_DEVEPTISR_RXSTPI = 0x4
	// Position of NAKOUTI field.
	USBHS_DEVEPTISR_NAKOUTI_Pos = 0x3
	// Bit mask of NAKOUTI field.
	USBHS_DEVEPTISR_NAKOUTI_Msk = 0x8
	// Bit NAKOUTI.
	USBHS_DEVEPTISR_NAKOUTI = 0x8
	// Position of NAKINI field.
	USBHS_DEVEPTISR_NAKINI_Pos = 0x4
	// Bit mask of NAKINI field.
	USBHS_DEVEPTISR_NAKINI_Msk = 0x10
	// Bit NAKINI.
	USBHS_DEVEPTISR_NAKINI = 0x10
	// Position of OVERFI field.
	USBHS_DEVEPTISR_OVERFI_Pos = 0x5
	// Bit mask of OVERFI field.
	USBHS_DEVEPTISR_OVERFI_Msk = 0x20
	// Bit OVERFI.
	USBHS_DEVEPTISR_OVERFI = 0x20
	// Position of STALLEDI field.
	USBHS_DEVEPTISR_STALLEDI_Pos = 0x6
	// Bit mask of STALLEDI field.
	USBHS_DEVEPTISR_STALLEDI_Msk = 0x40
	// Bit STALLEDI.
	USBHS_DEVEPTISR_STALLEDI = 0x40
	// Position of SHORTPACKET field.
	USBHS_DEVEPTISR_SHORTPACKET_Pos = 0x7
	// Bit mask of SHORTPACKET field.
	USBHS_DEVEPTISR_SHORTPACKET_Msk = 0x80
	// Bit SHORTPACKET.
	USBHS_DEVEPTISR_SHORTPACKET = 0x80
	// Position of DTSEQ field.
	USBHS_DEVEPTISR_DTSEQ_Pos = 0x8
	// Bit mask of DTSEQ field.
	USBHS_DEVEPTISR_DTSEQ_Msk = 0x300
	// Data0 toggle sequence
	USBHS_DEVEPTISR_DTSEQ_DATA0 = 0x0
	// Data1 toggle sequence
	USBHS_DEVEPTISR_DTSEQ_DATA1 = 0x1
	// Reserved for high-bandwidth isochronous endpoint
	USBHS_DEVEPTISR_DTSEQ_DATA2 = 0x2
	// Reserved for high-bandwidth isochronous endpoint
	USBHS_DEVEPTISR_DTSEQ_MDATA = 0x3
	// Position of NBUSYBK field.
	USBHS_DEVEPTISR_NBUSYBK_Pos = 0xc
	// Bit mask of NBUSYBK field.
	USBHS_DEVEPTISR_NBUSYBK_Msk = 0x3000
	// 0 busy bank (all banks free)
	USBHS_DEVEPTISR_NBUSYBK__0_BUSY = 0x0
	// 1 busy bank
	USBHS_DEVEPTISR_NBUSYBK__1_BUSY = 0x1
	// 2 busy banks
	USBHS_DEVEPTISR_NBUSYBK__2_BUSY = 0x2
	// 3 busy banks
	USBHS_DEVEPTISR_NBUSYBK__3_BUSY = 0x3
	// Position of CURRBK field.
	USBHS_DEVEPTISR_CURRBK_Pos = 0xe
	// Bit mask of CURRBK field.
	USBHS_DEVEPTISR_CURRBK_Msk = 0xc000
	// Current bank is bank0
	USBHS_DEVEPTISR_CURRBK_BANK0 = 0x0
	// Current bank is bank1
	USBHS_DEVEPTISR_CURRBK_BANK1 = 0x1
	// Current bank is bank2
	USBHS_DEVEPTISR_CURRBK_BANK2 = 0x2
	// Position of RWALL field.
	USBHS_DEVEPTISR_RWALL_Pos = 0x10
	// Bit mask of RWALL field.
	USBHS_DEVEPTISR_RWALL_Msk = 0x10000
	// Bit RWALL.
	USBHS_DEVEPTISR_RWALL = 0x10000
	// Position of CTRLDIR field.
	USBHS_DEVEPTISR_CTRLDIR_Pos = 0x11
	// Bit mask of CTRLDIR field.
	USBHS_DEVEPTISR_CTRLDIR_Msk = 0x20000
	// Bit CTRLDIR.
	USBHS_DEVEPTISR_CTRLDIR = 0x20000
	// Position of CFGOK field.
	USBHS_DEVEPTISR_CFGOK_Pos = 0x12
	// Bit mask of CFGOK field.
	USBHS_DEVEPTISR_CFGOK_Msk = 0x40000
	// Bit CFGOK.
	USBHS_DEVEPTISR_CFGOK = 0x40000
	// Position of BYCT field.
	USBHS_DEVEPTISR_BYCT_Pos = 0x14
	// Bit mask of BYCT field.
	USBHS_DEVEPTISR_BYCT_Msk = 0x7ff00000

	// DEVEPTICR: Device Endpoint Clear Register (n = 0) 0
	// Position of TXINIC field.
	USBHS_DEVEPTICR_TXINIC_Pos = 0x0
	// Bit mask of TXINIC field.
	USBHS_DEVEPTICR_TXINIC_Msk = 0x1
	// Bit TXINIC.
	USBHS_DEVEPTICR_TXINIC = 0x1
	// Position of RXOUTIC field.
	USBHS_DEVEPTICR_RXOUTIC_Pos = 0x1
	// Bit mask of RXOUTIC field.
	USBHS_DEVEPTICR_RXOUTIC_Msk = 0x2
	// Bit RXOUTIC.
	USBHS_DEVEPTICR_RXOUTIC = 0x2
	// Position of RXSTPIC field.
	USBHS_DEVEPTICR_RXSTPIC_Pos = 0x2
	// Bit mask of RXSTPIC field.
	USBHS_DEVEPTICR_RXSTPIC_Msk = 0x4
	// Bit RXSTPIC.
	USBHS_DEVEPTICR_RXSTPIC = 0x4
	// Position of NAKOUTIC field.
	USBHS_DEVEPTICR_NAKOUTIC_Pos = 0x3
	// Bit mask of NAKOUTIC field.
	USBHS_DEVEPTICR_NAKOUTIC_Msk = 0x8
	// Bit NAKOUTIC.
	USBHS_DEVEPTICR_NAKOUTIC = 0x8
	// Position of NAKINIC field.
	USBHS_DEVEPTICR_NAKINIC_Pos = 0x4
	// Bit mask of NAKINIC field.
	USBHS_DEVEPTICR_NAKINIC_Msk = 0x10
	// Bit NAKINIC.
	USBHS_DEVEPTICR_NAKINIC = 0x10
	// Position of OVERFIC field.
	USBHS_DEVEPTICR_OVERFIC_Pos = 0x5
	// Bit mask of OVERFIC field.
	USBHS_DEVEPTICR_OVERFIC_Msk = 0x20
	// Bit OVERFIC.
	USBHS_DEVEPTICR_OVERFIC = 0x20
	// Position of STALLEDIC field.
	USBHS_DEVEPTICR_STALLEDIC_Pos = 0x6
	// Bit mask of STALLEDIC field.
	USBHS_DEVEPTICR_STALLEDIC_Msk = 0x40
	// Bit STALLEDIC.
	USBHS_DEVEPTICR_STALLEDIC = 0x40
	// Position of SHORTPACKETC field.
	USBHS_DEVEPTICR_SHORTPACKETC_Pos = 0x7
	// Bit mask of SHORTPACKETC field.
	USBHS_DEVEPTICR_SHORTPACKETC_Msk = 0x80
	// Bit SHORTPACKETC.
	USBHS_DEVEPTICR_SHORTPACKETC = 0x80

	// DEVEPTIFR: Device Endpoint Set Register (n = 0) 0
	// Position of TXINIS field.
	USBHS_DEVEPTIFR_TXINIS_Pos = 0x0
	// Bit mask of TXINIS field.
	USBHS_DEVEPTIFR_TXINIS_Msk = 0x1
	// Bit TXINIS.
	USBHS_DEVEPTIFR_TXINIS = 0x1
	// Position of RXOUTIS field.
	USBHS_DEVEPTIFR_RXOUTIS_Pos = 0x1
	// Bit mask of RXOUTIS field.
	USBHS_DEVEPTIFR_RXOUTIS_Msk = 0x2
	// Bit RXOUTIS.
	USBHS_DEVEPTIFR_RXOUTIS = 0x2
	// Position of RXSTPIS field.
	USBHS_DEVEPTIFR_RXSTPIS_Pos = 0x2
	// Bit mask of RXSTPIS field.
	USBHS_DEVEPTIFR_RXSTPIS_Msk = 0x4
	// Bit RXSTPIS.
	USBHS_DEVEPTIFR_RXSTPIS = 0x4
	// Position of NAKOUTIS field.
	USBHS_DEVEPTIFR_NAKOUTIS_Pos = 0x3
	// Bit mask of NAKOUTIS field.
	USBHS_DEVEPTIFR_NAKOUTIS_Msk = 0x8
	// Bit NAKOUTIS.
	USBHS_DEVEPTIFR_NAKOUTIS = 0x8
	// Position of NAKINIS field.
	USBHS_DEVEPTIFR_NAKINIS_Pos = 0x4
	// Bit mask of NAKINIS field.
	USBHS_DEVEPTIFR_NAKINIS_Msk = 0x10
	// Bit NAKINIS.
	USBHS_DEVEPTIFR_NAKINIS = 0x10
	// Position of OVERFIS field.
	USBHS_DEVEPTIFR_OVERFIS_Pos = 0x5
	// Bit mask of OVERFIS field.
	USBHS_DEVEPTIFR_OVERFIS_Msk = 0x20
	// Bit OVERFIS.
	USBHS_DEVEPTIFR_OVERFIS = 0x20
	// Position of STALLEDIS field.
	USBHS_DEVEPTIFR_STALLEDIS_Pos = 0x6
	// Bit mask of STALLEDIS field.
	USBHS_DEVEPTIFR_STALLEDIS_Msk = 0x40
	// Bit STALLEDIS.
	USBHS_DEVEPTIFR_STALLEDIS = 0x40
	// Position of SHORTPACKETS field.
	USBHS_DEVEPTIFR_SHORTPACKETS_Pos = 0x7
	// Bit mask of SHORTPACKETS field.
	USBHS_DEVEPTIFR_SHORTPACKETS_Msk = 0x80
	// Bit SHORTPACKETS.
	USBHS_DEVEPTIFR_SHORTPACKETS = 0x80
	// Position of NBUSYBKS field.
	USBHS_DEVEPTIFR_NBUSYBKS_Pos = 0xc
	// Bit mask of NBUSYBKS field.
	USBHS_DEVEPTIFR_NBUSYBKS_Msk = 0x1000
	// Bit NBUSYBKS.
	USBHS_DEVEPTIFR_NBUSYBKS = 0x1000

	// DEVEPTIMR: Device Endpoint Mask Register (n = 0) 0
	// Position of TXINE field.
	USBHS_DEVEPTIMR_TXINE_Pos = 0x0
	// Bit mask of TXINE field.
	USBHS_DEVEPTIMR_TXINE_Msk = 0x1
	// Bit TXINE.
	USBHS_DEVEPTIMR_TXINE = 0x1
	// Position of RXOUTE field.
	USBHS_DEVEPTIMR_RXOUTE_Pos = 0x1
	// Bit mask of RXOUTE field.
	USBHS_DEVEPTIMR_RXOUTE_Msk = 0x2
	// Bit RXOUTE.
	USBHS_DEVEPTIMR_RXOUTE = 0x2
	// Position of RXSTPE field.
	USBHS_DEVEPTIMR_RXSTPE_Pos = 0x2
	// Bit mask of RXSTPE field.
	USBHS_DEVEPTIMR_RXSTPE_Msk = 0x4
	// Bit RXSTPE.
	USBHS_DEVEPTIMR_RXSTPE = 0x4
	// Position of NAKOUTE field.
	USBHS_DEVEPTIMR_NAKOUTE_Pos = 0x3
	// Bit mask of NAKOUTE field.
	USBHS_DEVEPTIMR_NAKOUTE_Msk = 0x8
	// Bit NAKOUTE.
	USBHS_DEVEPTIMR_NAKOUTE = 0x8
	// Position of NAKINE field.
	USBHS_DEVEPTIMR_NAKINE_Pos = 0x4
	// Bit mask of NAKINE field.
	USBHS_DEVEPTIMR_NAKINE_Msk = 0x10
	// Bit NAKINE.
	USBHS_DEVEPTIMR_NAKINE = 0x10
	// Position of OVERFE field.
	USBHS_DEVEPTIMR_OVERFE_Pos = 0x5
	// Bit mask of OVERFE field.
	USBHS_DEVEPTIMR_OVERFE_Msk = 0x20
	// Bit OVERFE.
	USBHS_DEVEPTIMR_OVERFE = 0x20
	// Position of STALLEDE field.
	USBHS_DEVEPTIMR_STALLEDE_Pos = 0x6
	// Bit mask of STALLEDE field.
	USBHS_DEVEPTIMR_STALLEDE_Msk = 0x40
	// Bit STALLEDE.
	USBHS_DEVEPTIMR_STALLEDE = 0x40
	// Position of SHORTPACKETE field.
	USBHS_DEVEPTIMR_SHORTPACKETE_Pos = 0x7
	// Bit mask of SHORTPACKETE field.
	USBHS_DEVEPTIMR_SHORTPACKETE_Msk = 0x80
	// Bit SHORTPACKETE.
	USBHS_DEVEPTIMR_SHORTPACKETE = 0x80
	// Position of NBUSYBKE field.
	USBHS_DEVEPTIMR_NBUSYBKE_Pos = 0xc
	// Bit mask of NBUSYBKE field.
	USBHS_DEVEPTIMR_NBUSYBKE_Msk = 0x1000
	// Bit NBUSYBKE.
	USBHS_DEVEPTIMR_NBUSYBKE = 0x1000
	// Position of KILLBK field.
	USBHS_DEVEPTIMR_KILLBK_Pos = 0xd
	// Bit mask of KILLBK field.
	USBHS_DEVEPTIMR_KILLBK_Msk = 0x2000
	// Bit KILLBK.
	USBHS_DEVEPTIMR_KILLBK = 0x2000
	// Position of FIFOCON field.
	USBHS_DEVEPTIMR_FIFOCON_Pos = 0xe
	// Bit mask of FIFOCON field.
	USBHS_DEVEPTIMR_FIFOCON_Msk = 0x4000
	// Bit FIFOCON.
	USBHS_DEVEPTIMR_FIFOCON = 0x4000
	// Position of EPDISHDMA field.
	USBHS_DEVEPTIMR_EPDISHDMA_Pos = 0x10
	// Bit mask of EPDISHDMA field.
	USBHS_DEVEPTIMR_EPDISHDMA_Msk = 0x10000
	// Bit EPDISHDMA.
	USBHS_DEVEPTIMR_EPDISHDMA = 0x10000
	// Position of NYETDIS field.
	USBHS_DEVEPTIMR_NYETDIS_Pos = 0x11
	// Bit mask of NYETDIS field.
	USBHS_DEVEPTIMR_NYETDIS_Msk = 0x20000
	// Bit NYETDIS.
	USBHS_DEVEPTIMR_NYETDIS = 0x20000
	// Position of RSTDT field.
	USBHS_DEVEPTIMR_RSTDT_Pos = 0x12
	// Bit mask of RSTDT field.
	USBHS_DEVEPTIMR_RSTDT_Msk = 0x40000
	// Bit RSTDT.
	USBHS_DEVEPTIMR_RSTDT = 0x40000
	// Position of STALLRQ field.
	USBHS_DEVEPTIMR_STALLRQ_Pos = 0x13
	// Bit mask of STALLRQ field.
	USBHS_DEVEPTIMR_STALLRQ_Msk = 0x80000
	// Bit STALLRQ.
	USBHS_DEVEPTIMR_STALLRQ = 0x80000

	// DEVEPTIER: Device Endpoint Enable Register (n = 0) 0
	// Position of TXINES field.
	USBHS_DEVEPTIER_TXINES_Pos = 0x0
	// Bit mask of TXINES field.
	USBHS_DEVEPTIER_TXINES_Msk = 0x1
	// Bit TXINES.
	USBHS_DEVEPTIER_TXINES = 0x1
	// Position of RXOUTES field.
	USBHS_DEVEPTIER_RXOUTES_Pos = 0x1
	// Bit mask of RXOUTES field.
	USBHS_DEVEPTIER_RXOUTES_Msk = 0x2
	// Bit RXOUTES.
	USBHS_DEVEPTIER_RXOUTES = 0x2
	// Position of RXSTPES field.
	USBHS_DEVEPTIER_RXSTPES_Pos = 0x2
	// Bit mask of RXSTPES field.
	USBHS_DEVEPTIER_RXSTPES_Msk = 0x4
	// Bit RXSTPES.
	USBHS_DEVEPTIER_RXSTPES = 0x4
	// Position of NAKOUTES field.
	USBHS_DEVEPTIER_NAKOUTES_Pos = 0x3
	// Bit mask of NAKOUTES field.
	USBHS_DEVEPTIER_NAKOUTES_Msk = 0x8
	// Bit NAKOUTES.
	USBHS_DEVEPTIER_NAKOUTES = 0x8
	// Position of NAKINES field.
	USBHS_DEVEPTIER_NAKINES_Pos = 0x4
	// Bit mask of NAKINES field.
	USBHS_DEVEPTIER_NAKINES_Msk = 0x10
	// Bit NAKINES.
	USBHS_DEVEPTIER_NAKINES = 0x10
	// Position of OVERFES field.
	USBHS_DEVEPTIER_OVERFES_Pos = 0x5
	// Bit mask of OVERFES field.
	USBHS_DEVEPTIER_OVERFES_Msk = 0x20
	// Bit OVERFES.
	USBHS_DEVEPTIER_OVERFES = 0x20
	// Position of STALLEDES field.
	USBHS_DEVEPTIER_STALLEDES_Pos = 0x6
	// Bit mask of STALLEDES field.
	USBHS_DEVEPTIER_STALLEDES_Msk = 0x40
	// Bit STALLEDES.
	USBHS_DEVEPTIER_STALLEDES = 0x40
	// Position of SHORTPACKETES field.
	USBHS_DEVEPTIER_SHORTPACKETES_Pos = 0x7
	// Bit mask of SHORTPACKETES field.
	USBHS_DEVEPTIER_SHORTPACKETES_Msk = 0x80
	// Bit SHORTPACKETES.
	USBHS_DEVEPTIER_SHORTPACKETES = 0x80
	// Position of NBUSYBKES field.
	USBHS_DEVEPTIER_NBUSYBKES_Pos = 0xc
	// Bit mask of NBUSYBKES field.
	USBHS_DEVEPTIER_NBUSYBKES_Msk = 0x1000
	// Bit NBUSYBKES.
	USBHS_DEVEPTIER_NBUSYBKES = 0x1000
	// Position of KILLBKS field.
	USBHS_DEVEPTIER_KILLBKS_Pos = 0xd
	// Bit mask of KILLBKS field.
	USBHS_DEVEPTIER_KILLBKS_Msk = 0x2000
	// Bit KILLBKS.
	USBHS_DEVEPTIER_KILLBKS = 0x2000
	// Position of FIFOCONS field.
	USBHS_DEVEPTIER_FIFOCONS_Pos = 0xe
	// Bit mask of FIFOCONS field.
	USBHS_DEVEPTIER_FIFOCONS_Msk = 0x4000
	// Bit FIFOCONS.
	USBHS_DEVEPTIER_FIFOCONS = 0x4000
	// Position of EPDISHDMAS field.
	USBHS_DEVEPTIER_EPDISHDMAS_Pos = 0x10
	// Bit mask of EPDISHDMAS field.
	USBHS_DEVEPTIER_EPDISHDMAS_Msk = 0x10000
	// Bit EPDISHDMAS.
	USBHS_DEVEPTIER_EPDISHDMAS = 0x10000
	// Position of NYETDISS field.
	USBHS_DEVEPTIER_NYETDISS_Pos = 0x11
	// Bit mask of NYETDISS field.
	USBHS_DEVEPTIER_NYETDISS_Msk = 0x20000
	// Bit NYETDISS.
	USBHS_DEVEPTIER_NYETDISS = 0x20000
	// Position of RSTDTS field.
	USBHS_DEVEPTIER_RSTDTS_Pos = 0x12
	// Bit mask of RSTDTS field.
	USBHS_DEVEPTIER_RSTDTS_Msk = 0x40000
	// Bit RSTDTS.
	USBHS_DEVEPTIER_RSTDTS = 0x40000
	// Position of STALLRQS field.
	USBHS_DEVEPTIER_STALLRQS_Pos = 0x13
	// Bit mask of STALLRQS field.
	USBHS_DEVEPTIER_STALLRQS_Msk = 0x80000
	// Bit STALLRQS.
	USBHS_DEVEPTIER_STALLRQS = 0x80000

	// DEVEPTIDR: Device Endpoint Disable Register (n = 0) 0
	// Position of TXINEC field.
	USBHS_DEVEPTIDR_TXINEC_Pos = 0x0
	// Bit mask of TXINEC field.
	USBHS_DEVEPTIDR_TXINEC_Msk = 0x1
	// Bit TXINEC.
	USBHS_DEVEPTIDR_TXINEC = 0x1
	// Position of RXOUTEC field.
	USBHS_DEVEPTIDR_RXOUTEC_Pos = 0x1
	// Bit mask of RXOUTEC field.
	USBHS_DEVEPTIDR_RXOUTEC_Msk = 0x2
	// Bit RXOUTEC.
	USBHS_DEVEPTIDR_RXOUTEC = 0x2
	// Position of RXSTPEC field.
	USBHS_DEVEPTIDR_RXSTPEC_Pos = 0x2
	// Bit mask of RXSTPEC field.
	USBHS_DEVEPTIDR_RXSTPEC_Msk = 0x4
	// Bit RXSTPEC.
	USBHS_DEVEPTIDR_RXSTPEC = 0x4
	// Position of NAKOUTEC field.
	USBHS_DEVEPTIDR_NAKOUTEC_Pos = 0x3
	// Bit mask of NAKOUTEC field.
	USBHS_DEVEPTIDR_NAKOUTEC_Msk = 0x8
	// Bit NAKOUTEC.
	USBHS_DEVEPTIDR_NAKOUTEC = 0x8
	// Position of NAKINEC field.
	USBHS_DEVEPTIDR_NAKINEC_Pos = 0x4
	// Bit mask of NAKINEC field.
	USBHS_DEVEPTIDR_NAKINEC_Msk = 0x10
	// Bit NAKINEC.
	USBHS_DEVEPTIDR_NAKINEC = 0x10
	// Position of OVERFEC field.
	USBHS_DEVEPTIDR_OVERFEC_Pos = 0x5
	// Bit mask of OVERFEC field.
	USBHS_DEVEPTIDR_OVERFEC_Msk = 0x20
	// Bit OVERFEC.
	USBHS_DEVEPTIDR_OVERFEC = 0x20
	// Position of STALLEDEC field.
	USBHS_DEVEPTIDR_STALLEDEC_Pos = 0x6
	// Bit mask of STALLEDEC field.
	USBHS_DEVEPTIDR_STALLEDEC_Msk = 0x40
	// Bit STALLEDEC.
	USBHS_DEVEPTIDR_STALLEDEC = 0x40
	// Position of SHORTPACKETEC field.
	USBHS_DEVEPTIDR_SHORTPACKETEC_Pos = 0x7
	// Bit mask of SHORTPACKETEC field.
	USBHS_DEVEPTIDR_SHORTPACKETEC_Msk = 0x80
	// Bit SHORTPACKETEC.
	USBHS_DEVEPTIDR_SHORTPACKETEC = 0x80
	// Position of NBUSYBKEC field.
	USBHS_DEVEPTIDR_NBUSYBKEC_Pos = 0xc
	// Bit mask of NBUSYBKEC field.
	USBHS_DEVEPTIDR_NBUSYBKEC_Msk = 0x1000
	// Bit NBUSYBKEC.
	USBHS_DEVEPTIDR_NBUSYBKEC = 0x1000
	// Position of FIFOCONC field.
	USBHS_DEVEPTIDR_FIFOCONC_Pos = 0xe
	// Bit mask of FIFOCONC field.
	USBHS_DEVEPTIDR_FIFOCONC_Msk = 0x4000
	// Bit FIFOCONC.
	USBHS_DEVEPTIDR_FIFOCONC = 0x4000
	// Position of EPDISHDMAC field.
	USBHS_DEVEPTIDR_EPDISHDMAC_Pos = 0x10
	// Bit mask of EPDISHDMAC field.
	USBHS_DEVEPTIDR_EPDISHDMAC_Msk = 0x10000
	// Bit EPDISHDMAC.
	USBHS_DEVEPTIDR_EPDISHDMAC = 0x10000
	// Position of NYETDISC field.
	USBHS_DEVEPTIDR_NYETDISC_Pos = 0x11
	// Bit mask of NYETDISC field.
	USBHS_DEVEPTIDR_NYETDISC_Msk = 0x20000
	// Bit NYETDISC.
	USBHS_DEVEPTIDR_NYETDISC = 0x20000
	// Position of STALLRQC field.
	USBHS_DEVEPTIDR_STALLRQC_Pos = 0x13
	// Bit mask of STALLRQC field.
	USBHS_DEVEPTIDR_STALLRQC_Msk = 0x80000
	// Bit STALLRQC.
	USBHS_DEVEPTIDR_STALLRQC = 0x80000

	// USBHS_DEVDMA.DEVDMANXTDSC: Device DMA Channel Next Descriptor Address Register (n = 1)
	// Position of NXT_DSC_ADD field.
	USBHS_USBHS_DEVDMA_DEVDMANXTDSC_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	USBHS_USBHS_DEVDMA_DEVDMANXTDSC_NXT_DSC_ADD_Msk = 0xffffffff

	// USBHS_DEVDMA.DEVDMAADDRESS: Device DMA Channel Address Register (n = 1)
	// Position of BUFF_ADD field.
	USBHS_USBHS_DEVDMA_DEVDMAADDRESS_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	USBHS_USBHS_DEVDMA_DEVDMAADDRESS_BUFF_ADD_Msk = 0xffffffff

	// USBHS_DEVDMA.DEVDMACONTROL: Device DMA Channel Control Register (n = 1)
	// Position of CHANN_ENB field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_EN = 0x4
	// Position of END_B_EN field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_B_EN = 0x8
	// Position of END_TR_IT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	USBHS_USBHS_DEVDMA_DEVDMACONTROL_BUFF_LENGTH_Msk = 0xffff0000

	// USBHS_DEVDMA.DEVDMASTATUS: Device DMA Channel Status Register (n = 1)
	// Position of CHANN_ENB field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	USBHS_USBHS_DEVDMA_DEVDMASTATUS_BUFF_COUNT_Msk = 0xffff0000

	// HSTCTRL: Host General Control Register
	// Position of SOFE field.
	USBHS_HSTCTRL_SOFE_Pos = 0x8
	// Bit mask of SOFE field.
	USBHS_HSTCTRL_SOFE_Msk = 0x100
	// Bit SOFE.
	USBHS_HSTCTRL_SOFE = 0x100
	// Position of RESET field.
	USBHS_HSTCTRL_RESET_Pos = 0x9
	// Bit mask of RESET field.
	USBHS_HSTCTRL_RESET_Msk = 0x200
	// Bit RESET.
	USBHS_HSTCTRL_RESET = 0x200
	// Position of RESUME field.
	USBHS_HSTCTRL_RESUME_Pos = 0xa
	// Bit mask of RESUME field.
	USBHS_HSTCTRL_RESUME_Msk = 0x400
	// Bit RESUME.
	USBHS_HSTCTRL_RESUME = 0x400
	// Position of SPDCONF field.
	USBHS_HSTCTRL_SPDCONF_Pos = 0xc
	// Bit mask of SPDCONF field.
	USBHS_HSTCTRL_SPDCONF_Msk = 0x3000
	// The host starts in Full-speed mode and performs a high-speed reset to switch to High-speed mode if the downstream peripheral is high-speed capable.
	USBHS_HSTCTRL_SPDCONF_NORMAL = 0x0
	// For a better consumption, if high speed is not needed.
	USBHS_HSTCTRL_SPDCONF_LOW_POWER = 0x1

	// HSTISR: Host Global Interrupt Status Register
	// Position of DCONNI field.
	USBHS_HSTISR_DCONNI_Pos = 0x0
	// Bit mask of DCONNI field.
	USBHS_HSTISR_DCONNI_Msk = 0x1
	// Bit DCONNI.
	USBHS_HSTISR_DCONNI = 0x1
	// Position of DDISCI field.
	USBHS_HSTISR_DDISCI_Pos = 0x1
	// Bit mask of DDISCI field.
	USBHS_HSTISR_DDISCI_Msk = 0x2
	// Bit DDISCI.
	USBHS_HSTISR_DDISCI = 0x2
	// Position of RSTI field.
	USBHS_HSTISR_RSTI_Pos = 0x2
	// Bit mask of RSTI field.
	USBHS_HSTISR_RSTI_Msk = 0x4
	// Bit RSTI.
	USBHS_HSTISR_RSTI = 0x4
	// Position of RSMEDI field.
	USBHS_HSTISR_RSMEDI_Pos = 0x3
	// Bit mask of RSMEDI field.
	USBHS_HSTISR_RSMEDI_Msk = 0x8
	// Bit RSMEDI.
	USBHS_HSTISR_RSMEDI = 0x8
	// Position of RXRSMI field.
	USBHS_HSTISR_RXRSMI_Pos = 0x4
	// Bit mask of RXRSMI field.
	USBHS_HSTISR_RXRSMI_Msk = 0x10
	// Bit RXRSMI.
	USBHS_HSTISR_RXRSMI = 0x10
	// Position of HSOFI field.
	USBHS_HSTISR_HSOFI_Pos = 0x5
	// Bit mask of HSOFI field.
	USBHS_HSTISR_HSOFI_Msk = 0x20
	// Bit HSOFI.
	USBHS_HSTISR_HSOFI = 0x20
	// Position of HWUPI field.
	USBHS_HSTISR_HWUPI_Pos = 0x6
	// Bit mask of HWUPI field.
	USBHS_HSTISR_HWUPI_Msk = 0x40
	// Bit HWUPI.
	USBHS_HSTISR_HWUPI = 0x40
	// Position of PEP_0 field.
	USBHS_HSTISR_PEP_0_Pos = 0x8
	// Bit mask of PEP_0 field.
	USBHS_HSTISR_PEP_0_Msk = 0x100
	// Bit PEP_0.
	USBHS_HSTISR_PEP_0 = 0x100
	// Position of PEP_1 field.
	USBHS_HSTISR_PEP_1_Pos = 0x9
	// Bit mask of PEP_1 field.
	USBHS_HSTISR_PEP_1_Msk = 0x200
	// Bit PEP_1.
	USBHS_HSTISR_PEP_1 = 0x200
	// Position of PEP_2 field.
	USBHS_HSTISR_PEP_2_Pos = 0xa
	// Bit mask of PEP_2 field.
	USBHS_HSTISR_PEP_2_Msk = 0x400
	// Bit PEP_2.
	USBHS_HSTISR_PEP_2 = 0x400
	// Position of PEP_3 field.
	USBHS_HSTISR_PEP_3_Pos = 0xb
	// Bit mask of PEP_3 field.
	USBHS_HSTISR_PEP_3_Msk = 0x800
	// Bit PEP_3.
	USBHS_HSTISR_PEP_3 = 0x800
	// Position of PEP_4 field.
	USBHS_HSTISR_PEP_4_Pos = 0xc
	// Bit mask of PEP_4 field.
	USBHS_HSTISR_PEP_4_Msk = 0x1000
	// Bit PEP_4.
	USBHS_HSTISR_PEP_4 = 0x1000
	// Position of PEP_5 field.
	USBHS_HSTISR_PEP_5_Pos = 0xd
	// Bit mask of PEP_5 field.
	USBHS_HSTISR_PEP_5_Msk = 0x2000
	// Bit PEP_5.
	USBHS_HSTISR_PEP_5 = 0x2000
	// Position of PEP_6 field.
	USBHS_HSTISR_PEP_6_Pos = 0xe
	// Bit mask of PEP_6 field.
	USBHS_HSTISR_PEP_6_Msk = 0x4000
	// Bit PEP_6.
	USBHS_HSTISR_PEP_6 = 0x4000
	// Position of PEP_7 field.
	USBHS_HSTISR_PEP_7_Pos = 0xf
	// Bit mask of PEP_7 field.
	USBHS_HSTISR_PEP_7_Msk = 0x8000
	// Bit PEP_7.
	USBHS_HSTISR_PEP_7 = 0x8000
	// Position of PEP_8 field.
	USBHS_HSTISR_PEP_8_Pos = 0x10
	// Bit mask of PEP_8 field.
	USBHS_HSTISR_PEP_8_Msk = 0x10000
	// Bit PEP_8.
	USBHS_HSTISR_PEP_8 = 0x10000
	// Position of PEP_9 field.
	USBHS_HSTISR_PEP_9_Pos = 0x11
	// Bit mask of PEP_9 field.
	USBHS_HSTISR_PEP_9_Msk = 0x20000
	// Bit PEP_9.
	USBHS_HSTISR_PEP_9 = 0x20000
	// Position of PEP_10 field.
	USBHS_HSTISR_PEP_10_Pos = 0x12
	// Bit mask of PEP_10 field.
	USBHS_HSTISR_PEP_10_Msk = 0x40000
	// Bit PEP_10.
	USBHS_HSTISR_PEP_10 = 0x40000
	// Position of PEP_11 field.
	USBHS_HSTISR_PEP_11_Pos = 0x13
	// Bit mask of PEP_11 field.
	USBHS_HSTISR_PEP_11_Msk = 0x80000
	// Bit PEP_11.
	USBHS_HSTISR_PEP_11 = 0x80000
	// Position of DMA_1 field.
	USBHS_HSTISR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_HSTISR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_HSTISR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_HSTISR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_HSTISR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_HSTISR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_HSTISR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_HSTISR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_HSTISR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_HSTISR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_HSTISR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_HSTISR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_HSTISR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_HSTISR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_HSTISR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_HSTISR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_HSTISR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_HSTISR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_HSTISR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_HSTISR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_HSTISR_DMA_7 = 0x80000000

	// HSTICR: Host Global Interrupt Clear Register
	// Position of DCONNIC field.
	USBHS_HSTICR_DCONNIC_Pos = 0x0
	// Bit mask of DCONNIC field.
	USBHS_HSTICR_DCONNIC_Msk = 0x1
	// Bit DCONNIC.
	USBHS_HSTICR_DCONNIC = 0x1
	// Position of DDISCIC field.
	USBHS_HSTICR_DDISCIC_Pos = 0x1
	// Bit mask of DDISCIC field.
	USBHS_HSTICR_DDISCIC_Msk = 0x2
	// Bit DDISCIC.
	USBHS_HSTICR_DDISCIC = 0x2
	// Position of RSTIC field.
	USBHS_HSTICR_RSTIC_Pos = 0x2
	// Bit mask of RSTIC field.
	USBHS_HSTICR_RSTIC_Msk = 0x4
	// Bit RSTIC.
	USBHS_HSTICR_RSTIC = 0x4
	// Position of RSMEDIC field.
	USBHS_HSTICR_RSMEDIC_Pos = 0x3
	// Bit mask of RSMEDIC field.
	USBHS_HSTICR_RSMEDIC_Msk = 0x8
	// Bit RSMEDIC.
	USBHS_HSTICR_RSMEDIC = 0x8
	// Position of RXRSMIC field.
	USBHS_HSTICR_RXRSMIC_Pos = 0x4
	// Bit mask of RXRSMIC field.
	USBHS_HSTICR_RXRSMIC_Msk = 0x10
	// Bit RXRSMIC.
	USBHS_HSTICR_RXRSMIC = 0x10
	// Position of HSOFIC field.
	USBHS_HSTICR_HSOFIC_Pos = 0x5
	// Bit mask of HSOFIC field.
	USBHS_HSTICR_HSOFIC_Msk = 0x20
	// Bit HSOFIC.
	USBHS_HSTICR_HSOFIC = 0x20
	// Position of HWUPIC field.
	USBHS_HSTICR_HWUPIC_Pos = 0x6
	// Bit mask of HWUPIC field.
	USBHS_HSTICR_HWUPIC_Msk = 0x40
	// Bit HWUPIC.
	USBHS_HSTICR_HWUPIC = 0x40

	// HSTIFR: Host Global Interrupt Set Register
	// Position of DCONNIS field.
	USBHS_HSTIFR_DCONNIS_Pos = 0x0
	// Bit mask of DCONNIS field.
	USBHS_HSTIFR_DCONNIS_Msk = 0x1
	// Bit DCONNIS.
	USBHS_HSTIFR_DCONNIS = 0x1
	// Position of DDISCIS field.
	USBHS_HSTIFR_DDISCIS_Pos = 0x1
	// Bit mask of DDISCIS field.
	USBHS_HSTIFR_DDISCIS_Msk = 0x2
	// Bit DDISCIS.
	USBHS_HSTIFR_DDISCIS = 0x2
	// Position of RSTIS field.
	USBHS_HSTIFR_RSTIS_Pos = 0x2
	// Bit mask of RSTIS field.
	USBHS_HSTIFR_RSTIS_Msk = 0x4
	// Bit RSTIS.
	USBHS_HSTIFR_RSTIS = 0x4
	// Position of RSMEDIS field.
	USBHS_HSTIFR_RSMEDIS_Pos = 0x3
	// Bit mask of RSMEDIS field.
	USBHS_HSTIFR_RSMEDIS_Msk = 0x8
	// Bit RSMEDIS.
	USBHS_HSTIFR_RSMEDIS = 0x8
	// Position of RXRSMIS field.
	USBHS_HSTIFR_RXRSMIS_Pos = 0x4
	// Bit mask of RXRSMIS field.
	USBHS_HSTIFR_RXRSMIS_Msk = 0x10
	// Bit RXRSMIS.
	USBHS_HSTIFR_RXRSMIS = 0x10
	// Position of HSOFIS field.
	USBHS_HSTIFR_HSOFIS_Pos = 0x5
	// Bit mask of HSOFIS field.
	USBHS_HSTIFR_HSOFIS_Msk = 0x20
	// Bit HSOFIS.
	USBHS_HSTIFR_HSOFIS = 0x20
	// Position of HWUPIS field.
	USBHS_HSTIFR_HWUPIS_Pos = 0x6
	// Bit mask of HWUPIS field.
	USBHS_HSTIFR_HWUPIS_Msk = 0x40
	// Bit HWUPIS.
	USBHS_HSTIFR_HWUPIS = 0x40
	// Position of DMA_1 field.
	USBHS_HSTIFR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_HSTIFR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_HSTIFR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_HSTIFR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_HSTIFR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_HSTIFR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_HSTIFR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_HSTIFR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_HSTIFR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_HSTIFR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_HSTIFR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_HSTIFR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_HSTIFR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_HSTIFR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_HSTIFR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_HSTIFR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_HSTIFR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_HSTIFR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_HSTIFR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_HSTIFR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_HSTIFR_DMA_7 = 0x80000000

	// HSTIMR: Host Global Interrupt Mask Register
	// Position of DCONNIE field.
	USBHS_HSTIMR_DCONNIE_Pos = 0x0
	// Bit mask of DCONNIE field.
	USBHS_HSTIMR_DCONNIE_Msk = 0x1
	// Bit DCONNIE.
	USBHS_HSTIMR_DCONNIE = 0x1
	// Position of DDISCIE field.
	USBHS_HSTIMR_DDISCIE_Pos = 0x1
	// Bit mask of DDISCIE field.
	USBHS_HSTIMR_DDISCIE_Msk = 0x2
	// Bit DDISCIE.
	USBHS_HSTIMR_DDISCIE = 0x2
	// Position of RSTIE field.
	USBHS_HSTIMR_RSTIE_Pos = 0x2
	// Bit mask of RSTIE field.
	USBHS_HSTIMR_RSTIE_Msk = 0x4
	// Bit RSTIE.
	USBHS_HSTIMR_RSTIE = 0x4
	// Position of RSMEDIE field.
	USBHS_HSTIMR_RSMEDIE_Pos = 0x3
	// Bit mask of RSMEDIE field.
	USBHS_HSTIMR_RSMEDIE_Msk = 0x8
	// Bit RSMEDIE.
	USBHS_HSTIMR_RSMEDIE = 0x8
	// Position of RXRSMIE field.
	USBHS_HSTIMR_RXRSMIE_Pos = 0x4
	// Bit mask of RXRSMIE field.
	USBHS_HSTIMR_RXRSMIE_Msk = 0x10
	// Bit RXRSMIE.
	USBHS_HSTIMR_RXRSMIE = 0x10
	// Position of HSOFIE field.
	USBHS_HSTIMR_HSOFIE_Pos = 0x5
	// Bit mask of HSOFIE field.
	USBHS_HSTIMR_HSOFIE_Msk = 0x20
	// Bit HSOFIE.
	USBHS_HSTIMR_HSOFIE = 0x20
	// Position of HWUPIE field.
	USBHS_HSTIMR_HWUPIE_Pos = 0x6
	// Bit mask of HWUPIE field.
	USBHS_HSTIMR_HWUPIE_Msk = 0x40
	// Bit HWUPIE.
	USBHS_HSTIMR_HWUPIE = 0x40
	// Position of PEP_0 field.
	USBHS_HSTIMR_PEP_0_Pos = 0x8
	// Bit mask of PEP_0 field.
	USBHS_HSTIMR_PEP_0_Msk = 0x100
	// Bit PEP_0.
	USBHS_HSTIMR_PEP_0 = 0x100
	// Position of PEP_1 field.
	USBHS_HSTIMR_PEP_1_Pos = 0x9
	// Bit mask of PEP_1 field.
	USBHS_HSTIMR_PEP_1_Msk = 0x200
	// Bit PEP_1.
	USBHS_HSTIMR_PEP_1 = 0x200
	// Position of PEP_2 field.
	USBHS_HSTIMR_PEP_2_Pos = 0xa
	// Bit mask of PEP_2 field.
	USBHS_HSTIMR_PEP_2_Msk = 0x400
	// Bit PEP_2.
	USBHS_HSTIMR_PEP_2 = 0x400
	// Position of PEP_3 field.
	USBHS_HSTIMR_PEP_3_Pos = 0xb
	// Bit mask of PEP_3 field.
	USBHS_HSTIMR_PEP_3_Msk = 0x800
	// Bit PEP_3.
	USBHS_HSTIMR_PEP_3 = 0x800
	// Position of PEP_4 field.
	USBHS_HSTIMR_PEP_4_Pos = 0xc
	// Bit mask of PEP_4 field.
	USBHS_HSTIMR_PEP_4_Msk = 0x1000
	// Bit PEP_4.
	USBHS_HSTIMR_PEP_4 = 0x1000
	// Position of PEP_5 field.
	USBHS_HSTIMR_PEP_5_Pos = 0xd
	// Bit mask of PEP_5 field.
	USBHS_HSTIMR_PEP_5_Msk = 0x2000
	// Bit PEP_5.
	USBHS_HSTIMR_PEP_5 = 0x2000
	// Position of PEP_6 field.
	USBHS_HSTIMR_PEP_6_Pos = 0xe
	// Bit mask of PEP_6 field.
	USBHS_HSTIMR_PEP_6_Msk = 0x4000
	// Bit PEP_6.
	USBHS_HSTIMR_PEP_6 = 0x4000
	// Position of PEP_7 field.
	USBHS_HSTIMR_PEP_7_Pos = 0xf
	// Bit mask of PEP_7 field.
	USBHS_HSTIMR_PEP_7_Msk = 0x8000
	// Bit PEP_7.
	USBHS_HSTIMR_PEP_7 = 0x8000
	// Position of PEP_8 field.
	USBHS_HSTIMR_PEP_8_Pos = 0x10
	// Bit mask of PEP_8 field.
	USBHS_HSTIMR_PEP_8_Msk = 0x10000
	// Bit PEP_8.
	USBHS_HSTIMR_PEP_8 = 0x10000
	// Position of PEP_9 field.
	USBHS_HSTIMR_PEP_9_Pos = 0x11
	// Bit mask of PEP_9 field.
	USBHS_HSTIMR_PEP_9_Msk = 0x20000
	// Bit PEP_9.
	USBHS_HSTIMR_PEP_9 = 0x20000
	// Position of PEP_10 field.
	USBHS_HSTIMR_PEP_10_Pos = 0x12
	// Bit mask of PEP_10 field.
	USBHS_HSTIMR_PEP_10_Msk = 0x40000
	// Bit PEP_10.
	USBHS_HSTIMR_PEP_10 = 0x40000
	// Position of PEP_11 field.
	USBHS_HSTIMR_PEP_11_Pos = 0x13
	// Bit mask of PEP_11 field.
	USBHS_HSTIMR_PEP_11_Msk = 0x80000
	// Bit PEP_11.
	USBHS_HSTIMR_PEP_11 = 0x80000
	// Position of DMA_1 field.
	USBHS_HSTIMR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_HSTIMR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_HSTIMR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_HSTIMR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_HSTIMR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_HSTIMR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_HSTIMR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_HSTIMR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_HSTIMR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_HSTIMR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_HSTIMR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_HSTIMR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_HSTIMR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_HSTIMR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_HSTIMR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_HSTIMR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_HSTIMR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_HSTIMR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_HSTIMR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_HSTIMR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_HSTIMR_DMA_7 = 0x80000000

	// HSTIDR: Host Global Interrupt Disable Register
	// Position of DCONNIEC field.
	USBHS_HSTIDR_DCONNIEC_Pos = 0x0
	// Bit mask of DCONNIEC field.
	USBHS_HSTIDR_DCONNIEC_Msk = 0x1
	// Bit DCONNIEC.
	USBHS_HSTIDR_DCONNIEC = 0x1
	// Position of DDISCIEC field.
	USBHS_HSTIDR_DDISCIEC_Pos = 0x1
	// Bit mask of DDISCIEC field.
	USBHS_HSTIDR_DDISCIEC_Msk = 0x2
	// Bit DDISCIEC.
	USBHS_HSTIDR_DDISCIEC = 0x2
	// Position of RSTIEC field.
	USBHS_HSTIDR_RSTIEC_Pos = 0x2
	// Bit mask of RSTIEC field.
	USBHS_HSTIDR_RSTIEC_Msk = 0x4
	// Bit RSTIEC.
	USBHS_HSTIDR_RSTIEC = 0x4
	// Position of RSMEDIEC field.
	USBHS_HSTIDR_RSMEDIEC_Pos = 0x3
	// Bit mask of RSMEDIEC field.
	USBHS_HSTIDR_RSMEDIEC_Msk = 0x8
	// Bit RSMEDIEC.
	USBHS_HSTIDR_RSMEDIEC = 0x8
	// Position of RXRSMIEC field.
	USBHS_HSTIDR_RXRSMIEC_Pos = 0x4
	// Bit mask of RXRSMIEC field.
	USBHS_HSTIDR_RXRSMIEC_Msk = 0x10
	// Bit RXRSMIEC.
	USBHS_HSTIDR_RXRSMIEC = 0x10
	// Position of HSOFIEC field.
	USBHS_HSTIDR_HSOFIEC_Pos = 0x5
	// Bit mask of HSOFIEC field.
	USBHS_HSTIDR_HSOFIEC_Msk = 0x20
	// Bit HSOFIEC.
	USBHS_HSTIDR_HSOFIEC = 0x20
	// Position of HWUPIEC field.
	USBHS_HSTIDR_HWUPIEC_Pos = 0x6
	// Bit mask of HWUPIEC field.
	USBHS_HSTIDR_HWUPIEC_Msk = 0x40
	// Bit HWUPIEC.
	USBHS_HSTIDR_HWUPIEC = 0x40
	// Position of PEP_0 field.
	USBHS_HSTIDR_PEP_0_Pos = 0x8
	// Bit mask of PEP_0 field.
	USBHS_HSTIDR_PEP_0_Msk = 0x100
	// Bit PEP_0.
	USBHS_HSTIDR_PEP_0 = 0x100
	// Position of PEP_1 field.
	USBHS_HSTIDR_PEP_1_Pos = 0x9
	// Bit mask of PEP_1 field.
	USBHS_HSTIDR_PEP_1_Msk = 0x200
	// Bit PEP_1.
	USBHS_HSTIDR_PEP_1 = 0x200
	// Position of PEP_2 field.
	USBHS_HSTIDR_PEP_2_Pos = 0xa
	// Bit mask of PEP_2 field.
	USBHS_HSTIDR_PEP_2_Msk = 0x400
	// Bit PEP_2.
	USBHS_HSTIDR_PEP_2 = 0x400
	// Position of PEP_3 field.
	USBHS_HSTIDR_PEP_3_Pos = 0xb
	// Bit mask of PEP_3 field.
	USBHS_HSTIDR_PEP_3_Msk = 0x800
	// Bit PEP_3.
	USBHS_HSTIDR_PEP_3 = 0x800
	// Position of PEP_4 field.
	USBHS_HSTIDR_PEP_4_Pos = 0xc
	// Bit mask of PEP_4 field.
	USBHS_HSTIDR_PEP_4_Msk = 0x1000
	// Bit PEP_4.
	USBHS_HSTIDR_PEP_4 = 0x1000
	// Position of PEP_5 field.
	USBHS_HSTIDR_PEP_5_Pos = 0xd
	// Bit mask of PEP_5 field.
	USBHS_HSTIDR_PEP_5_Msk = 0x2000
	// Bit PEP_5.
	USBHS_HSTIDR_PEP_5 = 0x2000
	// Position of PEP_6 field.
	USBHS_HSTIDR_PEP_6_Pos = 0xe
	// Bit mask of PEP_6 field.
	USBHS_HSTIDR_PEP_6_Msk = 0x4000
	// Bit PEP_6.
	USBHS_HSTIDR_PEP_6 = 0x4000
	// Position of PEP_7 field.
	USBHS_HSTIDR_PEP_7_Pos = 0xf
	// Bit mask of PEP_7 field.
	USBHS_HSTIDR_PEP_7_Msk = 0x8000
	// Bit PEP_7.
	USBHS_HSTIDR_PEP_7 = 0x8000
	// Position of PEP_8 field.
	USBHS_HSTIDR_PEP_8_Pos = 0x10
	// Bit mask of PEP_8 field.
	USBHS_HSTIDR_PEP_8_Msk = 0x10000
	// Bit PEP_8.
	USBHS_HSTIDR_PEP_8 = 0x10000
	// Position of PEP_9 field.
	USBHS_HSTIDR_PEP_9_Pos = 0x11
	// Bit mask of PEP_9 field.
	USBHS_HSTIDR_PEP_9_Msk = 0x20000
	// Bit PEP_9.
	USBHS_HSTIDR_PEP_9 = 0x20000
	// Position of PEP_10 field.
	USBHS_HSTIDR_PEP_10_Pos = 0x12
	// Bit mask of PEP_10 field.
	USBHS_HSTIDR_PEP_10_Msk = 0x40000
	// Bit PEP_10.
	USBHS_HSTIDR_PEP_10 = 0x40000
	// Position of PEP_11 field.
	USBHS_HSTIDR_PEP_11_Pos = 0x13
	// Bit mask of PEP_11 field.
	USBHS_HSTIDR_PEP_11_Msk = 0x80000
	// Bit PEP_11.
	USBHS_HSTIDR_PEP_11 = 0x80000
	// Position of DMA_1 field.
	USBHS_HSTIDR_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_HSTIDR_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_HSTIDR_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_HSTIDR_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_HSTIDR_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_HSTIDR_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_HSTIDR_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_HSTIDR_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_HSTIDR_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_HSTIDR_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_HSTIDR_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_HSTIDR_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_HSTIDR_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_HSTIDR_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_HSTIDR_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_HSTIDR_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_HSTIDR_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_HSTIDR_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_HSTIDR_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_HSTIDR_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_HSTIDR_DMA_7 = 0x80000000

	// HSTIER: Host Global Interrupt Enable Register
	// Position of DCONNIES field.
	USBHS_HSTIER_DCONNIES_Pos = 0x0
	// Bit mask of DCONNIES field.
	USBHS_HSTIER_DCONNIES_Msk = 0x1
	// Bit DCONNIES.
	USBHS_HSTIER_DCONNIES = 0x1
	// Position of DDISCIES field.
	USBHS_HSTIER_DDISCIES_Pos = 0x1
	// Bit mask of DDISCIES field.
	USBHS_HSTIER_DDISCIES_Msk = 0x2
	// Bit DDISCIES.
	USBHS_HSTIER_DDISCIES = 0x2
	// Position of RSTIES field.
	USBHS_HSTIER_RSTIES_Pos = 0x2
	// Bit mask of RSTIES field.
	USBHS_HSTIER_RSTIES_Msk = 0x4
	// Bit RSTIES.
	USBHS_HSTIER_RSTIES = 0x4
	// Position of RSMEDIES field.
	USBHS_HSTIER_RSMEDIES_Pos = 0x3
	// Bit mask of RSMEDIES field.
	USBHS_HSTIER_RSMEDIES_Msk = 0x8
	// Bit RSMEDIES.
	USBHS_HSTIER_RSMEDIES = 0x8
	// Position of RXRSMIES field.
	USBHS_HSTIER_RXRSMIES_Pos = 0x4
	// Bit mask of RXRSMIES field.
	USBHS_HSTIER_RXRSMIES_Msk = 0x10
	// Bit RXRSMIES.
	USBHS_HSTIER_RXRSMIES = 0x10
	// Position of HSOFIES field.
	USBHS_HSTIER_HSOFIES_Pos = 0x5
	// Bit mask of HSOFIES field.
	USBHS_HSTIER_HSOFIES_Msk = 0x20
	// Bit HSOFIES.
	USBHS_HSTIER_HSOFIES = 0x20
	// Position of HWUPIES field.
	USBHS_HSTIER_HWUPIES_Pos = 0x6
	// Bit mask of HWUPIES field.
	USBHS_HSTIER_HWUPIES_Msk = 0x40
	// Bit HWUPIES.
	USBHS_HSTIER_HWUPIES = 0x40
	// Position of PEP_0 field.
	USBHS_HSTIER_PEP_0_Pos = 0x8
	// Bit mask of PEP_0 field.
	USBHS_HSTIER_PEP_0_Msk = 0x100
	// Bit PEP_0.
	USBHS_HSTIER_PEP_0 = 0x100
	// Position of PEP_1 field.
	USBHS_HSTIER_PEP_1_Pos = 0x9
	// Bit mask of PEP_1 field.
	USBHS_HSTIER_PEP_1_Msk = 0x200
	// Bit PEP_1.
	USBHS_HSTIER_PEP_1 = 0x200
	// Position of PEP_2 field.
	USBHS_HSTIER_PEP_2_Pos = 0xa
	// Bit mask of PEP_2 field.
	USBHS_HSTIER_PEP_2_Msk = 0x400
	// Bit PEP_2.
	USBHS_HSTIER_PEP_2 = 0x400
	// Position of PEP_3 field.
	USBHS_HSTIER_PEP_3_Pos = 0xb
	// Bit mask of PEP_3 field.
	USBHS_HSTIER_PEP_3_Msk = 0x800
	// Bit PEP_3.
	USBHS_HSTIER_PEP_3 = 0x800
	// Position of PEP_4 field.
	USBHS_HSTIER_PEP_4_Pos = 0xc
	// Bit mask of PEP_4 field.
	USBHS_HSTIER_PEP_4_Msk = 0x1000
	// Bit PEP_4.
	USBHS_HSTIER_PEP_4 = 0x1000
	// Position of PEP_5 field.
	USBHS_HSTIER_PEP_5_Pos = 0xd
	// Bit mask of PEP_5 field.
	USBHS_HSTIER_PEP_5_Msk = 0x2000
	// Bit PEP_5.
	USBHS_HSTIER_PEP_5 = 0x2000
	// Position of PEP_6 field.
	USBHS_HSTIER_PEP_6_Pos = 0xe
	// Bit mask of PEP_6 field.
	USBHS_HSTIER_PEP_6_Msk = 0x4000
	// Bit PEP_6.
	USBHS_HSTIER_PEP_6 = 0x4000
	// Position of PEP_7 field.
	USBHS_HSTIER_PEP_7_Pos = 0xf
	// Bit mask of PEP_7 field.
	USBHS_HSTIER_PEP_7_Msk = 0x8000
	// Bit PEP_7.
	USBHS_HSTIER_PEP_7 = 0x8000
	// Position of PEP_8 field.
	USBHS_HSTIER_PEP_8_Pos = 0x10
	// Bit mask of PEP_8 field.
	USBHS_HSTIER_PEP_8_Msk = 0x10000
	// Bit PEP_8.
	USBHS_HSTIER_PEP_8 = 0x10000
	// Position of PEP_9 field.
	USBHS_HSTIER_PEP_9_Pos = 0x11
	// Bit mask of PEP_9 field.
	USBHS_HSTIER_PEP_9_Msk = 0x20000
	// Bit PEP_9.
	USBHS_HSTIER_PEP_9 = 0x20000
	// Position of PEP_10 field.
	USBHS_HSTIER_PEP_10_Pos = 0x12
	// Bit mask of PEP_10 field.
	USBHS_HSTIER_PEP_10_Msk = 0x40000
	// Bit PEP_10.
	USBHS_HSTIER_PEP_10 = 0x40000
	// Position of PEP_11 field.
	USBHS_HSTIER_PEP_11_Pos = 0x13
	// Bit mask of PEP_11 field.
	USBHS_HSTIER_PEP_11_Msk = 0x80000
	// Bit PEP_11.
	USBHS_HSTIER_PEP_11 = 0x80000
	// Position of DMA_1 field.
	USBHS_HSTIER_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	USBHS_HSTIER_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	USBHS_HSTIER_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	USBHS_HSTIER_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	USBHS_HSTIER_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	USBHS_HSTIER_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	USBHS_HSTIER_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	USBHS_HSTIER_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	USBHS_HSTIER_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	USBHS_HSTIER_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	USBHS_HSTIER_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	USBHS_HSTIER_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	USBHS_HSTIER_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	USBHS_HSTIER_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	USBHS_HSTIER_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	USBHS_HSTIER_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	USBHS_HSTIER_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	USBHS_HSTIER_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	USBHS_HSTIER_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	USBHS_HSTIER_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	USBHS_HSTIER_DMA_7 = 0x80000000

	// HSTPIP: Host Pipe Register
	// Position of PEN0 field.
	USBHS_HSTPIP_PEN0_Pos = 0x0
	// Bit mask of PEN0 field.
	USBHS_HSTPIP_PEN0_Msk = 0x1
	// Bit PEN0.
	USBHS_HSTPIP_PEN0 = 0x1
	// Position of PEN1 field.
	USBHS_HSTPIP_PEN1_Pos = 0x1
	// Bit mask of PEN1 field.
	USBHS_HSTPIP_PEN1_Msk = 0x2
	// Bit PEN1.
	USBHS_HSTPIP_PEN1 = 0x2
	// Position of PEN2 field.
	USBHS_HSTPIP_PEN2_Pos = 0x2
	// Bit mask of PEN2 field.
	USBHS_HSTPIP_PEN2_Msk = 0x4
	// Bit PEN2.
	USBHS_HSTPIP_PEN2 = 0x4
	// Position of PEN3 field.
	USBHS_HSTPIP_PEN3_Pos = 0x3
	// Bit mask of PEN3 field.
	USBHS_HSTPIP_PEN3_Msk = 0x8
	// Bit PEN3.
	USBHS_HSTPIP_PEN3 = 0x8
	// Position of PEN4 field.
	USBHS_HSTPIP_PEN4_Pos = 0x4
	// Bit mask of PEN4 field.
	USBHS_HSTPIP_PEN4_Msk = 0x10
	// Bit PEN4.
	USBHS_HSTPIP_PEN4 = 0x10
	// Position of PEN5 field.
	USBHS_HSTPIP_PEN5_Pos = 0x5
	// Bit mask of PEN5 field.
	USBHS_HSTPIP_PEN5_Msk = 0x20
	// Bit PEN5.
	USBHS_HSTPIP_PEN5 = 0x20
	// Position of PEN6 field.
	USBHS_HSTPIP_PEN6_Pos = 0x6
	// Bit mask of PEN6 field.
	USBHS_HSTPIP_PEN6_Msk = 0x40
	// Bit PEN6.
	USBHS_HSTPIP_PEN6 = 0x40
	// Position of PEN7 field.
	USBHS_HSTPIP_PEN7_Pos = 0x7
	// Bit mask of PEN7 field.
	USBHS_HSTPIP_PEN7_Msk = 0x80
	// Bit PEN7.
	USBHS_HSTPIP_PEN7 = 0x80
	// Position of PEN8 field.
	USBHS_HSTPIP_PEN8_Pos = 0x8
	// Bit mask of PEN8 field.
	USBHS_HSTPIP_PEN8_Msk = 0x100
	// Bit PEN8.
	USBHS_HSTPIP_PEN8 = 0x100
	// Position of PRST0 field.
	USBHS_HSTPIP_PRST0_Pos = 0x10
	// Bit mask of PRST0 field.
	USBHS_HSTPIP_PRST0_Msk = 0x10000
	// Bit PRST0.
	USBHS_HSTPIP_PRST0 = 0x10000
	// Position of PRST1 field.
	USBHS_HSTPIP_PRST1_Pos = 0x11
	// Bit mask of PRST1 field.
	USBHS_HSTPIP_PRST1_Msk = 0x20000
	// Bit PRST1.
	USBHS_HSTPIP_PRST1 = 0x20000
	// Position of PRST2 field.
	USBHS_HSTPIP_PRST2_Pos = 0x12
	// Bit mask of PRST2 field.
	USBHS_HSTPIP_PRST2_Msk = 0x40000
	// Bit PRST2.
	USBHS_HSTPIP_PRST2 = 0x40000
	// Position of PRST3 field.
	USBHS_HSTPIP_PRST3_Pos = 0x13
	// Bit mask of PRST3 field.
	USBHS_HSTPIP_PRST3_Msk = 0x80000
	// Bit PRST3.
	USBHS_HSTPIP_PRST3 = 0x80000
	// Position of PRST4 field.
	USBHS_HSTPIP_PRST4_Pos = 0x14
	// Bit mask of PRST4 field.
	USBHS_HSTPIP_PRST4_Msk = 0x100000
	// Bit PRST4.
	USBHS_HSTPIP_PRST4 = 0x100000
	// Position of PRST5 field.
	USBHS_HSTPIP_PRST5_Pos = 0x15
	// Bit mask of PRST5 field.
	USBHS_HSTPIP_PRST5_Msk = 0x200000
	// Bit PRST5.
	USBHS_HSTPIP_PRST5 = 0x200000
	// Position of PRST6 field.
	USBHS_HSTPIP_PRST6_Pos = 0x16
	// Bit mask of PRST6 field.
	USBHS_HSTPIP_PRST6_Msk = 0x400000
	// Bit PRST6.
	USBHS_HSTPIP_PRST6 = 0x400000
	// Position of PRST7 field.
	USBHS_HSTPIP_PRST7_Pos = 0x17
	// Bit mask of PRST7 field.
	USBHS_HSTPIP_PRST7_Msk = 0x800000
	// Bit PRST7.
	USBHS_HSTPIP_PRST7 = 0x800000
	// Position of PRST8 field.
	USBHS_HSTPIP_PRST8_Pos = 0x18
	// Bit mask of PRST8 field.
	USBHS_HSTPIP_PRST8_Msk = 0x1000000
	// Bit PRST8.
	USBHS_HSTPIP_PRST8 = 0x1000000

	// HSTFNUM: Host Frame Number Register
	// Position of MFNUM field.
	USBHS_HSTFNUM_MFNUM_Pos = 0x0
	// Bit mask of MFNUM field.
	USBHS_HSTFNUM_MFNUM_Msk = 0x7
	// Position of FNUM field.
	USBHS_HSTFNUM_FNUM_Pos = 0x3
	// Bit mask of FNUM field.
	USBHS_HSTFNUM_FNUM_Msk = 0x3ff8
	// Position of FLENHIGH field.
	USBHS_HSTFNUM_FLENHIGH_Pos = 0x10
	// Bit mask of FLENHIGH field.
	USBHS_HSTFNUM_FLENHIGH_Msk = 0xff0000

	// HSTADDR1: Host Address 1 Register
	// Position of HSTADDRP0 field.
	USBHS_HSTADDR1_HSTADDRP0_Pos = 0x0
	// Bit mask of HSTADDRP0 field.
	USBHS_HSTADDR1_HSTADDRP0_Msk = 0x7f
	// Position of HSTADDRP1 field.
	USBHS_HSTADDR1_HSTADDRP1_Pos = 0x8
	// Bit mask of HSTADDRP1 field.
	USBHS_HSTADDR1_HSTADDRP1_Msk = 0x7f00
	// Position of HSTADDRP2 field.
	USBHS_HSTADDR1_HSTADDRP2_Pos = 0x10
	// Bit mask of HSTADDRP2 field.
	USBHS_HSTADDR1_HSTADDRP2_Msk = 0x7f0000
	// Position of HSTADDRP3 field.
	USBHS_HSTADDR1_HSTADDRP3_Pos = 0x18
	// Bit mask of HSTADDRP3 field.
	USBHS_HSTADDR1_HSTADDRP3_Msk = 0x7f000000

	// HSTADDR2: Host Address 2 Register
	// Position of HSTADDRP4 field.
	USBHS_HSTADDR2_HSTADDRP4_Pos = 0x0
	// Bit mask of HSTADDRP4 field.
	USBHS_HSTADDR2_HSTADDRP4_Msk = 0x7f
	// Position of HSTADDRP5 field.
	USBHS_HSTADDR2_HSTADDRP5_Pos = 0x8
	// Bit mask of HSTADDRP5 field.
	USBHS_HSTADDR2_HSTADDRP5_Msk = 0x7f00
	// Position of HSTADDRP6 field.
	USBHS_HSTADDR2_HSTADDRP6_Pos = 0x10
	// Bit mask of HSTADDRP6 field.
	USBHS_HSTADDR2_HSTADDRP6_Msk = 0x7f0000
	// Position of HSTADDRP7 field.
	USBHS_HSTADDR2_HSTADDRP7_Pos = 0x18
	// Bit mask of HSTADDRP7 field.
	USBHS_HSTADDR2_HSTADDRP7_Msk = 0x7f000000

	// HSTADDR3: Host Address 3 Register
	// Position of HSTADDRP8 field.
	USBHS_HSTADDR3_HSTADDRP8_Pos = 0x0
	// Bit mask of HSTADDRP8 field.
	USBHS_HSTADDR3_HSTADDRP8_Msk = 0x7f
	// Position of HSTADDRP9 field.
	USBHS_HSTADDR3_HSTADDRP9_Pos = 0x8
	// Bit mask of HSTADDRP9 field.
	USBHS_HSTADDR3_HSTADDRP9_Msk = 0x7f00

	// HSTPIPCFG: Host Pipe Configuration Register (n = 0) 0
	// Position of ALLOC field.
	USBHS_HSTPIPCFG_ALLOC_Pos = 0x1
	// Bit mask of ALLOC field.
	USBHS_HSTPIPCFG_ALLOC_Msk = 0x2
	// Bit ALLOC.
	USBHS_HSTPIPCFG_ALLOC = 0x2
	// Position of PBK field.
	USBHS_HSTPIPCFG_PBK_Pos = 0x2
	// Bit mask of PBK field.
	USBHS_HSTPIPCFG_PBK_Msk = 0xc
	// Single-bank pipe
	USBHS_HSTPIPCFG_PBK__1_BANK = 0x0
	// Double-bank pipe
	USBHS_HSTPIPCFG_PBK__2_BANK = 0x1
	// Triple-bank pipe
	USBHS_HSTPIPCFG_PBK__3_BANK = 0x2
	// Position of PSIZE field.
	USBHS_HSTPIPCFG_PSIZE_Pos = 0x4
	// Bit mask of PSIZE field.
	USBHS_HSTPIPCFG_PSIZE_Msk = 0x70
	// 8 bytes
	USBHS_HSTPIPCFG_PSIZE__8_BYTE = 0x0
	// 16 bytes
	USBHS_HSTPIPCFG_PSIZE__16_BYTE = 0x1
	// 32 bytes
	USBHS_HSTPIPCFG_PSIZE__32_BYTE = 0x2
	// 64 bytes
	USBHS_HSTPIPCFG_PSIZE__64_BYTE = 0x3
	// 128 bytes
	USBHS_HSTPIPCFG_PSIZE__128_BYTE = 0x4
	// 256 bytes
	USBHS_HSTPIPCFG_PSIZE__256_BYTE = 0x5
	// 512 bytes
	USBHS_HSTPIPCFG_PSIZE__512_BYTE = 0x6
	// 1024 bytes
	USBHS_HSTPIPCFG_PSIZE__1024_BYTE = 0x7
	// Position of PTOKEN field.
	USBHS_HSTPIPCFG_PTOKEN_Pos = 0x8
	// Bit mask of PTOKEN field.
	USBHS_HSTPIPCFG_PTOKEN_Msk = 0x300
	// SETUP
	USBHS_HSTPIPCFG_PTOKEN_SETUP = 0x0
	// IN
	USBHS_HSTPIPCFG_PTOKEN_IN = 0x1
	// OUT
	USBHS_HSTPIPCFG_PTOKEN_OUT = 0x2
	// Position of AUTOSW field.
	USBHS_HSTPIPCFG_AUTOSW_Pos = 0xa
	// Bit mask of AUTOSW field.
	USBHS_HSTPIPCFG_AUTOSW_Msk = 0x400
	// Bit AUTOSW.
	USBHS_HSTPIPCFG_AUTOSW = 0x400
	// Position of PTYPE field.
	USBHS_HSTPIPCFG_PTYPE_Pos = 0xc
	// Bit mask of PTYPE field.
	USBHS_HSTPIPCFG_PTYPE_Msk = 0x3000
	// Control
	USBHS_HSTPIPCFG_PTYPE_CTRL = 0x0
	// Isochronous
	USBHS_HSTPIPCFG_PTYPE_ISO = 0x1
	// Bulk
	USBHS_HSTPIPCFG_PTYPE_BLK = 0x2
	// Interrupt
	USBHS_HSTPIPCFG_PTYPE_INTRPT = 0x3
	// Position of PEPNUM field.
	USBHS_HSTPIPCFG_PEPNUM_Pos = 0x10
	// Bit mask of PEPNUM field.
	USBHS_HSTPIPCFG_PEPNUM_Msk = 0xf0000
	// Position of INTFRQ field.
	USBHS_HSTPIPCFG_INTFRQ_Pos = 0x18
	// Bit mask of INTFRQ field.
	USBHS_HSTPIPCFG_INTFRQ_Msk = 0xff000000

	// HSTPIPISR: Host Pipe Status Register (n = 0) 0
	// Position of RXINI field.
	USBHS_HSTPIPISR_RXINI_Pos = 0x0
	// Bit mask of RXINI field.
	USBHS_HSTPIPISR_RXINI_Msk = 0x1
	// Bit RXINI.
	USBHS_HSTPIPISR_RXINI = 0x1
	// Position of TXOUTI field.
	USBHS_HSTPIPISR_TXOUTI_Pos = 0x1
	// Bit mask of TXOUTI field.
	USBHS_HSTPIPISR_TXOUTI_Msk = 0x2
	// Bit TXOUTI.
	USBHS_HSTPIPISR_TXOUTI = 0x2
	// Position of TXSTPI field.
	USBHS_HSTPIPISR_TXSTPI_Pos = 0x2
	// Bit mask of TXSTPI field.
	USBHS_HSTPIPISR_TXSTPI_Msk = 0x4
	// Bit TXSTPI.
	USBHS_HSTPIPISR_TXSTPI = 0x4
	// Position of PERRI field.
	USBHS_HSTPIPISR_PERRI_Pos = 0x3
	// Bit mask of PERRI field.
	USBHS_HSTPIPISR_PERRI_Msk = 0x8
	// Bit PERRI.
	USBHS_HSTPIPISR_PERRI = 0x8
	// Position of NAKEDI field.
	USBHS_HSTPIPISR_NAKEDI_Pos = 0x4
	// Bit mask of NAKEDI field.
	USBHS_HSTPIPISR_NAKEDI_Msk = 0x10
	// Bit NAKEDI.
	USBHS_HSTPIPISR_NAKEDI = 0x10
	// Position of OVERFI field.
	USBHS_HSTPIPISR_OVERFI_Pos = 0x5
	// Bit mask of OVERFI field.
	USBHS_HSTPIPISR_OVERFI_Msk = 0x20
	// Bit OVERFI.
	USBHS_HSTPIPISR_OVERFI = 0x20
	// Position of RXSTALLDI field.
	USBHS_HSTPIPISR_RXSTALLDI_Pos = 0x6
	// Bit mask of RXSTALLDI field.
	USBHS_HSTPIPISR_RXSTALLDI_Msk = 0x40
	// Bit RXSTALLDI.
	USBHS_HSTPIPISR_RXSTALLDI = 0x40
	// Position of SHORTPACKETI field.
	USBHS_HSTPIPISR_SHORTPACKETI_Pos = 0x7
	// Bit mask of SHORTPACKETI field.
	USBHS_HSTPIPISR_SHORTPACKETI_Msk = 0x80
	// Bit SHORTPACKETI.
	USBHS_HSTPIPISR_SHORTPACKETI = 0x80
	// Position of DTSEQ field.
	USBHS_HSTPIPISR_DTSEQ_Pos = 0x8
	// Bit mask of DTSEQ field.
	USBHS_HSTPIPISR_DTSEQ_Msk = 0x300
	// Data0 toggle sequence
	USBHS_HSTPIPISR_DTSEQ_DATA0 = 0x0
	// Data1 toggle sequence
	USBHS_HSTPIPISR_DTSEQ_DATA1 = 0x1
	// Position of NBUSYBK field.
	USBHS_HSTPIPISR_NBUSYBK_Pos = 0xc
	// Bit mask of NBUSYBK field.
	USBHS_HSTPIPISR_NBUSYBK_Msk = 0x3000
	// 0 busy bank (all banks free)
	USBHS_HSTPIPISR_NBUSYBK__0_BUSY = 0x0
	// 1 busy bank
	USBHS_HSTPIPISR_NBUSYBK__1_BUSY = 0x1
	// 2 busy banks
	USBHS_HSTPIPISR_NBUSYBK__2_BUSY = 0x2
	// 3 busy banks
	USBHS_HSTPIPISR_NBUSYBK__3_BUSY = 0x3
	// Position of CURRBK field.
	USBHS_HSTPIPISR_CURRBK_Pos = 0xe
	// Bit mask of CURRBK field.
	USBHS_HSTPIPISR_CURRBK_Msk = 0xc000
	// Current bank is bank0
	USBHS_HSTPIPISR_CURRBK_BANK0 = 0x0
	// Current bank is bank1
	USBHS_HSTPIPISR_CURRBK_BANK1 = 0x1
	// Current bank is bank2
	USBHS_HSTPIPISR_CURRBK_BANK2 = 0x2
	// Position of RWALL field.
	USBHS_HSTPIPISR_RWALL_Pos = 0x10
	// Bit mask of RWALL field.
	USBHS_HSTPIPISR_RWALL_Msk = 0x10000
	// Bit RWALL.
	USBHS_HSTPIPISR_RWALL = 0x10000
	// Position of CFGOK field.
	USBHS_HSTPIPISR_CFGOK_Pos = 0x12
	// Bit mask of CFGOK field.
	USBHS_HSTPIPISR_CFGOK_Msk = 0x40000
	// Bit CFGOK.
	USBHS_HSTPIPISR_CFGOK = 0x40000
	// Position of PBYCT field.
	USBHS_HSTPIPISR_PBYCT_Pos = 0x14
	// Bit mask of PBYCT field.
	USBHS_HSTPIPISR_PBYCT_Msk = 0x7ff00000

	// HSTPIPICR: Host Pipe Clear Register (n = 0) 0
	// Position of RXINIC field.
	USBHS_HSTPIPICR_RXINIC_Pos = 0x0
	// Bit mask of RXINIC field.
	USBHS_HSTPIPICR_RXINIC_Msk = 0x1
	// Bit RXINIC.
	USBHS_HSTPIPICR_RXINIC = 0x1
	// Position of TXOUTIC field.
	USBHS_HSTPIPICR_TXOUTIC_Pos = 0x1
	// Bit mask of TXOUTIC field.
	USBHS_HSTPIPICR_TXOUTIC_Msk = 0x2
	// Bit TXOUTIC.
	USBHS_HSTPIPICR_TXOUTIC = 0x2
	// Position of TXSTPIC field.
	USBHS_HSTPIPICR_TXSTPIC_Pos = 0x2
	// Bit mask of TXSTPIC field.
	USBHS_HSTPIPICR_TXSTPIC_Msk = 0x4
	// Bit TXSTPIC.
	USBHS_HSTPIPICR_TXSTPIC = 0x4
	// Position of NAKEDIC field.
	USBHS_HSTPIPICR_NAKEDIC_Pos = 0x4
	// Bit mask of NAKEDIC field.
	USBHS_HSTPIPICR_NAKEDIC_Msk = 0x10
	// Bit NAKEDIC.
	USBHS_HSTPIPICR_NAKEDIC = 0x10
	// Position of OVERFIC field.
	USBHS_HSTPIPICR_OVERFIC_Pos = 0x5
	// Bit mask of OVERFIC field.
	USBHS_HSTPIPICR_OVERFIC_Msk = 0x20
	// Bit OVERFIC.
	USBHS_HSTPIPICR_OVERFIC = 0x20
	// Position of RXSTALLDIC field.
	USBHS_HSTPIPICR_RXSTALLDIC_Pos = 0x6
	// Bit mask of RXSTALLDIC field.
	USBHS_HSTPIPICR_RXSTALLDIC_Msk = 0x40
	// Bit RXSTALLDIC.
	USBHS_HSTPIPICR_RXSTALLDIC = 0x40
	// Position of SHORTPACKETIC field.
	USBHS_HSTPIPICR_SHORTPACKETIC_Pos = 0x7
	// Bit mask of SHORTPACKETIC field.
	USBHS_HSTPIPICR_SHORTPACKETIC_Msk = 0x80
	// Bit SHORTPACKETIC.
	USBHS_HSTPIPICR_SHORTPACKETIC = 0x80

	// HSTPIPIFR: Host Pipe Set Register (n = 0) 0
	// Position of RXINIS field.
	USBHS_HSTPIPIFR_RXINIS_Pos = 0x0
	// Bit mask of RXINIS field.
	USBHS_HSTPIPIFR_RXINIS_Msk = 0x1
	// Bit RXINIS.
	USBHS_HSTPIPIFR_RXINIS = 0x1
	// Position of TXOUTIS field.
	USBHS_HSTPIPIFR_TXOUTIS_Pos = 0x1
	// Bit mask of TXOUTIS field.
	USBHS_HSTPIPIFR_TXOUTIS_Msk = 0x2
	// Bit TXOUTIS.
	USBHS_HSTPIPIFR_TXOUTIS = 0x2
	// Position of TXSTPIS field.
	USBHS_HSTPIPIFR_TXSTPIS_Pos = 0x2
	// Bit mask of TXSTPIS field.
	USBHS_HSTPIPIFR_TXSTPIS_Msk = 0x4
	// Bit TXSTPIS.
	USBHS_HSTPIPIFR_TXSTPIS = 0x4
	// Position of PERRIS field.
	USBHS_HSTPIPIFR_PERRIS_Pos = 0x3
	// Bit mask of PERRIS field.
	USBHS_HSTPIPIFR_PERRIS_Msk = 0x8
	// Bit PERRIS.
	USBHS_HSTPIPIFR_PERRIS = 0x8
	// Position of NAKEDIS field.
	USBHS_HSTPIPIFR_NAKEDIS_Pos = 0x4
	// Bit mask of NAKEDIS field.
	USBHS_HSTPIPIFR_NAKEDIS_Msk = 0x10
	// Bit NAKEDIS.
	USBHS_HSTPIPIFR_NAKEDIS = 0x10
	// Position of OVERFIS field.
	USBHS_HSTPIPIFR_OVERFIS_Pos = 0x5
	// Bit mask of OVERFIS field.
	USBHS_HSTPIPIFR_OVERFIS_Msk = 0x20
	// Bit OVERFIS.
	USBHS_HSTPIPIFR_OVERFIS = 0x20
	// Position of RXSTALLDIS field.
	USBHS_HSTPIPIFR_RXSTALLDIS_Pos = 0x6
	// Bit mask of RXSTALLDIS field.
	USBHS_HSTPIPIFR_RXSTALLDIS_Msk = 0x40
	// Bit RXSTALLDIS.
	USBHS_HSTPIPIFR_RXSTALLDIS = 0x40
	// Position of SHORTPACKETIS field.
	USBHS_HSTPIPIFR_SHORTPACKETIS_Pos = 0x7
	// Bit mask of SHORTPACKETIS field.
	USBHS_HSTPIPIFR_SHORTPACKETIS_Msk = 0x80
	// Bit SHORTPACKETIS.
	USBHS_HSTPIPIFR_SHORTPACKETIS = 0x80
	// Position of NBUSYBKS field.
	USBHS_HSTPIPIFR_NBUSYBKS_Pos = 0xc
	// Bit mask of NBUSYBKS field.
	USBHS_HSTPIPIFR_NBUSYBKS_Msk = 0x1000
	// Bit NBUSYBKS.
	USBHS_HSTPIPIFR_NBUSYBKS = 0x1000

	// HSTPIPIMR: Host Pipe Mask Register (n = 0) 0
	// Position of RXINE field.
	USBHS_HSTPIPIMR_RXINE_Pos = 0x0
	// Bit mask of RXINE field.
	USBHS_HSTPIPIMR_RXINE_Msk = 0x1
	// Bit RXINE.
	USBHS_HSTPIPIMR_RXINE = 0x1
	// Position of TXOUTE field.
	USBHS_HSTPIPIMR_TXOUTE_Pos = 0x1
	// Bit mask of TXOUTE field.
	USBHS_HSTPIPIMR_TXOUTE_Msk = 0x2
	// Bit TXOUTE.
	USBHS_HSTPIPIMR_TXOUTE = 0x2
	// Position of TXSTPE field.
	USBHS_HSTPIPIMR_TXSTPE_Pos = 0x2
	// Bit mask of TXSTPE field.
	USBHS_HSTPIPIMR_TXSTPE_Msk = 0x4
	// Bit TXSTPE.
	USBHS_HSTPIPIMR_TXSTPE = 0x4
	// Position of PERRE field.
	USBHS_HSTPIPIMR_PERRE_Pos = 0x3
	// Bit mask of PERRE field.
	USBHS_HSTPIPIMR_PERRE_Msk = 0x8
	// Bit PERRE.
	USBHS_HSTPIPIMR_PERRE = 0x8
	// Position of NAKEDE field.
	USBHS_HSTPIPIMR_NAKEDE_Pos = 0x4
	// Bit mask of NAKEDE field.
	USBHS_HSTPIPIMR_NAKEDE_Msk = 0x10
	// Bit NAKEDE.
	USBHS_HSTPIPIMR_NAKEDE = 0x10
	// Position of OVERFIE field.
	USBHS_HSTPIPIMR_OVERFIE_Pos = 0x5
	// Bit mask of OVERFIE field.
	USBHS_HSTPIPIMR_OVERFIE_Msk = 0x20
	// Bit OVERFIE.
	USBHS_HSTPIPIMR_OVERFIE = 0x20
	// Position of RXSTALLDE field.
	USBHS_HSTPIPIMR_RXSTALLDE_Pos = 0x6
	// Bit mask of RXSTALLDE field.
	USBHS_HSTPIPIMR_RXSTALLDE_Msk = 0x40
	// Bit RXSTALLDE.
	USBHS_HSTPIPIMR_RXSTALLDE = 0x40
	// Position of SHORTPACKETIE field.
	USBHS_HSTPIPIMR_SHORTPACKETIE_Pos = 0x7
	// Bit mask of SHORTPACKETIE field.
	USBHS_HSTPIPIMR_SHORTPACKETIE_Msk = 0x80
	// Bit SHORTPACKETIE.
	USBHS_HSTPIPIMR_SHORTPACKETIE = 0x80
	// Position of NBUSYBKE field.
	USBHS_HSTPIPIMR_NBUSYBKE_Pos = 0xc
	// Bit mask of NBUSYBKE field.
	USBHS_HSTPIPIMR_NBUSYBKE_Msk = 0x1000
	// Bit NBUSYBKE.
	USBHS_HSTPIPIMR_NBUSYBKE = 0x1000
	// Position of FIFOCON field.
	USBHS_HSTPIPIMR_FIFOCON_Pos = 0xe
	// Bit mask of FIFOCON field.
	USBHS_HSTPIPIMR_FIFOCON_Msk = 0x4000
	// Bit FIFOCON.
	USBHS_HSTPIPIMR_FIFOCON = 0x4000
	// Position of PDISHDMA field.
	USBHS_HSTPIPIMR_PDISHDMA_Pos = 0x10
	// Bit mask of PDISHDMA field.
	USBHS_HSTPIPIMR_PDISHDMA_Msk = 0x10000
	// Bit PDISHDMA.
	USBHS_HSTPIPIMR_PDISHDMA = 0x10000
	// Position of PFREEZE field.
	USBHS_HSTPIPIMR_PFREEZE_Pos = 0x11
	// Bit mask of PFREEZE field.
	USBHS_HSTPIPIMR_PFREEZE_Msk = 0x20000
	// Bit PFREEZE.
	USBHS_HSTPIPIMR_PFREEZE = 0x20000
	// Position of RSTDT field.
	USBHS_HSTPIPIMR_RSTDT_Pos = 0x12
	// Bit mask of RSTDT field.
	USBHS_HSTPIPIMR_RSTDT_Msk = 0x40000
	// Bit RSTDT.
	USBHS_HSTPIPIMR_RSTDT = 0x40000

	// HSTPIPIER: Host Pipe Enable Register (n = 0) 0
	// Position of RXINES field.
	USBHS_HSTPIPIER_RXINES_Pos = 0x0
	// Bit mask of RXINES field.
	USBHS_HSTPIPIER_RXINES_Msk = 0x1
	// Bit RXINES.
	USBHS_HSTPIPIER_RXINES = 0x1
	// Position of TXOUTES field.
	USBHS_HSTPIPIER_TXOUTES_Pos = 0x1
	// Bit mask of TXOUTES field.
	USBHS_HSTPIPIER_TXOUTES_Msk = 0x2
	// Bit TXOUTES.
	USBHS_HSTPIPIER_TXOUTES = 0x2
	// Position of TXSTPES field.
	USBHS_HSTPIPIER_TXSTPES_Pos = 0x2
	// Bit mask of TXSTPES field.
	USBHS_HSTPIPIER_TXSTPES_Msk = 0x4
	// Bit TXSTPES.
	USBHS_HSTPIPIER_TXSTPES = 0x4
	// Position of PERRES field.
	USBHS_HSTPIPIER_PERRES_Pos = 0x3
	// Bit mask of PERRES field.
	USBHS_HSTPIPIER_PERRES_Msk = 0x8
	// Bit PERRES.
	USBHS_HSTPIPIER_PERRES = 0x8
	// Position of NAKEDES field.
	USBHS_HSTPIPIER_NAKEDES_Pos = 0x4
	// Bit mask of NAKEDES field.
	USBHS_HSTPIPIER_NAKEDES_Msk = 0x10
	// Bit NAKEDES.
	USBHS_HSTPIPIER_NAKEDES = 0x10
	// Position of OVERFIES field.
	USBHS_HSTPIPIER_OVERFIES_Pos = 0x5
	// Bit mask of OVERFIES field.
	USBHS_HSTPIPIER_OVERFIES_Msk = 0x20
	// Bit OVERFIES.
	USBHS_HSTPIPIER_OVERFIES = 0x20
	// Position of RXSTALLDES field.
	USBHS_HSTPIPIER_RXSTALLDES_Pos = 0x6
	// Bit mask of RXSTALLDES field.
	USBHS_HSTPIPIER_RXSTALLDES_Msk = 0x40
	// Bit RXSTALLDES.
	USBHS_HSTPIPIER_RXSTALLDES = 0x40
	// Position of SHORTPACKETIES field.
	USBHS_HSTPIPIER_SHORTPACKETIES_Pos = 0x7
	// Bit mask of SHORTPACKETIES field.
	USBHS_HSTPIPIER_SHORTPACKETIES_Msk = 0x80
	// Bit SHORTPACKETIES.
	USBHS_HSTPIPIER_SHORTPACKETIES = 0x80
	// Position of NBUSYBKES field.
	USBHS_HSTPIPIER_NBUSYBKES_Pos = 0xc
	// Bit mask of NBUSYBKES field.
	USBHS_HSTPIPIER_NBUSYBKES_Msk = 0x1000
	// Bit NBUSYBKES.
	USBHS_HSTPIPIER_NBUSYBKES = 0x1000
	// Position of PDISHDMAS field.
	USBHS_HSTPIPIER_PDISHDMAS_Pos = 0x10
	// Bit mask of PDISHDMAS field.
	USBHS_HSTPIPIER_PDISHDMAS_Msk = 0x10000
	// Bit PDISHDMAS.
	USBHS_HSTPIPIER_PDISHDMAS = 0x10000
	// Position of PFREEZES field.
	USBHS_HSTPIPIER_PFREEZES_Pos = 0x11
	// Bit mask of PFREEZES field.
	USBHS_HSTPIPIER_PFREEZES_Msk = 0x20000
	// Bit PFREEZES.
	USBHS_HSTPIPIER_PFREEZES = 0x20000
	// Position of RSTDTS field.
	USBHS_HSTPIPIER_RSTDTS_Pos = 0x12
	// Bit mask of RSTDTS field.
	USBHS_HSTPIPIER_RSTDTS_Msk = 0x40000
	// Bit RSTDTS.
	USBHS_HSTPIPIER_RSTDTS = 0x40000

	// HSTPIPIDR: Host Pipe Disable Register (n = 0) 0
	// Position of RXINEC field.
	USBHS_HSTPIPIDR_RXINEC_Pos = 0x0
	// Bit mask of RXINEC field.
	USBHS_HSTPIPIDR_RXINEC_Msk = 0x1
	// Bit RXINEC.
	USBHS_HSTPIPIDR_RXINEC = 0x1
	// Position of TXOUTEC field.
	USBHS_HSTPIPIDR_TXOUTEC_Pos = 0x1
	// Bit mask of TXOUTEC field.
	USBHS_HSTPIPIDR_TXOUTEC_Msk = 0x2
	// Bit TXOUTEC.
	USBHS_HSTPIPIDR_TXOUTEC = 0x2
	// Position of TXSTPEC field.
	USBHS_HSTPIPIDR_TXSTPEC_Pos = 0x2
	// Bit mask of TXSTPEC field.
	USBHS_HSTPIPIDR_TXSTPEC_Msk = 0x4
	// Bit TXSTPEC.
	USBHS_HSTPIPIDR_TXSTPEC = 0x4
	// Position of PERREC field.
	USBHS_HSTPIPIDR_PERREC_Pos = 0x3
	// Bit mask of PERREC field.
	USBHS_HSTPIPIDR_PERREC_Msk = 0x8
	// Bit PERREC.
	USBHS_HSTPIPIDR_PERREC = 0x8
	// Position of NAKEDEC field.
	USBHS_HSTPIPIDR_NAKEDEC_Pos = 0x4
	// Bit mask of NAKEDEC field.
	USBHS_HSTPIPIDR_NAKEDEC_Msk = 0x10
	// Bit NAKEDEC.
	USBHS_HSTPIPIDR_NAKEDEC = 0x10
	// Position of OVERFIEC field.
	USBHS_HSTPIPIDR_OVERFIEC_Pos = 0x5
	// Bit mask of OVERFIEC field.
	USBHS_HSTPIPIDR_OVERFIEC_Msk = 0x20
	// Bit OVERFIEC.
	USBHS_HSTPIPIDR_OVERFIEC = 0x20
	// Position of RXSTALLDEC field.
	USBHS_HSTPIPIDR_RXSTALLDEC_Pos = 0x6
	// Bit mask of RXSTALLDEC field.
	USBHS_HSTPIPIDR_RXSTALLDEC_Msk = 0x40
	// Bit RXSTALLDEC.
	USBHS_HSTPIPIDR_RXSTALLDEC = 0x40
	// Position of SHORTPACKETIEC field.
	USBHS_HSTPIPIDR_SHORTPACKETIEC_Pos = 0x7
	// Bit mask of SHORTPACKETIEC field.
	USBHS_HSTPIPIDR_SHORTPACKETIEC_Msk = 0x80
	// Bit SHORTPACKETIEC.
	USBHS_HSTPIPIDR_SHORTPACKETIEC = 0x80
	// Position of NBUSYBKEC field.
	USBHS_HSTPIPIDR_NBUSYBKEC_Pos = 0xc
	// Bit mask of NBUSYBKEC field.
	USBHS_HSTPIPIDR_NBUSYBKEC_Msk = 0x1000
	// Bit NBUSYBKEC.
	USBHS_HSTPIPIDR_NBUSYBKEC = 0x1000
	// Position of FIFOCONC field.
	USBHS_HSTPIPIDR_FIFOCONC_Pos = 0xe
	// Bit mask of FIFOCONC field.
	USBHS_HSTPIPIDR_FIFOCONC_Msk = 0x4000
	// Bit FIFOCONC.
	USBHS_HSTPIPIDR_FIFOCONC = 0x4000
	// Position of PDISHDMAC field.
	USBHS_HSTPIPIDR_PDISHDMAC_Pos = 0x10
	// Bit mask of PDISHDMAC field.
	USBHS_HSTPIPIDR_PDISHDMAC_Msk = 0x10000
	// Bit PDISHDMAC.
	USBHS_HSTPIPIDR_PDISHDMAC = 0x10000
	// Position of PFREEZEC field.
	USBHS_HSTPIPIDR_PFREEZEC_Pos = 0x11
	// Bit mask of PFREEZEC field.
	USBHS_HSTPIPIDR_PFREEZEC_Msk = 0x20000
	// Bit PFREEZEC.
	USBHS_HSTPIPIDR_PFREEZEC = 0x20000

	// HSTPIPINRQ: Host Pipe IN Request Register (n = 0) 0
	// Position of INRQ field.
	USBHS_HSTPIPINRQ_INRQ_Pos = 0x0
	// Bit mask of INRQ field.
	USBHS_HSTPIPINRQ_INRQ_Msk = 0xff
	// Position of INMODE field.
	USBHS_HSTPIPINRQ_INMODE_Pos = 0x8
	// Bit mask of INMODE field.
	USBHS_HSTPIPINRQ_INMODE_Msk = 0x100
	// Bit INMODE.
	USBHS_HSTPIPINRQ_INMODE = 0x100

	// HSTPIPERR: Host Pipe Error Register (n = 0) 0
	// Position of DATATGL field.
	USBHS_HSTPIPERR_DATATGL_Pos = 0x0
	// Bit mask of DATATGL field.
	USBHS_HSTPIPERR_DATATGL_Msk = 0x1
	// Bit DATATGL.
	USBHS_HSTPIPERR_DATATGL = 0x1
	// Position of DATAPID field.
	USBHS_HSTPIPERR_DATAPID_Pos = 0x1
	// Bit mask of DATAPID field.
	USBHS_HSTPIPERR_DATAPID_Msk = 0x2
	// Bit DATAPID.
	USBHS_HSTPIPERR_DATAPID = 0x2
	// Position of PID field.
	USBHS_HSTPIPERR_PID_Pos = 0x2
	// Bit mask of PID field.
	USBHS_HSTPIPERR_PID_Msk = 0x4
	// Bit PID.
	USBHS_HSTPIPERR_PID = 0x4
	// Position of TIMEOUT field.
	USBHS_HSTPIPERR_TIMEOUT_Pos = 0x3
	// Bit mask of TIMEOUT field.
	USBHS_HSTPIPERR_TIMEOUT_Msk = 0x8
	// Bit TIMEOUT.
	USBHS_HSTPIPERR_TIMEOUT = 0x8
	// Position of CRC16 field.
	USBHS_HSTPIPERR_CRC16_Pos = 0x4
	// Bit mask of CRC16 field.
	USBHS_HSTPIPERR_CRC16_Msk = 0x10
	// Bit CRC16.
	USBHS_HSTPIPERR_CRC16 = 0x10
	// Position of COUNTER field.
	USBHS_HSTPIPERR_COUNTER_Pos = 0x5
	// Bit mask of COUNTER field.
	USBHS_HSTPIPERR_COUNTER_Msk = 0x60

	// USBHS_HSTDMA.HSTDMANXTDSC: Host DMA Channel Next Descriptor Address Register (n = 1)
	// Position of NXT_DSC_ADD field.
	USBHS_USBHS_HSTDMA_HSTDMANXTDSC_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	USBHS_USBHS_HSTDMA_HSTDMANXTDSC_NXT_DSC_ADD_Msk = 0xffffffff

	// USBHS_HSTDMA.HSTDMAADDRESS: Host DMA Channel Address Register (n = 1)
	// Position of BUFF_ADD field.
	USBHS_USBHS_HSTDMA_HSTDMAADDRESS_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	USBHS_USBHS_HSTDMA_HSTDMAADDRESS_BUFF_ADD_Msk = 0xffffffff

	// USBHS_HSTDMA.HSTDMACONTROL: Host DMA Channel Control Register (n = 1)
	// Position of CHANN_ENB field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_EN = 0x4
	// Position of END_B_EN field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_B_EN = 0x8
	// Position of END_TR_IT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	USBHS_USBHS_HSTDMA_HSTDMACONTROL_BUFF_LENGTH_Msk = 0xffff0000

	// USBHS_HSTDMA.HSTDMASTATUS: Host DMA Channel Status Register (n = 1)
	// Position of CHANN_ENB field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	USBHS_USBHS_HSTDMA_HSTDMASTATUS_BUFF_COUNT_Msk = 0xffff0000

	// CTRL: General Control Register
	// Position of RDERRE field.
	USBHS_CTRL_RDERRE_Pos = 0x4
	// Bit mask of RDERRE field.
	USBHS_CTRL_RDERRE_Msk = 0x10
	// Bit RDERRE.
	USBHS_CTRL_RDERRE = 0x10
	// Position of VBUSHWC field.
	USBHS_CTRL_VBUSHWC_Pos = 0x8
	// Bit mask of VBUSHWC field.
	USBHS_CTRL_VBUSHWC_Msk = 0x100
	// Bit VBUSHWC.
	USBHS_CTRL_VBUSHWC = 0x100
	// Position of FRZCLK field.
	USBHS_CTRL_FRZCLK_Pos = 0xe
	// Bit mask of FRZCLK field.
	USBHS_CTRL_FRZCLK_Msk = 0x4000
	// Bit FRZCLK.
	USBHS_CTRL_FRZCLK = 0x4000
	// Position of USBE field.
	USBHS_CTRL_USBE_Pos = 0xf
	// Bit mask of USBE field.
	USBHS_CTRL_USBE_Msk = 0x8000
	// Bit USBE.
	USBHS_CTRL_USBE = 0x8000
	// Position of UIMOD field.
	USBHS_CTRL_UIMOD_Pos = 0x19
	// Bit mask of UIMOD field.
	USBHS_CTRL_UIMOD_Msk = 0x2000000
	// Bit UIMOD.
	USBHS_CTRL_UIMOD = 0x2000000
	// The module is in USB Host mode.
	USBHS_CTRL_UIMOD_HOST = 0x0
	// The module is in USB Device mode.
	USBHS_CTRL_UIMOD_DEVICE = 0x1

	// SR: General Status Register
	// Position of RDERRI field.
	USBHS_SR_RDERRI_Pos = 0x4
	// Bit mask of RDERRI field.
	USBHS_SR_RDERRI_Msk = 0x10
	// Bit RDERRI.
	USBHS_SR_RDERRI = 0x10
	// Position of SPEED field.
	USBHS_SR_SPEED_Pos = 0xc
	// Bit mask of SPEED field.
	USBHS_SR_SPEED_Msk = 0x3000
	// Full-Speed mode
	USBHS_SR_SPEED_FULL_SPEED = 0x0
	// High-Speed mode
	USBHS_SR_SPEED_HIGH_SPEED = 0x1
	// Low-Speed mode
	USBHS_SR_SPEED_LOW_SPEED = 0x2
	// Position of CLKUSABLE field.
	USBHS_SR_CLKUSABLE_Pos = 0xe
	// Bit mask of CLKUSABLE field.
	USBHS_SR_CLKUSABLE_Msk = 0x4000
	// Bit CLKUSABLE.
	USBHS_SR_CLKUSABLE = 0x4000

	// SCR: General Status Clear Register
	// Position of RDERRIC field.
	USBHS_SCR_RDERRIC_Pos = 0x4
	// Bit mask of RDERRIC field.
	USBHS_SCR_RDERRIC_Msk = 0x10
	// Bit RDERRIC.
	USBHS_SCR_RDERRIC = 0x10

	// SFR: General Status Set Register
	// Position of RDERRIS field.
	USBHS_SFR_RDERRIS_Pos = 0x4
	// Bit mask of RDERRIS field.
	USBHS_SFR_RDERRIS_Msk = 0x10
	// Bit RDERRIS.
	USBHS_SFR_RDERRIS = 0x10
	// Position of VBUSRQS field.
	USBHS_SFR_VBUSRQS_Pos = 0x9
	// Bit mask of VBUSRQS field.
	USBHS_SFR_VBUSRQS_Msk = 0x200
	// Bit VBUSRQS.
	USBHS_SFR_VBUSRQS = 0x200
)

// Constants for UTMI: USB Transmitter Interface Macrocell
const (
	// OHCIICR: OHCI Interrupt Configuration Register
	// Position of RES0 field.
	UTMI_OHCIICR_RES0_Pos = 0x0
	// Bit mask of RES0 field.
	UTMI_OHCIICR_RES0_Msk = 0x1
	// Bit RES0.
	UTMI_OHCIICR_RES0 = 0x1
	// Position of ARIE field.
	UTMI_OHCIICR_ARIE_Pos = 0x4
	// Bit mask of ARIE field.
	UTMI_OHCIICR_ARIE_Msk = 0x10
	// Bit ARIE.
	UTMI_OHCIICR_ARIE = 0x10
	// Position of APPSTART field.
	UTMI_OHCIICR_APPSTART_Pos = 0x5
	// Bit mask of APPSTART field.
	UTMI_OHCIICR_APPSTART_Msk = 0x20
	// Bit APPSTART.
	UTMI_OHCIICR_APPSTART = 0x20
	// Position of UDPPUDIS field.
	UTMI_OHCIICR_UDPPUDIS_Pos = 0x17
	// Bit mask of UDPPUDIS field.
	UTMI_OHCIICR_UDPPUDIS_Msk = 0x800000
	// Bit UDPPUDIS.
	UTMI_OHCIICR_UDPPUDIS = 0x800000

	// CKTRIM: UTMI Clock Trimming Register
	// Position of FREQ field.
	UTMI_CKTRIM_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	UTMI_CKTRIM_FREQ_Msk = 0x3
	// 12 MHz reference clock
	UTMI_CKTRIM_FREQ_XTAL12 = 0x0
	// 16 MHz reference clock
	UTMI_CKTRIM_FREQ_XTAL16 = 0x1
)

// Constants for WDT: Watchdog Timer
const (
	// CR: Control Register
	// Position of WDRSTT field.
	WDT_CR_WDRSTT_Pos = 0x0
	// Bit mask of WDRSTT field.
	WDT_CR_WDRSTT_Msk = 0x1
	// Bit WDRSTT.
	WDT_CR_WDRSTT = 0x1
	// Position of KEY field.
	WDT_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	WDT_CR_KEY_Msk = 0xff000000
	// Writing any other value in this field aborts the write operation.
	WDT_CR_KEY_PASSWD = 0xa5

	// MR: Mode Register
	// Position of WDV field.
	WDT_MR_WDV_Pos = 0x0
	// Bit mask of WDV field.
	WDT_MR_WDV_Msk = 0xfff
	// Position of WDFIEN field.
	WDT_MR_WDFIEN_Pos = 0xc
	// Bit mask of WDFIEN field.
	WDT_MR_WDFIEN_Msk = 0x1000
	// Bit WDFIEN.
	WDT_MR_WDFIEN = 0x1000
	// Position of WDRSTEN field.
	WDT_MR_WDRSTEN_Pos = 0xd
	// Bit mask of WDRSTEN field.
	WDT_MR_WDRSTEN_Msk = 0x2000
	// Bit WDRSTEN.
	WDT_MR_WDRSTEN = 0x2000
	// Position of WDDIS field.
	WDT_MR_WDDIS_Pos = 0xf
	// Bit mask of WDDIS field.
	WDT_MR_WDDIS_Msk = 0x8000
	// Bit WDDIS.
	WDT_MR_WDDIS = 0x8000
	// Position of WDD field.
	WDT_MR_WDD_Pos = 0x10
	// Bit mask of WDD field.
	WDT_MR_WDD_Msk = 0xfff0000
	// Position of WDDBGHLT field.
	WDT_MR_WDDBGHLT_Pos = 0x1c
	// Bit mask of WDDBGHLT field.
	WDT_MR_WDDBGHLT_Msk = 0x10000000
	// Bit WDDBGHLT.
	WDT_MR_WDDBGHLT = 0x10000000
	// Position of WDIDLEHLT field.
	WDT_MR_WDIDLEHLT_Pos = 0x1d
	// Bit mask of WDIDLEHLT field.
	WDT_MR_WDIDLEHLT_Msk = 0x20000000
	// Bit WDIDLEHLT.
	WDT_MR_WDIDLEHLT = 0x20000000

	// SR: Status Register
	// Position of WDUNF field.
	WDT_SR_WDUNF_Pos = 0x0
	// Bit mask of WDUNF field.
	WDT_SR_WDUNF_Msk = 0x1
	// Bit WDUNF.
	WDT_SR_WDUNF = 0x1
	// Position of WDERR field.
	WDT_SR_WDERR_Pos = 0x1
	// Bit mask of WDERR field.
	WDT_SR_WDERR_Msk = 0x2
	// Bit WDERR.
	WDT_SR_WDERR = 0x2
)

// Constants for XDMAC: Extensible DMA Controller
const (
	// GTYPE: Global Type Register
	// Position of NB_CH field.
	XDMAC_GTYPE_NB_CH_Pos = 0x0
	// Bit mask of NB_CH field.
	XDMAC_GTYPE_NB_CH_Msk = 0x1f
	// Position of FIFO_SZ field.
	XDMAC_GTYPE_FIFO_SZ_Pos = 0x5
	// Bit mask of FIFO_SZ field.
	XDMAC_GTYPE_FIFO_SZ_Msk = 0xffe0
	// Position of NB_REQ field.
	XDMAC_GTYPE_NB_REQ_Pos = 0x10
	// Bit mask of NB_REQ field.
	XDMAC_GTYPE_NB_REQ_Msk = 0x7f0000

	// GCFG: Global Configuration Register
	// Position of CGDISREG field.
	XDMAC_GCFG_CGDISREG_Pos = 0x0
	// Bit mask of CGDISREG field.
	XDMAC_GCFG_CGDISREG_Msk = 0x1
	// Bit CGDISREG.
	XDMAC_GCFG_CGDISREG = 0x1
	// Position of CGDISPIPE field.
	XDMAC_GCFG_CGDISPIPE_Pos = 0x1
	// Bit mask of CGDISPIPE field.
	XDMAC_GCFG_CGDISPIPE_Msk = 0x2
	// Bit CGDISPIPE.
	XDMAC_GCFG_CGDISPIPE = 0x2
	// Position of CGDISFIFO field.
	XDMAC_GCFG_CGDISFIFO_Pos = 0x2
	// Bit mask of CGDISFIFO field.
	XDMAC_GCFG_CGDISFIFO_Msk = 0x4
	// Bit CGDISFIFO.
	XDMAC_GCFG_CGDISFIFO = 0x4
	// Position of CGDISIF field.
	XDMAC_GCFG_CGDISIF_Pos = 0x3
	// Bit mask of CGDISIF field.
	XDMAC_GCFG_CGDISIF_Msk = 0x8
	// Bit CGDISIF.
	XDMAC_GCFG_CGDISIF = 0x8
	// Position of BXKBEN field.
	XDMAC_GCFG_BXKBEN_Pos = 0x8
	// Bit mask of BXKBEN field.
	XDMAC_GCFG_BXKBEN_Msk = 0x100
	// Bit BXKBEN.
	XDMAC_GCFG_BXKBEN = 0x100

	// GWAC: Global Weighted Arbiter Configuration Register
	// Position of PW0 field.
	XDMAC_GWAC_PW0_Pos = 0x0
	// Bit mask of PW0 field.
	XDMAC_GWAC_PW0_Msk = 0xf
	// Position of PW1 field.
	XDMAC_GWAC_PW1_Pos = 0x4
	// Bit mask of PW1 field.
	XDMAC_GWAC_PW1_Msk = 0xf0
	// Position of PW2 field.
	XDMAC_GWAC_PW2_Pos = 0x8
	// Bit mask of PW2 field.
	XDMAC_GWAC_PW2_Msk = 0xf00
	// Position of PW3 field.
	XDMAC_GWAC_PW3_Pos = 0xc
	// Bit mask of PW3 field.
	XDMAC_GWAC_PW3_Msk = 0xf000

	// GIE: Global Interrupt Enable Register
	// Position of IE0 field.
	XDMAC_GIE_IE0_Pos = 0x0
	// Bit mask of IE0 field.
	XDMAC_GIE_IE0_Msk = 0x1
	// Bit IE0.
	XDMAC_GIE_IE0 = 0x1
	// Position of IE1 field.
	XDMAC_GIE_IE1_Pos = 0x1
	// Bit mask of IE1 field.
	XDMAC_GIE_IE1_Msk = 0x2
	// Bit IE1.
	XDMAC_GIE_IE1 = 0x2
	// Position of IE2 field.
	XDMAC_GIE_IE2_Pos = 0x2
	// Bit mask of IE2 field.
	XDMAC_GIE_IE2_Msk = 0x4
	// Bit IE2.
	XDMAC_GIE_IE2 = 0x4
	// Position of IE3 field.
	XDMAC_GIE_IE3_Pos = 0x3
	// Bit mask of IE3 field.
	XDMAC_GIE_IE3_Msk = 0x8
	// Bit IE3.
	XDMAC_GIE_IE3 = 0x8
	// Position of IE4 field.
	XDMAC_GIE_IE4_Pos = 0x4
	// Bit mask of IE4 field.
	XDMAC_GIE_IE4_Msk = 0x10
	// Bit IE4.
	XDMAC_GIE_IE4 = 0x10
	// Position of IE5 field.
	XDMAC_GIE_IE5_Pos = 0x5
	// Bit mask of IE5 field.
	XDMAC_GIE_IE5_Msk = 0x20
	// Bit IE5.
	XDMAC_GIE_IE5 = 0x20
	// Position of IE6 field.
	XDMAC_GIE_IE6_Pos = 0x6
	// Bit mask of IE6 field.
	XDMAC_GIE_IE6_Msk = 0x40
	// Bit IE6.
	XDMAC_GIE_IE6 = 0x40
	// Position of IE7 field.
	XDMAC_GIE_IE7_Pos = 0x7
	// Bit mask of IE7 field.
	XDMAC_GIE_IE7_Msk = 0x80
	// Bit IE7.
	XDMAC_GIE_IE7 = 0x80
	// Position of IE8 field.
	XDMAC_GIE_IE8_Pos = 0x8
	// Bit mask of IE8 field.
	XDMAC_GIE_IE8_Msk = 0x100
	// Bit IE8.
	XDMAC_GIE_IE8 = 0x100
	// Position of IE9 field.
	XDMAC_GIE_IE9_Pos = 0x9
	// Bit mask of IE9 field.
	XDMAC_GIE_IE9_Msk = 0x200
	// Bit IE9.
	XDMAC_GIE_IE9 = 0x200
	// Position of IE10 field.
	XDMAC_GIE_IE10_Pos = 0xa
	// Bit mask of IE10 field.
	XDMAC_GIE_IE10_Msk = 0x400
	// Bit IE10.
	XDMAC_GIE_IE10 = 0x400
	// Position of IE11 field.
	XDMAC_GIE_IE11_Pos = 0xb
	// Bit mask of IE11 field.
	XDMAC_GIE_IE11_Msk = 0x800
	// Bit IE11.
	XDMAC_GIE_IE11 = 0x800
	// Position of IE12 field.
	XDMAC_GIE_IE12_Pos = 0xc
	// Bit mask of IE12 field.
	XDMAC_GIE_IE12_Msk = 0x1000
	// Bit IE12.
	XDMAC_GIE_IE12 = 0x1000
	// Position of IE13 field.
	XDMAC_GIE_IE13_Pos = 0xd
	// Bit mask of IE13 field.
	XDMAC_GIE_IE13_Msk = 0x2000
	// Bit IE13.
	XDMAC_GIE_IE13 = 0x2000
	// Position of IE14 field.
	XDMAC_GIE_IE14_Pos = 0xe
	// Bit mask of IE14 field.
	XDMAC_GIE_IE14_Msk = 0x4000
	// Bit IE14.
	XDMAC_GIE_IE14 = 0x4000
	// Position of IE15 field.
	XDMAC_GIE_IE15_Pos = 0xf
	// Bit mask of IE15 field.
	XDMAC_GIE_IE15_Msk = 0x8000
	// Bit IE15.
	XDMAC_GIE_IE15 = 0x8000
	// Position of IE16 field.
	XDMAC_GIE_IE16_Pos = 0x10
	// Bit mask of IE16 field.
	XDMAC_GIE_IE16_Msk = 0x10000
	// Bit IE16.
	XDMAC_GIE_IE16 = 0x10000
	// Position of IE17 field.
	XDMAC_GIE_IE17_Pos = 0x11
	// Bit mask of IE17 field.
	XDMAC_GIE_IE17_Msk = 0x20000
	// Bit IE17.
	XDMAC_GIE_IE17 = 0x20000
	// Position of IE18 field.
	XDMAC_GIE_IE18_Pos = 0x12
	// Bit mask of IE18 field.
	XDMAC_GIE_IE18_Msk = 0x40000
	// Bit IE18.
	XDMAC_GIE_IE18 = 0x40000
	// Position of IE19 field.
	XDMAC_GIE_IE19_Pos = 0x13
	// Bit mask of IE19 field.
	XDMAC_GIE_IE19_Msk = 0x80000
	// Bit IE19.
	XDMAC_GIE_IE19 = 0x80000
	// Position of IE20 field.
	XDMAC_GIE_IE20_Pos = 0x14
	// Bit mask of IE20 field.
	XDMAC_GIE_IE20_Msk = 0x100000
	// Bit IE20.
	XDMAC_GIE_IE20 = 0x100000
	// Position of IE21 field.
	XDMAC_GIE_IE21_Pos = 0x15
	// Bit mask of IE21 field.
	XDMAC_GIE_IE21_Msk = 0x200000
	// Bit IE21.
	XDMAC_GIE_IE21 = 0x200000
	// Position of IE22 field.
	XDMAC_GIE_IE22_Pos = 0x16
	// Bit mask of IE22 field.
	XDMAC_GIE_IE22_Msk = 0x400000
	// Bit IE22.
	XDMAC_GIE_IE22 = 0x400000
	// Position of IE23 field.
	XDMAC_GIE_IE23_Pos = 0x17
	// Bit mask of IE23 field.
	XDMAC_GIE_IE23_Msk = 0x800000
	// Bit IE23.
	XDMAC_GIE_IE23 = 0x800000

	// GID: Global Interrupt Disable Register
	// Position of ID0 field.
	XDMAC_GID_ID0_Pos = 0x0
	// Bit mask of ID0 field.
	XDMAC_GID_ID0_Msk = 0x1
	// Bit ID0.
	XDMAC_GID_ID0 = 0x1
	// Position of ID1 field.
	XDMAC_GID_ID1_Pos = 0x1
	// Bit mask of ID1 field.
	XDMAC_GID_ID1_Msk = 0x2
	// Bit ID1.
	XDMAC_GID_ID1 = 0x2
	// Position of ID2 field.
	XDMAC_GID_ID2_Pos = 0x2
	// Bit mask of ID2 field.
	XDMAC_GID_ID2_Msk = 0x4
	// Bit ID2.
	XDMAC_GID_ID2 = 0x4
	// Position of ID3 field.
	XDMAC_GID_ID3_Pos = 0x3
	// Bit mask of ID3 field.
	XDMAC_GID_ID3_Msk = 0x8
	// Bit ID3.
	XDMAC_GID_ID3 = 0x8
	// Position of ID4 field.
	XDMAC_GID_ID4_Pos = 0x4
	// Bit mask of ID4 field.
	XDMAC_GID_ID4_Msk = 0x10
	// Bit ID4.
	XDMAC_GID_ID4 = 0x10
	// Position of ID5 field.
	XDMAC_GID_ID5_Pos = 0x5
	// Bit mask of ID5 field.
	XDMAC_GID_ID5_Msk = 0x20
	// Bit ID5.
	XDMAC_GID_ID5 = 0x20
	// Position of ID6 field.
	XDMAC_GID_ID6_Pos = 0x6
	// Bit mask of ID6 field.
	XDMAC_GID_ID6_Msk = 0x40
	// Bit ID6.
	XDMAC_GID_ID6 = 0x40
	// Position of ID7 field.
	XDMAC_GID_ID7_Pos = 0x7
	// Bit mask of ID7 field.
	XDMAC_GID_ID7_Msk = 0x80
	// Bit ID7.
	XDMAC_GID_ID7 = 0x80
	// Position of ID8 field.
	XDMAC_GID_ID8_Pos = 0x8
	// Bit mask of ID8 field.
	XDMAC_GID_ID8_Msk = 0x100
	// Bit ID8.
	XDMAC_GID_ID8 = 0x100
	// Position of ID9 field.
	XDMAC_GID_ID9_Pos = 0x9
	// Bit mask of ID9 field.
	XDMAC_GID_ID9_Msk = 0x200
	// Bit ID9.
	XDMAC_GID_ID9 = 0x200
	// Position of ID10 field.
	XDMAC_GID_ID10_Pos = 0xa
	// Bit mask of ID10 field.
	XDMAC_GID_ID10_Msk = 0x400
	// Bit ID10.
	XDMAC_GID_ID10 = 0x400
	// Position of ID11 field.
	XDMAC_GID_ID11_Pos = 0xb
	// Bit mask of ID11 field.
	XDMAC_GID_ID11_Msk = 0x800
	// Bit ID11.
	XDMAC_GID_ID11 = 0x800
	// Position of ID12 field.
	XDMAC_GID_ID12_Pos = 0xc
	// Bit mask of ID12 field.
	XDMAC_GID_ID12_Msk = 0x1000
	// Bit ID12.
	XDMAC_GID_ID12 = 0x1000
	// Position of ID13 field.
	XDMAC_GID_ID13_Pos = 0xd
	// Bit mask of ID13 field.
	XDMAC_GID_ID13_Msk = 0x2000
	// Bit ID13.
	XDMAC_GID_ID13 = 0x2000
	// Position of ID14 field.
	XDMAC_GID_ID14_Pos = 0xe
	// Bit mask of ID14 field.
	XDMAC_GID_ID14_Msk = 0x4000
	// Bit ID14.
	XDMAC_GID_ID14 = 0x4000
	// Position of ID15 field.
	XDMAC_GID_ID15_Pos = 0xf
	// Bit mask of ID15 field.
	XDMAC_GID_ID15_Msk = 0x8000
	// Bit ID15.
	XDMAC_GID_ID15 = 0x8000
	// Position of ID16 field.
	XDMAC_GID_ID16_Pos = 0x10
	// Bit mask of ID16 field.
	XDMAC_GID_ID16_Msk = 0x10000
	// Bit ID16.
	XDMAC_GID_ID16 = 0x10000
	// Position of ID17 field.
	XDMAC_GID_ID17_Pos = 0x11
	// Bit mask of ID17 field.
	XDMAC_GID_ID17_Msk = 0x20000
	// Bit ID17.
	XDMAC_GID_ID17 = 0x20000
	// Position of ID18 field.
	XDMAC_GID_ID18_Pos = 0x12
	// Bit mask of ID18 field.
	XDMAC_GID_ID18_Msk = 0x40000
	// Bit ID18.
	XDMAC_GID_ID18 = 0x40000
	// Position of ID19 field.
	XDMAC_GID_ID19_Pos = 0x13
	// Bit mask of ID19 field.
	XDMAC_GID_ID19_Msk = 0x80000
	// Bit ID19.
	XDMAC_GID_ID19 = 0x80000
	// Position of ID20 field.
	XDMAC_GID_ID20_Pos = 0x14
	// Bit mask of ID20 field.
	XDMAC_GID_ID20_Msk = 0x100000
	// Bit ID20.
	XDMAC_GID_ID20 = 0x100000
	// Position of ID21 field.
	XDMAC_GID_ID21_Pos = 0x15
	// Bit mask of ID21 field.
	XDMAC_GID_ID21_Msk = 0x200000
	// Bit ID21.
	XDMAC_GID_ID21 = 0x200000
	// Position of ID22 field.
	XDMAC_GID_ID22_Pos = 0x16
	// Bit mask of ID22 field.
	XDMAC_GID_ID22_Msk = 0x400000
	// Bit ID22.
	XDMAC_GID_ID22 = 0x400000
	// Position of ID23 field.
	XDMAC_GID_ID23_Pos = 0x17
	// Bit mask of ID23 field.
	XDMAC_GID_ID23_Msk = 0x800000
	// Bit ID23.
	XDMAC_GID_ID23 = 0x800000

	// GIM: Global Interrupt Mask Register
	// Position of IM0 field.
	XDMAC_GIM_IM0_Pos = 0x0
	// Bit mask of IM0 field.
	XDMAC_GIM_IM0_Msk = 0x1
	// Bit IM0.
	XDMAC_GIM_IM0 = 0x1
	// Position of IM1 field.
	XDMAC_GIM_IM1_Pos = 0x1
	// Bit mask of IM1 field.
	XDMAC_GIM_IM1_Msk = 0x2
	// Bit IM1.
	XDMAC_GIM_IM1 = 0x2
	// Position of IM2 field.
	XDMAC_GIM_IM2_Pos = 0x2
	// Bit mask of IM2 field.
	XDMAC_GIM_IM2_Msk = 0x4
	// Bit IM2.
	XDMAC_GIM_IM2 = 0x4
	// Position of IM3 field.
	XDMAC_GIM_IM3_Pos = 0x3
	// Bit mask of IM3 field.
	XDMAC_GIM_IM3_Msk = 0x8
	// Bit IM3.
	XDMAC_GIM_IM3 = 0x8
	// Position of IM4 field.
	XDMAC_GIM_IM4_Pos = 0x4
	// Bit mask of IM4 field.
	XDMAC_GIM_IM4_Msk = 0x10
	// Bit IM4.
	XDMAC_GIM_IM4 = 0x10
	// Position of IM5 field.
	XDMAC_GIM_IM5_Pos = 0x5
	// Bit mask of IM5 field.
	XDMAC_GIM_IM5_Msk = 0x20
	// Bit IM5.
	XDMAC_GIM_IM5 = 0x20
	// Position of IM6 field.
	XDMAC_GIM_IM6_Pos = 0x6
	// Bit mask of IM6 field.
	XDMAC_GIM_IM6_Msk = 0x40
	// Bit IM6.
	XDMAC_GIM_IM6 = 0x40
	// Position of IM7 field.
	XDMAC_GIM_IM7_Pos = 0x7
	// Bit mask of IM7 field.
	XDMAC_GIM_IM7_Msk = 0x80
	// Bit IM7.
	XDMAC_GIM_IM7 = 0x80
	// Position of IM8 field.
	XDMAC_GIM_IM8_Pos = 0x8
	// Bit mask of IM8 field.
	XDMAC_GIM_IM8_Msk = 0x100
	// Bit IM8.
	XDMAC_GIM_IM8 = 0x100
	// Position of IM9 field.
	XDMAC_GIM_IM9_Pos = 0x9
	// Bit mask of IM9 field.
	XDMAC_GIM_IM9_Msk = 0x200
	// Bit IM9.
	XDMAC_GIM_IM9 = 0x200
	// Position of IM10 field.
	XDMAC_GIM_IM10_Pos = 0xa
	// Bit mask of IM10 field.
	XDMAC_GIM_IM10_Msk = 0x400
	// Bit IM10.
	XDMAC_GIM_IM10 = 0x400
	// Position of IM11 field.
	XDMAC_GIM_IM11_Pos = 0xb
	// Bit mask of IM11 field.
	XDMAC_GIM_IM11_Msk = 0x800
	// Bit IM11.
	XDMAC_GIM_IM11 = 0x800
	// Position of IM12 field.
	XDMAC_GIM_IM12_Pos = 0xc
	// Bit mask of IM12 field.
	XDMAC_GIM_IM12_Msk = 0x1000
	// Bit IM12.
	XDMAC_GIM_IM12 = 0x1000
	// Position of IM13 field.
	XDMAC_GIM_IM13_Pos = 0xd
	// Bit mask of IM13 field.
	XDMAC_GIM_IM13_Msk = 0x2000
	// Bit IM13.
	XDMAC_GIM_IM13 = 0x2000
	// Position of IM14 field.
	XDMAC_GIM_IM14_Pos = 0xe
	// Bit mask of IM14 field.
	XDMAC_GIM_IM14_Msk = 0x4000
	// Bit IM14.
	XDMAC_GIM_IM14 = 0x4000
	// Position of IM15 field.
	XDMAC_GIM_IM15_Pos = 0xf
	// Bit mask of IM15 field.
	XDMAC_GIM_IM15_Msk = 0x8000
	// Bit IM15.
	XDMAC_GIM_IM15 = 0x8000
	// Position of IM16 field.
	XDMAC_GIM_IM16_Pos = 0x10
	// Bit mask of IM16 field.
	XDMAC_GIM_IM16_Msk = 0x10000
	// Bit IM16.
	XDMAC_GIM_IM16 = 0x10000
	// Position of IM17 field.
	XDMAC_GIM_IM17_Pos = 0x11
	// Bit mask of IM17 field.
	XDMAC_GIM_IM17_Msk = 0x20000
	// Bit IM17.
	XDMAC_GIM_IM17 = 0x20000
	// Position of IM18 field.
	XDMAC_GIM_IM18_Pos = 0x12
	// Bit mask of IM18 field.
	XDMAC_GIM_IM18_Msk = 0x40000
	// Bit IM18.
	XDMAC_GIM_IM18 = 0x40000
	// Position of IM19 field.
	XDMAC_GIM_IM19_Pos = 0x13
	// Bit mask of IM19 field.
	XDMAC_GIM_IM19_Msk = 0x80000
	// Bit IM19.
	XDMAC_GIM_IM19 = 0x80000
	// Position of IM20 field.
	XDMAC_GIM_IM20_Pos = 0x14
	// Bit mask of IM20 field.
	XDMAC_GIM_IM20_Msk = 0x100000
	// Bit IM20.
	XDMAC_GIM_IM20 = 0x100000
	// Position of IM21 field.
	XDMAC_GIM_IM21_Pos = 0x15
	// Bit mask of IM21 field.
	XDMAC_GIM_IM21_Msk = 0x200000
	// Bit IM21.
	XDMAC_GIM_IM21 = 0x200000
	// Position of IM22 field.
	XDMAC_GIM_IM22_Pos = 0x16
	// Bit mask of IM22 field.
	XDMAC_GIM_IM22_Msk = 0x400000
	// Bit IM22.
	XDMAC_GIM_IM22 = 0x400000
	// Position of IM23 field.
	XDMAC_GIM_IM23_Pos = 0x17
	// Bit mask of IM23 field.
	XDMAC_GIM_IM23_Msk = 0x800000
	// Bit IM23.
	XDMAC_GIM_IM23 = 0x800000

	// GIS: Global Interrupt Status Register
	// Position of IS0 field.
	XDMAC_GIS_IS0_Pos = 0x0
	// Bit mask of IS0 field.
	XDMAC_GIS_IS0_Msk = 0x1
	// Bit IS0.
	XDMAC_GIS_IS0 = 0x1
	// Position of IS1 field.
	XDMAC_GIS_IS1_Pos = 0x1
	// Bit mask of IS1 field.
	XDMAC_GIS_IS1_Msk = 0x2
	// Bit IS1.
	XDMAC_GIS_IS1 = 0x2
	// Position of IS2 field.
	XDMAC_GIS_IS2_Pos = 0x2
	// Bit mask of IS2 field.
	XDMAC_GIS_IS2_Msk = 0x4
	// Bit IS2.
	XDMAC_GIS_IS2 = 0x4
	// Position of IS3 field.
	XDMAC_GIS_IS3_Pos = 0x3
	// Bit mask of IS3 field.
	XDMAC_GIS_IS3_Msk = 0x8
	// Bit IS3.
	XDMAC_GIS_IS3 = 0x8
	// Position of IS4 field.
	XDMAC_GIS_IS4_Pos = 0x4
	// Bit mask of IS4 field.
	XDMAC_GIS_IS4_Msk = 0x10
	// Bit IS4.
	XDMAC_GIS_IS4 = 0x10
	// Position of IS5 field.
	XDMAC_GIS_IS5_Pos = 0x5
	// Bit mask of IS5 field.
	XDMAC_GIS_IS5_Msk = 0x20
	// Bit IS5.
	XDMAC_GIS_IS5 = 0x20
	// Position of IS6 field.
	XDMAC_GIS_IS6_Pos = 0x6
	// Bit mask of IS6 field.
	XDMAC_GIS_IS6_Msk = 0x40
	// Bit IS6.
	XDMAC_GIS_IS6 = 0x40
	// Position of IS7 field.
	XDMAC_GIS_IS7_Pos = 0x7
	// Bit mask of IS7 field.
	XDMAC_GIS_IS7_Msk = 0x80
	// Bit IS7.
	XDMAC_GIS_IS7 = 0x80
	// Position of IS8 field.
	XDMAC_GIS_IS8_Pos = 0x8
	// Bit mask of IS8 field.
	XDMAC_GIS_IS8_Msk = 0x100
	// Bit IS8.
	XDMAC_GIS_IS8 = 0x100
	// Position of IS9 field.
	XDMAC_GIS_IS9_Pos = 0x9
	// Bit mask of IS9 field.
	XDMAC_GIS_IS9_Msk = 0x200
	// Bit IS9.
	XDMAC_GIS_IS9 = 0x200
	// Position of IS10 field.
	XDMAC_GIS_IS10_Pos = 0xa
	// Bit mask of IS10 field.
	XDMAC_GIS_IS10_Msk = 0x400
	// Bit IS10.
	XDMAC_GIS_IS10 = 0x400
	// Position of IS11 field.
	XDMAC_GIS_IS11_Pos = 0xb
	// Bit mask of IS11 field.
	XDMAC_GIS_IS11_Msk = 0x800
	// Bit IS11.
	XDMAC_GIS_IS11 = 0x800
	// Position of IS12 field.
	XDMAC_GIS_IS12_Pos = 0xc
	// Bit mask of IS12 field.
	XDMAC_GIS_IS12_Msk = 0x1000
	// Bit IS12.
	XDMAC_GIS_IS12 = 0x1000
	// Position of IS13 field.
	XDMAC_GIS_IS13_Pos = 0xd
	// Bit mask of IS13 field.
	XDMAC_GIS_IS13_Msk = 0x2000
	// Bit IS13.
	XDMAC_GIS_IS13 = 0x2000
	// Position of IS14 field.
	XDMAC_GIS_IS14_Pos = 0xe
	// Bit mask of IS14 field.
	XDMAC_GIS_IS14_Msk = 0x4000
	// Bit IS14.
	XDMAC_GIS_IS14 = 0x4000
	// Position of IS15 field.
	XDMAC_GIS_IS15_Pos = 0xf
	// Bit mask of IS15 field.
	XDMAC_GIS_IS15_Msk = 0x8000
	// Bit IS15.
	XDMAC_GIS_IS15 = 0x8000
	// Position of IS16 field.
	XDMAC_GIS_IS16_Pos = 0x10
	// Bit mask of IS16 field.
	XDMAC_GIS_IS16_Msk = 0x10000
	// Bit IS16.
	XDMAC_GIS_IS16 = 0x10000
	// Position of IS17 field.
	XDMAC_GIS_IS17_Pos = 0x11
	// Bit mask of IS17 field.
	XDMAC_GIS_IS17_Msk = 0x20000
	// Bit IS17.
	XDMAC_GIS_IS17 = 0x20000
	// Position of IS18 field.
	XDMAC_GIS_IS18_Pos = 0x12
	// Bit mask of IS18 field.
	XDMAC_GIS_IS18_Msk = 0x40000
	// Bit IS18.
	XDMAC_GIS_IS18 = 0x40000
	// Position of IS19 field.
	XDMAC_GIS_IS19_Pos = 0x13
	// Bit mask of IS19 field.
	XDMAC_GIS_IS19_Msk = 0x80000
	// Bit IS19.
	XDMAC_GIS_IS19 = 0x80000
	// Position of IS20 field.
	XDMAC_GIS_IS20_Pos = 0x14
	// Bit mask of IS20 field.
	XDMAC_GIS_IS20_Msk = 0x100000
	// Bit IS20.
	XDMAC_GIS_IS20 = 0x100000
	// Position of IS21 field.
	XDMAC_GIS_IS21_Pos = 0x15
	// Bit mask of IS21 field.
	XDMAC_GIS_IS21_Msk = 0x200000
	// Bit IS21.
	XDMAC_GIS_IS21 = 0x200000
	// Position of IS22 field.
	XDMAC_GIS_IS22_Pos = 0x16
	// Bit mask of IS22 field.
	XDMAC_GIS_IS22_Msk = 0x400000
	// Bit IS22.
	XDMAC_GIS_IS22 = 0x400000
	// Position of IS23 field.
	XDMAC_GIS_IS23_Pos = 0x17
	// Bit mask of IS23 field.
	XDMAC_GIS_IS23_Msk = 0x800000
	// Bit IS23.
	XDMAC_GIS_IS23 = 0x800000

	// GE: Global Channel Enable Register
	// Position of EN0 field.
	XDMAC_GE_EN0_Pos = 0x0
	// Bit mask of EN0 field.
	XDMAC_GE_EN0_Msk = 0x1
	// Bit EN0.
	XDMAC_GE_EN0 = 0x1
	// Position of EN1 field.
	XDMAC_GE_EN1_Pos = 0x1
	// Bit mask of EN1 field.
	XDMAC_GE_EN1_Msk = 0x2
	// Bit EN1.
	XDMAC_GE_EN1 = 0x2
	// Position of EN2 field.
	XDMAC_GE_EN2_Pos = 0x2
	// Bit mask of EN2 field.
	XDMAC_GE_EN2_Msk = 0x4
	// Bit EN2.
	XDMAC_GE_EN2 = 0x4
	// Position of EN3 field.
	XDMAC_GE_EN3_Pos = 0x3
	// Bit mask of EN3 field.
	XDMAC_GE_EN3_Msk = 0x8
	// Bit EN3.
	XDMAC_GE_EN3 = 0x8
	// Position of EN4 field.
	XDMAC_GE_EN4_Pos = 0x4
	// Bit mask of EN4 field.
	XDMAC_GE_EN4_Msk = 0x10
	// Bit EN4.
	XDMAC_GE_EN4 = 0x10
	// Position of EN5 field.
	XDMAC_GE_EN5_Pos = 0x5
	// Bit mask of EN5 field.
	XDMAC_GE_EN5_Msk = 0x20
	// Bit EN5.
	XDMAC_GE_EN5 = 0x20
	// Position of EN6 field.
	XDMAC_GE_EN6_Pos = 0x6
	// Bit mask of EN6 field.
	XDMAC_GE_EN6_Msk = 0x40
	// Bit EN6.
	XDMAC_GE_EN6 = 0x40
	// Position of EN7 field.
	XDMAC_GE_EN7_Pos = 0x7
	// Bit mask of EN7 field.
	XDMAC_GE_EN7_Msk = 0x80
	// Bit EN7.
	XDMAC_GE_EN7 = 0x80
	// Position of EN8 field.
	XDMAC_GE_EN8_Pos = 0x8
	// Bit mask of EN8 field.
	XDMAC_GE_EN8_Msk = 0x100
	// Bit EN8.
	XDMAC_GE_EN8 = 0x100
	// Position of EN9 field.
	XDMAC_GE_EN9_Pos = 0x9
	// Bit mask of EN9 field.
	XDMAC_GE_EN9_Msk = 0x200
	// Bit EN9.
	XDMAC_GE_EN9 = 0x200
	// Position of EN10 field.
	XDMAC_GE_EN10_Pos = 0xa
	// Bit mask of EN10 field.
	XDMAC_GE_EN10_Msk = 0x400
	// Bit EN10.
	XDMAC_GE_EN10 = 0x400
	// Position of EN11 field.
	XDMAC_GE_EN11_Pos = 0xb
	// Bit mask of EN11 field.
	XDMAC_GE_EN11_Msk = 0x800
	// Bit EN11.
	XDMAC_GE_EN11 = 0x800
	// Position of EN12 field.
	XDMAC_GE_EN12_Pos = 0xc
	// Bit mask of EN12 field.
	XDMAC_GE_EN12_Msk = 0x1000
	// Bit EN12.
	XDMAC_GE_EN12 = 0x1000
	// Position of EN13 field.
	XDMAC_GE_EN13_Pos = 0xd
	// Bit mask of EN13 field.
	XDMAC_GE_EN13_Msk = 0x2000
	// Bit EN13.
	XDMAC_GE_EN13 = 0x2000
	// Position of EN14 field.
	XDMAC_GE_EN14_Pos = 0xe
	// Bit mask of EN14 field.
	XDMAC_GE_EN14_Msk = 0x4000
	// Bit EN14.
	XDMAC_GE_EN14 = 0x4000
	// Position of EN15 field.
	XDMAC_GE_EN15_Pos = 0xf
	// Bit mask of EN15 field.
	XDMAC_GE_EN15_Msk = 0x8000
	// Bit EN15.
	XDMAC_GE_EN15 = 0x8000
	// Position of EN16 field.
	XDMAC_GE_EN16_Pos = 0x10
	// Bit mask of EN16 field.
	XDMAC_GE_EN16_Msk = 0x10000
	// Bit EN16.
	XDMAC_GE_EN16 = 0x10000
	// Position of EN17 field.
	XDMAC_GE_EN17_Pos = 0x11
	// Bit mask of EN17 field.
	XDMAC_GE_EN17_Msk = 0x20000
	// Bit EN17.
	XDMAC_GE_EN17 = 0x20000
	// Position of EN18 field.
	XDMAC_GE_EN18_Pos = 0x12
	// Bit mask of EN18 field.
	XDMAC_GE_EN18_Msk = 0x40000
	// Bit EN18.
	XDMAC_GE_EN18 = 0x40000
	// Position of EN19 field.
	XDMAC_GE_EN19_Pos = 0x13
	// Bit mask of EN19 field.
	XDMAC_GE_EN19_Msk = 0x80000
	// Bit EN19.
	XDMAC_GE_EN19 = 0x80000
	// Position of EN20 field.
	XDMAC_GE_EN20_Pos = 0x14
	// Bit mask of EN20 field.
	XDMAC_GE_EN20_Msk = 0x100000
	// Bit EN20.
	XDMAC_GE_EN20 = 0x100000
	// Position of EN21 field.
	XDMAC_GE_EN21_Pos = 0x15
	// Bit mask of EN21 field.
	XDMAC_GE_EN21_Msk = 0x200000
	// Bit EN21.
	XDMAC_GE_EN21 = 0x200000
	// Position of EN22 field.
	XDMAC_GE_EN22_Pos = 0x16
	// Bit mask of EN22 field.
	XDMAC_GE_EN22_Msk = 0x400000
	// Bit EN22.
	XDMAC_GE_EN22 = 0x400000
	// Position of EN23 field.
	XDMAC_GE_EN23_Pos = 0x17
	// Bit mask of EN23 field.
	XDMAC_GE_EN23_Msk = 0x800000
	// Bit EN23.
	XDMAC_GE_EN23 = 0x800000

	// GD: Global Channel Disable Register
	// Position of DI0 field.
	XDMAC_GD_DI0_Pos = 0x0
	// Bit mask of DI0 field.
	XDMAC_GD_DI0_Msk = 0x1
	// Bit DI0.
	XDMAC_GD_DI0 = 0x1
	// Position of DI1 field.
	XDMAC_GD_DI1_Pos = 0x1
	// Bit mask of DI1 field.
	XDMAC_GD_DI1_Msk = 0x2
	// Bit DI1.
	XDMAC_GD_DI1 = 0x2
	// Position of DI2 field.
	XDMAC_GD_DI2_Pos = 0x2
	// Bit mask of DI2 field.
	XDMAC_GD_DI2_Msk = 0x4
	// Bit DI2.
	XDMAC_GD_DI2 = 0x4
	// Position of DI3 field.
	XDMAC_GD_DI3_Pos = 0x3
	// Bit mask of DI3 field.
	XDMAC_GD_DI3_Msk = 0x8
	// Bit DI3.
	XDMAC_GD_DI3 = 0x8
	// Position of DI4 field.
	XDMAC_GD_DI4_Pos = 0x4
	// Bit mask of DI4 field.
	XDMAC_GD_DI4_Msk = 0x10
	// Bit DI4.
	XDMAC_GD_DI4 = 0x10
	// Position of DI5 field.
	XDMAC_GD_DI5_Pos = 0x5
	// Bit mask of DI5 field.
	XDMAC_GD_DI5_Msk = 0x20
	// Bit DI5.
	XDMAC_GD_DI5 = 0x20
	// Position of DI6 field.
	XDMAC_GD_DI6_Pos = 0x6
	// Bit mask of DI6 field.
	XDMAC_GD_DI6_Msk = 0x40
	// Bit DI6.
	XDMAC_GD_DI6 = 0x40
	// Position of DI7 field.
	XDMAC_GD_DI7_Pos = 0x7
	// Bit mask of DI7 field.
	XDMAC_GD_DI7_Msk = 0x80
	// Bit DI7.
	XDMAC_GD_DI7 = 0x80
	// Position of DI8 field.
	XDMAC_GD_DI8_Pos = 0x8
	// Bit mask of DI8 field.
	XDMAC_GD_DI8_Msk = 0x100
	// Bit DI8.
	XDMAC_GD_DI8 = 0x100
	// Position of DI9 field.
	XDMAC_GD_DI9_Pos = 0x9
	// Bit mask of DI9 field.
	XDMAC_GD_DI9_Msk = 0x200
	// Bit DI9.
	XDMAC_GD_DI9 = 0x200
	// Position of DI10 field.
	XDMAC_GD_DI10_Pos = 0xa
	// Bit mask of DI10 field.
	XDMAC_GD_DI10_Msk = 0x400
	// Bit DI10.
	XDMAC_GD_DI10 = 0x400
	// Position of DI11 field.
	XDMAC_GD_DI11_Pos = 0xb
	// Bit mask of DI11 field.
	XDMAC_GD_DI11_Msk = 0x800
	// Bit DI11.
	XDMAC_GD_DI11 = 0x800
	// Position of DI12 field.
	XDMAC_GD_DI12_Pos = 0xc
	// Bit mask of DI12 field.
	XDMAC_GD_DI12_Msk = 0x1000
	// Bit DI12.
	XDMAC_GD_DI12 = 0x1000
	// Position of DI13 field.
	XDMAC_GD_DI13_Pos = 0xd
	// Bit mask of DI13 field.
	XDMAC_GD_DI13_Msk = 0x2000
	// Bit DI13.
	XDMAC_GD_DI13 = 0x2000
	// Position of DI14 field.
	XDMAC_GD_DI14_Pos = 0xe
	// Bit mask of DI14 field.
	XDMAC_GD_DI14_Msk = 0x4000
	// Bit DI14.
	XDMAC_GD_DI14 = 0x4000
	// Position of DI15 field.
	XDMAC_GD_DI15_Pos = 0xf
	// Bit mask of DI15 field.
	XDMAC_GD_DI15_Msk = 0x8000
	// Bit DI15.
	XDMAC_GD_DI15 = 0x8000
	// Position of DI16 field.
	XDMAC_GD_DI16_Pos = 0x10
	// Bit mask of DI16 field.
	XDMAC_GD_DI16_Msk = 0x10000
	// Bit DI16.
	XDMAC_GD_DI16 = 0x10000
	// Position of DI17 field.
	XDMAC_GD_DI17_Pos = 0x11
	// Bit mask of DI17 field.
	XDMAC_GD_DI17_Msk = 0x20000
	// Bit DI17.
	XDMAC_GD_DI17 = 0x20000
	// Position of DI18 field.
	XDMAC_GD_DI18_Pos = 0x12
	// Bit mask of DI18 field.
	XDMAC_GD_DI18_Msk = 0x40000
	// Bit DI18.
	XDMAC_GD_DI18 = 0x40000
	// Position of DI19 field.
	XDMAC_GD_DI19_Pos = 0x13
	// Bit mask of DI19 field.
	XDMAC_GD_DI19_Msk = 0x80000
	// Bit DI19.
	XDMAC_GD_DI19 = 0x80000
	// Position of DI20 field.
	XDMAC_GD_DI20_Pos = 0x14
	// Bit mask of DI20 field.
	XDMAC_GD_DI20_Msk = 0x100000
	// Bit DI20.
	XDMAC_GD_DI20 = 0x100000
	// Position of DI21 field.
	XDMAC_GD_DI21_Pos = 0x15
	// Bit mask of DI21 field.
	XDMAC_GD_DI21_Msk = 0x200000
	// Bit DI21.
	XDMAC_GD_DI21 = 0x200000
	// Position of DI22 field.
	XDMAC_GD_DI22_Pos = 0x16
	// Bit mask of DI22 field.
	XDMAC_GD_DI22_Msk = 0x400000
	// Bit DI22.
	XDMAC_GD_DI22 = 0x400000
	// Position of DI23 field.
	XDMAC_GD_DI23_Pos = 0x17
	// Bit mask of DI23 field.
	XDMAC_GD_DI23_Msk = 0x800000
	// Bit DI23.
	XDMAC_GD_DI23 = 0x800000

	// GS: Global Channel Status Register
	// Position of ST0 field.
	XDMAC_GS_ST0_Pos = 0x0
	// Bit mask of ST0 field.
	XDMAC_GS_ST0_Msk = 0x1
	// Bit ST0.
	XDMAC_GS_ST0 = 0x1
	// Position of ST1 field.
	XDMAC_GS_ST1_Pos = 0x1
	// Bit mask of ST1 field.
	XDMAC_GS_ST1_Msk = 0x2
	// Bit ST1.
	XDMAC_GS_ST1 = 0x2
	// Position of ST2 field.
	XDMAC_GS_ST2_Pos = 0x2
	// Bit mask of ST2 field.
	XDMAC_GS_ST2_Msk = 0x4
	// Bit ST2.
	XDMAC_GS_ST2 = 0x4
	// Position of ST3 field.
	XDMAC_GS_ST3_Pos = 0x3
	// Bit mask of ST3 field.
	XDMAC_GS_ST3_Msk = 0x8
	// Bit ST3.
	XDMAC_GS_ST3 = 0x8
	// Position of ST4 field.
	XDMAC_GS_ST4_Pos = 0x4
	// Bit mask of ST4 field.
	XDMAC_GS_ST4_Msk = 0x10
	// Bit ST4.
	XDMAC_GS_ST4 = 0x10
	// Position of ST5 field.
	XDMAC_GS_ST5_Pos = 0x5
	// Bit mask of ST5 field.
	XDMAC_GS_ST5_Msk = 0x20
	// Bit ST5.
	XDMAC_GS_ST5 = 0x20
	// Position of ST6 field.
	XDMAC_GS_ST6_Pos = 0x6
	// Bit mask of ST6 field.
	XDMAC_GS_ST6_Msk = 0x40
	// Bit ST6.
	XDMAC_GS_ST6 = 0x40
	// Position of ST7 field.
	XDMAC_GS_ST7_Pos = 0x7
	// Bit mask of ST7 field.
	XDMAC_GS_ST7_Msk = 0x80
	// Bit ST7.
	XDMAC_GS_ST7 = 0x80
	// Position of ST8 field.
	XDMAC_GS_ST8_Pos = 0x8
	// Bit mask of ST8 field.
	XDMAC_GS_ST8_Msk = 0x100
	// Bit ST8.
	XDMAC_GS_ST8 = 0x100
	// Position of ST9 field.
	XDMAC_GS_ST9_Pos = 0x9
	// Bit mask of ST9 field.
	XDMAC_GS_ST9_Msk = 0x200
	// Bit ST9.
	XDMAC_GS_ST9 = 0x200
	// Position of ST10 field.
	XDMAC_GS_ST10_Pos = 0xa
	// Bit mask of ST10 field.
	XDMAC_GS_ST10_Msk = 0x400
	// Bit ST10.
	XDMAC_GS_ST10 = 0x400
	// Position of ST11 field.
	XDMAC_GS_ST11_Pos = 0xb
	// Bit mask of ST11 field.
	XDMAC_GS_ST11_Msk = 0x800
	// Bit ST11.
	XDMAC_GS_ST11 = 0x800
	// Position of ST12 field.
	XDMAC_GS_ST12_Pos = 0xc
	// Bit mask of ST12 field.
	XDMAC_GS_ST12_Msk = 0x1000
	// Bit ST12.
	XDMAC_GS_ST12 = 0x1000
	// Position of ST13 field.
	XDMAC_GS_ST13_Pos = 0xd
	// Bit mask of ST13 field.
	XDMAC_GS_ST13_Msk = 0x2000
	// Bit ST13.
	XDMAC_GS_ST13 = 0x2000
	// Position of ST14 field.
	XDMAC_GS_ST14_Pos = 0xe
	// Bit mask of ST14 field.
	XDMAC_GS_ST14_Msk = 0x4000
	// Bit ST14.
	XDMAC_GS_ST14 = 0x4000
	// Position of ST15 field.
	XDMAC_GS_ST15_Pos = 0xf
	// Bit mask of ST15 field.
	XDMAC_GS_ST15_Msk = 0x8000
	// Bit ST15.
	XDMAC_GS_ST15 = 0x8000
	// Position of ST16 field.
	XDMAC_GS_ST16_Pos = 0x10
	// Bit mask of ST16 field.
	XDMAC_GS_ST16_Msk = 0x10000
	// Bit ST16.
	XDMAC_GS_ST16 = 0x10000
	// Position of ST17 field.
	XDMAC_GS_ST17_Pos = 0x11
	// Bit mask of ST17 field.
	XDMAC_GS_ST17_Msk = 0x20000
	// Bit ST17.
	XDMAC_GS_ST17 = 0x20000
	// Position of ST18 field.
	XDMAC_GS_ST18_Pos = 0x12
	// Bit mask of ST18 field.
	XDMAC_GS_ST18_Msk = 0x40000
	// Bit ST18.
	XDMAC_GS_ST18 = 0x40000
	// Position of ST19 field.
	XDMAC_GS_ST19_Pos = 0x13
	// Bit mask of ST19 field.
	XDMAC_GS_ST19_Msk = 0x80000
	// Bit ST19.
	XDMAC_GS_ST19 = 0x80000
	// Position of ST20 field.
	XDMAC_GS_ST20_Pos = 0x14
	// Bit mask of ST20 field.
	XDMAC_GS_ST20_Msk = 0x100000
	// Bit ST20.
	XDMAC_GS_ST20 = 0x100000
	// Position of ST21 field.
	XDMAC_GS_ST21_Pos = 0x15
	// Bit mask of ST21 field.
	XDMAC_GS_ST21_Msk = 0x200000
	// Bit ST21.
	XDMAC_GS_ST21 = 0x200000
	// Position of ST22 field.
	XDMAC_GS_ST22_Pos = 0x16
	// Bit mask of ST22 field.
	XDMAC_GS_ST22_Msk = 0x400000
	// Bit ST22.
	XDMAC_GS_ST22 = 0x400000
	// Position of ST23 field.
	XDMAC_GS_ST23_Pos = 0x17
	// Bit mask of ST23 field.
	XDMAC_GS_ST23_Msk = 0x800000
	// Bit ST23.
	XDMAC_GS_ST23 = 0x800000

	// GRS: Global Channel Read Suspend Register
	// Position of RS0 field.
	XDMAC_GRS_RS0_Pos = 0x0
	// Bit mask of RS0 field.
	XDMAC_GRS_RS0_Msk = 0x1
	// Bit RS0.
	XDMAC_GRS_RS0 = 0x1
	// Position of RS1 field.
	XDMAC_GRS_RS1_Pos = 0x1
	// Bit mask of RS1 field.
	XDMAC_GRS_RS1_Msk = 0x2
	// Bit RS1.
	XDMAC_GRS_RS1 = 0x2
	// Position of RS2 field.
	XDMAC_GRS_RS2_Pos = 0x2
	// Bit mask of RS2 field.
	XDMAC_GRS_RS2_Msk = 0x4
	// Bit RS2.
	XDMAC_GRS_RS2 = 0x4
	// Position of RS3 field.
	XDMAC_GRS_RS3_Pos = 0x3
	// Bit mask of RS3 field.
	XDMAC_GRS_RS3_Msk = 0x8
	// Bit RS3.
	XDMAC_GRS_RS3 = 0x8
	// Position of RS4 field.
	XDMAC_GRS_RS4_Pos = 0x4
	// Bit mask of RS4 field.
	XDMAC_GRS_RS4_Msk = 0x10
	// Bit RS4.
	XDMAC_GRS_RS4 = 0x10
	// Position of RS5 field.
	XDMAC_GRS_RS5_Pos = 0x5
	// Bit mask of RS5 field.
	XDMAC_GRS_RS5_Msk = 0x20
	// Bit RS5.
	XDMAC_GRS_RS5 = 0x20
	// Position of RS6 field.
	XDMAC_GRS_RS6_Pos = 0x6
	// Bit mask of RS6 field.
	XDMAC_GRS_RS6_Msk = 0x40
	// Bit RS6.
	XDMAC_GRS_RS6 = 0x40
	// Position of RS7 field.
	XDMAC_GRS_RS7_Pos = 0x7
	// Bit mask of RS7 field.
	XDMAC_GRS_RS7_Msk = 0x80
	// Bit RS7.
	XDMAC_GRS_RS7 = 0x80
	// Position of RS8 field.
	XDMAC_GRS_RS8_Pos = 0x8
	// Bit mask of RS8 field.
	XDMAC_GRS_RS8_Msk = 0x100
	// Bit RS8.
	XDMAC_GRS_RS8 = 0x100
	// Position of RS9 field.
	XDMAC_GRS_RS9_Pos = 0x9
	// Bit mask of RS9 field.
	XDMAC_GRS_RS9_Msk = 0x200
	// Bit RS9.
	XDMAC_GRS_RS9 = 0x200
	// Position of RS10 field.
	XDMAC_GRS_RS10_Pos = 0xa
	// Bit mask of RS10 field.
	XDMAC_GRS_RS10_Msk = 0x400
	// Bit RS10.
	XDMAC_GRS_RS10 = 0x400
	// Position of RS11 field.
	XDMAC_GRS_RS11_Pos = 0xb
	// Bit mask of RS11 field.
	XDMAC_GRS_RS11_Msk = 0x800
	// Bit RS11.
	XDMAC_GRS_RS11 = 0x800
	// Position of RS12 field.
	XDMAC_GRS_RS12_Pos = 0xc
	// Bit mask of RS12 field.
	XDMAC_GRS_RS12_Msk = 0x1000
	// Bit RS12.
	XDMAC_GRS_RS12 = 0x1000
	// Position of RS13 field.
	XDMAC_GRS_RS13_Pos = 0xd
	// Bit mask of RS13 field.
	XDMAC_GRS_RS13_Msk = 0x2000
	// Bit RS13.
	XDMAC_GRS_RS13 = 0x2000
	// Position of RS14 field.
	XDMAC_GRS_RS14_Pos = 0xe
	// Bit mask of RS14 field.
	XDMAC_GRS_RS14_Msk = 0x4000
	// Bit RS14.
	XDMAC_GRS_RS14 = 0x4000
	// Position of RS15 field.
	XDMAC_GRS_RS15_Pos = 0xf
	// Bit mask of RS15 field.
	XDMAC_GRS_RS15_Msk = 0x8000
	// Bit RS15.
	XDMAC_GRS_RS15 = 0x8000
	// Position of RS16 field.
	XDMAC_GRS_RS16_Pos = 0x10
	// Bit mask of RS16 field.
	XDMAC_GRS_RS16_Msk = 0x10000
	// Bit RS16.
	XDMAC_GRS_RS16 = 0x10000
	// Position of RS17 field.
	XDMAC_GRS_RS17_Pos = 0x11
	// Bit mask of RS17 field.
	XDMAC_GRS_RS17_Msk = 0x20000
	// Bit RS17.
	XDMAC_GRS_RS17 = 0x20000
	// Position of RS18 field.
	XDMAC_GRS_RS18_Pos = 0x12
	// Bit mask of RS18 field.
	XDMAC_GRS_RS18_Msk = 0x40000
	// Bit RS18.
	XDMAC_GRS_RS18 = 0x40000
	// Position of RS19 field.
	XDMAC_GRS_RS19_Pos = 0x13
	// Bit mask of RS19 field.
	XDMAC_GRS_RS19_Msk = 0x80000
	// Bit RS19.
	XDMAC_GRS_RS19 = 0x80000
	// Position of RS20 field.
	XDMAC_GRS_RS20_Pos = 0x14
	// Bit mask of RS20 field.
	XDMAC_GRS_RS20_Msk = 0x100000
	// Bit RS20.
	XDMAC_GRS_RS20 = 0x100000
	// Position of RS21 field.
	XDMAC_GRS_RS21_Pos = 0x15
	// Bit mask of RS21 field.
	XDMAC_GRS_RS21_Msk = 0x200000
	// Bit RS21.
	XDMAC_GRS_RS21 = 0x200000
	// Position of RS22 field.
	XDMAC_GRS_RS22_Pos = 0x16
	// Bit mask of RS22 field.
	XDMAC_GRS_RS22_Msk = 0x400000
	// Bit RS22.
	XDMAC_GRS_RS22 = 0x400000
	// Position of RS23 field.
	XDMAC_GRS_RS23_Pos = 0x17
	// Bit mask of RS23 field.
	XDMAC_GRS_RS23_Msk = 0x800000
	// Bit RS23.
	XDMAC_GRS_RS23 = 0x800000

	// GWS: Global Channel Write Suspend Register
	// Position of WS0 field.
	XDMAC_GWS_WS0_Pos = 0x0
	// Bit mask of WS0 field.
	XDMAC_GWS_WS0_Msk = 0x1
	// Bit WS0.
	XDMAC_GWS_WS0 = 0x1
	// Position of WS1 field.
	XDMAC_GWS_WS1_Pos = 0x1
	// Bit mask of WS1 field.
	XDMAC_GWS_WS1_Msk = 0x2
	// Bit WS1.
	XDMAC_GWS_WS1 = 0x2
	// Position of WS2 field.
	XDMAC_GWS_WS2_Pos = 0x2
	// Bit mask of WS2 field.
	XDMAC_GWS_WS2_Msk = 0x4
	// Bit WS2.
	XDMAC_GWS_WS2 = 0x4
	// Position of WS3 field.
	XDMAC_GWS_WS3_Pos = 0x3
	// Bit mask of WS3 field.
	XDMAC_GWS_WS3_Msk = 0x8
	// Bit WS3.
	XDMAC_GWS_WS3 = 0x8
	// Position of WS4 field.
	XDMAC_GWS_WS4_Pos = 0x4
	// Bit mask of WS4 field.
	XDMAC_GWS_WS4_Msk = 0x10
	// Bit WS4.
	XDMAC_GWS_WS4 = 0x10
	// Position of WS5 field.
	XDMAC_GWS_WS5_Pos = 0x5
	// Bit mask of WS5 field.
	XDMAC_GWS_WS5_Msk = 0x20
	// Bit WS5.
	XDMAC_GWS_WS5 = 0x20
	// Position of WS6 field.
	XDMAC_GWS_WS6_Pos = 0x6
	// Bit mask of WS6 field.
	XDMAC_GWS_WS6_Msk = 0x40
	// Bit WS6.
	XDMAC_GWS_WS6 = 0x40
	// Position of WS7 field.
	XDMAC_GWS_WS7_Pos = 0x7
	// Bit mask of WS7 field.
	XDMAC_GWS_WS7_Msk = 0x80
	// Bit WS7.
	XDMAC_GWS_WS7 = 0x80
	// Position of WS8 field.
	XDMAC_GWS_WS8_Pos = 0x8
	// Bit mask of WS8 field.
	XDMAC_GWS_WS8_Msk = 0x100
	// Bit WS8.
	XDMAC_GWS_WS8 = 0x100
	// Position of WS9 field.
	XDMAC_GWS_WS9_Pos = 0x9
	// Bit mask of WS9 field.
	XDMAC_GWS_WS9_Msk = 0x200
	// Bit WS9.
	XDMAC_GWS_WS9 = 0x200
	// Position of WS10 field.
	XDMAC_GWS_WS10_Pos = 0xa
	// Bit mask of WS10 field.
	XDMAC_GWS_WS10_Msk = 0x400
	// Bit WS10.
	XDMAC_GWS_WS10 = 0x400
	// Position of WS11 field.
	XDMAC_GWS_WS11_Pos = 0xb
	// Bit mask of WS11 field.
	XDMAC_GWS_WS11_Msk = 0x800
	// Bit WS11.
	XDMAC_GWS_WS11 = 0x800
	// Position of WS12 field.
	XDMAC_GWS_WS12_Pos = 0xc
	// Bit mask of WS12 field.
	XDMAC_GWS_WS12_Msk = 0x1000
	// Bit WS12.
	XDMAC_GWS_WS12 = 0x1000
	// Position of WS13 field.
	XDMAC_GWS_WS13_Pos = 0xd
	// Bit mask of WS13 field.
	XDMAC_GWS_WS13_Msk = 0x2000
	// Bit WS13.
	XDMAC_GWS_WS13 = 0x2000
	// Position of WS14 field.
	XDMAC_GWS_WS14_Pos = 0xe
	// Bit mask of WS14 field.
	XDMAC_GWS_WS14_Msk = 0x4000
	// Bit WS14.
	XDMAC_GWS_WS14 = 0x4000
	// Position of WS15 field.
	XDMAC_GWS_WS15_Pos = 0xf
	// Bit mask of WS15 field.
	XDMAC_GWS_WS15_Msk = 0x8000
	// Bit WS15.
	XDMAC_GWS_WS15 = 0x8000
	// Position of WS16 field.
	XDMAC_GWS_WS16_Pos = 0x10
	// Bit mask of WS16 field.
	XDMAC_GWS_WS16_Msk = 0x10000
	// Bit WS16.
	XDMAC_GWS_WS16 = 0x10000
	// Position of WS17 field.
	XDMAC_GWS_WS17_Pos = 0x11
	// Bit mask of WS17 field.
	XDMAC_GWS_WS17_Msk = 0x20000
	// Bit WS17.
	XDMAC_GWS_WS17 = 0x20000
	// Position of WS18 field.
	XDMAC_GWS_WS18_Pos = 0x12
	// Bit mask of WS18 field.
	XDMAC_GWS_WS18_Msk = 0x40000
	// Bit WS18.
	XDMAC_GWS_WS18 = 0x40000
	// Position of WS19 field.
	XDMAC_GWS_WS19_Pos = 0x13
	// Bit mask of WS19 field.
	XDMAC_GWS_WS19_Msk = 0x80000
	// Bit WS19.
	XDMAC_GWS_WS19 = 0x80000
	// Position of WS20 field.
	XDMAC_GWS_WS20_Pos = 0x14
	// Bit mask of WS20 field.
	XDMAC_GWS_WS20_Msk = 0x100000
	// Bit WS20.
	XDMAC_GWS_WS20 = 0x100000
	// Position of WS21 field.
	XDMAC_GWS_WS21_Pos = 0x15
	// Bit mask of WS21 field.
	XDMAC_GWS_WS21_Msk = 0x200000
	// Bit WS21.
	XDMAC_GWS_WS21 = 0x200000
	// Position of WS22 field.
	XDMAC_GWS_WS22_Pos = 0x16
	// Bit mask of WS22 field.
	XDMAC_GWS_WS22_Msk = 0x400000
	// Bit WS22.
	XDMAC_GWS_WS22 = 0x400000
	// Position of WS23 field.
	XDMAC_GWS_WS23_Pos = 0x17
	// Bit mask of WS23 field.
	XDMAC_GWS_WS23_Msk = 0x800000
	// Bit WS23.
	XDMAC_GWS_WS23 = 0x800000

	// GRWS: Global Channel Read Write Suspend Register
	// Position of RWS0 field.
	XDMAC_GRWS_RWS0_Pos = 0x0
	// Bit mask of RWS0 field.
	XDMAC_GRWS_RWS0_Msk = 0x1
	// Bit RWS0.
	XDMAC_GRWS_RWS0 = 0x1
	// Position of RWS1 field.
	XDMAC_GRWS_RWS1_Pos = 0x1
	// Bit mask of RWS1 field.
	XDMAC_GRWS_RWS1_Msk = 0x2
	// Bit RWS1.
	XDMAC_GRWS_RWS1 = 0x2
	// Position of RWS2 field.
	XDMAC_GRWS_RWS2_Pos = 0x2
	// Bit mask of RWS2 field.
	XDMAC_GRWS_RWS2_Msk = 0x4
	// Bit RWS2.
	XDMAC_GRWS_RWS2 = 0x4
	// Position of RWS3 field.
	XDMAC_GRWS_RWS3_Pos = 0x3
	// Bit mask of RWS3 field.
	XDMAC_GRWS_RWS3_Msk = 0x8
	// Bit RWS3.
	XDMAC_GRWS_RWS3 = 0x8
	// Position of RWS4 field.
	XDMAC_GRWS_RWS4_Pos = 0x4
	// Bit mask of RWS4 field.
	XDMAC_GRWS_RWS4_Msk = 0x10
	// Bit RWS4.
	XDMAC_GRWS_RWS4 = 0x10
	// Position of RWS5 field.
	XDMAC_GRWS_RWS5_Pos = 0x5
	// Bit mask of RWS5 field.
	XDMAC_GRWS_RWS5_Msk = 0x20
	// Bit RWS5.
	XDMAC_GRWS_RWS5 = 0x20
	// Position of RWS6 field.
	XDMAC_GRWS_RWS6_Pos = 0x6
	// Bit mask of RWS6 field.
	XDMAC_GRWS_RWS6_Msk = 0x40
	// Bit RWS6.
	XDMAC_GRWS_RWS6 = 0x40
	// Position of RWS7 field.
	XDMAC_GRWS_RWS7_Pos = 0x7
	// Bit mask of RWS7 field.
	XDMAC_GRWS_RWS7_Msk = 0x80
	// Bit RWS7.
	XDMAC_GRWS_RWS7 = 0x80
	// Position of RWS8 field.
	XDMAC_GRWS_RWS8_Pos = 0x8
	// Bit mask of RWS8 field.
	XDMAC_GRWS_RWS8_Msk = 0x100
	// Bit RWS8.
	XDMAC_GRWS_RWS8 = 0x100
	// Position of RWS9 field.
	XDMAC_GRWS_RWS9_Pos = 0x9
	// Bit mask of RWS9 field.
	XDMAC_GRWS_RWS9_Msk = 0x200
	// Bit RWS9.
	XDMAC_GRWS_RWS9 = 0x200
	// Position of RWS10 field.
	XDMAC_GRWS_RWS10_Pos = 0xa
	// Bit mask of RWS10 field.
	XDMAC_GRWS_RWS10_Msk = 0x400
	// Bit RWS10.
	XDMAC_GRWS_RWS10 = 0x400
	// Position of RWS11 field.
	XDMAC_GRWS_RWS11_Pos = 0xb
	// Bit mask of RWS11 field.
	XDMAC_GRWS_RWS11_Msk = 0x800
	// Bit RWS11.
	XDMAC_GRWS_RWS11 = 0x800
	// Position of RWS12 field.
	XDMAC_GRWS_RWS12_Pos = 0xc
	// Bit mask of RWS12 field.
	XDMAC_GRWS_RWS12_Msk = 0x1000
	// Bit RWS12.
	XDMAC_GRWS_RWS12 = 0x1000
	// Position of RWS13 field.
	XDMAC_GRWS_RWS13_Pos = 0xd
	// Bit mask of RWS13 field.
	XDMAC_GRWS_RWS13_Msk = 0x2000
	// Bit RWS13.
	XDMAC_GRWS_RWS13 = 0x2000
	// Position of RWS14 field.
	XDMAC_GRWS_RWS14_Pos = 0xe
	// Bit mask of RWS14 field.
	XDMAC_GRWS_RWS14_Msk = 0x4000
	// Bit RWS14.
	XDMAC_GRWS_RWS14 = 0x4000
	// Position of RWS15 field.
	XDMAC_GRWS_RWS15_Pos = 0xf
	// Bit mask of RWS15 field.
	XDMAC_GRWS_RWS15_Msk = 0x8000
	// Bit RWS15.
	XDMAC_GRWS_RWS15 = 0x8000
	// Position of RWS16 field.
	XDMAC_GRWS_RWS16_Pos = 0x10
	// Bit mask of RWS16 field.
	XDMAC_GRWS_RWS16_Msk = 0x10000
	// Bit RWS16.
	XDMAC_GRWS_RWS16 = 0x10000
	// Position of RWS17 field.
	XDMAC_GRWS_RWS17_Pos = 0x11
	// Bit mask of RWS17 field.
	XDMAC_GRWS_RWS17_Msk = 0x20000
	// Bit RWS17.
	XDMAC_GRWS_RWS17 = 0x20000
	// Position of RWS18 field.
	XDMAC_GRWS_RWS18_Pos = 0x12
	// Bit mask of RWS18 field.
	XDMAC_GRWS_RWS18_Msk = 0x40000
	// Bit RWS18.
	XDMAC_GRWS_RWS18 = 0x40000
	// Position of RWS19 field.
	XDMAC_GRWS_RWS19_Pos = 0x13
	// Bit mask of RWS19 field.
	XDMAC_GRWS_RWS19_Msk = 0x80000
	// Bit RWS19.
	XDMAC_GRWS_RWS19 = 0x80000
	// Position of RWS20 field.
	XDMAC_GRWS_RWS20_Pos = 0x14
	// Bit mask of RWS20 field.
	XDMAC_GRWS_RWS20_Msk = 0x100000
	// Bit RWS20.
	XDMAC_GRWS_RWS20 = 0x100000
	// Position of RWS21 field.
	XDMAC_GRWS_RWS21_Pos = 0x15
	// Bit mask of RWS21 field.
	XDMAC_GRWS_RWS21_Msk = 0x200000
	// Bit RWS21.
	XDMAC_GRWS_RWS21 = 0x200000
	// Position of RWS22 field.
	XDMAC_GRWS_RWS22_Pos = 0x16
	// Bit mask of RWS22 field.
	XDMAC_GRWS_RWS22_Msk = 0x400000
	// Bit RWS22.
	XDMAC_GRWS_RWS22 = 0x400000
	// Position of RWS23 field.
	XDMAC_GRWS_RWS23_Pos = 0x17
	// Bit mask of RWS23 field.
	XDMAC_GRWS_RWS23_Msk = 0x800000
	// Bit RWS23.
	XDMAC_GRWS_RWS23 = 0x800000

	// GRWR: Global Channel Read Write Resume Register
	// Position of RWR0 field.
	XDMAC_GRWR_RWR0_Pos = 0x0
	// Bit mask of RWR0 field.
	XDMAC_GRWR_RWR0_Msk = 0x1
	// Bit RWR0.
	XDMAC_GRWR_RWR0 = 0x1
	// Position of RWR1 field.
	XDMAC_GRWR_RWR1_Pos = 0x1
	// Bit mask of RWR1 field.
	XDMAC_GRWR_RWR1_Msk = 0x2
	// Bit RWR1.
	XDMAC_GRWR_RWR1 = 0x2
	// Position of RWR2 field.
	XDMAC_GRWR_RWR2_Pos = 0x2
	// Bit mask of RWR2 field.
	XDMAC_GRWR_RWR2_Msk = 0x4
	// Bit RWR2.
	XDMAC_GRWR_RWR2 = 0x4
	// Position of RWR3 field.
	XDMAC_GRWR_RWR3_Pos = 0x3
	// Bit mask of RWR3 field.
	XDMAC_GRWR_RWR3_Msk = 0x8
	// Bit RWR3.
	XDMAC_GRWR_RWR3 = 0x8
	// Position of RWR4 field.
	XDMAC_GRWR_RWR4_Pos = 0x4
	// Bit mask of RWR4 field.
	XDMAC_GRWR_RWR4_Msk = 0x10
	// Bit RWR4.
	XDMAC_GRWR_RWR4 = 0x10
	// Position of RWR5 field.
	XDMAC_GRWR_RWR5_Pos = 0x5
	// Bit mask of RWR5 field.
	XDMAC_GRWR_RWR5_Msk = 0x20
	// Bit RWR5.
	XDMAC_GRWR_RWR5 = 0x20
	// Position of RWR6 field.
	XDMAC_GRWR_RWR6_Pos = 0x6
	// Bit mask of RWR6 field.
	XDMAC_GRWR_RWR6_Msk = 0x40
	// Bit RWR6.
	XDMAC_GRWR_RWR6 = 0x40
	// Position of RWR7 field.
	XDMAC_GRWR_RWR7_Pos = 0x7
	// Bit mask of RWR7 field.
	XDMAC_GRWR_RWR7_Msk = 0x80
	// Bit RWR7.
	XDMAC_GRWR_RWR7 = 0x80
	// Position of RWR8 field.
	XDMAC_GRWR_RWR8_Pos = 0x8
	// Bit mask of RWR8 field.
	XDMAC_GRWR_RWR8_Msk = 0x100
	// Bit RWR8.
	XDMAC_GRWR_RWR8 = 0x100
	// Position of RWR9 field.
	XDMAC_GRWR_RWR9_Pos = 0x9
	// Bit mask of RWR9 field.
	XDMAC_GRWR_RWR9_Msk = 0x200
	// Bit RWR9.
	XDMAC_GRWR_RWR9 = 0x200
	// Position of RWR10 field.
	XDMAC_GRWR_RWR10_Pos = 0xa
	// Bit mask of RWR10 field.
	XDMAC_GRWR_RWR10_Msk = 0x400
	// Bit RWR10.
	XDMAC_GRWR_RWR10 = 0x400
	// Position of RWR11 field.
	XDMAC_GRWR_RWR11_Pos = 0xb
	// Bit mask of RWR11 field.
	XDMAC_GRWR_RWR11_Msk = 0x800
	// Bit RWR11.
	XDMAC_GRWR_RWR11 = 0x800
	// Position of RWR12 field.
	XDMAC_GRWR_RWR12_Pos = 0xc
	// Bit mask of RWR12 field.
	XDMAC_GRWR_RWR12_Msk = 0x1000
	// Bit RWR12.
	XDMAC_GRWR_RWR12 = 0x1000
	// Position of RWR13 field.
	XDMAC_GRWR_RWR13_Pos = 0xd
	// Bit mask of RWR13 field.
	XDMAC_GRWR_RWR13_Msk = 0x2000
	// Bit RWR13.
	XDMAC_GRWR_RWR13 = 0x2000
	// Position of RWR14 field.
	XDMAC_GRWR_RWR14_Pos = 0xe
	// Bit mask of RWR14 field.
	XDMAC_GRWR_RWR14_Msk = 0x4000
	// Bit RWR14.
	XDMAC_GRWR_RWR14 = 0x4000
	// Position of RWR15 field.
	XDMAC_GRWR_RWR15_Pos = 0xf
	// Bit mask of RWR15 field.
	XDMAC_GRWR_RWR15_Msk = 0x8000
	// Bit RWR15.
	XDMAC_GRWR_RWR15 = 0x8000
	// Position of RWR16 field.
	XDMAC_GRWR_RWR16_Pos = 0x10
	// Bit mask of RWR16 field.
	XDMAC_GRWR_RWR16_Msk = 0x10000
	// Bit RWR16.
	XDMAC_GRWR_RWR16 = 0x10000
	// Position of RWR17 field.
	XDMAC_GRWR_RWR17_Pos = 0x11
	// Bit mask of RWR17 field.
	XDMAC_GRWR_RWR17_Msk = 0x20000
	// Bit RWR17.
	XDMAC_GRWR_RWR17 = 0x20000
	// Position of RWR18 field.
	XDMAC_GRWR_RWR18_Pos = 0x12
	// Bit mask of RWR18 field.
	XDMAC_GRWR_RWR18_Msk = 0x40000
	// Bit RWR18.
	XDMAC_GRWR_RWR18 = 0x40000
	// Position of RWR19 field.
	XDMAC_GRWR_RWR19_Pos = 0x13
	// Bit mask of RWR19 field.
	XDMAC_GRWR_RWR19_Msk = 0x80000
	// Bit RWR19.
	XDMAC_GRWR_RWR19 = 0x80000
	// Position of RWR20 field.
	XDMAC_GRWR_RWR20_Pos = 0x14
	// Bit mask of RWR20 field.
	XDMAC_GRWR_RWR20_Msk = 0x100000
	// Bit RWR20.
	XDMAC_GRWR_RWR20 = 0x100000
	// Position of RWR21 field.
	XDMAC_GRWR_RWR21_Pos = 0x15
	// Bit mask of RWR21 field.
	XDMAC_GRWR_RWR21_Msk = 0x200000
	// Bit RWR21.
	XDMAC_GRWR_RWR21 = 0x200000
	// Position of RWR22 field.
	XDMAC_GRWR_RWR22_Pos = 0x16
	// Bit mask of RWR22 field.
	XDMAC_GRWR_RWR22_Msk = 0x400000
	// Bit RWR22.
	XDMAC_GRWR_RWR22 = 0x400000
	// Position of RWR23 field.
	XDMAC_GRWR_RWR23_Pos = 0x17
	// Bit mask of RWR23 field.
	XDMAC_GRWR_RWR23_Msk = 0x800000
	// Bit RWR23.
	XDMAC_GRWR_RWR23 = 0x800000

	// GSWR: Global Channel Software Request Register
	// Position of SWREQ0 field.
	XDMAC_GSWR_SWREQ0_Pos = 0x0
	// Bit mask of SWREQ0 field.
	XDMAC_GSWR_SWREQ0_Msk = 0x1
	// Bit SWREQ0.
	XDMAC_GSWR_SWREQ0 = 0x1
	// Position of SWREQ1 field.
	XDMAC_GSWR_SWREQ1_Pos = 0x1
	// Bit mask of SWREQ1 field.
	XDMAC_GSWR_SWREQ1_Msk = 0x2
	// Bit SWREQ1.
	XDMAC_GSWR_SWREQ1 = 0x2
	// Position of SWREQ2 field.
	XDMAC_GSWR_SWREQ2_Pos = 0x2
	// Bit mask of SWREQ2 field.
	XDMAC_GSWR_SWREQ2_Msk = 0x4
	// Bit SWREQ2.
	XDMAC_GSWR_SWREQ2 = 0x4
	// Position of SWREQ3 field.
	XDMAC_GSWR_SWREQ3_Pos = 0x3
	// Bit mask of SWREQ3 field.
	XDMAC_GSWR_SWREQ3_Msk = 0x8
	// Bit SWREQ3.
	XDMAC_GSWR_SWREQ3 = 0x8
	// Position of SWREQ4 field.
	XDMAC_GSWR_SWREQ4_Pos = 0x4
	// Bit mask of SWREQ4 field.
	XDMAC_GSWR_SWREQ4_Msk = 0x10
	// Bit SWREQ4.
	XDMAC_GSWR_SWREQ4 = 0x10
	// Position of SWREQ5 field.
	XDMAC_GSWR_SWREQ5_Pos = 0x5
	// Bit mask of SWREQ5 field.
	XDMAC_GSWR_SWREQ5_Msk = 0x20
	// Bit SWREQ5.
	XDMAC_GSWR_SWREQ5 = 0x20
	// Position of SWREQ6 field.
	XDMAC_GSWR_SWREQ6_Pos = 0x6
	// Bit mask of SWREQ6 field.
	XDMAC_GSWR_SWREQ6_Msk = 0x40
	// Bit SWREQ6.
	XDMAC_GSWR_SWREQ6 = 0x40
	// Position of SWREQ7 field.
	XDMAC_GSWR_SWREQ7_Pos = 0x7
	// Bit mask of SWREQ7 field.
	XDMAC_GSWR_SWREQ7_Msk = 0x80
	// Bit SWREQ7.
	XDMAC_GSWR_SWREQ7 = 0x80
	// Position of SWREQ8 field.
	XDMAC_GSWR_SWREQ8_Pos = 0x8
	// Bit mask of SWREQ8 field.
	XDMAC_GSWR_SWREQ8_Msk = 0x100
	// Bit SWREQ8.
	XDMAC_GSWR_SWREQ8 = 0x100
	// Position of SWREQ9 field.
	XDMAC_GSWR_SWREQ9_Pos = 0x9
	// Bit mask of SWREQ9 field.
	XDMAC_GSWR_SWREQ9_Msk = 0x200
	// Bit SWREQ9.
	XDMAC_GSWR_SWREQ9 = 0x200
	// Position of SWREQ10 field.
	XDMAC_GSWR_SWREQ10_Pos = 0xa
	// Bit mask of SWREQ10 field.
	XDMAC_GSWR_SWREQ10_Msk = 0x400
	// Bit SWREQ10.
	XDMAC_GSWR_SWREQ10 = 0x400
	// Position of SWREQ11 field.
	XDMAC_GSWR_SWREQ11_Pos = 0xb
	// Bit mask of SWREQ11 field.
	XDMAC_GSWR_SWREQ11_Msk = 0x800
	// Bit SWREQ11.
	XDMAC_GSWR_SWREQ11 = 0x800
	// Position of SWREQ12 field.
	XDMAC_GSWR_SWREQ12_Pos = 0xc
	// Bit mask of SWREQ12 field.
	XDMAC_GSWR_SWREQ12_Msk = 0x1000
	// Bit SWREQ12.
	XDMAC_GSWR_SWREQ12 = 0x1000
	// Position of SWREQ13 field.
	XDMAC_GSWR_SWREQ13_Pos = 0xd
	// Bit mask of SWREQ13 field.
	XDMAC_GSWR_SWREQ13_Msk = 0x2000
	// Bit SWREQ13.
	XDMAC_GSWR_SWREQ13 = 0x2000
	// Position of SWREQ14 field.
	XDMAC_GSWR_SWREQ14_Pos = 0xe
	// Bit mask of SWREQ14 field.
	XDMAC_GSWR_SWREQ14_Msk = 0x4000
	// Bit SWREQ14.
	XDMAC_GSWR_SWREQ14 = 0x4000
	// Position of SWREQ15 field.
	XDMAC_GSWR_SWREQ15_Pos = 0xf
	// Bit mask of SWREQ15 field.
	XDMAC_GSWR_SWREQ15_Msk = 0x8000
	// Bit SWREQ15.
	XDMAC_GSWR_SWREQ15 = 0x8000
	// Position of SWREQ16 field.
	XDMAC_GSWR_SWREQ16_Pos = 0x10
	// Bit mask of SWREQ16 field.
	XDMAC_GSWR_SWREQ16_Msk = 0x10000
	// Bit SWREQ16.
	XDMAC_GSWR_SWREQ16 = 0x10000
	// Position of SWREQ17 field.
	XDMAC_GSWR_SWREQ17_Pos = 0x11
	// Bit mask of SWREQ17 field.
	XDMAC_GSWR_SWREQ17_Msk = 0x20000
	// Bit SWREQ17.
	XDMAC_GSWR_SWREQ17 = 0x20000
	// Position of SWREQ18 field.
	XDMAC_GSWR_SWREQ18_Pos = 0x12
	// Bit mask of SWREQ18 field.
	XDMAC_GSWR_SWREQ18_Msk = 0x40000
	// Bit SWREQ18.
	XDMAC_GSWR_SWREQ18 = 0x40000
	// Position of SWREQ19 field.
	XDMAC_GSWR_SWREQ19_Pos = 0x13
	// Bit mask of SWREQ19 field.
	XDMAC_GSWR_SWREQ19_Msk = 0x80000
	// Bit SWREQ19.
	XDMAC_GSWR_SWREQ19 = 0x80000
	// Position of SWREQ20 field.
	XDMAC_GSWR_SWREQ20_Pos = 0x14
	// Bit mask of SWREQ20 field.
	XDMAC_GSWR_SWREQ20_Msk = 0x100000
	// Bit SWREQ20.
	XDMAC_GSWR_SWREQ20 = 0x100000
	// Position of SWREQ21 field.
	XDMAC_GSWR_SWREQ21_Pos = 0x15
	// Bit mask of SWREQ21 field.
	XDMAC_GSWR_SWREQ21_Msk = 0x200000
	// Bit SWREQ21.
	XDMAC_GSWR_SWREQ21 = 0x200000
	// Position of SWREQ22 field.
	XDMAC_GSWR_SWREQ22_Pos = 0x16
	// Bit mask of SWREQ22 field.
	XDMAC_GSWR_SWREQ22_Msk = 0x400000
	// Bit SWREQ22.
	XDMAC_GSWR_SWREQ22 = 0x400000
	// Position of SWREQ23 field.
	XDMAC_GSWR_SWREQ23_Pos = 0x17
	// Bit mask of SWREQ23 field.
	XDMAC_GSWR_SWREQ23_Msk = 0x800000
	// Bit SWREQ23.
	XDMAC_GSWR_SWREQ23 = 0x800000

	// GSWS: Global Channel Software Request Status Register
	// Position of SWRS0 field.
	XDMAC_GSWS_SWRS0_Pos = 0x0
	// Bit mask of SWRS0 field.
	XDMAC_GSWS_SWRS0_Msk = 0x1
	// Bit SWRS0.
	XDMAC_GSWS_SWRS0 = 0x1
	// Position of SWRS1 field.
	XDMAC_GSWS_SWRS1_Pos = 0x1
	// Bit mask of SWRS1 field.
	XDMAC_GSWS_SWRS1_Msk = 0x2
	// Bit SWRS1.
	XDMAC_GSWS_SWRS1 = 0x2
	// Position of SWRS2 field.
	XDMAC_GSWS_SWRS2_Pos = 0x2
	// Bit mask of SWRS2 field.
	XDMAC_GSWS_SWRS2_Msk = 0x4
	// Bit SWRS2.
	XDMAC_GSWS_SWRS2 = 0x4
	// Position of SWRS3 field.
	XDMAC_GSWS_SWRS3_Pos = 0x3
	// Bit mask of SWRS3 field.
	XDMAC_GSWS_SWRS3_Msk = 0x8
	// Bit SWRS3.
	XDMAC_GSWS_SWRS3 = 0x8
	// Position of SWRS4 field.
	XDMAC_GSWS_SWRS4_Pos = 0x4
	// Bit mask of SWRS4 field.
	XDMAC_GSWS_SWRS4_Msk = 0x10
	// Bit SWRS4.
	XDMAC_GSWS_SWRS4 = 0x10
	// Position of SWRS5 field.
	XDMAC_GSWS_SWRS5_Pos = 0x5
	// Bit mask of SWRS5 field.
	XDMAC_GSWS_SWRS5_Msk = 0x20
	// Bit SWRS5.
	XDMAC_GSWS_SWRS5 = 0x20
	// Position of SWRS6 field.
	XDMAC_GSWS_SWRS6_Pos = 0x6
	// Bit mask of SWRS6 field.
	XDMAC_GSWS_SWRS6_Msk = 0x40
	// Bit SWRS6.
	XDMAC_GSWS_SWRS6 = 0x40
	// Position of SWRS7 field.
	XDMAC_GSWS_SWRS7_Pos = 0x7
	// Bit mask of SWRS7 field.
	XDMAC_GSWS_SWRS7_Msk = 0x80
	// Bit SWRS7.
	XDMAC_GSWS_SWRS7 = 0x80
	// Position of SWRS8 field.
	XDMAC_GSWS_SWRS8_Pos = 0x8
	// Bit mask of SWRS8 field.
	XDMAC_GSWS_SWRS8_Msk = 0x100
	// Bit SWRS8.
	XDMAC_GSWS_SWRS8 = 0x100
	// Position of SWRS9 field.
	XDMAC_GSWS_SWRS9_Pos = 0x9
	// Bit mask of SWRS9 field.
	XDMAC_GSWS_SWRS9_Msk = 0x200
	// Bit SWRS9.
	XDMAC_GSWS_SWRS9 = 0x200
	// Position of SWRS10 field.
	XDMAC_GSWS_SWRS10_Pos = 0xa
	// Bit mask of SWRS10 field.
	XDMAC_GSWS_SWRS10_Msk = 0x400
	// Bit SWRS10.
	XDMAC_GSWS_SWRS10 = 0x400
	// Position of SWRS11 field.
	XDMAC_GSWS_SWRS11_Pos = 0xb
	// Bit mask of SWRS11 field.
	XDMAC_GSWS_SWRS11_Msk = 0x800
	// Bit SWRS11.
	XDMAC_GSWS_SWRS11 = 0x800
	// Position of SWRS12 field.
	XDMAC_GSWS_SWRS12_Pos = 0xc
	// Bit mask of SWRS12 field.
	XDMAC_GSWS_SWRS12_Msk = 0x1000
	// Bit SWRS12.
	XDMAC_GSWS_SWRS12 = 0x1000
	// Position of SWRS13 field.
	XDMAC_GSWS_SWRS13_Pos = 0xd
	// Bit mask of SWRS13 field.
	XDMAC_GSWS_SWRS13_Msk = 0x2000
	// Bit SWRS13.
	XDMAC_GSWS_SWRS13 = 0x2000
	// Position of SWRS14 field.
	XDMAC_GSWS_SWRS14_Pos = 0xe
	// Bit mask of SWRS14 field.
	XDMAC_GSWS_SWRS14_Msk = 0x4000
	// Bit SWRS14.
	XDMAC_GSWS_SWRS14 = 0x4000
	// Position of SWRS15 field.
	XDMAC_GSWS_SWRS15_Pos = 0xf
	// Bit mask of SWRS15 field.
	XDMAC_GSWS_SWRS15_Msk = 0x8000
	// Bit SWRS15.
	XDMAC_GSWS_SWRS15 = 0x8000
	// Position of SWRS16 field.
	XDMAC_GSWS_SWRS16_Pos = 0x10
	// Bit mask of SWRS16 field.
	XDMAC_GSWS_SWRS16_Msk = 0x10000
	// Bit SWRS16.
	XDMAC_GSWS_SWRS16 = 0x10000
	// Position of SWRS17 field.
	XDMAC_GSWS_SWRS17_Pos = 0x11
	// Bit mask of SWRS17 field.
	XDMAC_GSWS_SWRS17_Msk = 0x20000
	// Bit SWRS17.
	XDMAC_GSWS_SWRS17 = 0x20000
	// Position of SWRS18 field.
	XDMAC_GSWS_SWRS18_Pos = 0x12
	// Bit mask of SWRS18 field.
	XDMAC_GSWS_SWRS18_Msk = 0x40000
	// Bit SWRS18.
	XDMAC_GSWS_SWRS18 = 0x40000
	// Position of SWRS19 field.
	XDMAC_GSWS_SWRS19_Pos = 0x13
	// Bit mask of SWRS19 field.
	XDMAC_GSWS_SWRS19_Msk = 0x80000
	// Bit SWRS19.
	XDMAC_GSWS_SWRS19 = 0x80000
	// Position of SWRS20 field.
	XDMAC_GSWS_SWRS20_Pos = 0x14
	// Bit mask of SWRS20 field.
	XDMAC_GSWS_SWRS20_Msk = 0x100000
	// Bit SWRS20.
	XDMAC_GSWS_SWRS20 = 0x100000
	// Position of SWRS21 field.
	XDMAC_GSWS_SWRS21_Pos = 0x15
	// Bit mask of SWRS21 field.
	XDMAC_GSWS_SWRS21_Msk = 0x200000
	// Bit SWRS21.
	XDMAC_GSWS_SWRS21 = 0x200000
	// Position of SWRS22 field.
	XDMAC_GSWS_SWRS22_Pos = 0x16
	// Bit mask of SWRS22 field.
	XDMAC_GSWS_SWRS22_Msk = 0x400000
	// Bit SWRS22.
	XDMAC_GSWS_SWRS22 = 0x400000
	// Position of SWRS23 field.
	XDMAC_GSWS_SWRS23_Pos = 0x17
	// Bit mask of SWRS23 field.
	XDMAC_GSWS_SWRS23_Msk = 0x800000
	// Bit SWRS23.
	XDMAC_GSWS_SWRS23 = 0x800000

	// GSWF: Global Channel Software Flush Request Register
	// Position of SWF0 field.
	XDMAC_GSWF_SWF0_Pos = 0x0
	// Bit mask of SWF0 field.
	XDMAC_GSWF_SWF0_Msk = 0x1
	// Bit SWF0.
	XDMAC_GSWF_SWF0 = 0x1
	// Position of SWF1 field.
	XDMAC_GSWF_SWF1_Pos = 0x1
	// Bit mask of SWF1 field.
	XDMAC_GSWF_SWF1_Msk = 0x2
	// Bit SWF1.
	XDMAC_GSWF_SWF1 = 0x2
	// Position of SWF2 field.
	XDMAC_GSWF_SWF2_Pos = 0x2
	// Bit mask of SWF2 field.
	XDMAC_GSWF_SWF2_Msk = 0x4
	// Bit SWF2.
	XDMAC_GSWF_SWF2 = 0x4
	// Position of SWF3 field.
	XDMAC_GSWF_SWF3_Pos = 0x3
	// Bit mask of SWF3 field.
	XDMAC_GSWF_SWF3_Msk = 0x8
	// Bit SWF3.
	XDMAC_GSWF_SWF3 = 0x8
	// Position of SWF4 field.
	XDMAC_GSWF_SWF4_Pos = 0x4
	// Bit mask of SWF4 field.
	XDMAC_GSWF_SWF4_Msk = 0x10
	// Bit SWF4.
	XDMAC_GSWF_SWF4 = 0x10
	// Position of SWF5 field.
	XDMAC_GSWF_SWF5_Pos = 0x5
	// Bit mask of SWF5 field.
	XDMAC_GSWF_SWF5_Msk = 0x20
	// Bit SWF5.
	XDMAC_GSWF_SWF5 = 0x20
	// Position of SWF6 field.
	XDMAC_GSWF_SWF6_Pos = 0x6
	// Bit mask of SWF6 field.
	XDMAC_GSWF_SWF6_Msk = 0x40
	// Bit SWF6.
	XDMAC_GSWF_SWF6 = 0x40
	// Position of SWF7 field.
	XDMAC_GSWF_SWF7_Pos = 0x7
	// Bit mask of SWF7 field.
	XDMAC_GSWF_SWF7_Msk = 0x80
	// Bit SWF7.
	XDMAC_GSWF_SWF7 = 0x80
	// Position of SWF8 field.
	XDMAC_GSWF_SWF8_Pos = 0x8
	// Bit mask of SWF8 field.
	XDMAC_GSWF_SWF8_Msk = 0x100
	// Bit SWF8.
	XDMAC_GSWF_SWF8 = 0x100
	// Position of SWF9 field.
	XDMAC_GSWF_SWF9_Pos = 0x9
	// Bit mask of SWF9 field.
	XDMAC_GSWF_SWF9_Msk = 0x200
	// Bit SWF9.
	XDMAC_GSWF_SWF9 = 0x200
	// Position of SWF10 field.
	XDMAC_GSWF_SWF10_Pos = 0xa
	// Bit mask of SWF10 field.
	XDMAC_GSWF_SWF10_Msk = 0x400
	// Bit SWF10.
	XDMAC_GSWF_SWF10 = 0x400
	// Position of SWF11 field.
	XDMAC_GSWF_SWF11_Pos = 0xb
	// Bit mask of SWF11 field.
	XDMAC_GSWF_SWF11_Msk = 0x800
	// Bit SWF11.
	XDMAC_GSWF_SWF11 = 0x800
	// Position of SWF12 field.
	XDMAC_GSWF_SWF12_Pos = 0xc
	// Bit mask of SWF12 field.
	XDMAC_GSWF_SWF12_Msk = 0x1000
	// Bit SWF12.
	XDMAC_GSWF_SWF12 = 0x1000
	// Position of SWF13 field.
	XDMAC_GSWF_SWF13_Pos = 0xd
	// Bit mask of SWF13 field.
	XDMAC_GSWF_SWF13_Msk = 0x2000
	// Bit SWF13.
	XDMAC_GSWF_SWF13 = 0x2000
	// Position of SWF14 field.
	XDMAC_GSWF_SWF14_Pos = 0xe
	// Bit mask of SWF14 field.
	XDMAC_GSWF_SWF14_Msk = 0x4000
	// Bit SWF14.
	XDMAC_GSWF_SWF14 = 0x4000
	// Position of SWF15 field.
	XDMAC_GSWF_SWF15_Pos = 0xf
	// Bit mask of SWF15 field.
	XDMAC_GSWF_SWF15_Msk = 0x8000
	// Bit SWF15.
	XDMAC_GSWF_SWF15 = 0x8000
	// Position of SWF16 field.
	XDMAC_GSWF_SWF16_Pos = 0x10
	// Bit mask of SWF16 field.
	XDMAC_GSWF_SWF16_Msk = 0x10000
	// Bit SWF16.
	XDMAC_GSWF_SWF16 = 0x10000
	// Position of SWF17 field.
	XDMAC_GSWF_SWF17_Pos = 0x11
	// Bit mask of SWF17 field.
	XDMAC_GSWF_SWF17_Msk = 0x20000
	// Bit SWF17.
	XDMAC_GSWF_SWF17 = 0x20000
	// Position of SWF18 field.
	XDMAC_GSWF_SWF18_Pos = 0x12
	// Bit mask of SWF18 field.
	XDMAC_GSWF_SWF18_Msk = 0x40000
	// Bit SWF18.
	XDMAC_GSWF_SWF18 = 0x40000
	// Position of SWF19 field.
	XDMAC_GSWF_SWF19_Pos = 0x13
	// Bit mask of SWF19 field.
	XDMAC_GSWF_SWF19_Msk = 0x80000
	// Bit SWF19.
	XDMAC_GSWF_SWF19 = 0x80000
	// Position of SWF20 field.
	XDMAC_GSWF_SWF20_Pos = 0x14
	// Bit mask of SWF20 field.
	XDMAC_GSWF_SWF20_Msk = 0x100000
	// Bit SWF20.
	XDMAC_GSWF_SWF20 = 0x100000
	// Position of SWF21 field.
	XDMAC_GSWF_SWF21_Pos = 0x15
	// Bit mask of SWF21 field.
	XDMAC_GSWF_SWF21_Msk = 0x200000
	// Bit SWF21.
	XDMAC_GSWF_SWF21 = 0x200000
	// Position of SWF22 field.
	XDMAC_GSWF_SWF22_Pos = 0x16
	// Bit mask of SWF22 field.
	XDMAC_GSWF_SWF22_Msk = 0x400000
	// Bit SWF22.
	XDMAC_GSWF_SWF22 = 0x400000
	// Position of SWF23 field.
	XDMAC_GSWF_SWF23_Pos = 0x17
	// Bit mask of SWF23 field.
	XDMAC_GSWF_SWF23_Msk = 0x800000
	// Bit SWF23.
	XDMAC_GSWF_SWF23 = 0x800000

	// XDMAC_CHID.CIE: Channel Interrupt Enable Register (chid = 0)
	// Position of BIE field.
	XDMAC_XDMAC_CHID_CIE_BIE_Pos = 0x0
	// Bit mask of BIE field.
	XDMAC_XDMAC_CHID_CIE_BIE_Msk = 0x1
	// Bit BIE.
	XDMAC_XDMAC_CHID_CIE_BIE = 0x1
	// Position of LIE field.
	XDMAC_XDMAC_CHID_CIE_LIE_Pos = 0x1
	// Bit mask of LIE field.
	XDMAC_XDMAC_CHID_CIE_LIE_Msk = 0x2
	// Bit LIE.
	XDMAC_XDMAC_CHID_CIE_LIE = 0x2
	// Position of DIE field.
	XDMAC_XDMAC_CHID_CIE_DIE_Pos = 0x2
	// Bit mask of DIE field.
	XDMAC_XDMAC_CHID_CIE_DIE_Msk = 0x4
	// Bit DIE.
	XDMAC_XDMAC_CHID_CIE_DIE = 0x4
	// Position of FIE field.
	XDMAC_XDMAC_CHID_CIE_FIE_Pos = 0x3
	// Bit mask of FIE field.
	XDMAC_XDMAC_CHID_CIE_FIE_Msk = 0x8
	// Bit FIE.
	XDMAC_XDMAC_CHID_CIE_FIE = 0x8
	// Position of RBIE field.
	XDMAC_XDMAC_CHID_CIE_RBIE_Pos = 0x4
	// Bit mask of RBIE field.
	XDMAC_XDMAC_CHID_CIE_RBIE_Msk = 0x10
	// Bit RBIE.
	XDMAC_XDMAC_CHID_CIE_RBIE = 0x10
	// Position of WBIE field.
	XDMAC_XDMAC_CHID_CIE_WBIE_Pos = 0x5
	// Bit mask of WBIE field.
	XDMAC_XDMAC_CHID_CIE_WBIE_Msk = 0x20
	// Bit WBIE.
	XDMAC_XDMAC_CHID_CIE_WBIE = 0x20
	// Position of ROIE field.
	XDMAC_XDMAC_CHID_CIE_ROIE_Pos = 0x6
	// Bit mask of ROIE field.
	XDMAC_XDMAC_CHID_CIE_ROIE_Msk = 0x40
	// Bit ROIE.
	XDMAC_XDMAC_CHID_CIE_ROIE = 0x40

	// XDMAC_CHID.CID: Channel Interrupt Disable Register (chid = 0)
	// Position of BID field.
	XDMAC_XDMAC_CHID_CID_BID_Pos = 0x0
	// Bit mask of BID field.
	XDMAC_XDMAC_CHID_CID_BID_Msk = 0x1
	// Bit BID.
	XDMAC_XDMAC_CHID_CID_BID = 0x1
	// Position of LID field.
	XDMAC_XDMAC_CHID_CID_LID_Pos = 0x1
	// Bit mask of LID field.
	XDMAC_XDMAC_CHID_CID_LID_Msk = 0x2
	// Bit LID.
	XDMAC_XDMAC_CHID_CID_LID = 0x2
	// Position of DID field.
	XDMAC_XDMAC_CHID_CID_DID_Pos = 0x2
	// Bit mask of DID field.
	XDMAC_XDMAC_CHID_CID_DID_Msk = 0x4
	// Bit DID.
	XDMAC_XDMAC_CHID_CID_DID = 0x4
	// Position of FID field.
	XDMAC_XDMAC_CHID_CID_FID_Pos = 0x3
	// Bit mask of FID field.
	XDMAC_XDMAC_CHID_CID_FID_Msk = 0x8
	// Bit FID.
	XDMAC_XDMAC_CHID_CID_FID = 0x8
	// Position of RBEID field.
	XDMAC_XDMAC_CHID_CID_RBEID_Pos = 0x4
	// Bit mask of RBEID field.
	XDMAC_XDMAC_CHID_CID_RBEID_Msk = 0x10
	// Bit RBEID.
	XDMAC_XDMAC_CHID_CID_RBEID = 0x10
	// Position of WBEID field.
	XDMAC_XDMAC_CHID_CID_WBEID_Pos = 0x5
	// Bit mask of WBEID field.
	XDMAC_XDMAC_CHID_CID_WBEID_Msk = 0x20
	// Bit WBEID.
	XDMAC_XDMAC_CHID_CID_WBEID = 0x20
	// Position of ROID field.
	XDMAC_XDMAC_CHID_CID_ROID_Pos = 0x6
	// Bit mask of ROID field.
	XDMAC_XDMAC_CHID_CID_ROID_Msk = 0x40
	// Bit ROID.
	XDMAC_XDMAC_CHID_CID_ROID = 0x40

	// XDMAC_CHID.CIM: Channel Interrupt Mask Register (chid = 0)
	// Position of BIM field.
	XDMAC_XDMAC_CHID_CIM_BIM_Pos = 0x0
	// Bit mask of BIM field.
	XDMAC_XDMAC_CHID_CIM_BIM_Msk = 0x1
	// Bit BIM.
	XDMAC_XDMAC_CHID_CIM_BIM = 0x1
	// Position of LIM field.
	XDMAC_XDMAC_CHID_CIM_LIM_Pos = 0x1
	// Bit mask of LIM field.
	XDMAC_XDMAC_CHID_CIM_LIM_Msk = 0x2
	// Bit LIM.
	XDMAC_XDMAC_CHID_CIM_LIM = 0x2
	// Position of DIM field.
	XDMAC_XDMAC_CHID_CIM_DIM_Pos = 0x2
	// Bit mask of DIM field.
	XDMAC_XDMAC_CHID_CIM_DIM_Msk = 0x4
	// Bit DIM.
	XDMAC_XDMAC_CHID_CIM_DIM = 0x4
	// Position of FIM field.
	XDMAC_XDMAC_CHID_CIM_FIM_Pos = 0x3
	// Bit mask of FIM field.
	XDMAC_XDMAC_CHID_CIM_FIM_Msk = 0x8
	// Bit FIM.
	XDMAC_XDMAC_CHID_CIM_FIM = 0x8
	// Position of RBEIM field.
	XDMAC_XDMAC_CHID_CIM_RBEIM_Pos = 0x4
	// Bit mask of RBEIM field.
	XDMAC_XDMAC_CHID_CIM_RBEIM_Msk = 0x10
	// Bit RBEIM.
	XDMAC_XDMAC_CHID_CIM_RBEIM = 0x10
	// Position of WBEIM field.
	XDMAC_XDMAC_CHID_CIM_WBEIM_Pos = 0x5
	// Bit mask of WBEIM field.
	XDMAC_XDMAC_CHID_CIM_WBEIM_Msk = 0x20
	// Bit WBEIM.
	XDMAC_XDMAC_CHID_CIM_WBEIM = 0x20
	// Position of ROIM field.
	XDMAC_XDMAC_CHID_CIM_ROIM_Pos = 0x6
	// Bit mask of ROIM field.
	XDMAC_XDMAC_CHID_CIM_ROIM_Msk = 0x40
	// Bit ROIM.
	XDMAC_XDMAC_CHID_CIM_ROIM = 0x40

	// XDMAC_CHID.CIS: Channel Interrupt Status Register (chid = 0)
	// Position of BIS field.
	XDMAC_XDMAC_CHID_CIS_BIS_Pos = 0x0
	// Bit mask of BIS field.
	XDMAC_XDMAC_CHID_CIS_BIS_Msk = 0x1
	// Bit BIS.
	XDMAC_XDMAC_CHID_CIS_BIS = 0x1
	// Position of LIS field.
	XDMAC_XDMAC_CHID_CIS_LIS_Pos = 0x1
	// Bit mask of LIS field.
	XDMAC_XDMAC_CHID_CIS_LIS_Msk = 0x2
	// Bit LIS.
	XDMAC_XDMAC_CHID_CIS_LIS = 0x2
	// Position of DIS field.
	XDMAC_XDMAC_CHID_CIS_DIS_Pos = 0x2
	// Bit mask of DIS field.
	XDMAC_XDMAC_CHID_CIS_DIS_Msk = 0x4
	// Bit DIS.
	XDMAC_XDMAC_CHID_CIS_DIS = 0x4
	// Position of FIS field.
	XDMAC_XDMAC_CHID_CIS_FIS_Pos = 0x3
	// Bit mask of FIS field.
	XDMAC_XDMAC_CHID_CIS_FIS_Msk = 0x8
	// Bit FIS.
	XDMAC_XDMAC_CHID_CIS_FIS = 0x8
	// Position of RBEIS field.
	XDMAC_XDMAC_CHID_CIS_RBEIS_Pos = 0x4
	// Bit mask of RBEIS field.
	XDMAC_XDMAC_CHID_CIS_RBEIS_Msk = 0x10
	// Bit RBEIS.
	XDMAC_XDMAC_CHID_CIS_RBEIS = 0x10
	// Position of WBEIS field.
	XDMAC_XDMAC_CHID_CIS_WBEIS_Pos = 0x5
	// Bit mask of WBEIS field.
	XDMAC_XDMAC_CHID_CIS_WBEIS_Msk = 0x20
	// Bit WBEIS.
	XDMAC_XDMAC_CHID_CIS_WBEIS = 0x20
	// Position of ROIS field.
	XDMAC_XDMAC_CHID_CIS_ROIS_Pos = 0x6
	// Bit mask of ROIS field.
	XDMAC_XDMAC_CHID_CIS_ROIS_Msk = 0x40
	// Bit ROIS.
	XDMAC_XDMAC_CHID_CIS_ROIS = 0x40

	// XDMAC_CHID.CSA: Channel Source Address Register (chid = 0)
	// Position of SA field.
	XDMAC_XDMAC_CHID_CSA_SA_Pos = 0x0
	// Bit mask of SA field.
	XDMAC_XDMAC_CHID_CSA_SA_Msk = 0xffffffff

	// XDMAC_CHID.CDA: Channel Destination Address Register (chid = 0)
	// Position of DA field.
	XDMAC_XDMAC_CHID_CDA_DA_Pos = 0x0
	// Bit mask of DA field.
	XDMAC_XDMAC_CHID_CDA_DA_Msk = 0xffffffff

	// XDMAC_CHID.CNDA: Channel Next Descriptor Address Register (chid = 0)
	// Position of NDAIF field.
	XDMAC_XDMAC_CHID_CNDA_NDAIF_Pos = 0x0
	// Bit mask of NDAIF field.
	XDMAC_XDMAC_CHID_CNDA_NDAIF_Msk = 0x1
	// Bit NDAIF.
	XDMAC_XDMAC_CHID_CNDA_NDAIF = 0x1
	// Position of NDA field.
	XDMAC_XDMAC_CHID_CNDA_NDA_Pos = 0x2
	// Bit mask of NDA field.
	XDMAC_XDMAC_CHID_CNDA_NDA_Msk = 0xfffffffc

	// XDMAC_CHID.CNDC: Channel Next Descriptor Control Register (chid = 0)
	// Position of NDE field.
	XDMAC_XDMAC_CHID_CNDC_NDE_Pos = 0x0
	// Bit mask of NDE field.
	XDMAC_XDMAC_CHID_CNDC_NDE_Msk = 0x1
	// Bit NDE.
	XDMAC_XDMAC_CHID_CNDC_NDE = 0x1
	// Descriptor fetch is disabled.
	XDMAC_XDMAC_CHID_CNDC_NDE_DSCR_FETCH_DIS = 0x0
	// Descriptor fetch is enabled.
	XDMAC_XDMAC_CHID_CNDC_NDE_DSCR_FETCH_EN = 0x1
	// Position of NDSUP field.
	XDMAC_XDMAC_CHID_CNDC_NDSUP_Pos = 0x1
	// Bit mask of NDSUP field.
	XDMAC_XDMAC_CHID_CNDC_NDSUP_Msk = 0x2
	// Bit NDSUP.
	XDMAC_XDMAC_CHID_CNDC_NDSUP = 0x2
	// Source parameters remain unchanged.
	XDMAC_XDMAC_CHID_CNDC_NDSUP_SRC_PARAMS_UNCHANGED = 0x0
	// Source parameters are updated when the descriptor is retrieved.
	XDMAC_XDMAC_CHID_CNDC_NDSUP_SRC_PARAMS_UPDATED = 0x1
	// Position of NDDUP field.
	XDMAC_XDMAC_CHID_CNDC_NDDUP_Pos = 0x2
	// Bit mask of NDDUP field.
	XDMAC_XDMAC_CHID_CNDC_NDDUP_Msk = 0x4
	// Bit NDDUP.
	XDMAC_XDMAC_CHID_CNDC_NDDUP = 0x4
	// Destination parameters remain unchanged.
	XDMAC_XDMAC_CHID_CNDC_NDDUP_DST_PARAMS_UNCHANGED = 0x0
	// Destination parameters are updated when the descriptor is retrieved.
	XDMAC_XDMAC_CHID_CNDC_NDDUP_DST_PARAMS_UPDATED = 0x1
	// Position of NDVIEW field.
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_Pos = 0x3
	// Bit mask of NDVIEW field.
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_Msk = 0x18
	// Next Descriptor View 0
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_NDV0 = 0x0
	// Next Descriptor View 1
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_NDV1 = 0x1
	// Next Descriptor View 2
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_NDV2 = 0x2
	// Next Descriptor View 3
	XDMAC_XDMAC_CHID_CNDC_NDVIEW_NDV3 = 0x3

	// XDMAC_CHID.CUBC: Channel Microblock Control Register (chid = 0)
	// Position of UBLEN field.
	XDMAC_XDMAC_CHID_CUBC_UBLEN_Pos = 0x0
	// Bit mask of UBLEN field.
	XDMAC_XDMAC_CHID_CUBC_UBLEN_Msk = 0xffffff

	// XDMAC_CHID.CBC: Channel Block Control Register (chid = 0)
	// Position of BLEN field.
	XDMAC_XDMAC_CHID_CBC_BLEN_Pos = 0x0
	// Bit mask of BLEN field.
	XDMAC_XDMAC_CHID_CBC_BLEN_Msk = 0xfff

	// XDMAC_CHID.CC: Channel Configuration Register (chid = 0)
	// Position of TYPE field.
	XDMAC_XDMAC_CHID_CC_TYPE_Pos = 0x0
	// Bit mask of TYPE field.
	XDMAC_XDMAC_CHID_CC_TYPE_Msk = 0x1
	// Bit TYPE.
	XDMAC_XDMAC_CHID_CC_TYPE = 0x1
	// Self triggered mode (Memory to Memory Transfer).
	XDMAC_XDMAC_CHID_CC_TYPE_MEM_TRAN = 0x0
	// Synchronized mode (Peripheral to Memory or Memory to Peripheral Transfer).
	XDMAC_XDMAC_CHID_CC_TYPE_PER_TRAN = 0x1
	// Position of MBSIZE field.
	XDMAC_XDMAC_CHID_CC_MBSIZE_Pos = 0x1
	// Bit mask of MBSIZE field.
	XDMAC_XDMAC_CHID_CC_MBSIZE_Msk = 0x6
	// The memory burst size is set to one.
	XDMAC_XDMAC_CHID_CC_MBSIZE_SINGLE = 0x0
	// The memory burst size is set to four.
	XDMAC_XDMAC_CHID_CC_MBSIZE_FOUR = 0x1
	// The memory burst size is set to eight.
	XDMAC_XDMAC_CHID_CC_MBSIZE_EIGHT = 0x2
	// The memory burst size is set to sixteen.
	XDMAC_XDMAC_CHID_CC_MBSIZE_SIXTEEN = 0x3
	// Position of DSYNC field.
	XDMAC_XDMAC_CHID_CC_DSYNC_Pos = 0x4
	// Bit mask of DSYNC field.
	XDMAC_XDMAC_CHID_CC_DSYNC_Msk = 0x10
	// Bit DSYNC.
	XDMAC_XDMAC_CHID_CC_DSYNC = 0x10
	// Peripheral to Memory transfer.
	XDMAC_XDMAC_CHID_CC_DSYNC_PER2MEM = 0x0
	// Memory to Peripheral transfer.
	XDMAC_XDMAC_CHID_CC_DSYNC_MEM2PER = 0x1
	// Position of SWREQ field.
	XDMAC_XDMAC_CHID_CC_SWREQ_Pos = 0x6
	// Bit mask of SWREQ field.
	XDMAC_XDMAC_CHID_CC_SWREQ_Msk = 0x40
	// Bit SWREQ.
	XDMAC_XDMAC_CHID_CC_SWREQ = 0x40
	// Hardware request line is connected to the peripheral request line.
	XDMAC_XDMAC_CHID_CC_SWREQ_HWR_CONNECTED = 0x0
	// Software request is connected to the peripheral request line.
	XDMAC_XDMAC_CHID_CC_SWREQ_SWR_CONNECTED = 0x1
	// Position of MEMSET field.
	XDMAC_XDMAC_CHID_CC_MEMSET_Pos = 0x7
	// Bit mask of MEMSET field.
	XDMAC_XDMAC_CHID_CC_MEMSET_Msk = 0x80
	// Bit MEMSET.
	XDMAC_XDMAC_CHID_CC_MEMSET = 0x80
	// Memset is not activated.
	XDMAC_XDMAC_CHID_CC_MEMSET_NORMAL_MODE = 0x0
	// Sets the block of memory pointed by DA field to the specified value. This operation is performed on 8-, 16- or 32-bit basis.
	XDMAC_XDMAC_CHID_CC_MEMSET_HW_MODE = 0x1
	// Position of CSIZE field.
	XDMAC_XDMAC_CHID_CC_CSIZE_Pos = 0x8
	// Bit mask of CSIZE field.
	XDMAC_XDMAC_CHID_CC_CSIZE_Msk = 0x700
	// 1 data transferred
	XDMAC_XDMAC_CHID_CC_CSIZE_CHK_1 = 0x0
	// 2 data transferred
	XDMAC_XDMAC_CHID_CC_CSIZE_CHK_2 = 0x1
	// 4 data transferred
	XDMAC_XDMAC_CHID_CC_CSIZE_CHK_4 = 0x2
	// 8 data transferred
	XDMAC_XDMAC_CHID_CC_CSIZE_CHK_8 = 0x3
	// 16 data transferred
	XDMAC_XDMAC_CHID_CC_CSIZE_CHK_16 = 0x4
	// Position of DWIDTH field.
	XDMAC_XDMAC_CHID_CC_DWIDTH_Pos = 0xb
	// Bit mask of DWIDTH field.
	XDMAC_XDMAC_CHID_CC_DWIDTH_Msk = 0x1800
	// The data size is set to 8 bits
	XDMAC_XDMAC_CHID_CC_DWIDTH_BYTE = 0x0
	// The data size is set to 16 bits
	XDMAC_XDMAC_CHID_CC_DWIDTH_HALFWORD = 0x1
	// The data size is set to 32 bits
	XDMAC_XDMAC_CHID_CC_DWIDTH_WORD = 0x2
	// Position of SIF field.
	XDMAC_XDMAC_CHID_CC_SIF_Pos = 0xd
	// Bit mask of SIF field.
	XDMAC_XDMAC_CHID_CC_SIF_Msk = 0x2000
	// Bit SIF.
	XDMAC_XDMAC_CHID_CC_SIF = 0x2000
	// The data is read through the system bus interface 0.
	XDMAC_XDMAC_CHID_CC_SIF_AHB_IF0 = 0x0
	// The data is read through the system bus interface 1.
	XDMAC_XDMAC_CHID_CC_SIF_AHB_IF1 = 0x1
	// Position of DIF field.
	XDMAC_XDMAC_CHID_CC_DIF_Pos = 0xe
	// Bit mask of DIF field.
	XDMAC_XDMAC_CHID_CC_DIF_Msk = 0x4000
	// Bit DIF.
	XDMAC_XDMAC_CHID_CC_DIF = 0x4000
	// The data is written through the system bus interface 0.
	XDMAC_XDMAC_CHID_CC_DIF_AHB_IF0 = 0x0
	// The data is written though the system bus interface 1.
	XDMAC_XDMAC_CHID_CC_DIF_AHB_IF1 = 0x1
	// Position of SAM field.
	XDMAC_XDMAC_CHID_CC_SAM_Pos = 0x10
	// Bit mask of SAM field.
	XDMAC_XDMAC_CHID_CC_SAM_Msk = 0x30000
	// The address remains unchanged.
	XDMAC_XDMAC_CHID_CC_SAM_FIXED_AM = 0x0
	// The addressing mode is incremented (the increment size is set to the data size).
	XDMAC_XDMAC_CHID_CC_SAM_INCREMENTED_AM = 0x1
	// The microblock stride is added at the microblock boundary.
	XDMAC_XDMAC_CHID_CC_SAM_UBS_AM = 0x2
	// The microblock stride is added at the microblock boundary, the data stride is added at the data boundary.
	XDMAC_XDMAC_CHID_CC_SAM_UBS_DS_AM = 0x3
	// Position of DAM field.
	XDMAC_XDMAC_CHID_CC_DAM_Pos = 0x12
	// Bit mask of DAM field.
	XDMAC_XDMAC_CHID_CC_DAM_Msk = 0xc0000
	// The address remains unchanged.
	XDMAC_XDMAC_CHID_CC_DAM_FIXED_AM = 0x0
	// The addressing mode is incremented (the increment size is set to the data size).
	XDMAC_XDMAC_CHID_CC_DAM_INCREMENTED_AM = 0x1
	// The microblock stride is added at the microblock boundary.
	XDMAC_XDMAC_CHID_CC_DAM_UBS_AM = 0x2
	// The microblock stride is added at the microblock boundary, the data stride is added at the data boundary.
	XDMAC_XDMAC_CHID_CC_DAM_UBS_DS_AM = 0x3
	// Position of INITD field.
	XDMAC_XDMAC_CHID_CC_INITD_Pos = 0x15
	// Bit mask of INITD field.
	XDMAC_XDMAC_CHID_CC_INITD_Msk = 0x200000
	// Bit INITD.
	XDMAC_XDMAC_CHID_CC_INITD = 0x200000
	// Channel initialization is in progress.
	XDMAC_XDMAC_CHID_CC_INITD_IN_PROGRESS = 0x0
	// Channel initialization is completed.
	XDMAC_XDMAC_CHID_CC_INITD_TERMINATED = 0x1
	// Position of RDIP field.
	XDMAC_XDMAC_CHID_CC_RDIP_Pos = 0x16
	// Bit mask of RDIP field.
	XDMAC_XDMAC_CHID_CC_RDIP_Msk = 0x400000
	// Bit RDIP.
	XDMAC_XDMAC_CHID_CC_RDIP = 0x400000
	// No Active read transaction on the bus.
	XDMAC_XDMAC_CHID_CC_RDIP_DONE = 0x0
	// A read transaction is in progress.
	XDMAC_XDMAC_CHID_CC_RDIP_IN_PROGRESS = 0x1
	// Position of WRIP field.
	XDMAC_XDMAC_CHID_CC_WRIP_Pos = 0x17
	// Bit mask of WRIP field.
	XDMAC_XDMAC_CHID_CC_WRIP_Msk = 0x800000
	// Bit WRIP.
	XDMAC_XDMAC_CHID_CC_WRIP = 0x800000
	// No Active write transaction on the bus.
	XDMAC_XDMAC_CHID_CC_WRIP_DONE = 0x0
	// A Write transaction is in progress.
	XDMAC_XDMAC_CHID_CC_WRIP_IN_PROGRESS = 0x1
	// Position of PERID field.
	XDMAC_XDMAC_CHID_CC_PERID_Pos = 0x18
	// Bit mask of PERID field.
	XDMAC_XDMAC_CHID_CC_PERID_Msk = 0x7f000000

	// XDMAC_CHID.CDS_MSP: Channel Data Stride Memory Set Pattern (chid = 0)
	// Position of SDS_MSP field.
	XDMAC_XDMAC_CHID_CDS_MSP_SDS_MSP_Pos = 0x0
	// Bit mask of SDS_MSP field.
	XDMAC_XDMAC_CHID_CDS_MSP_SDS_MSP_Msk = 0xffff
	// Position of DDS_MSP field.
	XDMAC_XDMAC_CHID_CDS_MSP_DDS_MSP_Pos = 0x10
	// Bit mask of DDS_MSP field.
	XDMAC_XDMAC_CHID_CDS_MSP_DDS_MSP_Msk = 0xffff0000

	// XDMAC_CHID.CSUS: Channel Source Microblock Stride (chid = 0)
	// Position of SUBS field.
	XDMAC_XDMAC_CHID_CSUS_SUBS_Pos = 0x0
	// Bit mask of SUBS field.
	XDMAC_XDMAC_CHID_CSUS_SUBS_Msk = 0xffffff

	// XDMAC_CHID.CDUS: Channel Destination Microblock Stride (chid = 0)
	// Position of DUBS field.
	XDMAC_XDMAC_CHID_CDUS_DUBS_Pos = 0x0
	// Bit mask of DUBS field.
	XDMAC_XDMAC_CHID_CDUS_DUBS_Msk = 0xffffff
)

// Constants for LOCKBIT
const (
	// WORD0: Lock Bits Word 0
	// Position of LOCK_REGION_0 field.
	LOCKBIT_WORD0_LOCK_REGION_0_Pos = 0x0
	// Bit mask of LOCK_REGION_0 field.
	LOCKBIT_WORD0_LOCK_REGION_0_Msk = 0x1
	// Bit LOCK_REGION_0.
	LOCKBIT_WORD0_LOCK_REGION_0 = 0x1
	// Position of LOCK_REGION_1 field.
	LOCKBIT_WORD0_LOCK_REGION_1_Pos = 0x1
	// Bit mask of LOCK_REGION_1 field.
	LOCKBIT_WORD0_LOCK_REGION_1_Msk = 0x2
	// Bit LOCK_REGION_1.
	LOCKBIT_WORD0_LOCK_REGION_1 = 0x2
	// Position of LOCK_REGION_2 field.
	LOCKBIT_WORD0_LOCK_REGION_2_Pos = 0x2
	// Bit mask of LOCK_REGION_2 field.
	LOCKBIT_WORD0_LOCK_REGION_2_Msk = 0x4
	// Bit LOCK_REGION_2.
	LOCKBIT_WORD0_LOCK_REGION_2 = 0x4
	// Position of LOCK_REGION_3 field.
	LOCKBIT_WORD0_LOCK_REGION_3_Pos = 0x3
	// Bit mask of LOCK_REGION_3 field.
	LOCKBIT_WORD0_LOCK_REGION_3_Msk = 0x8
	// Bit LOCK_REGION_3.
	LOCKBIT_WORD0_LOCK_REGION_3 = 0x8
	// Position of LOCK_REGION_4 field.
	LOCKBIT_WORD0_LOCK_REGION_4_Pos = 0x4
	// Bit mask of LOCK_REGION_4 field.
	LOCKBIT_WORD0_LOCK_REGION_4_Msk = 0x10
	// Bit LOCK_REGION_4.
	LOCKBIT_WORD0_LOCK_REGION_4 = 0x10
	// Position of LOCK_REGION_5 field.
	LOCKBIT_WORD0_LOCK_REGION_5_Pos = 0x5
	// Bit mask of LOCK_REGION_5 field.
	LOCKBIT_WORD0_LOCK_REGION_5_Msk = 0x20
	// Bit LOCK_REGION_5.
	LOCKBIT_WORD0_LOCK_REGION_5 = 0x20
	// Position of LOCK_REGION_6 field.
	LOCKBIT_WORD0_LOCK_REGION_6_Pos = 0x6
	// Bit mask of LOCK_REGION_6 field.
	LOCKBIT_WORD0_LOCK_REGION_6_Msk = 0x40
	// Bit LOCK_REGION_6.
	LOCKBIT_WORD0_LOCK_REGION_6 = 0x40
	// Position of LOCK_REGION_7 field.
	LOCKBIT_WORD0_LOCK_REGION_7_Pos = 0x7
	// Bit mask of LOCK_REGION_7 field.
	LOCKBIT_WORD0_LOCK_REGION_7_Msk = 0x80
	// Bit LOCK_REGION_7.
	LOCKBIT_WORD0_LOCK_REGION_7 = 0x80
	// Position of LOCK_REGION_8 field.
	LOCKBIT_WORD0_LOCK_REGION_8_Pos = 0x8
	// Bit mask of LOCK_REGION_8 field.
	LOCKBIT_WORD0_LOCK_REGION_8_Msk = 0x100
	// Bit LOCK_REGION_8.
	LOCKBIT_WORD0_LOCK_REGION_8 = 0x100
	// Position of LOCK_REGION_9 field.
	LOCKBIT_WORD0_LOCK_REGION_9_Pos = 0x9
	// Bit mask of LOCK_REGION_9 field.
	LOCKBIT_WORD0_LOCK_REGION_9_Msk = 0x200
	// Bit LOCK_REGION_9.
	LOCKBIT_WORD0_LOCK_REGION_9 = 0x200
	// Position of LOCK_REGION_10 field.
	LOCKBIT_WORD0_LOCK_REGION_10_Pos = 0xa
	// Bit mask of LOCK_REGION_10 field.
	LOCKBIT_WORD0_LOCK_REGION_10_Msk = 0x400
	// Bit LOCK_REGION_10.
	LOCKBIT_WORD0_LOCK_REGION_10 = 0x400
	// Position of LOCK_REGION_11 field.
	LOCKBIT_WORD0_LOCK_REGION_11_Pos = 0xb
	// Bit mask of LOCK_REGION_11 field.
	LOCKBIT_WORD0_LOCK_REGION_11_Msk = 0x800
	// Bit LOCK_REGION_11.
	LOCKBIT_WORD0_LOCK_REGION_11 = 0x800
	// Position of LOCK_REGION_12 field.
	LOCKBIT_WORD0_LOCK_REGION_12_Pos = 0xc
	// Bit mask of LOCK_REGION_12 field.
	LOCKBIT_WORD0_LOCK_REGION_12_Msk = 0x1000
	// Bit LOCK_REGION_12.
	LOCKBIT_WORD0_LOCK_REGION_12 = 0x1000
	// Position of LOCK_REGION_13 field.
	LOCKBIT_WORD0_LOCK_REGION_13_Pos = 0xd
	// Bit mask of LOCK_REGION_13 field.
	LOCKBIT_WORD0_LOCK_REGION_13_Msk = 0x2000
	// Bit LOCK_REGION_13.
	LOCKBIT_WORD0_LOCK_REGION_13 = 0x2000
	// Position of LOCK_REGION_14 field.
	LOCKBIT_WORD0_LOCK_REGION_14_Pos = 0xe
	// Bit mask of LOCK_REGION_14 field.
	LOCKBIT_WORD0_LOCK_REGION_14_Msk = 0x4000
	// Bit LOCK_REGION_14.
	LOCKBIT_WORD0_LOCK_REGION_14 = 0x4000
	// Position of LOCK_REGION_15 field.
	LOCKBIT_WORD0_LOCK_REGION_15_Pos = 0xf
	// Bit mask of LOCK_REGION_15 field.
	LOCKBIT_WORD0_LOCK_REGION_15_Msk = 0x8000
	// Bit LOCK_REGION_15.
	LOCKBIT_WORD0_LOCK_REGION_15 = 0x8000
	// Position of LOCK_REGION_16 field.
	LOCKBIT_WORD0_LOCK_REGION_16_Pos = 0x10
	// Bit mask of LOCK_REGION_16 field.
	LOCKBIT_WORD0_LOCK_REGION_16_Msk = 0x10000
	// Bit LOCK_REGION_16.
	LOCKBIT_WORD0_LOCK_REGION_16 = 0x10000
	// Position of LOCK_REGION_17 field.
	LOCKBIT_WORD0_LOCK_REGION_17_Pos = 0x11
	// Bit mask of LOCK_REGION_17 field.
	LOCKBIT_WORD0_LOCK_REGION_17_Msk = 0x20000
	// Bit LOCK_REGION_17.
	LOCKBIT_WORD0_LOCK_REGION_17 = 0x20000
	// Position of LOCK_REGION_18 field.
	LOCKBIT_WORD0_LOCK_REGION_18_Pos = 0x12
	// Bit mask of LOCK_REGION_18 field.
	LOCKBIT_WORD0_LOCK_REGION_18_Msk = 0x40000
	// Bit LOCK_REGION_18.
	LOCKBIT_WORD0_LOCK_REGION_18 = 0x40000
	// Position of LOCK_REGION_19 field.
	LOCKBIT_WORD0_LOCK_REGION_19_Pos = 0x13
	// Bit mask of LOCK_REGION_19 field.
	LOCKBIT_WORD0_LOCK_REGION_19_Msk = 0x80000
	// Bit LOCK_REGION_19.
	LOCKBIT_WORD0_LOCK_REGION_19 = 0x80000
	// Position of LOCK_REGION_20 field.
	LOCKBIT_WORD0_LOCK_REGION_20_Pos = 0x14
	// Bit mask of LOCK_REGION_20 field.
	LOCKBIT_WORD0_LOCK_REGION_20_Msk = 0x100000
	// Bit LOCK_REGION_20.
	LOCKBIT_WORD0_LOCK_REGION_20 = 0x100000
	// Position of LOCK_REGION_21 field.
	LOCKBIT_WORD0_LOCK_REGION_21_Pos = 0x15
	// Bit mask of LOCK_REGION_21 field.
	LOCKBIT_WORD0_LOCK_REGION_21_Msk = 0x200000
	// Bit LOCK_REGION_21.
	LOCKBIT_WORD0_LOCK_REGION_21 = 0x200000
	// Position of LOCK_REGION_22 field.
	LOCKBIT_WORD0_LOCK_REGION_22_Pos = 0x16
	// Bit mask of LOCK_REGION_22 field.
	LOCKBIT_WORD0_LOCK_REGION_22_Msk = 0x400000
	// Bit LOCK_REGION_22.
	LOCKBIT_WORD0_LOCK_REGION_22 = 0x400000
	// Position of LOCK_REGION_23 field.
	LOCKBIT_WORD0_LOCK_REGION_23_Pos = 0x17
	// Bit mask of LOCK_REGION_23 field.
	LOCKBIT_WORD0_LOCK_REGION_23_Msk = 0x800000
	// Bit LOCK_REGION_23.
	LOCKBIT_WORD0_LOCK_REGION_23 = 0x800000
	// Position of LOCK_REGION_24 field.
	LOCKBIT_WORD0_LOCK_REGION_24_Pos = 0x18
	// Bit mask of LOCK_REGION_24 field.
	LOCKBIT_WORD0_LOCK_REGION_24_Msk = 0x1000000
	// Bit LOCK_REGION_24.
	LOCKBIT_WORD0_LOCK_REGION_24 = 0x1000000
	// Position of LOCK_REGION_25 field.
	LOCKBIT_WORD0_LOCK_REGION_25_Pos = 0x19
	// Bit mask of LOCK_REGION_25 field.
	LOCKBIT_WORD0_LOCK_REGION_25_Msk = 0x2000000
	// Bit LOCK_REGION_25.
	LOCKBIT_WORD0_LOCK_REGION_25 = 0x2000000
	// Position of LOCK_REGION_26 field.
	LOCKBIT_WORD0_LOCK_REGION_26_Pos = 0x1a
	// Bit mask of LOCK_REGION_26 field.
	LOCKBIT_WORD0_LOCK_REGION_26_Msk = 0x4000000
	// Bit LOCK_REGION_26.
	LOCKBIT_WORD0_LOCK_REGION_26 = 0x4000000
	// Position of LOCK_REGION_27 field.
	LOCKBIT_WORD0_LOCK_REGION_27_Pos = 0x1b
	// Bit mask of LOCK_REGION_27 field.
	LOCKBIT_WORD0_LOCK_REGION_27_Msk = 0x8000000
	// Bit LOCK_REGION_27.
	LOCKBIT_WORD0_LOCK_REGION_27 = 0x8000000
	// Position of LOCK_REGION_28 field.
	LOCKBIT_WORD0_LOCK_REGION_28_Pos = 0x1c
	// Bit mask of LOCK_REGION_28 field.
	LOCKBIT_WORD0_LOCK_REGION_28_Msk = 0x10000000
	// Bit LOCK_REGION_28.
	LOCKBIT_WORD0_LOCK_REGION_28 = 0x10000000
	// Position of LOCK_REGION_29 field.
	LOCKBIT_WORD0_LOCK_REGION_29_Pos = 0x1d
	// Bit mask of LOCK_REGION_29 field.
	LOCKBIT_WORD0_LOCK_REGION_29_Msk = 0x20000000
	// Bit LOCK_REGION_29.
	LOCKBIT_WORD0_LOCK_REGION_29 = 0x20000000
	// Position of LOCK_REGION_30 field.
	LOCKBIT_WORD0_LOCK_REGION_30_Pos = 0x1e
	// Bit mask of LOCK_REGION_30 field.
	LOCKBIT_WORD0_LOCK_REGION_30_Msk = 0x40000000
	// Bit LOCK_REGION_30.
	LOCKBIT_WORD0_LOCK_REGION_30 = 0x40000000
	// Position of LOCK_REGION_31 field.
	LOCKBIT_WORD0_LOCK_REGION_31_Pos = 0x1f
	// Bit mask of LOCK_REGION_31 field.
	LOCKBIT_WORD0_LOCK_REGION_31_Msk = 0x80000000
	// Bit LOCK_REGION_31.
	LOCKBIT_WORD0_LOCK_REGION_31 = 0x80000000
)

// Constants for SCnSCB: System control not in SCB
const (
	// ICTR: Interrupt Controller Type Register
	// Position of INTLINESNUM field.
	SCnSCB_ICTR_INTLINESNUM_Pos = 0x0
	// Bit mask of INTLINESNUM field.
	SCnSCB_ICTR_INTLINESNUM_Msk = 0xf

	// ACTLR: Auxiliary Control Register
	// Position of DISFOLD field.
	SCnSCB_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SCnSCB_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SCnSCB_ACTLR_DISFOLD = 0x4
	// Position of FPEXCODIS field.
	SCnSCB_ACTLR_FPEXCODIS_Pos = 0xa
	// Bit mask of FPEXCODIS field.
	SCnSCB_ACTLR_FPEXCODIS_Msk = 0x400
	// Bit FPEXCODIS.
	SCnSCB_ACTLR_FPEXCODIS = 0x400
	// Position of DISRAMODE field.
	SCnSCB_ACTLR_DISRAMODE_Pos = 0xb
	// Bit mask of DISRAMODE field.
	SCnSCB_ACTLR_DISRAMODE_Msk = 0x800
	// Bit DISRAMODE.
	SCnSCB_ACTLR_DISRAMODE = 0x800
	// Position of DISITMATBFLUSH field.
	SCnSCB_ACTLR_DISITMATBFLUSH_Pos = 0xc
	// Bit mask of DISITMATBFLUSH field.
	SCnSCB_ACTLR_DISITMATBFLUSH_Msk = 0x1000
	// Bit DISITMATBFLUSH.
	SCnSCB_ACTLR_DISITMATBFLUSH = 0x1000
	// Position of DISBTACREAD field.
	SCnSCB_ACTLR_DISBTACREAD_Pos = 0xd
	// Bit mask of DISBTACREAD field.
	SCnSCB_ACTLR_DISBTACREAD_Msk = 0x2000
	// Bit DISBTACREAD.
	SCnSCB_ACTLR_DISBTACREAD = 0x2000
	// Position of DISBTACALLOC field.
	SCnSCB_ACTLR_DISBTACALLOC_Pos = 0xe
	// Bit mask of DISBTACALLOC field.
	SCnSCB_ACTLR_DISBTACALLOC_Msk = 0x4000
	// Bit DISBTACALLOC.
	SCnSCB_ACTLR_DISBTACALLOC = 0x4000
	// Position of DISCRITAXIRUR field.
	SCnSCB_ACTLR_DISCRITAXIRUR_Pos = 0xf
	// Bit mask of DISCRITAXIRUR field.
	SCnSCB_ACTLR_DISCRITAXIRUR_Msk = 0x8000
	// Bit DISCRITAXIRUR.
	SCnSCB_ACTLR_DISCRITAXIRUR = 0x8000
	// Position of DISDI field.
	SCnSCB_ACTLR_DISDI_Pos = 0x10
	// Bit mask of DISDI field.
	SCnSCB_ACTLR_DISDI_Msk = 0x1f0000
	// Position of DISISSCH1 field.
	SCnSCB_ACTLR_DISISSCH1_Pos = 0x15
	// Bit mask of DISISSCH1 field.
	SCnSCB_ACTLR_DISISSCH1_Msk = 0x3e00000
	// Position of DISDYNADD field.
	SCnSCB_ACTLR_DISDYNADD_Pos = 0x1a
	// Bit mask of DISDYNADD field.
	SCnSCB_ACTLR_DISDYNADD_Msk = 0x4000000
	// Bit DISDYNADD.
	SCnSCB_ACTLR_DISDYNADD = 0x4000000
	// Position of DISCRITAXIRUW field.
	SCnSCB_ACTLR_DISCRITAXIRUW_Pos = 0x1b
	// Bit mask of DISCRITAXIRUW field.
	SCnSCB_ACTLR_DISCRITAXIRUW_Msk = 0x8000000
	// Bit DISCRITAXIRUW.
	SCnSCB_ACTLR_DISCRITAXIRUW = 0x8000000
	// Position of DISFPUISSOPT field.
	SCnSCB_ACTLR_DISFPUISSOPT_Pos = 0x1c
	// Bit mask of DISFPUISSOPT field.
	SCnSCB_ACTLR_DISFPUISSOPT_Msk = 0x10000000
	// Bit DISFPUISSOPT.
	SCnSCB_ACTLR_DISFPUISSOPT = 0x10000000
)

// Constants for SCB: System Control Block
const (
	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SCB_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SCB_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SCB_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SCB_CPUID_PARTNO_Msk = 0xfff0
	// Position of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Pos = 0x10
	// Bit mask of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Msk = 0xf0000
	// Position of VARIANT field.
	SCB_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SCB_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// there are preempted active exceptions to execute
	SCB_ICSR_RETTOBASE_VALUE_0 = 0x0
	// there are no active exceptions, or the currently-executing exception is the only active exception
	SCB_ICSR_RETTOBASE_VALUE_1 = 0x1
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x3f000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// Position of ISRPREEMPT field.
	SCB_ICSR_ISRPREEMPT_Pos = 0x17
	// Bit mask of ISRPREEMPT field.
	SCB_ICSR_ISRPREEMPT_Msk = 0x800000
	// Bit ISRPREEMPT.
	SCB_ICSR_ISRPREEMPT = 0x800000
	// Will not service
	SCB_ICSR_ISRPREEMPT_VALUE_0 = 0x0
	// Will service a pending exception
	SCB_ICSR_ISRPREEMPT_VALUE_1 = 0x1
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// no effect
	SCB_ICSR_PENDSTCLR_VALUE_0 = 0x0
	// removes the pending state from the SysTick exception
	SCB_ICSR_PENDSTCLR_VALUE_1 = 0x1
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// write: no effect; read: SysTick exception is not pending
	SCB_ICSR_PENDSTSET_VALUE_0 = 0x0
	// write: changes SysTick exception state to pending; read: SysTick exception is pending
	SCB_ICSR_PENDSTSET_VALUE_1 = 0x1
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// no effect
	SCB_ICSR_PENDSVCLR_VALUE_0 = 0x0
	// removes the pending state from the PendSV exception
	SCB_ICSR_PENDSVCLR_VALUE_1 = 0x1
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// write: no effect; read: PendSV exception is not pending
	SCB_ICSR_PENDSVSET_VALUE_0 = 0x0
	// write: changes PendSV exception state to pending; read: PendSV exception is pending
	SCB_ICSR_PENDSVSET_VALUE_1 = 0x1
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000
	// write: no effect; read: NMI exception is not pending
	SCB_ICSR_NMIPENDSET_VALUE_0 = 0x0
	// write: changes NMI exception state to pending; read: NMI exception is pending
	SCB_ICSR_NMIPENDSET_VALUE_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// no system reset request
	SCB_AIRCR_SYSRESETREQ_VALUE_0 = 0x0
	// asserts a signal to the outer system that requests a reset
	SCB_AIRCR_SYSRESETREQ_VALUE_1 = 0x1
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SCB_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SCB_AIRCR_ENDIANNESS_VALUE_0 = 0x0
	// Big-endian
	SCB_AIRCR_ENDIANNESS_VALUE_1 = 0x1
	// Position of VECTKEY field.
	SCB_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SCB_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// o not sleep when returning to Thread mode
	SCB_SCR_SLEEPONEXIT_VALUE_0 = 0x0
	// enter sleep, or deep sleep, on return from an ISR
	SCB_SCR_SLEEPONEXIT_VALUE_1 = 0x1
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// sleep
	SCB_SCR_SLEEPDEEP_VALUE_0 = 0x0
	// deep sleep
	SCB_SCR_SLEEPDEEP_VALUE_1 = 0x1
	// Position of SEVONPEND field.
	SCB_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SCB_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SCB_SCR_SEVONPEND = 0x10
	// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SCB_SCR_SEVONPEND_VALUE_0 = 0x0
	// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SCB_SCR_SEVONPEND_VALUE_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// processor can enter Thread mode only when no exception is active
	SCB_CCR_NONBASETHRDENA_VALUE_0 = 0x0
	// processor can enter Thread mode from any level under the control of an EXC_RETURN value
	SCB_CCR_NONBASETHRDENA_VALUE_1 = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// disable
	SCB_CCR_USERSETMPEND_VALUE_0 = 0x0
	// enable
	SCB_CCR_USERSETMPEND_VALUE_1 = 0x1
	// Position of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SCB_CCR_UNALIGN_TRP = 0x8
	// do not trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_VALUE_0 = 0x0
	// trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_VALUE_1 = 0x1
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// do not trap divide by 0
	SCB_CCR_DIV_0_TRP_VALUE_0 = 0x0
	// trap divide by 0
	SCB_CCR_DIV_0_TRP_VALUE_1 = 0x1
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// data bus faults caused by load and store instructions cause a lock-up
	SCB_CCR_BFHFNMIGN_VALUE_0 = 0x0
	// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
	SCB_CCR_BFHFNMIGN_VALUE_1 = 0x1
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SCB_CCR_STKALIGN_VALUE_0 = 0x0
	// 8-byte aligned
	SCB_CCR_STKALIGN_VALUE_1 = 0x1
	// Position of DC field.
	SCB_CCR_DC_Pos = 0x10
	// Bit mask of DC field.
	SCB_CCR_DC_Msk = 0x10000
	// Bit DC.
	SCB_CCR_DC = 0x10000
	// Position of IC field.
	SCB_CCR_IC_Pos = 0x11
	// Bit mask of IC field.
	SCB_CCR_IC_Msk = 0x20000
	// Bit IC.
	SCB_CCR_IC = 0x20000
	// Position of BP field.
	SCB_CCR_BP_Pos = 0x12
	// Bit mask of BP field.
	SCB_CCR_BP_Msk = 0x40000
	// Bit BP.
	SCB_CCR_BP = 0x40000

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_12 field.
	SCB_SHPR3_PRI_12_Pos = 0x0
	// Bit mask of PRI_12 field.
	SCB_SHPR3_PRI_12_Msk = 0xff
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// exception is not active
	SCB_SHCSR_MEMFAULTACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_MEMFAULTACT_VALUE_1 = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// exception is not active
	SCB_SHCSR_BUSFAULTACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_BUSFAULTACT_VALUE_1 = 0x1
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// exception is not active
	SCB_SHCSR_USGFAULTACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_USGFAULTACT_VALUE_1 = 0x1
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// exception is not active
	SCB_SHCSR_SVCALLACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_SVCALLACT_VALUE_1 = 0x1
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// exception is not active
	SCB_SHCSR_MONITORACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_MONITORACT_VALUE_1 = 0x1
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// exception is not active
	SCB_SHCSR_PENDSVACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_PENDSVACT_VALUE_1 = 0x1
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// exception is not active
	SCB_SHCSR_SYSTICKACT_VALUE_0 = 0x0
	// exception is active
	SCB_SHCSR_SYSTICKACT_VALUE_1 = 0x1
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// exception is not pending
	SCB_SHCSR_USGFAULTPENDED_VALUE_0 = 0x0
	// exception is pending
	SCB_SHCSR_USGFAULTPENDED_VALUE_1 = 0x1
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// exception is not pending
	SCB_SHCSR_MEMFAULTPENDED_VALUE_0 = 0x0
	// exception is pending
	SCB_SHCSR_MEMFAULTPENDED_VALUE_1 = 0x1
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// exception is not pending
	SCB_SHCSR_BUSFAULTPENDED_VALUE_0 = 0x0
	// exception is pending
	SCB_SHCSR_BUSFAULTPENDED_VALUE_1 = 0x1
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// exception is not pending
	SCB_SHCSR_SVCALLPENDED_VALUE_0 = 0x0
	// exception is pending
	SCB_SHCSR_SVCALLPENDED_VALUE_1 = 0x1
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// disable the exception
	SCB_SHCSR_MEMFAULTENA_VALUE_0 = 0x0
	// enable the exception
	SCB_SHCSR_MEMFAULTENA_VALUE_1 = 0x1
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// disable the exception
	SCB_SHCSR_BUSFAULTENA_VALUE_0 = 0x0
	// enable the exception
	SCB_SHCSR_BUSFAULTENA_VALUE_1 = 0x1
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000
	// disable the exception
	SCB_SHCSR_USGFAULTENA_VALUE_0 = 0x0
	// enable the exception
	SCB_SHCSR_USGFAULTENA_VALUE_1 = 0x1

	// CFSR: Configurable Fault Status Registers
	// Position of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SCB_CFSR_IACCVIOL = 0x1
	// no instruction access violation fault
	SCB_CFSR_IACCVIOL_VALUE_0 = 0x0
	// the processor attempted an instruction fetch from a location that does not permit execution
	SCB_CFSR_IACCVIOL_VALUE_1 = 0x1
	// Position of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SCB_CFSR_DACCVIOL = 0x2
	// no data access violation fault
	SCB_CFSR_DACCVIOL_VALUE_0 = 0x0
	// the processor attempted a load or store at a location that does not permit the operation
	SCB_CFSR_DACCVIOL_VALUE_1 = 0x1
	// Position of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_MUNSTKERR = 0x8
	// no unstacking fault
	SCB_CFSR_MUNSTKERR_VALUE_0 = 0x0
	// unstack for an exception return has caused one or more access violations
	SCB_CFSR_MUNSTKERR_VALUE_1 = 0x1
	// Position of MSTKERR field.
	SCB_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_MSTKERR = 0x10
	// no stacking fault
	SCB_CFSR_MSTKERR_VALUE_0 = 0x0
	// stacking for an exception entry has caused one or more access violations
	SCB_CFSR_MSTKERR_VALUE_1 = 0x1
	// Position of MLSPERR field.
	SCB_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_MLSPERR = 0x20
	// No MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_VALUE_0 = 0x0
	// A MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_VALUE_1 = 0x1
	// Position of MMARVALID field.
	SCB_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_MMARVALID = 0x80
	// value in MMAR is not a valid fault address
	SCB_CFSR_MMARVALID_VALUE_0 = 0x0
	// MMAR holds a valid fault address
	SCB_CFSR_MMARVALID_VALUE_1 = 0x1
	// Position of IBUSERR field.
	SCB_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_IBUSERR = 0x100
	// no instruction bus error
	SCB_CFSR_IBUSERR_VALUE_0 = 0x0
	// instruction bus error
	SCB_CFSR_IBUSERR_VALUE_1 = 0x1
	// Position of PRECISERR field.
	SCB_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_PRECISERR = 0x200
	// no precise data bus error
	SCB_CFSR_PRECISERR_VALUE_0 = 0x0
	// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
	SCB_CFSR_PRECISERR_VALUE_1 = 0x1
	// Position of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_IMPRECISERR = 0x400
	// no imprecise data bus error
	SCB_CFSR_IMPRECISERR_VALUE_0 = 0x0
	// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
	SCB_CFSR_IMPRECISERR_VALUE_1 = 0x1
	// Position of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UNSTKERR = 0x800
	// no unstacking fault
	SCB_CFSR_UNSTKERR_VALUE_0 = 0x0
	// unstack for an exception return has caused one or more BusFaults
	SCB_CFSR_UNSTKERR_VALUE_1 = 0x1
	// Position of STKERR field.
	SCB_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_STKERR = 0x1000
	// no stacking fault
	SCB_CFSR_STKERR_VALUE_0 = 0x0
	// stacking for an exception entry has caused one or more BusFaults
	SCB_CFSR_STKERR_VALUE_1 = 0x1
	// Position of LSPERR field.
	SCB_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_LSPERR = 0x2000
	// No bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_VALUE_0 = 0x0
	// A bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_VALUE_1 = 0x1
	// Position of BFARVALID field.
	SCB_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_BFARVALID = 0x8000
	// value in BFAR is not a valid fault address
	SCB_CFSR_BFARVALID_VALUE_0 = 0x0
	// BFAR holds a valid fault address
	SCB_CFSR_BFARVALID_VALUE_1 = 0x1
	// Position of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UNDEFINSTR = 0x10000
	// no undefined instruction UsageFault
	SCB_CFSR_UNDEFINSTR_VALUE_0 = 0x0
	// the processor has attempted to execute an undefined instruction
	SCB_CFSR_UNDEFINSTR_VALUE_1 = 0x1
	// Position of INVSTATE field.
	SCB_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_INVSTATE = 0x20000
	// no invalid state UsageFault
	SCB_CFSR_INVSTATE_VALUE_0 = 0x0
	// the processor has attempted to execute an instruction that makes illegal use of the EPSR
	SCB_CFSR_INVSTATE_VALUE_1 = 0x1
	// Position of INVPC field.
	SCB_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_INVPC = 0x40000
	// no invalid PC load UsageFault
	SCB_CFSR_INVPC_VALUE_0 = 0x0
	// the processor has attempted an illegal load of EXC_RETURN to the PC
	SCB_CFSR_INVPC_VALUE_1 = 0x1
	// Position of NOCP field.
	SCB_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_NOCP = 0x80000
	// no UsageFault caused by attempting to access a coprocessor
	SCB_CFSR_NOCP_VALUE_0 = 0x0
	// the processor has attempted to access a coprocessor
	SCB_CFSR_NOCP_VALUE_1 = 0x1
	// Position of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UNALIGNED = 0x1000000
	// no unaligned access fault, or unaligned access trapping not enabled
	SCB_CFSR_UNALIGNED_VALUE_0 = 0x0
	// the processor has made an unaligned memory access
	SCB_CFSR_UNALIGNED_VALUE_1 = 0x1
	// Position of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_DIVBYZERO = 0x2000000
	// no divide by zero fault, or divide by zero trapping not enabled
	SCB_CFSR_DIVBYZERO_VALUE_0 = 0x0
	// the processor has executed an SDIV or UDIV instruction with a divisor of 0
	SCB_CFSR_DIVBYZERO_VALUE_1 = 0x1

	// HFSR: HardFault Status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// no BusFault on vector table read
	SCB_HFSR_VECTTBL_VALUE_0 = 0x0
	// BusFault on vector table read
	SCB_HFSR_VECTTBL_VALUE_1 = 0x1
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// no forced HardFault
	SCB_HFSR_FORCED_VALUE_0 = 0x0
	// forced HardFault
	SCB_HFSR_FORCED_VALUE_1 = 0x1
	// Position of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SCB_HFSR_DEBUGEVT = 0x80000000

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SCB_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SCB_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SCB_DFSR_HALTED = 0x1
	// No active halt request debug event
	SCB_DFSR_HALTED_VALUE_0 = 0x0
	// Halt request debug event active
	SCB_DFSR_HALTED_VALUE_1 = 0x1
	// Position of BKPT field.
	SCB_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SCB_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SCB_DFSR_BKPT = 0x2
	// No current breakpoint debug event
	SCB_DFSR_BKPT_VALUE_0 = 0x0
	// At least one current breakpoint debug event
	SCB_DFSR_BKPT_VALUE_1 = 0x1
	// Position of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SCB_DFSR_DWTTRAP = 0x4
	// No current debug events generated by the DWT
	SCB_DFSR_DWTTRAP_VALUE_0 = 0x0
	// At least one current debug event generated by the DWT
	SCB_DFSR_DWTTRAP_VALUE_1 = 0x1
	// Position of VCATCH field.
	SCB_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SCB_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SCB_DFSR_VCATCH = 0x8
	// No Vector catch triggered
	SCB_DFSR_VCATCH_VALUE_0 = 0x0
	// Vector catch triggered
	SCB_DFSR_VCATCH_VALUE_1 = 0x1
	// Position of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SCB_DFSR_EXTERNAL = 0x10
	// No EDBGRQ debug event
	SCB_DFSR_EXTERNAL_VALUE_0 = 0x0
	// EDBGRQ debug event
	SCB_DFSR_EXTERNAL_VALUE_1 = 0x1

	// MMFAR: MemManage Fault Address Register
	// Position of ADDRESS field.
	SCB_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SCB_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_BFAR_ADDRESS_Msk = 0xffffffff

	// CLIDR: Cache Level ID Register
	// Position of LoC field.
	SCB_CLIDR_LoC_Pos = 0x18
	// Bit mask of LoC field.
	SCB_CLIDR_LoC_Msk = 0x7000000
	// if neither instruction nor data cache is implemented
	SCB_CLIDR_LoC_LEVEL_1 = 0x0
	// if either cache is implemented
	SCB_CLIDR_LoC_LEVEL_2 = 0x1
	// Position of LoU field.
	SCB_CLIDR_LoU_Pos = 0x1b
	// Bit mask of LoU field.
	SCB_CLIDR_LoU_Msk = 0x38000000
	// if neither instruction nor data cache is implemented
	SCB_CLIDR_LoU_LEVEL_1 = 0x0
	// if either cache is implemented
	SCB_CLIDR_LoU_LEVEL_2 = 0x1

	// CTR: Cache Type Register
	// Position of IMINLINE field.
	SCB_CTR_IMINLINE_Pos = 0x0
	// Bit mask of IMINLINE field.
	SCB_CTR_IMINLINE_Msk = 0xf
	// Position of DMINLINE field.
	SCB_CTR_DMINLINE_Pos = 0x10
	// Bit mask of DMINLINE field.
	SCB_CTR_DMINLINE_Msk = 0xf0000
	// Position of ERG field.
	SCB_CTR_ERG_Pos = 0x14
	// Bit mask of ERG field.
	SCB_CTR_ERG_Msk = 0xf00000
	// Position of CWG field.
	SCB_CTR_CWG_Pos = 0x18
	// Bit mask of CWG field.
	SCB_CTR_CWG_Msk = 0xf000000
	// Position of FORMAT field.
	SCB_CTR_FORMAT_Pos = 0x1d
	// Bit mask of FORMAT field.
	SCB_CTR_FORMAT_Msk = 0xe0000000

	// CCSIDR: Cache Size ID Register
	// Position of LineSize field.
	SCB_CCSIDR_LineSize_Pos = 0x0
	// Bit mask of LineSize field.
	SCB_CCSIDR_LineSize_Msk = 0x7
	// Position of Associativity field.
	SCB_CCSIDR_Associativity_Pos = 0x3
	// Bit mask of Associativity field.
	SCB_CCSIDR_Associativity_Msk = 0xff8
	// Position of NumSets field.
	SCB_CCSIDR_NumSets_Pos = 0xc
	// Bit mask of NumSets field.
	SCB_CCSIDR_NumSets_Msk = 0xffff000
	// Position of WA field.
	SCB_CCSIDR_WA_Pos = 0x1c
	// Bit mask of WA field.
	SCB_CCSIDR_WA_Msk = 0x10000000
	// Bit WA.
	SCB_CCSIDR_WA = 0x10000000
	// Position of RA field.
	SCB_CCSIDR_RA_Pos = 0x1d
	// Bit mask of RA field.
	SCB_CCSIDR_RA_Msk = 0x20000000
	// Bit RA.
	SCB_CCSIDR_RA = 0x20000000
	// Position of WB field.
	SCB_CCSIDR_WB_Pos = 0x1e
	// Bit mask of WB field.
	SCB_CCSIDR_WB_Msk = 0x40000000
	// Bit WB.
	SCB_CCSIDR_WB = 0x40000000
	// Position of WT field.
	SCB_CCSIDR_WT_Pos = 0x1f
	// Bit mask of WT field.
	SCB_CCSIDR_WT_Msk = 0x80000000
	// Bit WT.
	SCB_CCSIDR_WT = 0x80000000

	// CSSELR: Cache Size Selection Register
	// Position of IND field.
	SCB_CSSELR_IND_Pos = 0x0
	// Bit mask of IND field.
	SCB_CSSELR_IND_Msk = 0x1
	// Bit IND.
	SCB_CSSELR_IND = 0x1
	// Data cache
	SCB_CSSELR_IND_DATA = 0x0
	// Instruction cache
	SCB_CSSELR_IND_INSTRUCTION = 0x1
	// Position of LEVEL field.
	SCB_CSSELR_LEVEL_Pos = 0x1
	// Bit mask of LEVEL field.
	SCB_CSSELR_LEVEL_Msk = 0xe

	// CPACR: Coprocessor Access Control Register
	// Position of CP10 field.
	SCB_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SCB_CPACR_CP10_Msk = 0x300000
	// Position of CP11 field.
	SCB_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SCB_CPACR_CP11_Msk = 0xc00000

	// STIR: Software Trigger Interrupt Register
	// Position of INTID field.
	SCB_STIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	SCB_STIR_INTID_Msk = 0x1ff
)

// Constants for SysTick: System timer
const (
	// CSR: Control and Status Register
	// Position of ENABLE field.
	SysTick_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SysTick_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SysTick_CSR_ENABLE = 0x1
	// counter disabled
	SysTick_CSR_ENABLE_VALUE_0 = 0x0
	// counter enabled
	SysTick_CSR_ENABLE_VALUE_1 = 0x1
	// Position of TICKINT field.
	SysTick_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	SysTick_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	SysTick_CSR_TICKINT = 0x2
	// counting down to 0 does not assert the SysTick exception request
	SysTick_CSR_TICKINT_VALUE_0 = 0x0
	// counting down to 0 asserts the SysTick exception request
	SysTick_CSR_TICKINT_VALUE_1 = 0x1
	// Position of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	SysTick_CSR_CLKSOURCE = 0x4
	// external clock
	SysTick_CSR_CLKSOURCE_VALUE_0 = 0x0
	// processor clock
	SysTick_CSR_CLKSOURCE_VALUE_1 = 0x1
	// Position of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	SysTick_CSR_COUNTFLAG = 0x10000

	// RVR: Reload Value Register
	// Position of RELOAD field.
	SysTick_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	SysTick_RVR_RELOAD_Msk = 0xffffff

	// CVR: Current Value Register
	// Position of CURRENT field.
	SysTick_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	SysTick_CVR_CURRENT_Msk = 0xffffff

	// CALIB: Calibration Value Register
	// Position of TENMS field.
	SysTick_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	SysTick_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	SysTick_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	SysTick_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	SysTick_CALIB_SKEW = 0x40000000
	// 10ms calibration value is exact
	SysTick_CALIB_SKEW_VALUE_0 = 0x0
	// 10ms calibration value is inexact, because of the clock frequency
	SysTick_CALIB_SKEW_VALUE_1 = 0x1
	// Position of NOREF field.
	SysTick_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	SysTick_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	SysTick_CALIB_NOREF = 0x80000000
	// The reference clock is provided
	SysTick_CALIB_NOREF_VALUE_0 = 0x0
	// The reference clock is not provided
	SysTick_CALIB_NOREF_VALUE_1 = 0x1
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_ISER_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER_SETENA_Msk = 0xffffffff

	// ICER: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_ICER_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER_CLRENA_Msk = 0xffffffff

	// ISPR: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_ISPR_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR_SETPEND_Msk = 0xffffffff

	// ICPR: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_ICPR_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR_CLRPEND_Msk = 0xffffffff

	// IABR: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_IABR_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR_ACTIVE_Msk = 0xffffffff

	// IP: Interrupt Priority Register (8Bit wide) n
	// Position of PRI0 field.
	NVIC_IP_PRI0_Pos = 0x0
	// Bit mask of PRI0 field.
	NVIC_IP_PRI0_Msk = 0xff

	// STIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_STIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_STIR_INTID_Msk = 0x1ff
)

// Constants for MPU: Memory Protection Unit
const (
	// TYPE: MPU Type Register
	// Position of SEPARATE field.
	MPU_TYPE_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPE_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPE_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPE_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPE_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPE_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPE_IREGION_Msk = 0xff0000

	// CTRL: MPU Control Register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU Region Number Register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU Region Base Address Register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU Region Attribute and Size Register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for FPU: Floating Point Unit
const (
	// FPCCR: Floating-point Context Control Register
	// Position of LSPACT field.
	FPU_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	FPU_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	FPU_FPCCR_LSPACT = 0x1
	// Position of USER field.
	FPU_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	FPU_FPCCR_USER_Msk = 0x2
	// Bit USER.
	FPU_FPCCR_USER = 0x2
	// Position of THREAD field.
	FPU_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	FPU_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	FPU_FPCCR_THREAD = 0x8
	// Position of HFRDY field.
	FPU_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	FPU_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	FPU_FPCCR_HFRDY = 0x10
	// Position of MMRDY field.
	FPU_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	FPU_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	FPU_FPCCR_MMRDY = 0x20
	// Position of BFRDY field.
	FPU_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	FPU_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	FPU_FPCCR_BFRDY = 0x40
	// Position of MONRDY field.
	FPU_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	FPU_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	FPU_FPCCR_MONRDY = 0x100
	// Position of LSPEN field.
	FPU_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	FPU_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	FPU_FPCCR_LSPEN = 0x40000000
	// Position of ASPEN field.
	FPU_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	FPU_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	FPU_FPCCR_ASPEN = 0x80000000

	// FPCAR: Floating-point Context Address Register
	// Position of ADDRESS field.
	FPU_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	FPU_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPDSCR: Floating-point Default Status Control Register
	// Position of RMode field.
	FPU_FPDSCR_RMode_Pos = 0x16
	// Bit mask of RMode field.
	FPU_FPDSCR_RMode_Msk = 0xc00000
	// Position of FZ field.
	FPU_FPDSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	FPU_FPDSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	FPU_FPDSCR_FZ = 0x1000000
	// Position of DN field.
	FPU_FPDSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	FPU_FPDSCR_DN_Msk = 0x2000000
	// Bit DN.
	FPU_FPDSCR_DN = 0x2000000
	// Position of AHP field.
	FPU_FPDSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	FPU_FPDSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	FPU_FPDSCR_AHP = 0x4000000

	// MVFR0: Media and VFP Feature Register 0
	// Position of A_SIMD_registers field.
	FPU_MVFR0_A_SIMD_registers_Pos = 0x0
	// Bit mask of A_SIMD_registers field.
	FPU_MVFR0_A_SIMD_registers_Msk = 0xf
	// Position of Single_precision field.
	FPU_MVFR0_Single_precision_Pos = 0x4
	// Bit mask of Single_precision field.
	FPU_MVFR0_Single_precision_Msk = 0xf0
	// Position of Double_precision field.
	FPU_MVFR0_Double_precision_Pos = 0x8
	// Bit mask of Double_precision field.
	FPU_MVFR0_Double_precision_Msk = 0xf00
	// Position of FP_excep_trapping field.
	FPU_MVFR0_FP_excep_trapping_Pos = 0xc
	// Bit mask of FP_excep_trapping field.
	FPU_MVFR0_FP_excep_trapping_Msk = 0xf000
	// Position of Divide field.
	FPU_MVFR0_Divide_Pos = 0x10
	// Bit mask of Divide field.
	FPU_MVFR0_Divide_Msk = 0xf0000
	// Position of Square_root field.
	FPU_MVFR0_Square_root_Pos = 0x14
	// Bit mask of Square_root field.
	FPU_MVFR0_Square_root_Msk = 0xf00000
	// Position of Short_vectors field.
	FPU_MVFR0_Short_vectors_Pos = 0x18
	// Bit mask of Short_vectors field.
	FPU_MVFR0_Short_vectors_Msk = 0xf000000
	// Position of FP_rounding_modes field.
	FPU_MVFR0_FP_rounding_modes_Pos = 0x1c
	// Bit mask of FP_rounding_modes field.
	FPU_MVFR0_FP_rounding_modes_Msk = 0xf0000000

	// MVFR1: Media and VFP Feature Register 1
	// Position of FtZ_mode field.
	FPU_MVFR1_FtZ_mode_Pos = 0x0
	// Bit mask of FtZ_mode field.
	FPU_MVFR1_FtZ_mode_Msk = 0xf
	// Position of D_NaN_mode field.
	FPU_MVFR1_D_NaN_mode_Pos = 0x4
	// Bit mask of D_NaN_mode field.
	FPU_MVFR1_D_NaN_mode_Msk = 0xf0
	// Position of FP_HPFP field.
	FPU_MVFR1_FP_HPFP_Pos = 0x18
	// Bit mask of FP_HPFP field.
	FPU_MVFR1_FP_HPFP_Msk = 0xf000000
	// Position of FP_fused_MAC field.
	FPU_MVFR1_FP_fused_MAC_Pos = 0x1c
	// Bit mask of FP_fused_MAC field.
	FPU_MVFR1_FP_fused_MAC_Msk = 0xf0000000

	// MVFR2: Media and VFP Feature Register 2
	// Position of VFP_Misc field.
	FPU_MVFR2_VFP_Misc_Pos = 0x4
	// Bit mask of VFP_Misc field.
	FPU_MVFR2_VFP_Misc_Msk = 0xf0
)
