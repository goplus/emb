// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from AT91SAM9M11.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Atmel

//go:build sam && at91sam9m11

/*
// Atmel AT91SAM9M11 device: ARM926EJ Embedded Microprocessor Unit, 400MHz, Hardware Encryption, Video Decoder, DDR2/LPDDR, Dual EBI, 324 Pins (refer to http://www.atmel.com/devices/SAM9M11.aspx for more)
*/

package sam

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device = "AT91SAM9M11"
)

// Interrupt numbers.
const (
	// Advanced Interrupt Controller
	IRQ_FIQ = 0

	// DDR_SDR SDRAM Controller 0
	IRQ_DDRSDRC0 = 1

	// Parallel Input/Output Controller A
	IRQ_PIOA = 2

	// Parallel Input/Output Controller B
	IRQ_PIOB = 3

	// Parallel Input/Output Controller C
	IRQ_PIOC = 4

	// Parallel Input/Output Controller D
	IRQ_PIOD = 5

	// True Random Number Generator
	IRQ_TRNG = 6

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	IRQ_USART0 = 7

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	IRQ_USART1 = 8

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	IRQ_USART2 = 9

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	IRQ_USART3 = 10

	// High Speed MultiMedia Card Interface 0
	IRQ_HSMCI0 = 11

	// Two-wire Interface 0
	IRQ_TWI0 = 12

	// Two-wire Interface 1
	IRQ_TWI1 = 13

	// Serial Peripheral Interface 0
	IRQ_SPI0 = 14

	// Serial Peripheral Interface 1
	IRQ_SPI1 = 15

	// Synchronous Serial Controller 0
	IRQ_SSC0 = 16

	// Synchronous Serial Controller 1
	IRQ_SSC1 = 17

	// Timer Counter 0
	IRQ_TC0 = 18

	// Pulse Width Modulation Controller
	IRQ_PWM = 19

	// Touch Screen ADC Controller
	IRQ_TSADCC = 20

	// DMA Controller
	IRQ_DMAC = 21

	// LCD Controller
	IRQ_LCDC = 23

	// AC97 Controller
	IRQ_AC97C = 24

	// Ethernet MAC 10/100
	IRQ_EMAC = 25

	// Image Sensor Interface
	IRQ_ISI = 26

	// USB High Speed Device Port
	IRQ_UDPHS = 27

	// Advanced Encryption Standard
	IRQ_AES = 28

	// High Speed MultiMedia Card Interface 1
	IRQ_HSMCI1 = 29

	// Video Decoder
	IRQ_VDEC = 30

	// Advanced Interrupt Controller
	IRQ_IRQ = 31

	// Highest interrupt number on this device.
	IRQ_max = 31
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export FIQ_IRQHandler
func interruptFIQ() {
	callHandlers(IRQ_FIQ)
}

//export DDRSDRC0_IRQHandler
func interruptDDRSDRC0() {
	callHandlers(IRQ_DDRSDRC0)
}

//export PIOA_IRQHandler
func interruptPIOA() {
	callHandlers(IRQ_PIOA)
}

//export PIOB_IRQHandler
func interruptPIOB() {
	callHandlers(IRQ_PIOB)
}

//export PIOC_IRQHandler
func interruptPIOC() {
	callHandlers(IRQ_PIOC)
}

//export PIOD_IRQHandler
func interruptPIOD() {
	callHandlers(IRQ_PIOD)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export USART0_IRQHandler
func interruptUSART0() {
	callHandlers(IRQ_USART0)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export HSMCI0_IRQHandler
func interruptHSMCI0() {
	callHandlers(IRQ_HSMCI0)
}

//export TWI0_IRQHandler
func interruptTWI0() {
	callHandlers(IRQ_TWI0)
}

//export TWI1_IRQHandler
func interruptTWI1() {
	callHandlers(IRQ_TWI1)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SSC0_IRQHandler
func interruptSSC0() {
	callHandlers(IRQ_SSC0)
}

//export SSC1_IRQHandler
func interruptSSC1() {
	callHandlers(IRQ_SSC1)
}

//export TC0_IRQHandler
func interruptTC0() {
	callHandlers(IRQ_TC0)
}

//export PWM_IRQHandler
func interruptPWM() {
	callHandlers(IRQ_PWM)
}

//export TSADCC_IRQHandler
func interruptTSADCC() {
	callHandlers(IRQ_TSADCC)
}

//export DMAC_IRQHandler
func interruptDMAC() {
	callHandlers(IRQ_DMAC)
}

//export LCDC_IRQHandler
func interruptLCDC() {
	callHandlers(IRQ_LCDC)
}

//export AC97C_IRQHandler
func interruptAC97C() {
	callHandlers(IRQ_AC97C)
}

//export EMAC_IRQHandler
func interruptEMAC() {
	callHandlers(IRQ_EMAC)
}

//export ISI_IRQHandler
func interruptISI() {
	callHandlers(IRQ_ISI)
}

//export UDPHS_IRQHandler
func interruptUDPHS() {
	callHandlers(IRQ_UDPHS)
}

//export AES_IRQHandler
func interruptAES() {
	callHandlers(IRQ_AES)
}

//export HSMCI1_IRQHandler
func interruptHSMCI1() {
	callHandlers(IRQ_HSMCI1)
}

//export VDEC_IRQHandler
func interruptVDEC() {
	callHandlers(IRQ_VDEC)
}

//export IRQ_IRQHandler
func interruptIRQ() {
	callHandlers(IRQ_IRQ)
}

// Peripherals.
var (
	// LCD Controller
	LCDC = (*LCDC_Type)(unsafe.Pointer(uintptr(0x500000)))

	// Video Decoder
	VDEC = (*VDEC_Type)(unsafe.Pointer(uintptr(0x900000)))

	// USB High Speed Device Port
	UDPHS = (*UDPHS_Type)(unsafe.Pointer(uintptr(0xfff78000)))

	// Timer Counter 0
	TC0 = (*TC_Type)(unsafe.Pointer(uintptr(0xfff7c000)))

	// High Speed MultiMedia Card Interface 0
	HSMCI0 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xfff80000)))

	// Two-wire Interface 0
	TWI0 = (*TWI_Type)(unsafe.Pointer(uintptr(0xfff84000)))

	// Two-wire Interface 1
	TWI1 = (*TWI_Type)(unsafe.Pointer(uintptr(0xfff88000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0xfff8c000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0xfff90000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0xfff94000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0xfff98000)))

	// Synchronous Serial Controller 0
	SSC0 = (*SSC_Type)(unsafe.Pointer(uintptr(0xfff9c000)))

	// Synchronous Serial Controller 1
	SSC1 = (*SSC_Type)(unsafe.Pointer(uintptr(0xfffa0000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0xfffa4000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0xfffa8000)))

	// AC97 Controller
	AC97C = (*AC97C_Type)(unsafe.Pointer(uintptr(0xfffac000)))

	// Touch Screen ADC Controller
	TSADCC = (*TSADCC_Type)(unsafe.Pointer(uintptr(0xfffb0000)))

	// Image Sensor Interface
	ISI = (*ISI_Type)(unsafe.Pointer(uintptr(0xfffb4000)))

	// Pulse Width Modulation Controller
	PWM = (*PWM_Type)(unsafe.Pointer(uintptr(0xfffb8000)))

	// Ethernet MAC 10/100
	EMAC = (*EMAC_Type)(unsafe.Pointer(uintptr(0xfffbc000)))

	// Advanced Encryption Standard
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0xfffc0000)))

	// Triple Data Encryption Standard
	TDES = (*TDES_Type)(unsafe.Pointer(uintptr(0xfffc4000)))

	// Secure Hash Algorithm
	SHA = (*SHA_Type)(unsafe.Pointer(uintptr(0xfffc8000)))

	// True Random Number Generator
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0xfffcc000)))

	// High Speed MultiMedia Card Interface 1
	HSMCI1 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xfffd0000)))

	// Timer Counter 1
	TC1 = (*TC_Type)(unsafe.Pointer(uintptr(0xfffd4000)))

	// DDR_SDR SDRAM Controller 1
	DDRSDRC1 = (*EBI_Type)(unsafe.Pointer(uintptr(0xffffe400)))

	// DDR_SDR SDRAM Controller 0
	DDRSDRC0 = (*DDRSDRC_Type)(unsafe.Pointer(uintptr(0xffffe600)))

	// Static Memory Controller
	SMC = (*EBI_Type)(unsafe.Pointer(uintptr(0xffffe800)))

	// AHB Bus Matrix
	MATRIX = (*MATRIX_Type)(unsafe.Pointer(uintptr(0xffffea00)))

	// DMA Controller
	DMAC = (*DMAC_Type)(unsafe.Pointer(uintptr(0xffffec00)))

	// Debug Unit
	DBGU = (*DBGU_Type)(unsafe.Pointer(uintptr(0xffffee00)))

	// Advanced Interrupt Controller
	AIC = (*AIC_Type)(unsafe.Pointer(uintptr(0xfffff000)))

	// Parallel Input/Output Controller A
	PIOA = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff200)))

	// Parallel Input/Output Controller B
	PIOB = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff400)))

	// Parallel Input/Output Controller C
	PIOC = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff600)))

	// Parallel Input/Output Controller D
	PIOD = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff800)))

	// Parallel Input/Output Controller E
	PIOE = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffffa00)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0xfffffc00)))

	// Reset Controller
	RSTC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd00)))

	// Shutdown Controller
	SHDWC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd10)))

	// Real-time Timer
	RTT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd20)))

	// Periodic Interval Timer
	PIT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd30)))

	// Watchdog Timer
	WDT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd40)))

	// General Purpose Backup Register
	GPBR = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffd60)))

	// Real-time Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0xfffffdb0)))
)

// LCD Controller
type LCDC_Type struct {
	DMABADDR1    volatile.Register32 // 0x0
	DMABADDR2    volatile.Register32 // 0x4
	DMAFRMPT1    volatile.Register32 // 0x8
	DMAFRMPT2    volatile.Register32 // 0xC
	DMAFRMADD1   volatile.Register32 // 0x10
	DMAFRMADD2   volatile.Register32 // 0x14
	DMAFRMCFG    volatile.Register32 // 0x18
	DMACON       volatile.Register32 // 0x1C
	DMA2DCFG     volatile.Register32 // 0x20
	_            [2012]byte
	LCDCON1      volatile.Register32 // 0x800
	LCDCON2      volatile.Register32 // 0x804
	LCDTIM1      volatile.Register32 // 0x808
	LCDTIM2      volatile.Register32 // 0x80C
	LCDFRMCFG    volatile.Register32 // 0x810
	LCDFIFO      volatile.Register32 // 0x814
	_            [4]byte
	DP1_2        volatile.Register32 // 0x81C
	DP4_7        volatile.Register32 // 0x820
	DP3_5        volatile.Register32 // 0x824
	DP2_3        volatile.Register32 // 0x828
	DP5_7        volatile.Register32 // 0x82C
	DP3_4        volatile.Register32 // 0x830
	DP4_5        volatile.Register32 // 0x834
	DP6_7        volatile.Register32 // 0x838
	PWRCON       volatile.Register32 // 0x83C
	CONTRAST_CTR volatile.Register32 // 0x840
	CONTRAST_VAL volatile.Register32 // 0x844
	LCD_IER      volatile.Register32 // 0x848
	LCD_IDR      volatile.Register32 // 0x84C
	LCD_IMR      volatile.Register32 // 0x850
	LCD_ISR      volatile.Register32 // 0x854
	LCD_ICR      volatile.Register32 // 0x858
	_            [4]byte
	LCD_ITR      volatile.Register32 // 0x860
	LCD_IRR      volatile.Register32 // 0x864
	_            [124]byte
	LCD_WPCR     volatile.Register32 // 0x8E4
	LCD_WPSR     volatile.Register32 // 0x8E8
	_            [788]byte
	LUTENTRY     [256]volatile.Register32 // 0xC00
}

// LCDC.DMABADDR1: DMA Base Address Register 1
func (o *LCDC_Type) SetDMABADDR1_BADDR_U(value uint32) {
	volatile.StoreUint32(&o.DMABADDR1.Reg, volatile.LoadUint32(&o.DMABADDR1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCDC_Type) GetDMABADDR1_BADDR_U() uint32 {
	return (volatile.LoadUint32(&o.DMABADDR1.Reg) & 0xfffffffc) >> 2
}

// LCDC.DMABADDR2: DMA Base Address Register 2
func (o *LCDC_Type) SetDMABADDR2(value uint32) {
	volatile.StoreUint32(&o.DMABADDR2.Reg, value)
}
func (o *LCDC_Type) GetDMABADDR2() uint32 {
	return volatile.LoadUint32(&o.DMABADDR2.Reg)
}

// LCDC.DMAFRMPT1: DMA Frame Pointer Register 1
func (o *LCDC_Type) SetDMAFRMPT1_FRMPT_U(value uint32) {
	volatile.StoreUint32(&o.DMAFRMPT1.Reg, volatile.LoadUint32(&o.DMAFRMPT1.Reg)&^(0x7fffff)|value)
}
func (o *LCDC_Type) GetDMAFRMPT1_FRMPT_U() uint32 {
	return volatile.LoadUint32(&o.DMAFRMPT1.Reg) & 0x7fffff
}

// LCDC.DMAFRMPT2: DMA Frame Pointer Register 2
func (o *LCDC_Type) SetDMAFRMPT2_FRMPT_L(value uint32) {
	volatile.StoreUint32(&o.DMAFRMPT2.Reg, volatile.LoadUint32(&o.DMAFRMPT2.Reg)&^(0x7fffff)|value)
}
func (o *LCDC_Type) GetDMAFRMPT2_FRMPT_L() uint32 {
	return volatile.LoadUint32(&o.DMAFRMPT2.Reg) & 0x7fffff
}

// LCDC.DMAFRMADD1: DMA Frame Address Register 1
func (o *LCDC_Type) SetDMAFRMADD1(value uint32) {
	volatile.StoreUint32(&o.DMAFRMADD1.Reg, value)
}
func (o *LCDC_Type) GetDMAFRMADD1() uint32 {
	return volatile.LoadUint32(&o.DMAFRMADD1.Reg)
}

// LCDC.DMAFRMADD2: DMA Frame Address Register 2
func (o *LCDC_Type) SetDMAFRMADD2(value uint32) {
	volatile.StoreUint32(&o.DMAFRMADD2.Reg, value)
}
func (o *LCDC_Type) GetDMAFRMADD2() uint32 {
	return volatile.LoadUint32(&o.DMAFRMADD2.Reg)
}

// LCDC.DMAFRMCFG: DMA Frame Configuration Register
func (o *LCDC_Type) SetDMAFRMCFG_FRMSIZE(value uint32) {
	volatile.StoreUint32(&o.DMAFRMCFG.Reg, volatile.LoadUint32(&o.DMAFRMCFG.Reg)&^(0x7fffff)|value)
}
func (o *LCDC_Type) GetDMAFRMCFG_FRMSIZE() uint32 {
	return volatile.LoadUint32(&o.DMAFRMCFG.Reg) & 0x7fffff
}
func (o *LCDC_Type) SetDMAFRMCFG_BRSTLN(value uint32) {
	volatile.StoreUint32(&o.DMAFRMCFG.Reg, volatile.LoadUint32(&o.DMAFRMCFG.Reg)&^(0x7f000000)|value<<24)
}
func (o *LCDC_Type) GetDMAFRMCFG_BRSTLN() uint32 {
	return (volatile.LoadUint32(&o.DMAFRMCFG.Reg) & 0x7f000000) >> 24
}

// LCDC.DMACON: DMA Control Register
func (o *LCDC_Type) SetDMACON_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DMACON.Reg, volatile.LoadUint32(&o.DMACON.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetDMACON_DMAEN() uint32 {
	return volatile.LoadUint32(&o.DMACON.Reg) & 0x1
}
func (o *LCDC_Type) SetDMACON_DMARST(value uint32) {
	volatile.StoreUint32(&o.DMACON.Reg, volatile.LoadUint32(&o.DMACON.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetDMACON_DMARST() uint32 {
	return (volatile.LoadUint32(&o.DMACON.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetDMACON_DMABUSY(value uint32) {
	volatile.StoreUint32(&o.DMACON.Reg, volatile.LoadUint32(&o.DMACON.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetDMACON_DMABUSY() uint32 {
	return (volatile.LoadUint32(&o.DMACON.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetDMACON_DMAUPDT(value uint32) {
	volatile.StoreUint32(&o.DMACON.Reg, volatile.LoadUint32(&o.DMACON.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetDMACON_DMAUPDT() uint32 {
	return (volatile.LoadUint32(&o.DMACON.Reg) & 0x8) >> 3
}
func (o *LCDC_Type) SetDMACON_DMA2DEN(value uint32) {
	volatile.StoreUint32(&o.DMACON.Reg, volatile.LoadUint32(&o.DMACON.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetDMACON_DMA2DEN() uint32 {
	return (volatile.LoadUint32(&o.DMACON.Reg) & 0x10) >> 4
}

// LCDC.DMA2DCFG: DMA Control Register
func (o *LCDC_Type) SetDMA2DCFG_ADDRINC(value uint32) {
	volatile.StoreUint32(&o.DMA2DCFG.Reg, volatile.LoadUint32(&o.DMA2DCFG.Reg)&^(0xffff)|value)
}
func (o *LCDC_Type) GetDMA2DCFG_ADDRINC() uint32 {
	return volatile.LoadUint32(&o.DMA2DCFG.Reg) & 0xffff
}
func (o *LCDC_Type) SetDMA2DCFG_PIXELOFF(value uint32) {
	volatile.StoreUint32(&o.DMA2DCFG.Reg, volatile.LoadUint32(&o.DMA2DCFG.Reg)&^(0x1f000000)|value<<24)
}
func (o *LCDC_Type) GetDMA2DCFG_PIXELOFF() uint32 {
	return (volatile.LoadUint32(&o.DMA2DCFG.Reg) & 0x1f000000) >> 24
}

// LCDC.LCDCON1: LCD Control Register 1
func (o *LCDC_Type) SetLCDCON1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.LCDCON1.Reg, volatile.LoadUint32(&o.LCDCON1.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCDCON1_BYPASS() uint32 {
	return volatile.LoadUint32(&o.LCDCON1.Reg) & 0x1
}
func (o *LCDC_Type) SetLCDCON1_CLKVAL(value uint32) {
	volatile.StoreUint32(&o.LCDCON1.Reg, volatile.LoadUint32(&o.LCDCON1.Reg)&^(0x1ff000)|value<<12)
}
func (o *LCDC_Type) GetLCDCON1_CLKVAL() uint32 {
	return (volatile.LoadUint32(&o.LCDCON1.Reg) & 0x1ff000) >> 12
}
func (o *LCDC_Type) SetLCDCON1_LINECNT(value uint32) {
	volatile.StoreUint32(&o.LCDCON1.Reg, volatile.LoadUint32(&o.LCDCON1.Reg)&^(0xffe00000)|value<<21)
}
func (o *LCDC_Type) GetLCDCON1_LINECNT() uint32 {
	return (volatile.LoadUint32(&o.LCDCON1.Reg) & 0xffe00000) >> 21
}

// LCDC.LCDCON2: LCD Control Register 2
func (o *LCDC_Type) SetLCDCON2_DISTYPE(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x3)|value)
}
func (o *LCDC_Type) GetLCDCON2_DISTYPE() uint32 {
	return volatile.LoadUint32(&o.LCDCON2.Reg) & 0x3
}
func (o *LCDC_Type) SetLCDCON2_SCANMOD(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCDCON2_SCANMOD() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCDCON2_IFWIDTH(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x18)|value<<3)
}
func (o *LCDC_Type) GetLCDCON2_IFWIDTH() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x18) >> 3
}
func (o *LCDC_Type) SetLCDCON2_PIXELSIZE(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0xe0)|value<<5)
}
func (o *LCDC_Type) GetLCDCON2_PIXELSIZE() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0xe0) >> 5
}
func (o *LCDC_Type) SetLCDCON2_INVVD(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x100)|value<<8)
}
func (o *LCDC_Type) GetLCDCON2_INVVD() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x100) >> 8
}
func (o *LCDC_Type) SetLCDCON2_INVFRAME(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x200)|value<<9)
}
func (o *LCDC_Type) GetLCDCON2_INVFRAME() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x200) >> 9
}
func (o *LCDC_Type) SetLCDCON2_INVLINE(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x400)|value<<10)
}
func (o *LCDC_Type) GetLCDCON2_INVLINE() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x400) >> 10
}
func (o *LCDC_Type) SetLCDCON2_INVCLK(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x800)|value<<11)
}
func (o *LCDC_Type) GetLCDCON2_INVCLK() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x800) >> 11
}
func (o *LCDC_Type) SetLCDCON2_INVDVAL(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x1000)|value<<12)
}
func (o *LCDC_Type) GetLCDCON2_INVDVAL() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x1000) >> 12
}
func (o *LCDC_Type) SetLCDCON2_CLKMOD(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0x8000)|value<<15)
}
func (o *LCDC_Type) GetLCDCON2_CLKMOD() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0x8000) >> 15
}
func (o *LCDC_Type) SetLCDCON2_MEMOR(value uint32) {
	volatile.StoreUint32(&o.LCDCON2.Reg, volatile.LoadUint32(&o.LCDCON2.Reg)&^(0xc0000000)|value<<30)
}
func (o *LCDC_Type) GetLCDCON2_MEMOR() uint32 {
	return (volatile.LoadUint32(&o.LCDCON2.Reg) & 0xc0000000) >> 30
}

// LCDC.LCDTIM1: LCD Timing Register 1
func (o *LCDC_Type) SetLCDTIM1_VFP(value uint32) {
	volatile.StoreUint32(&o.LCDTIM1.Reg, volatile.LoadUint32(&o.LCDTIM1.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetLCDTIM1_VFP() uint32 {
	return volatile.LoadUint32(&o.LCDTIM1.Reg) & 0xff
}
func (o *LCDC_Type) SetLCDTIM1_VBP(value uint32) {
	volatile.StoreUint32(&o.LCDTIM1.Reg, volatile.LoadUint32(&o.LCDTIM1.Reg)&^(0xff00)|value<<8)
}
func (o *LCDC_Type) GetLCDTIM1_VBP() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM1.Reg) & 0xff00) >> 8
}
func (o *LCDC_Type) SetLCDTIM1_VPW(value uint32) {
	volatile.StoreUint32(&o.LCDTIM1.Reg, volatile.LoadUint32(&o.LCDTIM1.Reg)&^(0x3f0000)|value<<16)
}
func (o *LCDC_Type) GetLCDTIM1_VPW() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM1.Reg) & 0x3f0000) >> 16
}
func (o *LCDC_Type) SetLCDTIM1_VHDLY(value uint32) {
	volatile.StoreUint32(&o.LCDTIM1.Reg, volatile.LoadUint32(&o.LCDTIM1.Reg)&^(0xf000000)|value<<24)
}
func (o *LCDC_Type) GetLCDTIM1_VHDLY() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM1.Reg) & 0xf000000) >> 24
}
func (o *LCDC_Type) SetLCDTIM1_STUCKTO1(value uint32) {
	volatile.StoreUint32(&o.LCDTIM1.Reg, volatile.LoadUint32(&o.LCDTIM1.Reg)&^(0x80000000)|value<<31)
}
func (o *LCDC_Type) GetLCDTIM1_STUCKTO1() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM1.Reg) & 0x80000000) >> 31
}

// LCDC.LCDTIM2: LCD Timing Register 2
func (o *LCDC_Type) SetLCDTIM2_HBP(value uint32) {
	volatile.StoreUint32(&o.LCDTIM2.Reg, volatile.LoadUint32(&o.LCDTIM2.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetLCDTIM2_HBP() uint32 {
	return volatile.LoadUint32(&o.LCDTIM2.Reg) & 0xff
}
func (o *LCDC_Type) SetLCDTIM2_HPW(value uint32) {
	volatile.StoreUint32(&o.LCDTIM2.Reg, volatile.LoadUint32(&o.LCDTIM2.Reg)&^(0x3f00)|value<<8)
}
func (o *LCDC_Type) GetLCDTIM2_HPW() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM2.Reg) & 0x3f00) >> 8
}
func (o *LCDC_Type) SetLCDTIM2_HFP(value uint32) {
	volatile.StoreUint32(&o.LCDTIM2.Reg, volatile.LoadUint32(&o.LCDTIM2.Reg)&^(0xffe00000)|value<<21)
}
func (o *LCDC_Type) GetLCDTIM2_HFP() uint32 {
	return (volatile.LoadUint32(&o.LCDTIM2.Reg) & 0xffe00000) >> 21
}

// LCDC.LCDFRMCFG: LCD Frame Configuration Register
func (o *LCDC_Type) SetLCDFRMCFG_LINEVAL(value uint32) {
	volatile.StoreUint32(&o.LCDFRMCFG.Reg, volatile.LoadUint32(&o.LCDFRMCFG.Reg)&^(0x7ff)|value)
}
func (o *LCDC_Type) GetLCDFRMCFG_LINEVAL() uint32 {
	return volatile.LoadUint32(&o.LCDFRMCFG.Reg) & 0x7ff
}
func (o *LCDC_Type) SetLCDFRMCFG_LINESIZE(value uint32) {
	volatile.StoreUint32(&o.LCDFRMCFG.Reg, volatile.LoadUint32(&o.LCDFRMCFG.Reg)&^(0xffe00000)|value<<21)
}
func (o *LCDC_Type) GetLCDFRMCFG_LINESIZE() uint32 {
	return (volatile.LoadUint32(&o.LCDFRMCFG.Reg) & 0xffe00000) >> 21
}

// LCDC.LCDFIFO: LCD FIFO Register
func (o *LCDC_Type) SetLCDFIFO_FIFOTH(value uint32) {
	volatile.StoreUint32(&o.LCDFIFO.Reg, volatile.LoadUint32(&o.LCDFIFO.Reg)&^(0xffff)|value)
}
func (o *LCDC_Type) GetLCDFIFO_FIFOTH() uint32 {
	return volatile.LoadUint32(&o.LCDFIFO.Reg) & 0xffff
}

// LCDC.DP1_2: Dithering Pattern DP1_2
func (o *LCDC_Type) SetDP1_2(value uint32) {
	volatile.StoreUint32(&o.DP1_2.Reg, volatile.LoadUint32(&o.DP1_2.Reg)&^(0xff)|value)
}
func (o *LCDC_Type) GetDP1_2() uint32 {
	return volatile.LoadUint32(&o.DP1_2.Reg) & 0xff
}

// LCDC.DP4_7: Dithering Pattern DP4_7
func (o *LCDC_Type) SetDP4_7(value uint32) {
	volatile.StoreUint32(&o.DP4_7.Reg, volatile.LoadUint32(&o.DP4_7.Reg)&^(0xfffffff)|value)
}
func (o *LCDC_Type) GetDP4_7() uint32 {
	return volatile.LoadUint32(&o.DP4_7.Reg) & 0xfffffff
}

// LCDC.DP3_5: Dithering Pattern DP3_5
func (o *LCDC_Type) SetDP3_5(value uint32) {
	volatile.StoreUint32(&o.DP3_5.Reg, volatile.LoadUint32(&o.DP3_5.Reg)&^(0xfffff)|value)
}
func (o *LCDC_Type) GetDP3_5() uint32 {
	return volatile.LoadUint32(&o.DP3_5.Reg) & 0xfffff
}

// LCDC.DP2_3: Dithering Pattern DP2_3
func (o *LCDC_Type) SetDP2_3(value uint32) {
	volatile.StoreUint32(&o.DP2_3.Reg, volatile.LoadUint32(&o.DP2_3.Reg)&^(0xfff)|value)
}
func (o *LCDC_Type) GetDP2_3() uint32 {
	return volatile.LoadUint32(&o.DP2_3.Reg) & 0xfff
}

// LCDC.DP5_7: Dithering Pattern DP5_7
func (o *LCDC_Type) SetDP5_7(value uint32) {
	volatile.StoreUint32(&o.DP5_7.Reg, volatile.LoadUint32(&o.DP5_7.Reg)&^(0xfffffff)|value)
}
func (o *LCDC_Type) GetDP5_7() uint32 {
	return volatile.LoadUint32(&o.DP5_7.Reg) & 0xfffffff
}

// LCDC.DP3_4: Dithering Pattern DP3_4
func (o *LCDC_Type) SetDP3_4(value uint32) {
	volatile.StoreUint32(&o.DP3_4.Reg, volatile.LoadUint32(&o.DP3_4.Reg)&^(0xffff)|value)
}
func (o *LCDC_Type) GetDP3_4() uint32 {
	return volatile.LoadUint32(&o.DP3_4.Reg) & 0xffff
}

// LCDC.DP4_5: Dithering Pattern DP4_5
func (o *LCDC_Type) SetDP4_5(value uint32) {
	volatile.StoreUint32(&o.DP4_5.Reg, volatile.LoadUint32(&o.DP4_5.Reg)&^(0xfffff)|value)
}
func (o *LCDC_Type) GetDP4_5() uint32 {
	return volatile.LoadUint32(&o.DP4_5.Reg) & 0xfffff
}

// LCDC.DP6_7: Dithering Pattern DP6_7
func (o *LCDC_Type) SetDP6_7(value uint32) {
	volatile.StoreUint32(&o.DP6_7.Reg, volatile.LoadUint32(&o.DP6_7.Reg)&^(0xfffffff)|value)
}
func (o *LCDC_Type) GetDP6_7() uint32 {
	return volatile.LoadUint32(&o.DP6_7.Reg) & 0xfffffff
}

// LCDC.PWRCON: Power Control Register
func (o *LCDC_Type) SetPWRCON_LCD_PWR(value uint32) {
	volatile.StoreUint32(&o.PWRCON.Reg, volatile.LoadUint32(&o.PWRCON.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetPWRCON_LCD_PWR() uint32 {
	return volatile.LoadUint32(&o.PWRCON.Reg) & 0x1
}
func (o *LCDC_Type) SetPWRCON_GUARD_TIME(value uint32) {
	volatile.StoreUint32(&o.PWRCON.Reg, volatile.LoadUint32(&o.PWRCON.Reg)&^(0xfe)|value<<1)
}
func (o *LCDC_Type) GetPWRCON_GUARD_TIME() uint32 {
	return (volatile.LoadUint32(&o.PWRCON.Reg) & 0xfe) >> 1
}
func (o *LCDC_Type) SetPWRCON_LCD_BUSY(value uint32) {
	volatile.StoreUint32(&o.PWRCON.Reg, volatile.LoadUint32(&o.PWRCON.Reg)&^(0x80000000)|value<<31)
}
func (o *LCDC_Type) GetPWRCON_LCD_BUSY() uint32 {
	return (volatile.LoadUint32(&o.PWRCON.Reg) & 0x80000000) >> 31
}

// LCDC.CONTRAST_CTR: Contrast Control Register
func (o *LCDC_Type) SetCONTRAST_CTR_PS(value uint32) {
	volatile.StoreUint32(&o.CONTRAST_CTR.Reg, volatile.LoadUint32(&o.CONTRAST_CTR.Reg)&^(0x3)|value)
}
func (o *LCDC_Type) GetCONTRAST_CTR_PS() uint32 {
	return volatile.LoadUint32(&o.CONTRAST_CTR.Reg) & 0x3
}
func (o *LCDC_Type) SetCONTRAST_CTR_POL(value uint32) {
	volatile.StoreUint32(&o.CONTRAST_CTR.Reg, volatile.LoadUint32(&o.CONTRAST_CTR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetCONTRAST_CTR_POL() uint32 {
	return (volatile.LoadUint32(&o.CONTRAST_CTR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetCONTRAST_CTR_ENA(value uint32) {
	volatile.StoreUint32(&o.CONTRAST_CTR.Reg, volatile.LoadUint32(&o.CONTRAST_CTR.Reg)&^(0x8)|value<<3)
}
func (o *LCDC_Type) GetCONTRAST_CTR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CONTRAST_CTR.Reg) & 0x8) >> 3
}

// LCDC.LCD_IER: LCD Interrupt Enable Register
func (o *LCDC_Type) SetLCD_IER_LNIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_IER_LNIE() uint32 {
	return volatile.LoadUint32(&o.LCD_IER.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_IER_LSTLNIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_IER_LSTLNIE() uint32 {
	return (volatile.LoadUint32(&o.LCD_IER.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_IER_EOFIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_IER_EOFIE() uint32 {
	return (volatile.LoadUint32(&o.LCD_IER.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_IER_UFLWIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_IER_UFLWIE() uint32 {
	return (volatile.LoadUint32(&o.LCD_IER.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_IER_OWRIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_IER_OWRIE() uint32 {
	return (volatile.LoadUint32(&o.LCD_IER.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_IER_MERIE(value uint32) {
	volatile.StoreUint32(&o.LCD_IER.Reg, volatile.LoadUint32(&o.LCD_IER.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_IER_MERIE() uint32 {
	return (volatile.LoadUint32(&o.LCD_IER.Reg) & 0x40) >> 6
}

// LCDC.LCD_IDR: LCD Interrupt Disable Register
func (o *LCDC_Type) SetLCD_IDR_LNID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_IDR_LNID() uint32 {
	return volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_IDR_LSTLNID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_IDR_LSTLNID() uint32 {
	return (volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_IDR_EOFID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_IDR_EOFID() uint32 {
	return (volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_IDR_UFLWID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_IDR_UFLWID() uint32 {
	return (volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_IDR_OWRID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_IDR_OWRID() uint32 {
	return (volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_IDR_MERID(value uint32) {
	volatile.StoreUint32(&o.LCD_IDR.Reg, volatile.LoadUint32(&o.LCD_IDR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_IDR_MERID() uint32 {
	return (volatile.LoadUint32(&o.LCD_IDR.Reg) & 0x40) >> 6
}

// LCDC.LCD_IMR: LCD Interrupt Mask Register
func (o *LCDC_Type) SetLCD_IMR_LNIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_IMR_LNIM() uint32 {
	return volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_IMR_LSTLNIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_IMR_LSTLNIM() uint32 {
	return (volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_IMR_EOFIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_IMR_EOFIM() uint32 {
	return (volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_IMR_UFLWIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_IMR_UFLWIM() uint32 {
	return (volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_IMR_OWRIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_IMR_OWRIM() uint32 {
	return (volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_IMR_MERIM(value uint32) {
	volatile.StoreUint32(&o.LCD_IMR.Reg, volatile.LoadUint32(&o.LCD_IMR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_IMR_MERIM() uint32 {
	return (volatile.LoadUint32(&o.LCD_IMR.Reg) & 0x40) >> 6
}

// LCDC.LCD_ISR: LCD Interrupt Status Register
func (o *LCDC_Type) SetLCD_ISR_LNIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_ISR_LNIS() uint32 {
	return volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_ISR_LSTLNIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_ISR_LSTLNIS() uint32 {
	return (volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_ISR_EOFIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_ISR_EOFIS() uint32 {
	return (volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_ISR_UFLWIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_ISR_UFLWIS() uint32 {
	return (volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_ISR_OWRIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_ISR_OWRIS() uint32 {
	return (volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_ISR_MERIS(value uint32) {
	volatile.StoreUint32(&o.LCD_ISR.Reg, volatile.LoadUint32(&o.LCD_ISR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_ISR_MERIS() uint32 {
	return (volatile.LoadUint32(&o.LCD_ISR.Reg) & 0x40) >> 6
}

// LCDC.LCD_ICR: LCD Interrupt Clear Register
func (o *LCDC_Type) SetLCD_ICR_LNIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_ICR_LNIC() uint32 {
	return volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_ICR_LSTLNIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_ICR_LSTLNIC() uint32 {
	return (volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_ICR_EOFIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_ICR_EOFIC() uint32 {
	return (volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_ICR_UFLWIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_ICR_UFLWIC() uint32 {
	return (volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_ICR_OWRIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_ICR_OWRIC() uint32 {
	return (volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_ICR_MERIC(value uint32) {
	volatile.StoreUint32(&o.LCD_ICR.Reg, volatile.LoadUint32(&o.LCD_ICR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_ICR_MERIC() uint32 {
	return (volatile.LoadUint32(&o.LCD_ICR.Reg) & 0x40) >> 6
}

// LCDC.LCD_ITR: LCD Interrupt Test Register
func (o *LCDC_Type) SetLCD_ITR_LNIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_ITR_LNIT() uint32 {
	return volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_ITR_LSTLNIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_ITR_LSTLNIT() uint32 {
	return (volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_ITR_EOFIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_ITR_EOFIT() uint32 {
	return (volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_ITR_UFLWIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_ITR_UFLWIT() uint32 {
	return (volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_ITR_OWRIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_ITR_OWRIT() uint32 {
	return (volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_ITR_MERIT(value uint32) {
	volatile.StoreUint32(&o.LCD_ITR.Reg, volatile.LoadUint32(&o.LCD_ITR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_ITR_MERIT() uint32 {
	return (volatile.LoadUint32(&o.LCD_ITR.Reg) & 0x40) >> 6
}

// LCDC.LCD_IRR: LCD Interrupt Raw Status Register
func (o *LCDC_Type) SetLCD_IRR_LNIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_IRR_LNIR() uint32 {
	return volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_IRR_LSTLNIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x2)|value<<1)
}
func (o *LCDC_Type) GetLCD_IRR_LSTLNIR() uint32 {
	return (volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x2) >> 1
}
func (o *LCDC_Type) SetLCD_IRR_EOFIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x4)|value<<2)
}
func (o *LCDC_Type) GetLCD_IRR_EOFIR() uint32 {
	return (volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x4) >> 2
}
func (o *LCDC_Type) SetLCD_IRR_UFLWIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x10)|value<<4)
}
func (o *LCDC_Type) GetLCD_IRR_UFLWIR() uint32 {
	return (volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x10) >> 4
}
func (o *LCDC_Type) SetLCD_IRR_OWRIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x20)|value<<5)
}
func (o *LCDC_Type) GetLCD_IRR_OWRIR() uint32 {
	return (volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x20) >> 5
}
func (o *LCDC_Type) SetLCD_IRR_MERIR(value uint32) {
	volatile.StoreUint32(&o.LCD_IRR.Reg, volatile.LoadUint32(&o.LCD_IRR.Reg)&^(0x40)|value<<6)
}
func (o *LCDC_Type) GetLCD_IRR_MERIR() uint32 {
	return (volatile.LoadUint32(&o.LCD_IRR.Reg) & 0x40) >> 6
}

// LCDC.LCD_WPSR: Write Protection Status Register
func (o *LCDC_Type) SetLCD_WPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.LCD_WPSR.Reg, volatile.LoadUint32(&o.LCD_WPSR.Reg)&^(0x1)|value)
}
func (o *LCDC_Type) GetLCD_WPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.LCD_WPSR.Reg) & 0x1
}
func (o *LCDC_Type) SetLCD_WPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.LCD_WPSR.Reg, volatile.LoadUint32(&o.LCD_WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *LCDC_Type) GetLCD_WPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.LCD_WPSR.Reg) & 0xffff00) >> 8
}

// Video Decoder
type VDEC_Type struct {
	IDR      volatile.Register32     // 0x0
	DIR      volatile.Register32     // 0x4
	DDCR     volatile.Register32     // 0x8
	CTLR0    volatile.Register32     // 0xC
	CTLR1    volatile.Register32     // 0x10
	CTLR2    volatile.Register32     // 0x14
	CTLR3    volatile.Register32     // 0x18
	CTLR4    volatile.Register32     // 0x1C
	CTLR5    volatile.Register32     // 0x20
	CTLR6    volatile.Register32     // 0x24
	DMVBA    volatile.Register32     // 0x28
	CTLR7    volatile.Register32     // 0x2C
	RLCVLCBA volatile.Register32     // 0x30
	PICTBA   volatile.Register32     // 0x34
	PIDXBA   [16]volatile.Register32 // 0x38
	PNR0     volatile.Register32     // 0x78
	PNR1     volatile.Register32     // 0x7C
	PNR2     volatile.Register32     // 0x80
	PNR3     volatile.Register32     // 0x84
	PNR4     volatile.Register32     // 0x88
	PNR5     volatile.Register32     // 0x8C
	PNR6     volatile.Register32     // 0x90
	PNR7     volatile.Register32     // 0x94
	PLTFR    volatile.Register32     // 0x98
	PVFR     volatile.Register32     // 0x9C
	SDTBA    volatile.Register32     // 0xA0
	DMMVBA   volatile.Register32     // 0xA4
	IRPLR0   volatile.Register32     // 0xA8
	IRPLR1   volatile.Register32     // 0xAC
	IRPLR2   volatile.Register32     // 0xB0
	IRPLR3   volatile.Register32     // 0xB4
	IRPLR4   volatile.Register32     // 0xB8
	IRPLR5   volatile.Register32     // 0xBC
	ECR      volatile.Register32     // 0xC0
}

// VDEC.IDR: ID Register
func (o *VDEC_Type) SetIDR_BUILD_VER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf)|value)
}
func (o *VDEC_Type) GetIDR_BUILD_VER() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0xf
}
func (o *VDEC_Type) SetIDR_MINOR_VER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xff0)|value<<4)
}
func (o *VDEC_Type) GetIDR_MINOR_VER() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xff0) >> 4
}
func (o *VDEC_Type) SetIDR_MAJOR_VER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf000)|value<<12)
}
func (o *VDEC_Type) GetIDR_MAJOR_VER() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf000) >> 12
}
func (o *VDEC_Type) SetIDR_PROD_ID(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetIDR_PROD_ID() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xffff0000) >> 16
}

// VDEC.DIR: Decoder Interrupt Register
func (o *VDEC_Type) SetDIR_DE(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1)|value)
}
func (o *VDEC_Type) GetDIR_DE() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1
}
func (o *VDEC_Type) SetDIR_ID(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10)|value<<4)
}
func (o *VDEC_Type) GetDIR_ID() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10) >> 4
}
func (o *VDEC_Type) SetDIR_ISET(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100)|value<<8)
}
func (o *VDEC_Type) GetDIR_ISET() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100) >> 8
}
func (o *VDEC_Type) SetDIR_DR(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000)|value<<12)
}
func (o *VDEC_Type) GetDIR_DR() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000) >> 12
}
func (o *VDEC_Type) SetDIR_BE(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000)|value<<13)
}
func (o *VDEC_Type) GetDIR_BE() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000) >> 13
}
func (o *VDEC_Type) SetDIR_SBE(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000)|value<<14)
}
func (o *VDEC_Type) GetDIR_SBE() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000) >> 14
}
func (o *VDEC_Type) SetDIR_ASOD(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000)|value<<15)
}
func (o *VDEC_Type) GetDIR_ASOD() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000) >> 15
}
func (o *VDEC_Type) SetDIR_ISE(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000)|value<<16)
}
func (o *VDEC_Type) GetDIR_ISE() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000) >> 16
}
func (o *VDEC_Type) SetDIR_JPEGSD(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000)|value<<17)
}
func (o *VDEC_Type) GetDIR_JPEGSD() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000) >> 17
}
func (o *VDEC_Type) SetDIR_TO(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000)|value<<18)
}
func (o *VDEC_Type) GetDIR_TO() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000) >> 18
}

// VDEC.DDCR: Decoder Device Configuration Register
func (o *VDEC_Type) SetDDCR_MAX_BURST_LEN(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetDDCR_MAX_BURST_LEN() uint32 {
	return volatile.LoadUint32(&o.DDCR.Reg) & 0x1f
}
func (o *VDEC_Type) SetDDCR_PRIOR(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0xe0)|value<<5)
}
func (o *VDEC_Type) GetDDCR_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0xe0) >> 5
}
func (o *VDEC_Type) SetDDCR_DO_LE(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x100)|value<<8)
}
func (o *VDEC_Type) GetDDCR_DO_LE() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x100) >> 8
}
func (o *VDEC_Type) SetDDCR_INTCE_LE(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x200)|value<<9)
}
func (o *VDEC_Type) GetDDCR_INTCE_LE() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x200) >> 9
}
func (o *VDEC_Type) SetDDCR_DDCGE(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x400)|value<<10)
}
func (o *VDEC_Type) GetDDCR_DDCGE() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x400) >> 10
}
func (o *VDEC_Type) SetDDCR_LAT_COMP(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x1f800)|value<<11)
}
func (o *VDEC_Type) GetDDCR_LAT_COMP() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x1f800) >> 11
}
func (o *VDEC_Type) SetDDCR_DOPF(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x20000)|value<<17)
}
func (o *VDEC_Type) GetDDCR_DOPF() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x20000) >> 17
}
func (o *VDEC_Type) SetDDCR_AHB_BURST(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x40000)|value<<18)
}
func (o *VDEC_Type) GetDDCR_AHB_BURST() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x40000) >> 18
}
func (o *VDEC_Type) SetDDCR_DI_LE(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x200000)|value<<21)
}
func (o *VDEC_Type) GetDDCR_DI_LE() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x200000) >> 21
}
func (o *VDEC_Type) SetDDCR_HTI(value uint32) {
	volatile.StoreUint32(&o.DDCR.Reg, volatile.LoadUint32(&o.DDCR.Reg)&^(0x800000)|value<<23)
}
func (o *VDEC_Type) GetDDCR_HTI() uint32 {
	return (volatile.LoadUint32(&o.DDCR.Reg) & 0x800000) >> 23
}

// VDEC.CTLR0: Decoder Control Register 0
func (o *VDEC_Type) SetCTLR0_HLOCK(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x100)|value<<8)
}
func (o *VDEC_Type) GetCTLR0_HLOCK() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x100) >> 8
}
func (o *VDEC_Type) SetCTLR0_REFFIRST(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x800)|value<<11)
}
func (o *VDEC_Type) GetCTLR0_REFFIRST() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x800) >> 11
}
func (o *VDEC_Type) SetCTLR0_MV(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x1000)|value<<12)
}
func (o *VDEC_Type) GetCTLR0_MV() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x1000) >> 12
}
func (o *VDEC_Type) SetCTLR0_QUANT(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x2000)|value<<13)
}
func (o *VDEC_Type) GetCTLR0_QUANT() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x2000) >> 13
}
func (o *VDEC_Type) SetCTLR0_FILTDIS(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x4000)|value<<14)
}
func (o *VDEC_Type) GetCTLR0_FILTDIS() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x4000) >> 14
}
func (o *VDEC_Type) SetCTLR0_OUTDIS(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x8000)|value<<15)
}
func (o *VDEC_Type) GetCTLR0_OUTDIS() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x8000) >> 15
}
func (o *VDEC_Type) SetCTLR0_REFFIELD(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x10000)|value<<16)
}
func (o *VDEC_Type) GetCTLR0_REFFIELD() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x10000) >> 16
}
func (o *VDEC_Type) SetCTLR0_FORWMODE(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x40000)|value<<18)
}
func (o *VDEC_Type) GetCTLR0_FORWMODE() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x40000) >> 18
}
func (o *VDEC_Type) SetCTLR0_PICFIELD(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x80000)|value<<19)
}
func (o *VDEC_Type) GetCTLR0_PICFIELD() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x80000) >> 19
}
func (o *VDEC_Type) SetCTLR0_PICTYPE(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x100000)|value<<20)
}
func (o *VDEC_Type) GetCTLR0_PICTYPE() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x100000) >> 20
}
func (o *VDEC_Type) SetCTLR0_PICBEN(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x200000)|value<<21)
}
func (o *VDEC_Type) GetCTLR0_PICBEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x200000) >> 21
}
func (o *VDEC_Type) SetCTLR0_PICSTRUCT(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x400000)|value<<22)
}
func (o *VDEC_Type) GetCTLR0_PICSTRUCT() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x400000) >> 22
}
func (o *VDEC_Type) SetCTLR0_PICMODE(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x800000)|value<<23)
}
func (o *VDEC_Type) GetCTLR0_PICMODE() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x800000) >> 23
}
func (o *VDEC_Type) SetCTLR0_RLCEN(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0x8000000)|value<<27)
}
func (o *VDEC_Type) GetCTLR0_RLCEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0x8000000) >> 27
}
func (o *VDEC_Type) SetCTLR0_DEC_MODE(value uint32) {
	volatile.StoreUint32(&o.CTLR0.Reg, volatile.LoadUint32(&o.CTLR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *VDEC_Type) GetCTLR0_DEC_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTLR0.Reg) & 0xf0000000) >> 28
}

// VDEC.CTLR1: Decoder Control Register 1
func (o *VDEC_Type) SetCTLR1_REF_FRAMES(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetCTLR1_REF_FRAMES() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1f
}
func (o *VDEC_Type) SetCTLR1_TOPF(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x20)|value<<5)
}
func (o *VDEC_Type) GetCTLR1_TOPF() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x20) >> 5
}
func (o *VDEC_Type) SetCTLR1_AVSM(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x40)|value<<6)
}
func (o *VDEC_Type) GetCTLR1_AVSM() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x40) >> 6
}
func (o *VDEC_Type) SetCTLR1_HEIGHT_OFF(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x780)|value<<7)
}
func (o *VDEC_Type) GetCTLR1_HEIGHT_OFF() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x780) >> 7
}
func (o *VDEC_Type) SetCTLR1_PIC_HEIGHT(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x7f800)|value<<11)
}
func (o *VDEC_Type) GetCTLR1_PIC_HEIGHT() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x7f800) >> 11
}
func (o *VDEC_Type) SetCTLR1_WIDTH_OFF(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x780000)|value<<19)
}
func (o *VDEC_Type) GetCTLR1_WIDTH_OFF() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x780000) >> 19
}
func (o *VDEC_Type) SetCTLR1_PIC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0xff800000)|value<<23)
}
func (o *VDEC_Type) GetCTLR1_PIC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0xff800000) >> 23
}

// VDEC.CTLR2: Decoder Control Register 2
func (o *VDEC_Type) SetCTLR2_FIELDPIC(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1)|value)
}
func (o *VDEC_Type) GetCTLR2_FIELDPIC() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0x1
}
func (o *VDEC_Type) SetCTLR2_QP_FILT_CR_OFF(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x7c000)|value<<14)
}
func (o *VDEC_Type) GetCTLR2_QP_FILT_CR_OFF() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x7c000) >> 14
}
func (o *VDEC_Type) SetCTLR2_QP_FILT_CB_OFF(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0xf80000)|value<<19)
}
func (o *VDEC_Type) GetCTLR2_QP_FILT_CB_OFF() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0xf80000) >> 19
}
func (o *VDEC_Type) SetCTLR2_STREAM_START_BIT(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0xfc000000)|value<<26)
}
func (o *VDEC_Type) GetCTLR2_STREAM_START_BIT() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0xfc000000) >> 26
}

// VDEC.CTLR3: Decoder Control Register 3
func (o *VDEC_Type) SetCTLR3_STREAM_LEN(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0xffffff)|value)
}
func (o *VDEC_Type) GetCTLR3_STREAM_LEN() uint32 {
	return volatile.LoadUint32(&o.CTLR3.Reg) & 0xffffff
}
func (o *VDEC_Type) SetCTLR3_INIT_QP(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x7e000000)|value<<25)
}
func (o *VDEC_Type) GetCTLR3_INIT_QP() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x7e000000) >> 25
}
func (o *VDEC_Type) SetCTLR3_ST_COD_EN(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x80000000)|value<<31)
}
func (o *VDEC_Type) GetCTLR3_ST_COD_EN() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x80000000) >> 31
}

// VDEC.CTLR4: Decoder Control Register 4
func (o *VDEC_Type) SetCTLR4_FRAME_NUM(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetCTLR4_FRAME_NUM() uint32 {
	return volatile.LoadUint32(&o.CTLR4.Reg) & 0xffff
}
func (o *VDEC_Type) SetCTLR4_FRAME_NUM_LEN(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *VDEC_Type) GetCTLR4_FRAME_NUM_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0x1f0000) >> 16
}
func (o *VDEC_Type) SetCTLR4_W_BIPR(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0xc000000)|value<<26)
}
func (o *VDEC_Type) GetCTLR4_W_BIPR() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0xc000000) >> 26
}
func (o *VDEC_Type) SetCTLR4_W_PRED(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0x10000000)|value<<28)
}
func (o *VDEC_Type) GetCTLR4_W_PRED() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0x10000000) >> 28
}
func (o *VDEC_Type) SetCTLR4_DIRMV_PRED(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0x20000000)|value<<29)
}
func (o *VDEC_Type) GetCTLR4_DIRMV_PRED() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0x20000000) >> 29
}
func (o *VDEC_Type) SetCTLR4_BW(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0x40000000)|value<<30)
}
func (o *VDEC_Type) GetCTLR4_BW() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0x40000000) >> 30
}
func (o *VDEC_Type) SetCTLR4_CABAC(value uint32) {
	volatile.StoreUint32(&o.CTLR4.Reg, volatile.LoadUint32(&o.CTLR4.Reg)&^(0x80000000)|value<<31)
}
func (o *VDEC_Type) GetCTLR4_CABAC() uint32 {
	return (volatile.LoadUint32(&o.CTLR4.Reg) & 0x80000000) >> 31
}

// VDEC.CTLR5: Decoder Control Register 5
func (o *VDEC_Type) SetCTLR5_IDR_PIC_ID(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetCTLR5_IDR_PIC_ID() uint32 {
	return volatile.LoadUint32(&o.CTLR5.Reg) & 0xffff
}
func (o *VDEC_Type) SetCTLR5_IDREN(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0x10000)|value<<16)
}
func (o *VDEC_Type) GetCTLR5_IDREN() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0x10000) >> 16
}
func (o *VDEC_Type) SetCTLR5_REF_PIC_LEN(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0xffe0000)|value<<17)
}
func (o *VDEC_Type) GetCTLR5_REF_PIC_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0xffe0000) >> 17
}
func (o *VDEC_Type) SetCTLR5_EIGHT58(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0x10000000)|value<<28)
}
func (o *VDEC_Type) GetCTLR5_EIGHT58() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0x10000000) >> 28
}
func (o *VDEC_Type) SetCTLR5_RD_PIC(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0x20000000)|value<<29)
}
func (o *VDEC_Type) GetCTLR5_RD_PIC() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0x20000000) >> 29
}
func (o *VDEC_Type) SetCTLR5_FILT_CTRL(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0x40000000)|value<<30)
}
func (o *VDEC_Type) GetCTLR5_FILT_CTRL() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0x40000000) >> 30
}
func (o *VDEC_Type) SetCTLR5_CONS_INTRA(value uint32) {
	volatile.StoreUint32(&o.CTLR5.Reg, volatile.LoadUint32(&o.CTLR5.Reg)&^(0x80000000)|value<<31)
}
func (o *VDEC_Type) GetCTLR5_CONS_INTRA() uint32 {
	return (volatile.LoadUint32(&o.CTLR5.Reg) & 0x80000000) >> 31
}

// VDEC.CTLR6: Decoder Control Register 6
func (o *VDEC_Type) SetCTLR6_POC_LEN(value uint32) {
	volatile.StoreUint32(&o.CTLR6.Reg, volatile.LoadUint32(&o.CTLR6.Reg)&^(0xff)|value)
}
func (o *VDEC_Type) GetCTLR6_POC_LEN() uint32 {
	return volatile.LoadUint32(&o.CTLR6.Reg) & 0xff
}
func (o *VDEC_Type) SetCTLR6_REF_IDX0(value uint32) {
	volatile.StoreUint32(&o.CTLR6.Reg, volatile.LoadUint32(&o.CTLR6.Reg)&^(0x7c000)|value<<14)
}
func (o *VDEC_Type) GetCTLR6_REF_IDX0() uint32 {
	return (volatile.LoadUint32(&o.CTLR6.Reg) & 0x7c000) >> 14
}
func (o *VDEC_Type) SetCTLR6_REF_IDX1(value uint32) {
	volatile.StoreUint32(&o.CTLR6.Reg, volatile.LoadUint32(&o.CTLR6.Reg)&^(0xf80000)|value<<19)
}
func (o *VDEC_Type) GetCTLR6_REF_IDX1() uint32 {
	return (volatile.LoadUint32(&o.CTLR6.Reg) & 0xf80000) >> 19
}
func (o *VDEC_Type) SetCTLR6_PPS_ID(value uint32) {
	volatile.StoreUint32(&o.CTLR6.Reg, volatile.LoadUint32(&o.CTLR6.Reg)&^(0xff000000)|value<<24)
}
func (o *VDEC_Type) GetCTLR6_PPS_ID() uint32 {
	return (volatile.LoadUint32(&o.CTLR6.Reg) & 0xff000000) >> 24
}

// VDEC.DMVBA: Base Address for Differential Motion Vector
func (o *VDEC_Type) SetDMVBA_MV_CONTROL_BASE(value uint32) {
	volatile.StoreUint32(&o.DMVBA.Reg, volatile.LoadUint32(&o.DMVBA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetDMVBA_MV_CONTROL_BASE() uint32 {
	return (volatile.LoadUint32(&o.DMVBA.Reg) & 0xfffffffc) >> 2
}

// VDEC.CTLR7: Decoder Control Register 7
func (o *VDEC_Type) SetCTLR7_BA(value uint32) {
	volatile.StoreUint32(&o.CTLR7.Reg, volatile.LoadUint32(&o.CTLR7.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetCTLR7_BA() uint32 {
	return (volatile.LoadUint32(&o.CTLR7.Reg) & 0xfffffffc) >> 2
}

// VDEC.RLCVLCBA: RLC/VLC Data Base Address
func (o *VDEC_Type) SetRLCVLCBA_BA(value uint32) {
	volatile.StoreUint32(&o.RLCVLCBA.Reg, volatile.LoadUint32(&o.RLCVLCBA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetRLCVLCBA_BA() uint32 {
	return (volatile.LoadUint32(&o.RLCVLCBA.Reg) & 0xfffffffc) >> 2
}

// VDEC.PICTBA: Decoded Picture Base Address
func (o *VDEC_Type) SetPICTBA_BA(value uint32) {
	volatile.StoreUint32(&o.PICTBA.Reg, volatile.LoadUint32(&o.PICTBA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetPICTBA_BA() uint32 {
	return (volatile.LoadUint32(&o.PICTBA.Reg) & 0xfffffffc) >> 2
}

// VDEC.PIDXBA: Reference Picture Index 0 Base Address
func (o *VDEC_Type) SetPIDXBA_BA(idx int, value uint32) {
	volatile.StoreUint32(&o.PIDXBA[idx].Reg, volatile.LoadUint32(&o.PIDXBA[idx].Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetPIDXBA_BA(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIDXBA[idx].Reg) & 0xfffffffc) >> 2
}

// VDEC.PNR0: Reference Picture Numbers Register 0
func (o *VDEC_Type) SetPNR0_REFER0(value uint32) {
	volatile.StoreUint32(&o.PNR0.Reg, volatile.LoadUint32(&o.PNR0.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR0_REFER0() uint32 {
	return volatile.LoadUint32(&o.PNR0.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR0_REFER1(value uint32) {
	volatile.StoreUint32(&o.PNR0.Reg, volatile.LoadUint32(&o.PNR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR0_REFER1() uint32 {
	return (volatile.LoadUint32(&o.PNR0.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR1: Reference Picture Numbers Register 1
func (o *VDEC_Type) SetPNR1_REFER2(value uint32) {
	volatile.StoreUint32(&o.PNR1.Reg, volatile.LoadUint32(&o.PNR1.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR1_REFER2() uint32 {
	return volatile.LoadUint32(&o.PNR1.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR1_REFER3(value uint32) {
	volatile.StoreUint32(&o.PNR1.Reg, volatile.LoadUint32(&o.PNR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR1_REFER3() uint32 {
	return (volatile.LoadUint32(&o.PNR1.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR3: Reference Picture Numbers Register 3
func (o *VDEC_Type) SetPNR3_REFER4(value uint32) {
	volatile.StoreUint32(&o.PNR3.Reg, volatile.LoadUint32(&o.PNR3.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR3_REFER4() uint32 {
	return volatile.LoadUint32(&o.PNR3.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR3_REFER5(value uint32) {
	volatile.StoreUint32(&o.PNR3.Reg, volatile.LoadUint32(&o.PNR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR3_REFER5() uint32 {
	return (volatile.LoadUint32(&o.PNR3.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR4: Reference Picture Numbers Register 4
func (o *VDEC_Type) SetPNR4_REFER8(value uint32) {
	volatile.StoreUint32(&o.PNR4.Reg, volatile.LoadUint32(&o.PNR4.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR4_REFER8() uint32 {
	return volatile.LoadUint32(&o.PNR4.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR4_REFER9(value uint32) {
	volatile.StoreUint32(&o.PNR4.Reg, volatile.LoadUint32(&o.PNR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR4_REFER9() uint32 {
	return (volatile.LoadUint32(&o.PNR4.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR5: Reference Picture Numbers Register 5
func (o *VDEC_Type) SetPNR5_REFER10(value uint32) {
	volatile.StoreUint32(&o.PNR5.Reg, volatile.LoadUint32(&o.PNR5.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR5_REFER10() uint32 {
	return volatile.LoadUint32(&o.PNR5.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR5_REFER11(value uint32) {
	volatile.StoreUint32(&o.PNR5.Reg, volatile.LoadUint32(&o.PNR5.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR5_REFER11() uint32 {
	return (volatile.LoadUint32(&o.PNR5.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR6: Reference Picture Numbers Register 6
func (o *VDEC_Type) SetPNR6_REFER12(value uint32) {
	volatile.StoreUint32(&o.PNR6.Reg, volatile.LoadUint32(&o.PNR6.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR6_REFER12() uint32 {
	return volatile.LoadUint32(&o.PNR6.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR6_REFER13(value uint32) {
	volatile.StoreUint32(&o.PNR6.Reg, volatile.LoadUint32(&o.PNR6.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR6_REFER13() uint32 {
	return (volatile.LoadUint32(&o.PNR6.Reg) & 0xffff0000) >> 16
}

// VDEC.PNR7: Reference Picture Numbers Register 7
func (o *VDEC_Type) SetPNR7_REFER14(value uint32) {
	volatile.StoreUint32(&o.PNR7.Reg, volatile.LoadUint32(&o.PNR7.Reg)&^(0xffff)|value)
}
func (o *VDEC_Type) GetPNR7_REFER14() uint32 {
	return volatile.LoadUint32(&o.PNR7.Reg) & 0xffff
}
func (o *VDEC_Type) SetPNR7_REFER15(value uint32) {
	volatile.StoreUint32(&o.PNR7.Reg, volatile.LoadUint32(&o.PNR7.Reg)&^(0xffff0000)|value<<16)
}
func (o *VDEC_Type) GetPNR7_REFER15() uint32 {
	return (volatile.LoadUint32(&o.PNR7.Reg) & 0xffff0000) >> 16
}

// VDEC.PLTFR: Reference Picture Long Term Flag Register
func (o *VDEC_Type) SetPLTFR(value uint32) {
	volatile.StoreUint32(&o.PLTFR.Reg, value)
}
func (o *VDEC_Type) GetPLTFR() uint32 {
	return volatile.LoadUint32(&o.PLTFR.Reg)
}

// VDEC.SDTBA: Standard Dependent Tables Base Address
func (o *VDEC_Type) SetSDTBA_BA(value uint32) {
	volatile.StoreUint32(&o.SDTBA.Reg, volatile.LoadUint32(&o.SDTBA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetSDTBA_BA() uint32 {
	return (volatile.LoadUint32(&o.SDTBA.Reg) & 0xfffffffc) >> 2
}

// VDEC.DMMVBA: Direct Mode Motion Vector Base Address
func (o *VDEC_Type) SetDMMVBA_BA(value uint32) {
	volatile.StoreUint32(&o.DMMVBA.Reg, volatile.LoadUint32(&o.DMMVBA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *VDEC_Type) GetDMMVBA_BA() uint32 {
	return (volatile.LoadUint32(&o.DMMVBA.Reg) & 0xfffffffc) >> 2
}

// VDEC.IRPLR0: H264 Initial Reference Picture List Register 0
func (o *VDEC_Type) SetIRPLR0_IREFL_FW0(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_FW0() uint32 {
	return volatile.LoadUint32(&o.IRPLR0.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR0_IREFL_BW0(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_BW0() uint32 {
	return (volatile.LoadUint32(&o.IRPLR0.Reg) & 0x3e0) >> 5
}
func (o *VDEC_Type) SetIRPLR0_IREFL_FW1(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0x7c00)|value<<10)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_FW1() uint32 {
	return (volatile.LoadUint32(&o.IRPLR0.Reg) & 0x7c00) >> 10
}
func (o *VDEC_Type) SetIRPLR0_IREFL_BW1(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0xf8000)|value<<15)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_BW1() uint32 {
	return (volatile.LoadUint32(&o.IRPLR0.Reg) & 0xf8000) >> 15
}
func (o *VDEC_Type) SetIRPLR0_IREFL_FW2(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0x1f00000)|value<<20)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_FW2() uint32 {
	return (volatile.LoadUint32(&o.IRPLR0.Reg) & 0x1f00000) >> 20
}
func (o *VDEC_Type) SetIRPLR0_IREFL_BW2(value uint32) {
	volatile.StoreUint32(&o.IRPLR0.Reg, volatile.LoadUint32(&o.IRPLR0.Reg)&^(0x3e000000)|value<<25)
}
func (o *VDEC_Type) GetIRPLR0_IREFL_BW2() uint32 {
	return (volatile.LoadUint32(&o.IRPLR0.Reg) & 0x3e000000) >> 25
}

// VDEC.IRPLR1: H264 Initial Reference Picture List Register 1
func (o *VDEC_Type) SetIRPLR1_IREFL_FW3(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_FW3() uint32 {
	return volatile.LoadUint32(&o.IRPLR1.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR1_IREFL_BW3(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_BW3() uint32 {
	return (volatile.LoadUint32(&o.IRPLR1.Reg) & 0x3e0) >> 5
}
func (o *VDEC_Type) SetIRPLR1_IREFL_FW4(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0x7c00)|value<<10)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_FW4() uint32 {
	return (volatile.LoadUint32(&o.IRPLR1.Reg) & 0x7c00) >> 10
}
func (o *VDEC_Type) SetIRPLR1_IREFL_BW4(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0xf8000)|value<<15)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_BW4() uint32 {
	return (volatile.LoadUint32(&o.IRPLR1.Reg) & 0xf8000) >> 15
}
func (o *VDEC_Type) SetIRPLR1_IREFL_FW5(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0x1f00000)|value<<20)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_FW5() uint32 {
	return (volatile.LoadUint32(&o.IRPLR1.Reg) & 0x1f00000) >> 20
}
func (o *VDEC_Type) SetIRPLR1_IREFL_BW5(value uint32) {
	volatile.StoreUint32(&o.IRPLR1.Reg, volatile.LoadUint32(&o.IRPLR1.Reg)&^(0x3e000000)|value<<25)
}
func (o *VDEC_Type) GetIRPLR1_IREFL_BW5() uint32 {
	return (volatile.LoadUint32(&o.IRPLR1.Reg) & 0x3e000000) >> 25
}

// VDEC.IRPLR2: H264 Initial Reference Picture List Register 2
func (o *VDEC_Type) SetIRPLR2_IREFL_FW6(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_FW6() uint32 {
	return volatile.LoadUint32(&o.IRPLR2.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR2_IREFL_BW6(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_BW6() uint32 {
	return (volatile.LoadUint32(&o.IRPLR2.Reg) & 0x3e0) >> 5
}
func (o *VDEC_Type) SetIRPLR2_IREFL_FW7(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0x7c00)|value<<10)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_FW7() uint32 {
	return (volatile.LoadUint32(&o.IRPLR2.Reg) & 0x7c00) >> 10
}
func (o *VDEC_Type) SetIRPLR2_IREFL_BW7(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0xf8000)|value<<15)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_BW7() uint32 {
	return (volatile.LoadUint32(&o.IRPLR2.Reg) & 0xf8000) >> 15
}
func (o *VDEC_Type) SetIRPLR2_IREFL_FW8(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0x1f00000)|value<<20)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_FW8() uint32 {
	return (volatile.LoadUint32(&o.IRPLR2.Reg) & 0x1f00000) >> 20
}
func (o *VDEC_Type) SetIRPLR2_IREFL_BW8(value uint32) {
	volatile.StoreUint32(&o.IRPLR2.Reg, volatile.LoadUint32(&o.IRPLR2.Reg)&^(0x3e000000)|value<<25)
}
func (o *VDEC_Type) GetIRPLR2_IREFL_BW8() uint32 {
	return (volatile.LoadUint32(&o.IRPLR2.Reg) & 0x3e000000) >> 25
}

// VDEC.IRPLR3: H264 Initial Reference Picture List Register 3
func (o *VDEC_Type) SetIRPLR3_IREFL_FW9(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_FW9() uint32 {
	return volatile.LoadUint32(&o.IRPLR3.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR3_IREFL_BW9(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_BW9() uint32 {
	return (volatile.LoadUint32(&o.IRPLR3.Reg) & 0x3e0) >> 5
}
func (o *VDEC_Type) SetIRPLR3_IREFL_FW10(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0x7c00)|value<<10)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_FW10() uint32 {
	return (volatile.LoadUint32(&o.IRPLR3.Reg) & 0x7c00) >> 10
}
func (o *VDEC_Type) SetIRPLR3_IREFL_BW10(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0xf8000)|value<<15)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_BW10() uint32 {
	return (volatile.LoadUint32(&o.IRPLR3.Reg) & 0xf8000) >> 15
}
func (o *VDEC_Type) SetIRPLR3_IREFL_FW11(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0x1f00000)|value<<20)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_FW11() uint32 {
	return (volatile.LoadUint32(&o.IRPLR3.Reg) & 0x1f00000) >> 20
}
func (o *VDEC_Type) SetIRPLR3_IREFL_BW11(value uint32) {
	volatile.StoreUint32(&o.IRPLR3.Reg, volatile.LoadUint32(&o.IRPLR3.Reg)&^(0x3e000000)|value<<25)
}
func (o *VDEC_Type) GetIRPLR3_IREFL_BW11() uint32 {
	return (volatile.LoadUint32(&o.IRPLR3.Reg) & 0x3e000000) >> 25
}

// VDEC.IRPLR4: H264 Initial Reference Picture List Register 4
func (o *VDEC_Type) SetIRPLR4_IREFL_FW12(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_FW12() uint32 {
	return volatile.LoadUint32(&o.IRPLR4.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR4_IREFL_BW12(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_BW12() uint32 {
	return (volatile.LoadUint32(&o.IRPLR4.Reg) & 0x3e0) >> 5
}
func (o *VDEC_Type) SetIRPLR4_IREFL_FW13(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0x7c00)|value<<10)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_FW13() uint32 {
	return (volatile.LoadUint32(&o.IRPLR4.Reg) & 0x7c00) >> 10
}
func (o *VDEC_Type) SetIRPLR4_IREFL_BW13(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0xf8000)|value<<15)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_BW13() uint32 {
	return (volatile.LoadUint32(&o.IRPLR4.Reg) & 0xf8000) >> 15
}
func (o *VDEC_Type) SetIRPLR4_IREFL_FW14(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0x1f00000)|value<<20)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_FW14() uint32 {
	return (volatile.LoadUint32(&o.IRPLR4.Reg) & 0x1f00000) >> 20
}
func (o *VDEC_Type) SetIRPLR4_IREFL_BW14(value uint32) {
	volatile.StoreUint32(&o.IRPLR4.Reg, volatile.LoadUint32(&o.IRPLR4.Reg)&^(0x3e000000)|value<<25)
}
func (o *VDEC_Type) GetIRPLR4_IREFL_BW14() uint32 {
	return (volatile.LoadUint32(&o.IRPLR4.Reg) & 0x3e000000) >> 25
}

// VDEC.IRPLR5: H264 Initial Reference Picture List Register 5
func (o *VDEC_Type) SetIRPLR5_IREFL_FW15(value uint32) {
	volatile.StoreUint32(&o.IRPLR5.Reg, volatile.LoadUint32(&o.IRPLR5.Reg)&^(0x1f)|value)
}
func (o *VDEC_Type) GetIRPLR5_IREFL_FW15() uint32 {
	return volatile.LoadUint32(&o.IRPLR5.Reg) & 0x1f
}
func (o *VDEC_Type) SetIRPLR5_IREFL_BW15(value uint32) {
	volatile.StoreUint32(&o.IRPLR5.Reg, volatile.LoadUint32(&o.IRPLR5.Reg)&^(0x3e0)|value<<5)
}
func (o *VDEC_Type) GetIRPLR5_IREFL_BW15() uint32 {
	return (volatile.LoadUint32(&o.IRPLR5.Reg) & 0x3e0) >> 5
}

// VDEC.ECR: Error Concealment Register
func (o *VDEC_Type) SetECR_STARTMB_Y(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x7f8000)|value<<15)
}
func (o *VDEC_Type) GetECR_STARTMB_Y() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x7f8000) >> 15
}
func (o *VDEC_Type) SetECR_STARTMB_X(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff800000)|value<<23)
}
func (o *VDEC_Type) GetECR_STARTMB_X() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0xff800000) >> 23
}

// USB High Speed Device Port
type UDPHS_Type struct {
	CTRL        volatile.Register32 // 0x0
	FNUM        volatile.Register32 // 0x4
	_           [8]byte
	IEN         volatile.Register32 // 0x10
	INTSTA      volatile.Register32 // 0x14
	CLRINT      volatile.Register32 // 0x18
	EPTRST      volatile.Register32 // 0x1C
	_           [192]byte
	TST         volatile.Register32 // 0xE0
	_           [28]byte
	EPTCFG0     volatile.Register32 // 0x100
	EPTCTLENB0  volatile.Register32 // 0x104
	EPTCTLDIS0  volatile.Register32 // 0x108
	EPTCTL0     volatile.Register32 // 0x10C
	_           [4]byte
	EPTSETSTA0  volatile.Register32 // 0x114
	EPTCLRSTA0  volatile.Register32 // 0x118
	EPTSTA0     volatile.Register32 // 0x11C
	EPTCFG1     volatile.Register32 // 0x120
	EPTCTLENB1  volatile.Register32 // 0x124
	EPTCTLDIS1  volatile.Register32 // 0x128
	EPTCTL1     volatile.Register32 // 0x12C
	_           [4]byte
	EPTSETSTA1  volatile.Register32 // 0x134
	EPTCLRSTA1  volatile.Register32 // 0x138
	EPTSTA1     volatile.Register32 // 0x13C
	EPTCFG2     volatile.Register32 // 0x140
	EPTCTLENB2  volatile.Register32 // 0x144
	EPTCTLDIS2  volatile.Register32 // 0x148
	EPTCTL2     volatile.Register32 // 0x14C
	_           [4]byte
	EPTSETSTA2  volatile.Register32 // 0x154
	EPTCLRSTA2  volatile.Register32 // 0x158
	EPTSTA2     volatile.Register32 // 0x15C
	EPTCFG3     volatile.Register32 // 0x160
	EPTCTLENB3  volatile.Register32 // 0x164
	EPTCTLDIS3  volatile.Register32 // 0x168
	EPTCTL3     volatile.Register32 // 0x16C
	_           [4]byte
	EPTSETSTA3  volatile.Register32 // 0x174
	EPTCLRSTA3  volatile.Register32 // 0x178
	EPTSTA3     volatile.Register32 // 0x17C
	EPTCFG4     volatile.Register32 // 0x180
	EPTCTLENB4  volatile.Register32 // 0x184
	EPTCTLDIS4  volatile.Register32 // 0x188
	EPTCTL4     volatile.Register32 // 0x18C
	_           [4]byte
	EPTSETSTA4  volatile.Register32 // 0x194
	EPTCLRSTA4  volatile.Register32 // 0x198
	EPTSTA4     volatile.Register32 // 0x19C
	EPTCFG5     volatile.Register32 // 0x1A0
	EPTCTLENB5  volatile.Register32 // 0x1A4
	EPTCTLDIS5  volatile.Register32 // 0x1A8
	EPTCTL5     volatile.Register32 // 0x1AC
	_           [4]byte
	EPTSETSTA5  volatile.Register32 // 0x1B4
	EPTCLRSTA5  volatile.Register32 // 0x1B8
	EPTSTA5     volatile.Register32 // 0x1BC
	EPTCFG6     volatile.Register32 // 0x1C0
	EPTCTLENB6  volatile.Register32 // 0x1C4
	EPTCTLDIS6  volatile.Register32 // 0x1C8
	EPTCTL6     volatile.Register32 // 0x1CC
	_           [4]byte
	EPTSETSTA6  volatile.Register32 // 0x1D4
	EPTCLRSTA6  volatile.Register32 // 0x1D8
	EPTSTA6     volatile.Register32 // 0x1DC
	_           [288]byte
	DMANXTDSC0  volatile.Register32 // 0x300
	DMAADDRESS0 volatile.Register32 // 0x304
	DMACONTROL0 volatile.Register32 // 0x308
	DMASTATUS0  volatile.Register32 // 0x30C
	DMANXTDSC1  volatile.Register32 // 0x310
	DMAADDRESS1 volatile.Register32 // 0x314
	DMACONTROL1 volatile.Register32 // 0x318
	DMASTATUS1  volatile.Register32 // 0x31C
	DMANXTDSC2  volatile.Register32 // 0x320
	DMAADDRESS2 volatile.Register32 // 0x324
	DMACONTROL2 volatile.Register32 // 0x328
	DMASTATUS2  volatile.Register32 // 0x32C
	DMANXTDSC3  volatile.Register32 // 0x330
	DMAADDRESS3 volatile.Register32 // 0x334
	DMACONTROL3 volatile.Register32 // 0x338
	DMASTATUS3  volatile.Register32 // 0x33C
	DMANXTDSC4  volatile.Register32 // 0x340
	DMAADDRESS4 volatile.Register32 // 0x344
	DMACONTROL4 volatile.Register32 // 0x348
	DMASTATUS4  volatile.Register32 // 0x34C
	DMANXTDSC5  volatile.Register32 // 0x350
	DMAADDRESS5 volatile.Register32 // 0x354
	DMACONTROL5 volatile.Register32 // 0x358
	DMASTATUS5  volatile.Register32 // 0x35C
}

// UDPHS.CTRL: UDPHS Control Register
func (o *UDPHS_Type) SetCTRL_DEV_ADDR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f)|value)
}
func (o *UDPHS_Type) GetCTRL_DEV_ADDR() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x7f
}
func (o *UDPHS_Type) SetCTRL_FADDR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCTRL_FADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetCTRL_EN_UDPHS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetCTRL_EN_UDPHS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetCTRL_DETACH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetCTRL_DETACH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetCTRL_REWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetCTRL_REWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetCTRL_PULLD_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetCTRL_PULLD_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}

// UDPHS.FNUM: UDPHS Frame Number Register
func (o *UDPHS_Type) SetFNUM_MICRO_FRAME_NUM(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetFNUM_MICRO_FRAME_NUM() uint32 {
	return volatile.LoadUint32(&o.FNUM.Reg) & 0x7
}
func (o *UDPHS_Type) SetFNUM_FRAME_NUMBER(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *UDPHS_Type) GetFNUM_FRAME_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x3ff8) >> 3
}
func (o *UDPHS_Type) SetFNUM_FNUM_ERR(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetFNUM_FNUM_ERR() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x80000000) >> 31
}

// UDPHS.IEN: UDPHS Interrupt Enable Register
func (o *UDPHS_Type) SetIEN_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetIEN_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetIEN_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetIEN_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetIEN_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetIEN_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetIEN_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetIEN_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetIEN_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetIEN_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetIEN_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetIEN_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetIEN_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetIEN_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetIEN_EPT_0(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetIEN_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetIEN_EPT_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetIEN_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetIEN_EPT_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetIEN_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetIEN_EPT_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetIEN_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetIEN_EPT_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetIEN_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetIEN_EPT_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetIEN_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetIEN_EPT_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetIEN_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetIEN_DMA_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetIEN_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetIEN_DMA_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetIEN_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetIEN_DMA_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetIEN_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetIEN_DMA_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetIEN_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetIEN_DMA_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetIEN_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetIEN_DMA_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetIEN_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40000000) >> 30
}

// UDPHS.INTSTA: UDPHS Interrupt Status Register
func (o *UDPHS_Type) SetINTSTA_SPEED(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetINTSTA_SPEED() uint32 {
	return volatile.LoadUint32(&o.INTSTA.Reg) & 0x1
}
func (o *UDPHS_Type) SetINTSTA_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetINTSTA_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetINTSTA_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetINTSTA_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetINTSTA_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetINTSTA_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetINTSTA_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetINTSTA_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetINTSTA_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetINTSTA_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetINTSTA_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetINTSTA_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetINTSTA_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetINTSTA_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetINTSTA_EPT_0(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetINTSTA_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetINTSTA_EPT_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetINTSTA_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetINTSTA_EPT_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetINTSTA_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetINTSTA_EPT_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetINTSTA_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetINTSTA_EPT_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetINTSTA_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetINTSTA_EPT_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetINTSTA_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetINTSTA_EPT_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetINTSTA_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetINTSTA_DMA_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetINTSTA_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetINTSTA_DMA_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetINTSTA_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetINTSTA_DMA_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetINTSTA_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetINTSTA_DMA_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetINTSTA_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetINTSTA_DMA_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetINTSTA_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetINTSTA_DMA_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetINTSTA_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40000000) >> 30
}

// UDPHS.CLRINT: UDPHS Clear Interrupt Register
func (o *UDPHS_Type) SetCLRINT_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetCLRINT_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetCLRINT_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetCLRINT_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetCLRINT_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetCLRINT_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetCLRINT_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetCLRINT_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetCLRINT_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetCLRINT_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetCLRINT_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetCLRINT_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetCLRINT_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCLRINT_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x80) >> 7
}

// UDPHS.EPTRST: UDPHS Endpoints Reset Register
func (o *UDPHS_Type) SetEPTRST_EPT_0(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTRST_EPT_0() uint32 {
	return volatile.LoadUint32(&o.EPTRST.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTRST_EPT_1(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTRST_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTRST_EPT_2(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetEPTRST_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetEPTRST_EPT_3(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTRST_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTRST_EPT_4(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTRST_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTRST_EPT_5(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTRST_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTRST_EPT_6(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTRST_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x40) >> 6
}

// UDPHS.TST: UDPHS Test Register
func (o *UDPHS_Type) SetTST_SPEED_CFG(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x3)|value)
}
func (o *UDPHS_Type) GetTST_SPEED_CFG() uint32 {
	return volatile.LoadUint32(&o.TST.Reg) & 0x3
}
func (o *UDPHS_Type) SetTST_TST_J(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetTST_TST_J() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetTST_TST_K(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetTST_TST_K() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetTST_TST_PKT(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetTST_TST_PKT() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetTST_OPMODE2(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetTST_OPMODE2() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x20) >> 5
}

// UDPHS.EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCFG0_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG0_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG0_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG0_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG0_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLENB0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLDIS0_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTL0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSETSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCLRSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA0_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA0_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA0_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA0_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA0_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA0_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA0_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA0_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCFG1_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG1_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG1_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG1_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG1_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLENB1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLDIS1_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTL1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSETSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCLRSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA1_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA1_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA1_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA1_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA1_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA1_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA1_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA1_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCFG2_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG2_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG2_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG2_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG2_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLENB2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLDIS2_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTL2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSETSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCLRSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA2_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA2_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA2_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA2_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA2_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA2_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA2_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA2_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCFG3_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG3_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG3_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG3_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG3_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLENB3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLDIS3_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTL3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSETSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCLRSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA3_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA3_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA3_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA3_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA3_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA3_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA3_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA3_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCFG4_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG4_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG4_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG4_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG4_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLENB4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLDIS4_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTL4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSETSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCLRSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA4_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA4_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA4_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA4_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA4_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA4_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA4_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA4_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCFG5_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG5_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG5_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG5_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG5_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLENB5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLDIS5_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTL5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSETSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCLRSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA5_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA5_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA5_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA5_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA5_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA5_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA5_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA5_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCFG6_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG6_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG6_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG6_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG6_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLENB6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLDIS6_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTL6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSETSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCLRSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA6_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA6_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA6_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA6_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA6_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA6_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA6_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA6_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x80000000) >> 31
}

// UDPHS.DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
func (o *UDPHS_Type) SetDMANXTDSC0(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC0.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC0() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC0.Reg)
}

// UDPHS.DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
func (o *UDPHS_Type) SetDMAADDRESS0(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS0.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS0() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS0.Reg)
}

// UDPHS.DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
func (o *UDPHS_Type) SetDMACONTROL0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL0_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL0_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL0_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL0_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL0_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL0_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL0_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL0_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL0_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL0_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS0_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS0_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS0_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS0_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS0_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS0_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
func (o *UDPHS_Type) SetDMANXTDSC1(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC1.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC1() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC1.Reg)
}

// UDPHS.DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
func (o *UDPHS_Type) SetDMAADDRESS1(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS1.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS1() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS1.Reg)
}

// UDPHS.DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
func (o *UDPHS_Type) SetDMACONTROL1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL1_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL1_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL1_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL1_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL1_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL1_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL1_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL1_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL1_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL1_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS1_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS1_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS1_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS1_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS1_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS1_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
func (o *UDPHS_Type) SetDMANXTDSC2(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC2.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC2() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC2.Reg)
}

// UDPHS.DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
func (o *UDPHS_Type) SetDMAADDRESS2(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS2.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS2() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS2.Reg)
}

// UDPHS.DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
func (o *UDPHS_Type) SetDMACONTROL2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL2_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL2_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL2_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL2_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL2_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL2_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL2_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL2_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL2_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL2_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS2_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS2_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS2_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS2_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS2_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS2_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
func (o *UDPHS_Type) SetDMANXTDSC3(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC3.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC3() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC3.Reg)
}

// UDPHS.DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
func (o *UDPHS_Type) SetDMAADDRESS3(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS3.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS3() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS3.Reg)
}

// UDPHS.DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
func (o *UDPHS_Type) SetDMACONTROL3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL3_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL3_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL3_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL3_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL3_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL3_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL3_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL3_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL3_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL3_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS3_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS3_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS3_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS3_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS3_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS3_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
func (o *UDPHS_Type) SetDMANXTDSC4(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC4.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC4() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC4.Reg)
}

// UDPHS.DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
func (o *UDPHS_Type) SetDMAADDRESS4(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS4.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS4() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS4.Reg)
}

// UDPHS.DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
func (o *UDPHS_Type) SetDMACONTROL4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL4_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL4_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL4_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL4_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL4_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL4_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL4_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL4_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL4_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL4_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS4_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS4_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS4_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS4_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS4_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS4_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
func (o *UDPHS_Type) SetDMANXTDSC5(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC5.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC5() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC5.Reg)
}

// UDPHS.DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
func (o *UDPHS_Type) SetDMAADDRESS5(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS5.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS5() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS5.Reg)
}

// UDPHS.DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
func (o *UDPHS_Type) SetDMACONTROL5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL5_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL5_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL5_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL5_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL5_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL5_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL5_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL5_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL5_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL5_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS5_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS5_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS5_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS5_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS5_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS5_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0xffff0000) >> 16
}

// Timer Counter 0
type TC_Type struct {
	CCR0 volatile.Register32 // 0x0
	CMR0 volatile.Register32 // 0x4
	_    [8]byte
	CV0  volatile.Register32 // 0x10
	RA0  volatile.Register32 // 0x14
	RB0  volatile.Register32 // 0x18
	RC0  volatile.Register32 // 0x1C
	SR0  volatile.Register32 // 0x20
	IER0 volatile.Register32 // 0x24
	IDR0 volatile.Register32 // 0x28
	IMR0 volatile.Register32 // 0x2C
	_    [16]byte
	CCR1 volatile.Register32 // 0x40
	CMR1 volatile.Register32 // 0x44
	_    [8]byte
	CV1  volatile.Register32 // 0x50
	RA1  volatile.Register32 // 0x54
	RB1  volatile.Register32 // 0x58
	RC1  volatile.Register32 // 0x5C
	SR1  volatile.Register32 // 0x60
	IER1 volatile.Register32 // 0x64
	IDR1 volatile.Register32 // 0x68
	IMR1 volatile.Register32 // 0x6C
	_    [16]byte
	CCR2 volatile.Register32 // 0x80
	CMR2 volatile.Register32 // 0x84
	_    [8]byte
	CV2  volatile.Register32 // 0x90
	RA2  volatile.Register32 // 0x94
	RB2  volatile.Register32 // 0x98
	RC2  volatile.Register32 // 0x9C
	SR2  volatile.Register32 // 0xA0
	IER2 volatile.Register32 // 0xA4
	IDR2 volatile.Register32 // 0xA8
	IMR2 volatile.Register32 // 0xAC
	_    [16]byte
	BCR  volatile.Register32 // 0xC0
	BMR  volatile.Register32 // 0xC4
}

// TC.CCR0: Channel Control Register (channel = 0)
func (o *TC_Type) SetCCR0_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR0_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR0.Reg) & 0x1
}
func (o *TC_Type) SetCCR0_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR0_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR0_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR0_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x4) >> 2
}

// TC.CMR0: Channel Mode Register (channel = 0)
func (o *TC_Type) SetCMR0_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR0_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0x7
}
func (o *TC_Type) SetCMR0_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR0_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR0_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR0_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR0_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR0_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR0_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR0_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR0_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR0_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR0_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR0_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR0_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR0_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR0_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR0_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR0_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR0_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR0_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR0_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0xc0000) >> 18
}

// TC.CV0: Counter Value (channel = 0)
func (o *TC_Type) SetCV0_CV(value uint32) {
	volatile.StoreUint32(&o.CV0.Reg, volatile.LoadUint32(&o.CV0.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetCV0_CV() uint32 {
	return volatile.LoadUint32(&o.CV0.Reg) & 0xffff
}

// TC.RA0: Register A (channel = 0)
func (o *TC_Type) SetRA0_RA(value uint32) {
	volatile.StoreUint32(&o.RA0.Reg, volatile.LoadUint32(&o.RA0.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRA0_RA() uint32 {
	return volatile.LoadUint32(&o.RA0.Reg) & 0xffff
}

// TC.RB0: Register B (channel = 0)
func (o *TC_Type) SetRB0_RB(value uint32) {
	volatile.StoreUint32(&o.RB0.Reg, volatile.LoadUint32(&o.RB0.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRB0_RB() uint32 {
	return volatile.LoadUint32(&o.RB0.Reg) & 0xffff
}

// TC.RC0: Register C (channel = 0)
func (o *TC_Type) SetRC0_RC(value uint32) {
	volatile.StoreUint32(&o.RC0.Reg, volatile.LoadUint32(&o.RC0.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRC0_RC() uint32 {
	return volatile.LoadUint32(&o.RC0.Reg) & 0xffff
}

// TC.SR0: Status Register (channel = 0)
func (o *TC_Type) SetSR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR0.Reg) & 0x1
}
func (o *TC_Type) SetSR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR0_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR0_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR0_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR0_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR0_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR0_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40000) >> 18
}

// TC.IER0: Interrupt Enable Register (channel = 0)
func (o *TC_Type) SetIER0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER0.Reg) & 0x1
}
func (o *TC_Type) SetIER0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80) >> 7
}

// TC.IDR0: Interrupt Disable Register (channel = 0)
func (o *TC_Type) SetIDR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR0.Reg) & 0x1
}
func (o *TC_Type) SetIDR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x80) >> 7
}

// TC.IMR0: Interrupt Mask Register (channel = 0)
func (o *TC_Type) SetIMR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR0.Reg) & 0x1
}
func (o *TC_Type) SetIMR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x80) >> 7
}

// TC.CCR1: Channel Control Register (channel = 1)
func (o *TC_Type) SetCCR1_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR1_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0x1
}
func (o *TC_Type) SetCCR1_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR1_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR1_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR1_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4) >> 2
}

// TC.CMR1: Channel Mode Register (channel = 1)
func (o *TC_Type) SetCMR1_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR1_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0x7
}
func (o *TC_Type) SetCMR1_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR1_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR1_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR1_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR1_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR1_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR1_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR1_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR1_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR1_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR1_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR1_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR1_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR1_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR1_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR1_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR1_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR1_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR1_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR1_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0xc0000) >> 18
}

// TC.CV1: Counter Value (channel = 1)
func (o *TC_Type) SetCV1_CV(value uint32) {
	volatile.StoreUint32(&o.CV1.Reg, volatile.LoadUint32(&o.CV1.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetCV1_CV() uint32 {
	return volatile.LoadUint32(&o.CV1.Reg) & 0xffff
}

// TC.RA1: Register A (channel = 1)
func (o *TC_Type) SetRA1_RA(value uint32) {
	volatile.StoreUint32(&o.RA1.Reg, volatile.LoadUint32(&o.RA1.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRA1_RA() uint32 {
	return volatile.LoadUint32(&o.RA1.Reg) & 0xffff
}

// TC.RB1: Register B (channel = 1)
func (o *TC_Type) SetRB1_RB(value uint32) {
	volatile.StoreUint32(&o.RB1.Reg, volatile.LoadUint32(&o.RB1.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRB1_RB() uint32 {
	return volatile.LoadUint32(&o.RB1.Reg) & 0xffff
}

// TC.RC1: Register C (channel = 1)
func (o *TC_Type) SetRC1_RC(value uint32) {
	volatile.StoreUint32(&o.RC1.Reg, volatile.LoadUint32(&o.RC1.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRC1_RC() uint32 {
	return volatile.LoadUint32(&o.RC1.Reg) & 0xffff
}

// TC.SR1: Status Register (channel = 1)
func (o *TC_Type) SetSR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}
func (o *TC_Type) SetSR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR1_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR1_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR1_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR1_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR1_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR1_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40000) >> 18
}

// TC.IER1: Interrupt Enable Register (channel = 1)
func (o *TC_Type) SetIER1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *TC_Type) SetIER1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80) >> 7
}

// TC.IDR1: Interrupt Disable Register (channel = 1)
func (o *TC_Type) SetIDR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *TC_Type) SetIDR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80) >> 7
}

// TC.IMR1: Interrupt Mask Register (channel = 1)
func (o *TC_Type) SetIMR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *TC_Type) SetIMR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80) >> 7
}

// TC.CCR2: Channel Control Register (channel = 2)
func (o *TC_Type) SetCCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR2_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0x1
}
func (o *TC_Type) SetCCR2_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR2_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR2_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR2_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4) >> 2
}

// TC.CMR2: Channel Mode Register (channel = 2)
func (o *TC_Type) SetCMR2_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR2_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0x7
}
func (o *TC_Type) SetCMR2_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR2_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR2_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR2_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR2_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR2_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR2_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR2_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR2_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR2_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR2_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR2_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR2_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR2_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR2_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR2_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR2_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR2_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR2_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR2_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0xc0000) >> 18
}

// TC.CV2: Counter Value (channel = 2)
func (o *TC_Type) SetCV2_CV(value uint32) {
	volatile.StoreUint32(&o.CV2.Reg, volatile.LoadUint32(&o.CV2.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetCV2_CV() uint32 {
	return volatile.LoadUint32(&o.CV2.Reg) & 0xffff
}

// TC.RA2: Register A (channel = 2)
func (o *TC_Type) SetRA2_RA(value uint32) {
	volatile.StoreUint32(&o.RA2.Reg, volatile.LoadUint32(&o.RA2.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRA2_RA() uint32 {
	return volatile.LoadUint32(&o.RA2.Reg) & 0xffff
}

// TC.RB2: Register B (channel = 2)
func (o *TC_Type) SetRB2_RB(value uint32) {
	volatile.StoreUint32(&o.RB2.Reg, volatile.LoadUint32(&o.RB2.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRB2_RB() uint32 {
	return volatile.LoadUint32(&o.RB2.Reg) & 0xffff
}

// TC.RC2: Register C (channel = 2)
func (o *TC_Type) SetRC2_RC(value uint32) {
	volatile.StoreUint32(&o.RC2.Reg, volatile.LoadUint32(&o.RC2.Reg)&^(0xffff)|value)
}
func (o *TC_Type) GetRC2_RC() uint32 {
	return volatile.LoadUint32(&o.RC2.Reg) & 0xffff
}

// TC.SR2: Status Register (channel = 2)
func (o *TC_Type) SetSR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR2.Reg) & 0x1
}
func (o *TC_Type) SetSR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR2_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR2_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR2_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR2_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR2_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR2_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40000) >> 18
}

// TC.IER2: Interrupt Enable Register (channel = 2)
func (o *TC_Type) SetIER2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *TC_Type) SetIER2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80) >> 7
}

// TC.IDR2: Interrupt Disable Register (channel = 2)
func (o *TC_Type) SetIDR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *TC_Type) SetIDR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80) >> 7
}

// TC.IMR2: Interrupt Mask Register (channel = 2)
func (o *TC_Type) SetIMR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *TC_Type) SetIMR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80) >> 7
}

// TC.BCR: Block Control Register
func (o *TC_Type) SetBCR_SYNC(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetBCR_SYNC() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// TC.BMR: Block Mode Register
func (o *TC_Type) SetBMR_TC0XC0S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3)|value)
}
func (o *TC_Type) GetBMR_TC0XC0S() uint32 {
	return volatile.LoadUint32(&o.BMR.Reg) & 0x3
}
func (o *TC_Type) SetBMR_TC1XC1S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0xc)|value<<2)
}
func (o *TC_Type) GetBMR_TC1XC1S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0xc) >> 2
}
func (o *TC_Type) SetBMR_TC2XC2S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetBMR_TC2XC2S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x30) >> 4
}

// High Speed MultiMedia Card Interface 0
type HSMCI_Type struct {
	CR    volatile.Register32    // 0x0
	MR    volatile.Register32    // 0x4
	DTOR  volatile.Register32    // 0x8
	SDCR  volatile.Register32    // 0xC
	ARGR  volatile.Register32    // 0x10
	CMDR  volatile.Register32    // 0x14
	BLKR  volatile.Register32    // 0x18
	CSTOR volatile.Register32    // 0x1C
	RSPR  [4]volatile.Register32 // 0x20
	RDR   volatile.Register32    // 0x30
	TDR   volatile.Register32    // 0x34
	_     [8]byte
	SR    volatile.Register32 // 0x40
	IER   volatile.Register32 // 0x44
	IDR   volatile.Register32 // 0x48
	IMR   volatile.Register32 // 0x4C
	DMA   volatile.Register32 // 0x50
	CFG   volatile.Register32 // 0x54
	_     [140]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// HSMCI.CR: Control Register
func (o *HSMCI_Type) SetCR_MCIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCR_MCIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *HSMCI_Type) SetCR_MCIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetCR_MCIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetCR_PWSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetCR_PWSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetCR_PWSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetCR_PWSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *HSMCI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// HSMCI.MR: Mode Register
func (o *HSMCI_Type) SetMR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff)|value)
}
func (o *HSMCI_Type) GetMR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xff
}
func (o *HSMCI_Type) SetMR_PWSDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetMR_PWSDIV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetMR_RDPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetMR_RDPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetMR_WRPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetMR_WRPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetMR_FBYTE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetMR_FBYTE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetMR_PADV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000)|value<<14)
}
func (o *HSMCI_Type) GetMR_PADV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000) >> 14
}
func (o *HSMCI_Type) SetMR_BLKLEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSMCI_Type) GetMR_BLKLEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xffff0000) >> 16
}

// HSMCI.DTOR: Data Timeout Register
func (o *HSMCI_Type) SetDTOR_DTOCYC(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetDTOR_DTOCYC() uint32 {
	return volatile.LoadUint32(&o.DTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetDTOR_DTOMUL(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetDTOR_DTOMUL() uint32 {
	return (volatile.LoadUint32(&o.DTOR.Reg) & 0x70) >> 4
}

// HSMCI.SDCR: SD/SDIO Card Register
func (o *HSMCI_Type) SetSDCR_SDCSEL(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetSDCR_SDCSEL() uint32 {
	return volatile.LoadUint32(&o.SDCR.Reg) & 0x3
}
func (o *HSMCI_Type) SetSDCR_SDCBUS(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetSDCR_SDCBUS() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0xc0) >> 6
}

// HSMCI.ARGR: Argument Register
func (o *HSMCI_Type) SetARGR(value uint32) {
	volatile.StoreUint32(&o.ARGR.Reg, value)
}
func (o *HSMCI_Type) GetARGR() uint32 {
	return volatile.LoadUint32(&o.ARGR.Reg)
}

// HSMCI.CMDR: Command Register
func (o *HSMCI_Type) SetCMDR_CMDNB(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3f)|value)
}
func (o *HSMCI_Type) GetCMDR_CMDNB() uint32 {
	return volatile.LoadUint32(&o.CMDR.Reg) & 0x3f
}
func (o *HSMCI_Type) SetCMDR_RSPTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetCMDR_RSPTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0xc0) >> 6
}
func (o *HSMCI_Type) SetCMDR_SPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetCMDR_SPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetCMDR_OPDCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetCMDR_OPDCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetCMDR_MAXLAT(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCMDR_MAXLAT() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetCMDR_TRCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x30000)|value<<16)
}
func (o *HSMCI_Type) GetCMDR_TRCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x30000) >> 16
}
func (o *HSMCI_Type) SetCMDR_TRDIR(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetCMDR_TRDIR() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetCMDR_TRTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x380000)|value<<19)
}
func (o *HSMCI_Type) GetCMDR_TRTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x380000) >> 19
}
func (o *HSMCI_Type) SetCMDR_IOSPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3000000)|value<<24)
}
func (o *HSMCI_Type) GetCMDR_IOSPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x3000000) >> 24
}
func (o *HSMCI_Type) SetCMDR_ATACS(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetCMDR_ATACS() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetCMDR_BOOT_ACK(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetCMDR_BOOT_ACK() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x8000000) >> 27
}

// HSMCI.BLKR: Block Register
func (o *HSMCI_Type) SetBLKR_BCNT(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff)|value)
}
func (o *HSMCI_Type) GetBLKR_BCNT() uint32 {
	return volatile.LoadUint32(&o.BLKR.Reg) & 0xffff
}
func (o *HSMCI_Type) SetBLKR_BLKLEN(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSMCI_Type) GetBLKR_BLKLEN() uint32 {
	return (volatile.LoadUint32(&o.BLKR.Reg) & 0xffff0000) >> 16
}

// HSMCI.CSTOR: Completion Signal Timeout Register
func (o *HSMCI_Type) SetCSTOR_CSTOCYC(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetCSTOR_CSTOCYC() uint32 {
	return volatile.LoadUint32(&o.CSTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetCSTOR_CSTOMUL(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetCSTOR_CSTOMUL() uint32 {
	return (volatile.LoadUint32(&o.CSTOR.Reg) & 0x70) >> 4
}

// HSMCI.RSPR: Response Register
func (o *HSMCI_Type) SetRSPR(idx int, value uint32) {
	volatile.StoreUint32(&o.RSPR[idx].Reg, value)
}
func (o *HSMCI_Type) GetRSPR(idx int) uint32 {
	return volatile.LoadUint32(&o.RSPR[idx].Reg)
}

// HSMCI.RDR: Receive Data Register
func (o *HSMCI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *HSMCI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// HSMCI.TDR: Transmit Data Register
func (o *HSMCI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *HSMCI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// HSMCI.SR: Status Register
func (o *HSMCI_Type) SetSR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetSR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *HSMCI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetSR_BLKE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetSR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetSR_DTIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetSR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetSR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetSR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetSR_MCI_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetSR_MCI_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetSR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetSR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetSR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetSR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetSR_RINDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetSR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetSR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetSR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetSR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetSR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetSR_RENDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetSR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetSR_RTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetSR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetSR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetSR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetSR_DTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetSR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetSR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetSR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetSR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetSR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetSR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetSR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetSR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetSR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetSR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetSR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetSR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetSR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetSR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetSR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetSR_UNRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetSR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// HSMCI.IER: Interrupt Enable Register
func (o *HSMCI_Type) SetIER_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIER_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *HSMCI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIER_BLKE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIER_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIER_DTIP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIER_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIER_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIER_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIER_MCI_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIER_MCI_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIER_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIER_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIER_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIER_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIER_RINDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIER_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIER_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIER_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIER_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIER_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIER_RENDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIER_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIER_RTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIER_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIER_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIER_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIER_DTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIER_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIER_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIER_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIER_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIER_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIER_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIER_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIER_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIER_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIER_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIER_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIER_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIER_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIER_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIER_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIER_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIER_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// HSMCI.IDR: Interrupt Disable Register
func (o *HSMCI_Type) SetIDR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIDR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIDR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIDR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIDR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIDR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIDR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIDR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIDR_MCI_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIDR_MCI_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIDR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIDR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIDR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIDR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIDR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIDR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIDR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIDR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIDR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIDR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIDR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIDR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIDR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIDR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIDR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIDR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIDR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIDR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIDR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIDR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIDR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIDR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIDR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIDR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIDR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIDR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIDR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIDR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIDR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIDR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIDR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIDR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIDR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIDR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// HSMCI.IMR: Interrupt Mask Register
func (o *HSMCI_Type) SetIMR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIMR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIMR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIMR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIMR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIMR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIMR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIMR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIMR_MCI_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIMR_MCI_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIMR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIMR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIMR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIMR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIMR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIMR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIMR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIMR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIMR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIMR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIMR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIMR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIMR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIMR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIMR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIMR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIMR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIMR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIMR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIMR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIMR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIMR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIMR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIMR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIMR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIMR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIMR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIMR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIMR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIMR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIMR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIMR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIMR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIMR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// HSMCI.DMA: DMA Configuration Register
func (o *HSMCI_Type) SetDMA_OFFSET(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetDMA_OFFSET() uint32 {
	return volatile.LoadUint32(&o.DMA.Reg) & 0x3
}
func (o *HSMCI_Type) SetDMA_CHKSIZE(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x30)|value<<4)
}
func (o *HSMCI_Type) GetDMA_CHKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x30) >> 4
}
func (o *HSMCI_Type) SetDMA_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetDMA_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetDMA_ROPT(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetDMA_ROPT() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x1000) >> 12
}

// HSMCI.CFG: Configuration Register
func (o *HSMCI_Type) SetCFG_FIFOMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCFG_FIFOMODE() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *HSMCI_Type) SetCFG_FERRCTRL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetCFG_FERRCTRL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetCFG_HSMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetCFG_HSMODE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetCFG_LSYNC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCFG_LSYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}

// HSMCI.WPMR: Write Protection Mode Register
func (o *HSMCI_Type) SetWPMR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetWPMR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetWPMR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPMR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// HSMCI.WPSR: Write Protection Status Register
func (o *HSMCI_Type) SetWPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetWPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0xf
}
func (o *HSMCI_Type) SetWPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Two-wire Interface 0
type TWI_Type struct {
	CR   volatile.Register32 // 0x0
	MMR  volatile.Register32 // 0x4
	SMR  volatile.Register32 // 0x8
	IADR volatile.Register32 // 0xC
	CWGR volatile.Register32 // 0x10
	_    [12]byte
	SR   volatile.Register32 // 0x20
	IER  volatile.Register32 // 0x24
	IDR  volatile.Register32 // 0x28
	IMR  volatile.Register32 // 0x2C
	RHR  volatile.Register32 // 0x30
	THR  volatile.Register32 // 0x34
}

// TWI.CR: Control Register
func (o *TWI_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TWI_Type) SetCR_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetCR_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetCR_MSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetCR_MSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetCR_MSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetCR_MSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetCR_SVEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetCR_SVEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetCR_SVDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetCR_SVDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetCR_QUICK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetCR_QUICK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// TWI.MMR: Master Mode Register
func (o *TWI_Type) SetMMR_IADRSZ(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x300)|value<<8)
}
func (o *TWI_Type) GetMMR_IADRSZ() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x300) >> 8
}
func (o *TWI_Type) SetMMR_MREAD(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x1000)|value<<12)
}
func (o *TWI_Type) GetMMR_MREAD() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x1000) >> 12
}
func (o *TWI_Type) SetMMR_DADR(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetMMR_DADR() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x7f0000) >> 16
}

// TWI.SMR: Slave Mode Register
func (o *TWI_Type) SetSMR_SADR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetSMR_SADR() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x7f0000) >> 16
}

// TWI.IADR: Internal Address Register
func (o *TWI_Type) SetIADR(value uint32) {
	volatile.StoreUint32(&o.IADR.Reg, volatile.LoadUint32(&o.IADR.Reg)&^(0xffffff)|value)
}
func (o *TWI_Type) GetIADR() uint32 {
	return volatile.LoadUint32(&o.IADR.Reg) & 0xffffff
}

// TWI.CWGR: Clock Waveform Generator Register
func (o *TWI_Type) SetCWGR_CLDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetCWGR_CLDIV() uint32 {
	return volatile.LoadUint32(&o.CWGR.Reg) & 0xff
}
func (o *TWI_Type) SetCWGR_CHDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff00)|value<<8)
}
func (o *TWI_Type) GetCWGR_CHDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0xff00) >> 8
}
func (o *TWI_Type) SetCWGR_CKDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0x70000)|value<<16)
}
func (o *TWI_Type) GetCWGR_CKDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0x70000) >> 16
}

// TWI.SR: Status Register
func (o *TWI_Type) SetSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetSR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TWI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetSR_SVREAD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetSR_SVREAD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetSR_SVACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetSR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetSR_GACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetSR_GACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetSR_NACK(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetSR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetSR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetSR_SCLWS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetSR_SCLWS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetSR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetSR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}

// TWI.IER: Interrupt Enable Register
func (o *TWI_Type) SetIER_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIER_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TWI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIER_SVACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIER_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIER_GACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIER_GACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIER_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIER_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIER_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIER_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIER_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIER_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// TWI.IDR: Interrupt Disable Register
func (o *TWI_Type) SetIDR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIDR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TWI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIDR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIDR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIDR_GACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIDR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIDR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIDR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIDR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIDR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIDR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIDR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// TWI.IMR: Interrupt Mask Register
func (o *TWI_Type) SetIMR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIMR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TWI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIMR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIMR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIMR_GACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIMR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIMR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIMR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIMR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIMR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIMR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIMR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// TWI.RHR: Receive Holding Register
func (o *TWI_Type) SetRHR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetRHR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// TWI.THR: Transmit Holding Register
func (o *TWI_Type) SetTHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetTHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// Universal Synchronous Asynchronous Receiver Transmitter 0
type USART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	CSR  volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	RTOR volatile.Register32 // 0x24
	TTGR volatile.Register32 // 0x28
	_    [20]byte
	FIDI volatile.Register32 // 0x40
	NER  volatile.Register32 // 0x44
	_    [4]byte
	IF   volatile.Register32 // 0x4C
	MAN  volatile.Register32 // 0x50
	_    [172]byte
	RPR  volatile.Register32 // 0x100
	RCR  volatile.Register32 // 0x104
	TPR  volatile.Register32 // 0x108
	TCR  volatile.Register32 // 0x10C
	RNPR volatile.Register32 // 0x110
	RNCR volatile.Register32 // 0x114
	TNPR volatile.Register32 // 0x118
	TNCR volatile.Register32 // 0x11C
	PTCR volatile.Register32 // 0x120
	PTSR volatile.Register32 // 0x124
}

// USART.CR: Control Register
func (o *USART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR_STTBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR_STTBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR_STPBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR_STPBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR_STTTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR_STTTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR_SENDA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR_SENDA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR_RSTIT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR_RSTIT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR_RSTNACK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR_RSTNACK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR_RETTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR_RETTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR_RTSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR_RTSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}

// USART.MR: Mode Register
func (o *USART_Type) SetMR_USART_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMR_USART_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xf
}
func (o *USART_Type) SetMR_USCLKS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetMR_USCLKS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetMR_CHRL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc0)|value<<6)
}
func (o *USART_Type) GetMR_CHRL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc0) >> 6
}
func (o *USART_Type) SetMR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetMR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *USART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *USART_Type) SetMR_NBSTOP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetMR_NBSTOP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *USART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}
func (o *USART_Type) SetMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetMR_MODE9(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetMR_MODE9() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetMR_CLKO(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetMR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetMR_OVER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetMR_OVER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetMR_INACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetMR_INACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetMR_DSNACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetMR_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetMR_VAR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetMR_VAR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetMR_MAX_ITERATION(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000000)|value<<24)
}
func (o *USART_Type) GetMR_MAX_ITERATION() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000000) >> 24
}
func (o *USART_Type) SetMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMR_MAN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMR_MAN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMR_MODSYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMR_MODSYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetMR_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetMR_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// USART.IER: Interrupt Enable Register
func (o *USART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *USART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIER_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIER_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIER_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIER_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIER_ITER(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIER_ITER() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIER_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIER_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIER_MANE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIER_MANE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}

// USART.IDR: Interrupt Disable Register
func (o *USART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *USART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIDR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIDR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIDR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIDR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIDR_ITER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIDR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIDR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIDR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIDR_MANE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIDR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}

// USART.IMR: Interrupt Mask Register
func (o *USART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *USART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIMR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIMR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIMR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIMR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIMR_ITER(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIMR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIMR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIMR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIMR_MANE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIMR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}

// USART.CSR: Channel Status Register
func (o *USART_Type) SetCSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *USART_Type) SetCSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCSR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCSR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCSR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCSR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCSR_PARE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCSR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCSR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCSR_ITER(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCSR_ITER() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCSR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCSR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCSR_NACK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCSR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCSR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCSR_CTS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCSR_MANERR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetCSR_MANERR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}

// USART.RHR: Receiver Holding Register
func (o *USART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0x1ff
}
func (o *USART_Type) SetRHR_RXSYNH(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetRHR_RXSYNH() uint32 {
	return (volatile.LoadUint32(&o.RHR.Reg) & 0x8000) >> 15
}

// USART.THR: Transmitter Holding Register
func (o *USART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0x1ff
}
func (o *USART_Type) SetTHR_TXSYNH(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetTHR_TXSYNH() uint32 {
	return (volatile.LoadUint32(&o.THR.Reg) & 0x8000) >> 15
}

// USART.BRGR: Baud Rate Generator Register
func (o *USART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}
func (o *USART_Type) SetBRGR_FP(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0x70000)|value<<16)
}
func (o *USART_Type) GetBRGR_FP() uint32 {
	return (volatile.LoadUint32(&o.BRGR.Reg) & 0x70000) >> 16
}

// USART.RTOR: Receiver Time-out Register
func (o *USART_Type) SetRTOR_TO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetRTOR_TO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffff
}

// USART.TTGR: Transmitter Timeguard Register
func (o *USART_Type) SetTTGR_TG(value uint32) {
	volatile.StoreUint32(&o.TTGR.Reg, volatile.LoadUint32(&o.TTGR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetTTGR_TG() uint32 {
	return volatile.LoadUint32(&o.TTGR.Reg) & 0xff
}

// USART.FIDI: FI DI Ratio Register
func (o *USART_Type) SetFIDI_FI_DI_RATIO(value uint32) {
	volatile.StoreUint32(&o.FIDI.Reg, volatile.LoadUint32(&o.FIDI.Reg)&^(0x7ff)|value)
}
func (o *USART_Type) GetFIDI_FI_DI_RATIO() uint32 {
	return volatile.LoadUint32(&o.FIDI.Reg) & 0x7ff
}

// USART.NER: Number of Errors Register
func (o *USART_Type) SetNER_NB_ERRORS(value uint32) {
	volatile.StoreUint32(&o.NER.Reg, volatile.LoadUint32(&o.NER.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetNER_NB_ERRORS() uint32 {
	return volatile.LoadUint32(&o.NER.Reg) & 0xff
}

// USART.IF: IrDA Filter Register
func (o *USART_Type) SetIF_IRDA_FILTER(value uint32) {
	volatile.StoreUint32(&o.IF.Reg, volatile.LoadUint32(&o.IF.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetIF_IRDA_FILTER() uint32 {
	return volatile.LoadUint32(&o.IF.Reg) & 0xff
}

// USART.MAN: Manchester Encoder Decoder Register
func (o *USART_Type) SetMAN_TX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMAN_TX_PL() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xf
}
func (o *USART_Type) SetMAN_TX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x300)|value<<8)
}
func (o *USART_Type) GetMAN_TX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x300) >> 8
}
func (o *USART_Type) SetMAN_TX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetMAN_TX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetMAN_RX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf0000)|value<<16)
}
func (o *USART_Type) GetMAN_RX_PL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf0000) >> 16
}
func (o *USART_Type) SetMAN_RX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x3000000)|value<<24)
}
func (o *USART_Type) GetMAN_RX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x3000000) >> 24
}
func (o *USART_Type) SetMAN_RX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMAN_RX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMAN_ONE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMAN_ONE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMAN_DRIFT(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMAN_DRIFT() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}

// USART.RPR: Receive Pointer Register
func (o *USART_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *USART_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// USART.RCR: Receive Counter Register
func (o *USART_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// USART.TPR: Transmit Pointer Register
func (o *USART_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *USART_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// USART.TCR: Transmit Counter Register
func (o *USART_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// USART.RNPR: Receive Next Pointer Register
func (o *USART_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *USART_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// USART.RNCR: Receive Next Counter Register
func (o *USART_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// USART.TNPR: Transmit Next Pointer Register
func (o *USART_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *USART_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// USART.TNCR: Transmit Next Counter Register
func (o *USART_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// USART.PTCR: Transfer Control Register
func (o *USART_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *USART_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// USART.PTSR: Transfer Status Register
func (o *USART_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *USART_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Synchronous Serial Controller 0
type SSC_Type struct {
	CR   volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	_    [8]byte
	RCMR volatile.Register32 // 0x10
	RFMR volatile.Register32 // 0x14
	TCMR volatile.Register32 // 0x18
	TFMR volatile.Register32 // 0x1C
	RHR  volatile.Register32 // 0x20
	THR  volatile.Register32 // 0x24
	_    [8]byte
	RSHR volatile.Register32 // 0x30
	TSHR volatile.Register32 // 0x34
	RC0R volatile.Register32 // 0x38
	RC1R volatile.Register32 // 0x3C
	SR   volatile.Register32 // 0x40
	IER  volatile.Register32 // 0x44
	IDR  volatile.Register32 // 0x48
	IMR  volatile.Register32 // 0x4C
	_    [176]byte
	RPR  volatile.Register32 // 0x100
	RCR  volatile.Register32 // 0x104
	TPR  volatile.Register32 // 0x108
	TCR  volatile.Register32 // 0x10C
	RNPR volatile.Register32 // 0x110
	RNCR volatile.Register32 // 0x114
	TNPR volatile.Register32 // 0x118
	TNCR volatile.Register32 // 0x11C
	PTCR volatile.Register32 // 0x120
	PTSR volatile.Register32 // 0x124
}

// SSC.CR: Control Register
func (o *SSC_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetCR_RXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SSC_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *SSC_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}

// SSC.CMR: Clock Mode Register
func (o *SSC_Type) SetCMR_DIV(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xfff)|value)
}
func (o *SSC_Type) GetCMR_DIV() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xfff
}

// SSC.RCMR: Receive Clock Mode Register
func (o *SSC_Type) SetRCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetRCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.RCMR.Reg) & 0x3
}
func (o *SSC_Type) SetRCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetRCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetRCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetRCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetRCMR_START(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRCMR_START() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRCMR_STOP(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1000)|value<<12)
}
func (o *SSC_Type) GetRCMR_STOP() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1000) >> 12
}
func (o *SSC_Type) SetRCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetRCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetRCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetRCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff000000) >> 24
}

// SSC.RFMR: Receive Frame Mode Register
func (o *SSC_Type) SetRFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetRFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.RFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetRFMR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRFMR_LOOP() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetRFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetRFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetRFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetRFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetRFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetRFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetRFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetRFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetRFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000000) >> 28
}

// SSC.TCMR: Transmit Clock Mode Register
func (o *SSC_Type) SetTCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetTCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.TCMR.Reg) & 0x3
}
func (o *SSC_Type) SetTCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetTCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetTCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetTCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetTCMR_START(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTCMR_START() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetTCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetTCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetTCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff000000) >> 24
}

// SSC.TFMR: Transmit Frame Mode Register
func (o *SSC_Type) SetTFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetTFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.TFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetTFMR_DATDEF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTFMR_DATDEF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetTFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetTFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetTFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetTFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetTFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetTFMR_FSDEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x800000)|value<<23)
}
func (o *SSC_Type) GetTFMR_FSDEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x800000) >> 23
}
func (o *SSC_Type) SetTFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetTFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetTFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetTFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000000) >> 28
}

// SSC.RHR: Receive Holding Register
func (o *SSC_Type) SetRHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, value)
}
func (o *SSC_Type) GetRHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg)
}

// SSC.THR: Transmit Holding Register
func (o *SSC_Type) SetTHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, value)
}
func (o *SSC_Type) GetTHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg)
}

// SSC.RSHR: Receive Sync. Holding Register
func (o *SSC_Type) SetRSHR_RSDAT(value uint32) {
	volatile.StoreUint32(&o.RSHR.Reg, volatile.LoadUint32(&o.RSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRSHR_RSDAT() uint32 {
	return volatile.LoadUint32(&o.RSHR.Reg) & 0xffff
}

// SSC.TSHR: Transmit Sync. Holding Register
func (o *SSC_Type) SetTSHR_TSDAT(value uint32) {
	volatile.StoreUint32(&o.TSHR.Reg, volatile.LoadUint32(&o.TSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTSHR_TSDAT() uint32 {
	return volatile.LoadUint32(&o.TSHR.Reg) & 0xffff
}

// SSC.RC0R: Receive Compare 0 Register
func (o *SSC_Type) SetRC0R_CP0(value uint32) {
	volatile.StoreUint32(&o.RC0R.Reg, volatile.LoadUint32(&o.RC0R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC0R_CP0() uint32 {
	return volatile.LoadUint32(&o.RC0R.Reg) & 0xffff
}

// SSC.RC1R: Receive Compare 1 Register
func (o *SSC_Type) SetRC1R_CP1(value uint32) {
	volatile.StoreUint32(&o.RC1R.Reg, volatile.LoadUint32(&o.RC1R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC1R_CP1() uint32 {
	return volatile.LoadUint32(&o.RC1R.Reg) & 0xffff
}

// SSC.SR: Status Register
func (o *SSC_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSC_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetSR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SSC_Type) GetSR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SSC_Type) SetSR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SSC_Type) GetSR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SSC_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SSC_Type) GetSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SSC_Type) SetSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetSR_CP0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetSR_CP0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetSR_CP1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetSR_CP1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetSR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetSR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetSR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetSR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *SSC_Type) SetSR_TXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SSC_Type) GetSR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SSC_Type) SetSR_RXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SSC_Type) GetSR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SSC.IER: Interrupt Enable Register
func (o *SSC_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIER_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SSC_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SSC_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SSC_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SSC_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SSC_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIER_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIER_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *SSC_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *SSC_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetIER_CP0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIER_CP0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIER_CP1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIER_CP1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIER_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIER_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIER_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIER_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// SSC.IDR: Interrupt Disable Register
func (o *SSC_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIDR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SSC_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *SSC_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *SSC_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *SSC_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *SSC_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIDR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIDR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *SSC_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *SSC_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetIDR_CP0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIDR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIDR_CP1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIDR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIDR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIDR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIDR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIDR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// SSC.IMR: Interrupt Mask Register
func (o *SSC_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SSC_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SSC_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SSC_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SSC_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SSC_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *SSC_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *SSC_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetIMR_CP0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIMR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIMR_CP1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIMR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIMR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIMR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIMR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIMR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// SSC.RPR: Receive Pointer Register
func (o *SSC_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *SSC_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// SSC.RCR: Receive Counter Register
func (o *SSC_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// SSC.TPR: Transmit Pointer Register
func (o *SSC_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *SSC_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// SSC.TCR: Transmit Counter Register
func (o *SSC_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// SSC.RNPR: Receive Next Pointer Register
func (o *SSC_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *SSC_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// SSC.RNCR: Receive Next Counter Register
func (o *SSC_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// SSC.TNPR: Transmit Next Pointer Register
func (o *SSC_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *SSC_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// SSC.TNCR: Transmit Next Counter Register
func (o *SSC_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// SSC.PTCR: Transfer Control Register
func (o *SSC_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *SSC_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// SSC.PTSR: Transfer Status Register
func (o *SSC_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *SSC_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Serial Peripheral Interface 0
type SPI_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	RDR  volatile.Register32 // 0x8
	TDR  volatile.Register32 // 0xC
	SR   volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
	IDR  volatile.Register32 // 0x18
	IMR  volatile.Register32 // 0x1C
	_    [16]byte
	CSR  [4]volatile.Register32 // 0x30
	_    [192]byte
	RPR  volatile.Register32 // 0x100
	RCR  volatile.Register32 // 0x104
	TPR  volatile.Register32 // 0x108
	TCR  volatile.Register32 // 0x10C
	RNPR volatile.Register32 // 0x110
	RNCR volatile.Register32 // 0x114
	TNPR volatile.Register32 // 0x118
	TNCR volatile.Register32 // 0x11C
	PTCR volatile.Register32 // 0x120
	PTSR volatile.Register32 // 0x124
}

// SPI.CR: Control Register
func (o *SPI_Type) SetCR_SPIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR_SPIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SPI_Type) SetCR_SPIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR_SPIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// SPI.MR: Mode Register
func (o *SPI_Type) SetMR_MSTR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMR_MSTR() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *SPI_Type) SetMR_PS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetMR_PS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetMR_PCSDEC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetMR_PCSDEC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetMR_MODFDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetMR_MODFDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetMR_WDRBT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetMR_WDRBT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetMR_LLB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetMR_LLB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetMR_PCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetMR_PCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetMR_DLYBCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetMR_DLYBCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// SPI.RDR: Receive Data Register
func (o *SPI_Type) SetRDR_RD(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRDR_RD() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0xffff
}
func (o *SPI_Type) SetRDR_PCS(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetRDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.RDR.Reg) & 0xf0000) >> 16
}

// SPI.TDR: Transmit Data Register
func (o *SPI_Type) SetTDR_TD(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTDR_TD() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0xffff
}
func (o *SPI_Type) SetTDR_PCS(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetTDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetTDR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetTDR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0x1000000) >> 24
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_RDRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RDRF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TDRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_OVRES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_NSSR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetSR_SPIENS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetSR_SPIENS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// SPI.IER: Interrupt Enable Register
func (o *SPI_Type) SetIER_RDRF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIER_RDRF() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SPI_Type) SetIER_TDRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIER_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIER_MODF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIER_MODF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIER_OVRES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIER_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetIER_NSSR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIER_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}

// SPI.IDR: Interrupt Disable Register
func (o *SPI_Type) SetIDR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIDR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SPI_Type) SetIDR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIDR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIDR_MODF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIDR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIDR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIDR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetIDR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIDR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}

// SPI.IMR: Interrupt Mask Register
func (o *SPI_Type) SetIMR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIMR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SPI_Type) SetIMR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIMR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIMR_MODF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIMR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIMR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIMR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetIMR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIMR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}

// SPI.CSR: Chip Select Register
func (o *SPI_Type) SetCSR_CPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCSR_CPOL(idx int) uint32 {
	return volatile.LoadUint32(&o.CSR[idx].Reg) & 0x1
}
func (o *SPI_Type) SetCSR_NCPHA(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCSR_NCPHA(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCSR_CSAAT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCSR_CSAAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCSR_BITS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCSR_BITS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCSR_SCBR(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetCSR_SCBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff00) >> 8
}
func (o *SPI_Type) SetCSR_DLYBS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *SPI_Type) GetCSR_DLYBS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff0000) >> 16
}
func (o *SPI_Type) SetCSR_DLYBCT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetCSR_DLYBCT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff000000) >> 24
}

// SPI.RPR: Receive Pointer Register
func (o *SPI_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *SPI_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// SPI.RCR: Receive Counter Register
func (o *SPI_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// SPI.TPR: Transmit Pointer Register
func (o *SPI_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *SPI_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// SPI.TCR: Transmit Counter Register
func (o *SPI_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// SPI.RNPR: Receive Next Pointer Register
func (o *SPI_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *SPI_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// SPI.RNCR: Receive Next Counter Register
func (o *SPI_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// SPI.TNPR: Transmit Next Pointer Register
func (o *SPI_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *SPI_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// SPI.TNCR: Transmit Next Counter Register
func (o *SPI_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// SPI.PTCR: Transfer Control Register
func (o *SPI_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *SPI_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// SPI.PTSR: Transfer Status Register
func (o *SPI_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *SPI_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// AC97 Controller
type AC97C_Type struct {
	_     [8]byte
	MR    volatile.Register32 // 0x8
	_     [4]byte
	ICA   volatile.Register32 // 0x10
	OCA   volatile.Register32 // 0x14
	_     [8]byte
	CARHR volatile.Register32 // 0x20
	CATHR volatile.Register32 // 0x24
	CASR  volatile.Register32 // 0x28
	CAMR  volatile.Register32 // 0x2C
	CBRHR volatile.Register32 // 0x30
	CBTHR volatile.Register32 // 0x34
	CBSR  volatile.Register32 // 0x38
	CBMR  volatile.Register32 // 0x3C
	CORHR volatile.Register32 // 0x40
	COTHR volatile.Register32 // 0x44
	COSR  volatile.Register32 // 0x48
	COMR  volatile.Register32 // 0x4C
	SR    volatile.Register32 // 0x50
	IER   volatile.Register32 // 0x54
	IDR   volatile.Register32 // 0x58
	IMR   volatile.Register32 // 0x5C
	_     [160]byte
	RPR   volatile.Register32 // 0x100
	RCR   volatile.Register32 // 0x104
	TPR   volatile.Register32 // 0x108
	TCR   volatile.Register32 // 0x10C
	RNPR  volatile.Register32 // 0x110
	RNCR  volatile.Register32 // 0x114
	TNPR  volatile.Register32 // 0x118
	TNCR  volatile.Register32 // 0x11C
	PTCR  volatile.Register32 // 0x120
	PTSR  volatile.Register32 // 0x124
}

// AC97C.MR: Mode Register
func (o *AC97C_Type) SetMR_ENA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetMR_ENA() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *AC97C_Type) SetMR_WRST(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetMR_WRST() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetMR_VRA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetMR_VRA() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}

// AC97C.ICA: Input Channel Assignment Register
func (o *AC97C_Type) SetICA_CHID3(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x7)|value)
}
func (o *AC97C_Type) GetICA_CHID3() uint32 {
	return volatile.LoadUint32(&o.ICA.Reg) & 0x7
}
func (o *AC97C_Type) SetICA_CHID4(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x38)|value<<3)
}
func (o *AC97C_Type) GetICA_CHID4() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x38) >> 3
}
func (o *AC97C_Type) SetICA_CHID5(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x1c0)|value<<6)
}
func (o *AC97C_Type) GetICA_CHID5() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x1c0) >> 6
}
func (o *AC97C_Type) SetICA_CHID6(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0xe00)|value<<9)
}
func (o *AC97C_Type) GetICA_CHID6() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0xe00) >> 9
}
func (o *AC97C_Type) SetICA_CHID7(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x7000)|value<<12)
}
func (o *AC97C_Type) GetICA_CHID7() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x7000) >> 12
}
func (o *AC97C_Type) SetICA_CHID8(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x38000)|value<<15)
}
func (o *AC97C_Type) GetICA_CHID8() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x38000) >> 15
}
func (o *AC97C_Type) SetICA_CHID9(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x1c0000)|value<<18)
}
func (o *AC97C_Type) GetICA_CHID9() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x1c0000) >> 18
}
func (o *AC97C_Type) SetICA_CHID10(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0xe00000)|value<<21)
}
func (o *AC97C_Type) GetICA_CHID10() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0xe00000) >> 21
}
func (o *AC97C_Type) SetICA_CHID11(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x7000000)|value<<24)
}
func (o *AC97C_Type) GetICA_CHID11() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x7000000) >> 24
}
func (o *AC97C_Type) SetICA_CHID12(value uint32) {
	volatile.StoreUint32(&o.ICA.Reg, volatile.LoadUint32(&o.ICA.Reg)&^(0x38000000)|value<<27)
}
func (o *AC97C_Type) GetICA_CHID12() uint32 {
	return (volatile.LoadUint32(&o.ICA.Reg) & 0x38000000) >> 27
}

// AC97C.OCA: Output Channel Assignment Register
func (o *AC97C_Type) SetOCA_CHID3(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x7)|value)
}
func (o *AC97C_Type) GetOCA_CHID3() uint32 {
	return volatile.LoadUint32(&o.OCA.Reg) & 0x7
}
func (o *AC97C_Type) SetOCA_CHID4(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x38)|value<<3)
}
func (o *AC97C_Type) GetOCA_CHID4() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x38) >> 3
}
func (o *AC97C_Type) SetOCA_CHID5(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x1c0)|value<<6)
}
func (o *AC97C_Type) GetOCA_CHID5() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x1c0) >> 6
}
func (o *AC97C_Type) SetOCA_CHID6(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0xe00)|value<<9)
}
func (o *AC97C_Type) GetOCA_CHID6() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0xe00) >> 9
}
func (o *AC97C_Type) SetOCA_CHID7(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x7000)|value<<12)
}
func (o *AC97C_Type) GetOCA_CHID7() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x7000) >> 12
}
func (o *AC97C_Type) SetOCA_CHID8(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x38000)|value<<15)
}
func (o *AC97C_Type) GetOCA_CHID8() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x38000) >> 15
}
func (o *AC97C_Type) SetOCA_CHID9(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x1c0000)|value<<18)
}
func (o *AC97C_Type) GetOCA_CHID9() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x1c0000) >> 18
}
func (o *AC97C_Type) SetOCA_CHID10(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0xe00000)|value<<21)
}
func (o *AC97C_Type) GetOCA_CHID10() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0xe00000) >> 21
}
func (o *AC97C_Type) SetOCA_CHID11(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x7000000)|value<<24)
}
func (o *AC97C_Type) GetOCA_CHID11() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x7000000) >> 24
}
func (o *AC97C_Type) SetOCA_CHID12(value uint32) {
	volatile.StoreUint32(&o.OCA.Reg, volatile.LoadUint32(&o.OCA.Reg)&^(0x38000000)|value<<27)
}
func (o *AC97C_Type) GetOCA_CHID12() uint32 {
	return (volatile.LoadUint32(&o.OCA.Reg) & 0x38000000) >> 27
}

// AC97C.CARHR: Channel A Receive Holding Register
func (o *AC97C_Type) SetCARHR_RDATA(value uint32) {
	volatile.StoreUint32(&o.CARHR.Reg, volatile.LoadUint32(&o.CARHR.Reg)&^(0xfffff)|value)
}
func (o *AC97C_Type) GetCARHR_RDATA() uint32 {
	return volatile.LoadUint32(&o.CARHR.Reg) & 0xfffff
}

// AC97C.CATHR: Channel A Transmit Holding Register
func (o *AC97C_Type) SetCATHR_TDATA(value uint32) {
	volatile.StoreUint32(&o.CATHR.Reg, volatile.LoadUint32(&o.CATHR.Reg)&^(0xfffff)|value)
}
func (o *AC97C_Type) GetCATHR_TDATA() uint32 {
	return volatile.LoadUint32(&o.CATHR.Reg) & 0xfffff
}

// AC97C.CASR: Channel A Status Register
func (o *AC97C_Type) SetCASR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCASR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.CASR.Reg) & 0x1
}
func (o *AC97C_Type) SetCASR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCASR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCASR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCASR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCASR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCASR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCASR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCASR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x20) >> 5
}
func (o *AC97C_Type) SetCASR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x400)|value<<10)
}
func (o *AC97C_Type) GetCASR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x400) >> 10
}
func (o *AC97C_Type) SetCASR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x800)|value<<11)
}
func (o *AC97C_Type) GetCASR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x800) >> 11
}
func (o *AC97C_Type) SetCASR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x4000)|value<<14)
}
func (o *AC97C_Type) GetCASR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x4000) >> 14
}
func (o *AC97C_Type) SetCASR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.CASR.Reg, volatile.LoadUint32(&o.CASR.Reg)&^(0x8000)|value<<15)
}
func (o *AC97C_Type) GetCASR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.CASR.Reg) & 0x8000) >> 15
}

// AC97C.CAMR: Channel A Mode Register
func (o *AC97C_Type) SetCAMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCAMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.CAMR.Reg) & 0x1
}
func (o *AC97C_Type) SetCAMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCAMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCAMR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCAMR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCAMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCAMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCAMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCAMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x20) >> 5
}
func (o *AC97C_Type) SetCAMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x400)|value<<10)
}
func (o *AC97C_Type) GetCAMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x400) >> 10
}
func (o *AC97C_Type) SetCAMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x800)|value<<11)
}
func (o *AC97C_Type) GetCAMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x800) >> 11
}
func (o *AC97C_Type) SetCAMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x4000)|value<<14)
}
func (o *AC97C_Type) GetCAMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x4000) >> 14
}
func (o *AC97C_Type) SetCAMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x8000)|value<<15)
}
func (o *AC97C_Type) GetCAMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x8000) >> 15
}
func (o *AC97C_Type) SetCAMR_SIZE(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x30000)|value<<16)
}
func (o *AC97C_Type) GetCAMR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x30000) >> 16
}
func (o *AC97C_Type) SetCAMR_CEM(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x40000)|value<<18)
}
func (o *AC97C_Type) GetCAMR_CEM() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x40000) >> 18
}
func (o *AC97C_Type) SetCAMR_CEN(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x200000)|value<<21)
}
func (o *AC97C_Type) GetCAMR_CEN() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x200000) >> 21
}
func (o *AC97C_Type) SetCAMR_PDCEN(value uint32) {
	volatile.StoreUint32(&o.CAMR.Reg, volatile.LoadUint32(&o.CAMR.Reg)&^(0x400000)|value<<22)
}
func (o *AC97C_Type) GetCAMR_PDCEN() uint32 {
	return (volatile.LoadUint32(&o.CAMR.Reg) & 0x400000) >> 22
}

// AC97C.CBRHR: Channel B Receive Holding Register
func (o *AC97C_Type) SetCBRHR_RDATA(value uint32) {
	volatile.StoreUint32(&o.CBRHR.Reg, volatile.LoadUint32(&o.CBRHR.Reg)&^(0xfffff)|value)
}
func (o *AC97C_Type) GetCBRHR_RDATA() uint32 {
	return volatile.LoadUint32(&o.CBRHR.Reg) & 0xfffff
}

// AC97C.CBTHR: Channel B Transmit Holding Register
func (o *AC97C_Type) SetCBTHR_TDATA(value uint32) {
	volatile.StoreUint32(&o.CBTHR.Reg, volatile.LoadUint32(&o.CBTHR.Reg)&^(0xfffff)|value)
}
func (o *AC97C_Type) GetCBTHR_TDATA() uint32 {
	return volatile.LoadUint32(&o.CBTHR.Reg) & 0xfffff
}

// AC97C.CBSR: Channel B Status Register
func (o *AC97C_Type) SetCBSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCBSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.CBSR.Reg) & 0x1
}
func (o *AC97C_Type) SetCBSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCBSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCBSR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCBSR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCBSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCBSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCBSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCBSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x20) >> 5
}
func (o *AC97C_Type) SetCBSR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x200)|value<<9)
}
func (o *AC97C_Type) GetCBSR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x200) >> 9
}
func (o *AC97C_Type) SetCBSR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x400)|value<<10)
}
func (o *AC97C_Type) GetCBSR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x400) >> 10
}
func (o *AC97C_Type) SetCBSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x4000)|value<<14)
}
func (o *AC97C_Type) GetCBSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x4000) >> 14
}
func (o *AC97C_Type) SetCBSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.CBSR.Reg, volatile.LoadUint32(&o.CBSR.Reg)&^(0x8000)|value<<15)
}
func (o *AC97C_Type) GetCBSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.CBSR.Reg) & 0x8000) >> 15
}

// AC97C.CBMR: Channel B Mode Register
func (o *AC97C_Type) SetCBMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCBMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.CBMR.Reg) & 0x1
}
func (o *AC97C_Type) SetCBMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCBMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCBMR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCBMR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCBMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCBMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCBMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCBMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x20) >> 5
}
func (o *AC97C_Type) SetCBMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x400)|value<<10)
}
func (o *AC97C_Type) GetCBMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x400) >> 10
}
func (o *AC97C_Type) SetCBMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x800)|value<<11)
}
func (o *AC97C_Type) GetCBMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x800) >> 11
}
func (o *AC97C_Type) SetCBMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x4000)|value<<14)
}
func (o *AC97C_Type) GetCBMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x4000) >> 14
}
func (o *AC97C_Type) SetCBMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x8000)|value<<15)
}
func (o *AC97C_Type) GetCBMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x8000) >> 15
}
func (o *AC97C_Type) SetCBMR_SIZE(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x30000)|value<<16)
}
func (o *AC97C_Type) GetCBMR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x30000) >> 16
}
func (o *AC97C_Type) SetCBMR_CEM(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x40000)|value<<18)
}
func (o *AC97C_Type) GetCBMR_CEM() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x40000) >> 18
}
func (o *AC97C_Type) SetCBMR_CEN(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x200000)|value<<21)
}
func (o *AC97C_Type) GetCBMR_CEN() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x200000) >> 21
}
func (o *AC97C_Type) SetCBMR_PDCEN(value uint32) {
	volatile.StoreUint32(&o.CBMR.Reg, volatile.LoadUint32(&o.CBMR.Reg)&^(0x400000)|value<<22)
}
func (o *AC97C_Type) GetCBMR_PDCEN() uint32 {
	return (volatile.LoadUint32(&o.CBMR.Reg) & 0x400000) >> 22
}

// AC97C.CORHR: Codec Channel Receive Holding Register
func (o *AC97C_Type) SetCORHR_SDATA(value uint32) {
	volatile.StoreUint32(&o.CORHR.Reg, volatile.LoadUint32(&o.CORHR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetCORHR_SDATA() uint32 {
	return volatile.LoadUint32(&o.CORHR.Reg) & 0xffff
}

// AC97C.COTHR: Codec Channel Transmit Holding Register
func (o *AC97C_Type) SetCOTHR_CDATA(value uint32) {
	volatile.StoreUint32(&o.COTHR.Reg, volatile.LoadUint32(&o.COTHR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetCOTHR_CDATA() uint32 {
	return volatile.LoadUint32(&o.COTHR.Reg) & 0xffff
}
func (o *AC97C_Type) SetCOTHR_CADDR(value uint32) {
	volatile.StoreUint32(&o.COTHR.Reg, volatile.LoadUint32(&o.COTHR.Reg)&^(0x7f0000)|value<<16)
}
func (o *AC97C_Type) GetCOTHR_CADDR() uint32 {
	return (volatile.LoadUint32(&o.COTHR.Reg) & 0x7f0000) >> 16
}
func (o *AC97C_Type) SetCOTHR_READ(value uint32) {
	volatile.StoreUint32(&o.COTHR.Reg, volatile.LoadUint32(&o.COTHR.Reg)&^(0x800000)|value<<23)
}
func (o *AC97C_Type) GetCOTHR_READ() uint32 {
	return (volatile.LoadUint32(&o.COTHR.Reg) & 0x800000) >> 23
}

// AC97C.COSR: Codec Status Register
func (o *AC97C_Type) SetCOSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCOSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.COSR.Reg) & 0x1
}
func (o *AC97C_Type) SetCOSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCOSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.COSR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCOSR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCOSR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.COSR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCOSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCOSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.COSR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCOSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.COSR.Reg, volatile.LoadUint32(&o.COSR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCOSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.COSR.Reg) & 0x20) >> 5
}

// AC97C.COMR: Codec Mode Register
func (o *AC97C_Type) SetCOMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.COMR.Reg, volatile.LoadUint32(&o.COMR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetCOMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.COMR.Reg) & 0x1
}
func (o *AC97C_Type) SetCOMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.COMR.Reg, volatile.LoadUint32(&o.COMR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetCOMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.COMR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetCOMR_UNRUN(value uint32) {
	volatile.StoreUint32(&o.COMR.Reg, volatile.LoadUint32(&o.COMR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetCOMR_UNRUN() uint32 {
	return (volatile.LoadUint32(&o.COMR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetCOMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.COMR.Reg, volatile.LoadUint32(&o.COMR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetCOMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.COMR.Reg) & 0x10) >> 4
}
func (o *AC97C_Type) SetCOMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.COMR.Reg, volatile.LoadUint32(&o.COMR.Reg)&^(0x20)|value<<5)
}
func (o *AC97C_Type) GetCOMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.COMR.Reg) & 0x20) >> 5
}

// AC97C.SR: Status Register
func (o *AC97C_Type) SetSR_SOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetSR_SOF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *AC97C_Type) SetSR_WKUP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetSR_WKUP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetSR_COEVT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetSR_COEVT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetSR_CAEVT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *AC97C_Type) GetSR_CAEVT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *AC97C_Type) SetSR_CBEVT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetSR_CBEVT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}

// AC97C.IER: Interrupt Enable Register
func (o *AC97C_Type) SetIER_SOF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetIER_SOF() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *AC97C_Type) SetIER_WKUP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetIER_WKUP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetIER_COEVT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetIER_COEVT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetIER_CAEVT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *AC97C_Type) GetIER_CAEVT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *AC97C_Type) SetIER_CBEVT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetIER_CBEVT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}

// AC97C.IDR: Interrupt Disable Register
func (o *AC97C_Type) SetIDR_SOF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetIDR_SOF() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *AC97C_Type) SetIDR_WKUP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetIDR_WKUP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetIDR_COEVT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetIDR_COEVT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetIDR_CAEVT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *AC97C_Type) GetIDR_CAEVT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *AC97C_Type) SetIDR_CBEVT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetIDR_CBEVT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}

// AC97C.IMR: Interrupt Mask Register
func (o *AC97C_Type) SetIMR_SOF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetIMR_SOF() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *AC97C_Type) SetIMR_WKUP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetIMR_WKUP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetIMR_COEVT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *AC97C_Type) GetIMR_COEVT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *AC97C_Type) SetIMR_CAEVT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *AC97C_Type) GetIMR_CAEVT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *AC97C_Type) SetIMR_CBEVT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *AC97C_Type) GetIMR_CBEVT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}

// AC97C.RPR: Receive Pointer Register
func (o *AC97C_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *AC97C_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// AC97C.RCR: Receive Counter Register
func (o *AC97C_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// AC97C.TPR: Transmit Pointer Register
func (o *AC97C_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *AC97C_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// AC97C.TCR: Transmit Counter Register
func (o *AC97C_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// AC97C.RNPR: Receive Next Pointer Register
func (o *AC97C_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *AC97C_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// AC97C.RNCR: Receive Next Counter Register
func (o *AC97C_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// AC97C.TNPR: Transmit Next Pointer Register
func (o *AC97C_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *AC97C_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// AC97C.TNCR: Transmit Next Counter Register
func (o *AC97C_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *AC97C_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// AC97C.PTCR: Transfer Control Register
func (o *AC97C_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *AC97C_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *AC97C_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *AC97C_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *AC97C_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *AC97C_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *AC97C_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// AC97C.PTSR: Transfer Status Register
func (o *AC97C_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *AC97C_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *AC97C_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *AC97C_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Touch Screen ADC Controller
type TSADCC_Type struct {
	CR   volatile.Register32    // 0x0
	MR   volatile.Register32    // 0x4
	TRGR volatile.Register32    // 0x8
	TSR  volatile.Register32    // 0xC
	CHER volatile.Register32    // 0x10
	CHDR volatile.Register32    // 0x14
	CHSR volatile.Register32    // 0x18
	SR   volatile.Register32    // 0x1C
	LCDR volatile.Register32    // 0x20
	IER  volatile.Register32    // 0x24
	IDR  volatile.Register32    // 0x28
	IMR  volatile.Register32    // 0x2C
	CDR  [8]volatile.Register32 // 0x30
	XPDR volatile.Register32    // 0x50
	Z1DR volatile.Register32    // 0x54
	Z2DR volatile.Register32    // 0x58
	_    [4]byte
	MSCR volatile.Register32 // 0x60
	_    [128]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
	_    [20]byte
	RPR  volatile.Register32 // 0x100
	RCR  volatile.Register32 // 0x104
	_    [8]byte
	RNPR volatile.Register32 // 0x110
	RNCR volatile.Register32 // 0x114
	_    [8]byte
	PTCR volatile.Register32 // 0x120
	PTSR volatile.Register32 // 0x124
}

// TSADCC.CR: Control Register
func (o *TSADCC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TSADCC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}

// TSADCC.MR: Mode Register
func (o *TSADCC_Type) SetMR_TSAMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3)|value)
}
func (o *TSADCC_Type) GetMR_TSAMOD() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x3
}
func (o *TSADCC_Type) SetMR_PDCEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetMR_PDCEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetMR_LOWRES(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetMR_LOWRES() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetMR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetMR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetMR_PENDET(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetMR_PENDET() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetMR_PRES(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetMR_PRES() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}
func (o *TSADCC_Type) SetMR_PRESCAL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *TSADCC_Type) GetMR_PRESCAL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}
func (o *TSADCC_Type) SetMR_STARTUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TSADCC_Type) GetMR_STARTUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7f0000) >> 16
}
func (o *TSADCC_Type) SetMR_SHTIM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *TSADCC_Type) GetMR_SHTIM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}
func (o *TSADCC_Type) SetMR_PENDBC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000000)|value<<28)
}
func (o *TSADCC_Type) GetMR_PENDBC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000000) >> 28
}

// TSADCC.TRGR: Trigger Register
func (o *TSADCC_Type) SetTRGR_TRGMOD(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0x7)|value)
}
func (o *TSADCC_Type) GetTRGR_TRGMOD() uint32 {
	return volatile.LoadUint32(&o.TRGR.Reg) & 0x7
}
func (o *TSADCC_Type) SetTRGR_TRGPER(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0xffff0000)|value<<16)
}
func (o *TSADCC_Type) GetTRGR_TRGPER() uint32 {
	return (volatile.LoadUint32(&o.TRGR.Reg) & 0xffff0000) >> 16
}

// TSADCC.TSR: Touch Screen Register
func (o *TSADCC_Type) SetTSR_TSFREQ(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0xf)|value)
}
func (o *TSADCC_Type) GetTSR_TSFREQ() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0xf
}
func (o *TSADCC_Type) SetTSR_TSSHTIM(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0xf000000)|value<<24)
}
func (o *TSADCC_Type) GetTSR_TSSHTIM() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0xf000000) >> 24
}

// TSADCC.CHER: Channel Enable Register
func (o *TSADCC_Type) SetCHER_CH0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetCHER_CH0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *TSADCC_Type) SetCHER_CH1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetCHER_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetCHER_CH2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetCHER_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetCHER_CH3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetCHER_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetCHER_CH4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetCHER_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetCHER_CH5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetCHER_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetCHER_CH6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetCHER_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetCHER_CH7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetCHER_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}

// TSADCC.CHDR: Channel Disable Register
func (o *TSADCC_Type) SetCHDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetCHDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *TSADCC_Type) SetCHDR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetCHDR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetCHDR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetCHDR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetCHDR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetCHDR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetCHDR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetCHDR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetCHDR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetCHDR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetCHDR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetCHDR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetCHDR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetCHDR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}

// TSADCC.CHSR: Channel Status Register
func (o *TSADCC_Type) SetCHSR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetCHSR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *TSADCC_Type) SetCHSR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetCHSR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetCHSR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetCHSR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetCHSR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetCHSR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetCHSR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetCHSR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetCHSR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetCHSR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetCHSR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetCHSR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetCHSR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetCHSR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}

// TSADCC.SR: Status Register
func (o *TSADCC_Type) SetSR_EOC0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetSR_EOC0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TSADCC_Type) SetSR_EOC1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetSR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetSR_EOC2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetSR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetSR_EOC3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetSR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetSR_EOC4(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetSR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetSR_EOC5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetSR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetSR_EOC6(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetSR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetSR_EOC7(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetSR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TSADCC_Type) SetSR_OVRE0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetSR_OVRE0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TSADCC_Type) SetSR_OVRE1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TSADCC_Type) GetSR_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TSADCC_Type) SetSR_OVRE2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TSADCC_Type) GetSR_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TSADCC_Type) SetSR_OVRE3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TSADCC_Type) GetSR_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TSADCC_Type) SetSR_OVRE4(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *TSADCC_Type) GetSR_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *TSADCC_Type) SetSR_OVRE5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *TSADCC_Type) GetSR_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *TSADCC_Type) SetSR_OVRE6(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *TSADCC_Type) GetSR_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *TSADCC_Type) SetSR_OVRE7(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *TSADCC_Type) GetSR_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *TSADCC_Type) SetSR_DRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TSADCC_Type) GetSR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TSADCC_Type) SetSR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *TSADCC_Type) GetSR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *TSADCC_Type) SetSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *TSADCC_Type) GetSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *TSADCC_Type) SetSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *TSADCC_Type) GetSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *TSADCC_Type) SetSR_PENCNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *TSADCC_Type) GetSR_PENCNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *TSADCC_Type) SetSR_NOCNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *TSADCC_Type) GetSR_NOCNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *TSADCC_Type) SetSR_EOCXP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSADCC_Type) GetSR_EOCXP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *TSADCC_Type) SetSR_EOCZ1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSADCC_Type) GetSR_EOCZ1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *TSADCC_Type) SetSR_EOCZ2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSADCC_Type) GetSR_EOCZ2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *TSADCC_Type) SetSR_OVREXP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSADCC_Type) GetSR_OVREXP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *TSADCC_Type) SetSR_OVREZ1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSADCC_Type) GetSR_OVREZ1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *TSADCC_Type) SetSR_OVREZ2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSADCC_Type) GetSR_OVREZ2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}

// TSADCC.LCDR: Last Converted Data Register
func (o *TSADCC_Type) SetLCDR_LDATA(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0x3ff)|value)
}
func (o *TSADCC_Type) GetLCDR_LDATA() uint32 {
	return volatile.LoadUint32(&o.LCDR.Reg) & 0x3ff
}

// TSADCC.IER: Interrupt Enable Register
func (o *TSADCC_Type) SetIER_EOC0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetIER_EOC0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TSADCC_Type) SetIER_EOC1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetIER_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetIER_EOC2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetIER_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetIER_EOC3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetIER_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetIER_EOC4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetIER_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetIER_EOC5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetIER_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetIER_EOC6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetIER_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetIER_EOC7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetIER_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *TSADCC_Type) SetIER_OVRE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetIER_OVRE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *TSADCC_Type) SetIER_OVRE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *TSADCC_Type) GetIER_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *TSADCC_Type) SetIER_OVRE2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *TSADCC_Type) GetIER_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *TSADCC_Type) SetIER_OVRE3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *TSADCC_Type) GetIER_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *TSADCC_Type) SetIER_OVRE4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *TSADCC_Type) GetIER_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *TSADCC_Type) SetIER_OVRE5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *TSADCC_Type) GetIER_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *TSADCC_Type) SetIER_OVRE6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *TSADCC_Type) GetIER_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *TSADCC_Type) SetIER_OVRE7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *TSADCC_Type) GetIER_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *TSADCC_Type) SetIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *TSADCC_Type) GetIER_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *TSADCC_Type) SetIER_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *TSADCC_Type) GetIER_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *TSADCC_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *TSADCC_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *TSADCC_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *TSADCC_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *TSADCC_Type) SetIER_PENCNT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *TSADCC_Type) GetIER_PENCNT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *TSADCC_Type) SetIER_NOCNT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *TSADCC_Type) GetIER_NOCNT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *TSADCC_Type) SetIER_EOCXP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *TSADCC_Type) GetIER_EOCXP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *TSADCC_Type) SetIER_EOCZ1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *TSADCC_Type) GetIER_EOCZ1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *TSADCC_Type) SetIER_EOCZ2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *TSADCC_Type) GetIER_EOCZ2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *TSADCC_Type) SetIER_OVREXP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *TSADCC_Type) GetIER_OVREXP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *TSADCC_Type) SetIER_OVREZ1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *TSADCC_Type) GetIER_OVREZ1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *TSADCC_Type) SetIER_OVREZ2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *TSADCC_Type) GetIER_OVREZ2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}

// TSADCC.IDR: Interrupt Disable Register
func (o *TSADCC_Type) SetIDR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetIDR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TSADCC_Type) SetIDR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetIDR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetIDR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetIDR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetIDR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetIDR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetIDR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetIDR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetIDR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetIDR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetIDR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetIDR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetIDR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetIDR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *TSADCC_Type) SetIDR_OVRE0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetIDR_OVRE0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *TSADCC_Type) SetIDR_OVRE1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *TSADCC_Type) GetIDR_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *TSADCC_Type) SetIDR_OVRE2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *TSADCC_Type) GetIDR_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *TSADCC_Type) SetIDR_OVRE3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *TSADCC_Type) GetIDR_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *TSADCC_Type) SetIDR_OVRE4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *TSADCC_Type) GetIDR_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *TSADCC_Type) SetIDR_OVRE5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *TSADCC_Type) GetIDR_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *TSADCC_Type) SetIDR_OVRE6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *TSADCC_Type) GetIDR_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *TSADCC_Type) SetIDR_OVRE7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *TSADCC_Type) GetIDR_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *TSADCC_Type) SetIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *TSADCC_Type) GetIDR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *TSADCC_Type) SetIDR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *TSADCC_Type) GetIDR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *TSADCC_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *TSADCC_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *TSADCC_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *TSADCC_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *TSADCC_Type) SetIDR_PENCNT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *TSADCC_Type) GetIDR_PENCNT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *TSADCC_Type) SetIDR_NOCNT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *TSADCC_Type) GetIDR_NOCNT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *TSADCC_Type) SetIDR_EOCXP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSADCC_Type) GetIDR_EOCXP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *TSADCC_Type) SetIDR_EOCZ1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSADCC_Type) GetIDR_EOCZ1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *TSADCC_Type) SetIDR_EOCZ2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSADCC_Type) GetIDR_EOCZ2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *TSADCC_Type) SetIDR_OVREXP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSADCC_Type) GetIDR_OVREXP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *TSADCC_Type) SetIDR_OVREZ1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSADCC_Type) GetIDR_OVREZ1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *TSADCC_Type) SetIDR_OVREZ2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSADCC_Type) GetIDR_OVREZ2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}

// TSADCC.IMR: Interrupt Mask Register
func (o *TSADCC_Type) SetIMR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetIMR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TSADCC_Type) SetIMR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetIMR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetIMR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetIMR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetIMR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetIMR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *TSADCC_Type) SetIMR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TSADCC_Type) GetIMR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TSADCC_Type) SetIMR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TSADCC_Type) GetIMR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TSADCC_Type) SetIMR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TSADCC_Type) GetIMR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TSADCC_Type) SetIMR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *TSADCC_Type) GetIMR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *TSADCC_Type) SetIMR_OVRE0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetIMR_OVRE0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *TSADCC_Type) SetIMR_OVRE1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *TSADCC_Type) GetIMR_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *TSADCC_Type) SetIMR_OVRE2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *TSADCC_Type) GetIMR_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *TSADCC_Type) SetIMR_OVRE3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *TSADCC_Type) GetIMR_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *TSADCC_Type) SetIMR_OVRE4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *TSADCC_Type) GetIMR_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *TSADCC_Type) SetIMR_OVRE5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *TSADCC_Type) GetIMR_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *TSADCC_Type) SetIMR_OVRE6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *TSADCC_Type) GetIMR_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *TSADCC_Type) SetIMR_OVRE7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *TSADCC_Type) GetIMR_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *TSADCC_Type) SetIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *TSADCC_Type) GetIMR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *TSADCC_Type) SetIMR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *TSADCC_Type) GetIMR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *TSADCC_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *TSADCC_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *TSADCC_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *TSADCC_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *TSADCC_Type) SetIMR_PENCNT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *TSADCC_Type) GetIMR_PENCNT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *TSADCC_Type) SetIMR_NOCNT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *TSADCC_Type) GetIMR_NOCNT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *TSADCC_Type) SetIMR_EOCXP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSADCC_Type) GetIMR_EOCXP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *TSADCC_Type) SetIMR_EOCZ1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSADCC_Type) GetIMR_EOCZ1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *TSADCC_Type) SetIMR_EOCZ2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSADCC_Type) GetIMR_EOCZ2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *TSADCC_Type) SetIMR_OVREXP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSADCC_Type) GetIMR_OVREXP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *TSADCC_Type) SetIMR_OVREZ1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSADCC_Type) GetIMR_OVREZ1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *TSADCC_Type) SetIMR_OVREZ2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSADCC_Type) GetIMR_OVREZ2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}

// TSADCC.CDR: Channel Data Register
func (o *TSADCC_Type) SetCDR_DATA(idx int, value uint32) {
	volatile.StoreUint32(&o.CDR[idx].Reg, volatile.LoadUint32(&o.CDR[idx].Reg)&^(0x3ff)|value)
}
func (o *TSADCC_Type) GetCDR_DATA(idx int) uint32 {
	return volatile.LoadUint32(&o.CDR[idx].Reg) & 0x3ff
}

// TSADCC.XPDR: X Position Data Register
func (o *TSADCC_Type) SetXPDR_DATA(value uint32) {
	volatile.StoreUint32(&o.XPDR.Reg, volatile.LoadUint32(&o.XPDR.Reg)&^(0x3ff)|value)
}
func (o *TSADCC_Type) GetXPDR_DATA() uint32 {
	return volatile.LoadUint32(&o.XPDR.Reg) & 0x3ff
}

// TSADCC.Z1DR: Z1 Data Register
func (o *TSADCC_Type) SetZ1DR_DATA(value uint32) {
	volatile.StoreUint32(&o.Z1DR.Reg, volatile.LoadUint32(&o.Z1DR.Reg)&^(0x3ff)|value)
}
func (o *TSADCC_Type) GetZ1DR_DATA() uint32 {
	return volatile.LoadUint32(&o.Z1DR.Reg) & 0x3ff
}

// TSADCC.Z2DR: Z2 Data Register
func (o *TSADCC_Type) SetZ2DR_Z2(value uint32) {
	volatile.StoreUint32(&o.Z2DR.Reg, volatile.LoadUint32(&o.Z2DR.Reg)&^(0x3ff)|value)
}
func (o *TSADCC_Type) GetZ2DR_Z2() uint32 {
	return volatile.LoadUint32(&o.Z2DR.Reg) & 0x3ff
}

// TSADCC.MSCR: Manual Switch Command Register
func (o *TSADCC_Type) SetMSCR_XP(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetMSCR_XP() uint32 {
	return volatile.LoadUint32(&o.MSCR.Reg) & 0x1
}
func (o *TSADCC_Type) SetMSCR_XM(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetMSCR_XM() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetMSCR_YP(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x4)|value<<2)
}
func (o *TSADCC_Type) GetMSCR_YP() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x4) >> 2
}
func (o *TSADCC_Type) SetMSCR_YM(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x8)|value<<3)
}
func (o *TSADCC_Type) GetMSCR_YM() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x8) >> 3
}

// TSADCC.WPMR: Write Protection Mode Register
func (o *TSADCC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *TSADCC_Type) SetWPMR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TSADCC_Type) GetWPMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// TSADCC.WPSR: Write Protection Status Register
func (o *TSADCC_Type) SetWPSR_WPS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetWPSR_WPS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *TSADCC_Type) SetWPSR_OFFSET_ERR(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TSADCC_Type) GetWPSR_OFFSET_ERR() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffffff00) >> 8
}

// TSADCC.RPR: Receive Pointer Register
func (o *TSADCC_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *TSADCC_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// TSADCC.RCR: Receive Counter Register
func (o *TSADCC_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *TSADCC_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// TSADCC.RNPR: Receive Next Pointer Register
func (o *TSADCC_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *TSADCC_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// TSADCC.RNCR: Receive Next Counter Register
func (o *TSADCC_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *TSADCC_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// TSADCC.PTCR: Transfer Control Register
func (o *TSADCC_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *TSADCC_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *TSADCC_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *TSADCC_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *TSADCC_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *TSADCC_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// TSADCC.PTSR: Transfer Status Register
func (o *TSADCC_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *TSADCC_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *TSADCC_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *TSADCC_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Image Sensor Interface
type ISI_Type struct {
	ISI_CFG1     volatile.Register32 // 0x0
	ISI_CFG2     volatile.Register32 // 0x4
	ISI_PSIZE    volatile.Register32 // 0x8
	ISI_PDECF    volatile.Register32 // 0xC
	ISI_Y2R_SET0 volatile.Register32 // 0x10
	ISI_Y2R_SET1 volatile.Register32 // 0x14
	ISI_R2Y_SET0 volatile.Register32 // 0x18
	ISI_R2Y_SET1 volatile.Register32 // 0x1C
	ISI_R2Y_SET2 volatile.Register32 // 0x20
	ISI_CR       volatile.Register32 // 0x24
	ISI_SR       volatile.Register32 // 0x28
	ISI_IER      volatile.Register32 // 0x2C
	ISI_IDR      volatile.Register32 // 0x30
	ISI_IMR      volatile.Register32 // 0x34
	DMA_CHER     volatile.Register32 // 0x38
	DMA_CHDR     volatile.Register32 // 0x3C
	DMA_CHSR     volatile.Register32 // 0x40
	DMA_P_ADDR   volatile.Register32 // 0x44
	DMA_P_CTRL   volatile.Register32 // 0x48
	DMA_P_DSCR   volatile.Register32 // 0x4C
	DMA_C_ADDR   volatile.Register32 // 0x50
	DMA_C_CTRL   volatile.Register32 // 0x54
	DMA_C_DSCR   volatile.Register32 // 0x58
	_            [136]byte
	ISI_WPCR     volatile.Register32 // 0xE4
	ISI_WPSR     volatile.Register32 // 0xE8
}

// ISI.ISI_CFG1: ISI Configuration 1 Register
func (o *ISI_Type) SetISI_CFG1_HSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_CFG1_HSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_CFG1_VSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetISI_CFG1_VSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x8) >> 3
}
func (o *ISI_Type) SetISI_CFG1_PIXCLK_POL(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ISI_Type) GetISI_CFG1_PIXCLK_POL() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x10) >> 4
}
func (o *ISI_Type) SetISI_CFG1_EMB_SYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x40)|value<<6)
}
func (o *ISI_Type) GetISI_CFG1_EMB_SYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x40) >> 6
}
func (o *ISI_Type) SetISI_CFG1_CRC_SYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ISI_Type) GetISI_CFG1_CRC_SYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x80) >> 7
}
func (o *ISI_Type) SetISI_CFG1_FRATE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x700)|value<<8)
}
func (o *ISI_Type) GetISI_CFG1_FRATE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x700) >> 8
}
func (o *ISI_Type) SetISI_CFG1_DISCR(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetISI_CFG1_DISCR() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetISI_CFG1_FULL(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetISI_CFG1_FULL() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetISI_CFG1_THMASK(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0x6000)|value<<13)
}
func (o *ISI_Type) GetISI_CFG1_THMASK() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0x6000) >> 13
}
func (o *ISI_Type) SetISI_CFG1_SLD(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetISI_CFG1_SLD() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetISI_CFG1_SFD(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG1.Reg, volatile.LoadUint32(&o.ISI_CFG1.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetISI_CFG1_SFD() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG1.Reg) & 0xff000000) >> 24
}

// ISI.ISI_CFG2: ISI Configuration 2 Register
func (o *ISI_Type) SetISI_CFG2_IM_VSIZE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x7ff)|value)
}
func (o *ISI_Type) GetISI_CFG2_IM_VSIZE() uint32 {
	return volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x7ff
}
func (o *ISI_Type) SetISI_CFG2_GS_MODE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetISI_CFG2_GS_MODE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetISI_CFG2_RGB_MODE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetISI_CFG2_RGB_MODE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetISI_CFG2_GRAYSCALE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetISI_CFG2_GRAYSCALE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetISI_CFG2_RGB_SWAP(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetISI_CFG2_RGB_SWAP() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x4000) >> 14
}
func (o *ISI_Type) SetISI_CFG2_COL_SPACE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x8000)|value<<15)
}
func (o *ISI_Type) GetISI_CFG2_COL_SPACE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x8000) >> 15
}
func (o *ISI_Type) SetISI_CFG2_IM_HSIZE(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *ISI_Type) GetISI_CFG2_IM_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x7ff0000) >> 16
}
func (o *ISI_Type) SetISI_CFG2_YCC_SWAP(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *ISI_Type) GetISI_CFG2_YCC_SWAP() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0x30000000) >> 28
}
func (o *ISI_Type) SetISI_CFG2_RGB_CFG(value uint32) {
	volatile.StoreUint32(&o.ISI_CFG2.Reg, volatile.LoadUint32(&o.ISI_CFG2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ISI_Type) GetISI_CFG2_RGB_CFG() uint32 {
	return (volatile.LoadUint32(&o.ISI_CFG2.Reg) & 0xc0000000) >> 30
}

// ISI.ISI_PSIZE: ISI Preview Size Register
func (o *ISI_Type) SetISI_PSIZE_PREV_VSIZE(value uint32) {
	volatile.StoreUint32(&o.ISI_PSIZE.Reg, volatile.LoadUint32(&o.ISI_PSIZE.Reg)&^(0x3ff)|value)
}
func (o *ISI_Type) GetISI_PSIZE_PREV_VSIZE() uint32 {
	return volatile.LoadUint32(&o.ISI_PSIZE.Reg) & 0x3ff
}
func (o *ISI_Type) SetISI_PSIZE_PREV_HSIZE(value uint32) {
	volatile.StoreUint32(&o.ISI_PSIZE.Reg, volatile.LoadUint32(&o.ISI_PSIZE.Reg)&^(0x3ff0000)|value<<16)
}
func (o *ISI_Type) GetISI_PSIZE_PREV_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.ISI_PSIZE.Reg) & 0x3ff0000) >> 16
}

// ISI.ISI_PDECF: ISI Preview Decimation Factor Register
func (o *ISI_Type) SetISI_PDECF_DEC_FACTOR(value uint32) {
	volatile.StoreUint32(&o.ISI_PDECF.Reg, volatile.LoadUint32(&o.ISI_PDECF.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetISI_PDECF_DEC_FACTOR() uint32 {
	return volatile.LoadUint32(&o.ISI_PDECF.Reg) & 0xff
}

// ISI.ISI_Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
func (o *ISI_Type) SetISI_Y2R_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET0.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetISI_Y2R_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg) & 0xff
}
func (o *ISI_Type) SetISI_Y2R_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET0.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetISI_Y2R_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetISI_Y2R_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET0.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetISI_Y2R_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetISI_Y2R_SET0_C3(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET0.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetISI_Y2R_SET0_C3() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET0.Reg) & 0xff000000) >> 24
}

// ISI.ISI_Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
func (o *ISI_Type) SetISI_Y2R_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET1.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg)&^(0x1ff)|value)
}
func (o *ISI_Type) GetISI_Y2R_SET1_C4() uint32 {
	return volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg) & 0x1ff
}
func (o *ISI_Type) SetISI_Y2R_SET1_Yoff(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET1.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetISI_Y2R_SET1_Yoff() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetISI_Y2R_SET1_Croff(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET1.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetISI_Y2R_SET1_Croff() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetISI_Y2R_SET1_Cboff(value uint32) {
	volatile.StoreUint32(&o.ISI_Y2R_SET1.Reg, volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetISI_Y2R_SET1_Cboff() uint32 {
	return (volatile.LoadUint32(&o.ISI_Y2R_SET1.Reg) & 0x4000) >> 14
}

// ISI.ISI_R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
func (o *ISI_Type) SetISI_R2Y_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET0.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetISI_R2Y_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg) & 0xff
}
func (o *ISI_Type) SetISI_R2Y_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET0.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetISI_R2Y_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetISI_R2Y_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET0.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetISI_R2Y_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetISI_R2Y_SET0_Roff(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET0.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_R2Y_SET0_Roff() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET0.Reg) & 0x1000000) >> 24
}

// ISI.ISI_R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
func (o *ISI_Type) SetISI_R2Y_SET1_C3(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET1.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetISI_R2Y_SET1_C3() uint32 {
	return volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg) & 0xff
}
func (o *ISI_Type) SetISI_R2Y_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET1.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetISI_R2Y_SET1_C4() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetISI_R2Y_SET1_C5(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET1.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetISI_R2Y_SET1_C5() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetISI_R2Y_SET1_Goff(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET1.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_R2Y_SET1_Goff() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET1.Reg) & 0x1000000) >> 24
}

// ISI.ISI_R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
func (o *ISI_Type) SetISI_R2Y_SET2_C6(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET2.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetISI_R2Y_SET2_C6() uint32 {
	return volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg) & 0xff
}
func (o *ISI_Type) SetISI_R2Y_SET2_C7(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET2.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetISI_R2Y_SET2_C7() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetISI_R2Y_SET2_C8(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET2.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetISI_R2Y_SET2_C8() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetISI_R2Y_SET2_Boff(value uint32) {
	volatile.StoreUint32(&o.ISI_R2Y_SET2.Reg, volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_R2Y_SET2_Boff() uint32 {
	return (volatile.LoadUint32(&o.ISI_R2Y_SET2.Reg) & 0x1000000) >> 24
}

// ISI.ISI_CR: ISI Control Register
func (o *ISI_Type) SetISI_CR_ISI_EN(value uint32) {
	volatile.StoreUint32(&o.ISI_CR.Reg, volatile.LoadUint32(&o.ISI_CR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetISI_CR_ISI_EN() uint32 {
	return volatile.LoadUint32(&o.ISI_CR.Reg) & 0x1
}
func (o *ISI_Type) SetISI_CR_ISI_DIS(value uint32) {
	volatile.StoreUint32(&o.ISI_CR.Reg, volatile.LoadUint32(&o.ISI_CR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetISI_CR_ISI_DIS() uint32 {
	return (volatile.LoadUint32(&o.ISI_CR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetISI_CR_ISI_SRST(value uint32) {
	volatile.StoreUint32(&o.ISI_CR.Reg, volatile.LoadUint32(&o.ISI_CR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_CR_ISI_SRST() uint32 {
	return (volatile.LoadUint32(&o.ISI_CR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_CR_ISI_CDC(value uint32) {
	volatile.StoreUint32(&o.ISI_CR.Reg, volatile.LoadUint32(&o.ISI_CR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetISI_CR_ISI_CDC() uint32 {
	return (volatile.LoadUint32(&o.ISI_CR.Reg) & 0x100) >> 8
}

// ISI.ISI_SR: ISI Status Register
func (o *ISI_Type) SetISI_SR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetISI_SR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.ISI_SR.Reg) & 0x1
}
func (o *ISI_Type) SetISI_SR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetISI_SR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetISI_SR_SRST(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_SR_SRST() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_SR_CDC_PND(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetISI_SR_CDC_PND() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x100) >> 8
}
func (o *ISI_Type) SetISI_SR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetISI_SR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetISI_SR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetISI_SR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetISI_SR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetISI_SR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetISI_SR_SIP(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x80000)|value<<19)
}
func (o *ISI_Type) GetISI_SR_SIP() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x80000) >> 19
}
func (o *ISI_Type) SetISI_SR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_SR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetISI_SR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetISI_SR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetISI_SR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetISI_SR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetISI_SR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_SR.Reg, volatile.LoadUint32(&o.ISI_SR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetISI_SR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_SR.Reg) & 0x8000000) >> 27
}

// ISI.ISI_IER: ISI Interrupt Enable Register
func (o *ISI_Type) SetISI_IER_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetISI_IER_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetISI_IER_SRST(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_IER_SRST() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_IER_VSYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetISI_IER_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetISI_IER_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetISI_IER_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetISI_IER_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetISI_IER_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetISI_IER_P_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_IER_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetISI_IER_C_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetISI_IER_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetISI_IER_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetISI_IER_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetISI_IER_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IER.Reg, volatile.LoadUint32(&o.ISI_IER.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetISI_IER_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IER.Reg) & 0x8000000) >> 27
}

// ISI.ISI_IDR: ISI Interrupt Disable Register
func (o *ISI_Type) SetISI_IDR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetISI_IDR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetISI_IDR_SRST(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_IDR_SRST() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_IDR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetISI_IDR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetISI_IDR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetISI_IDR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetISI_IDR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetISI_IDR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetISI_IDR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_IDR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetISI_IDR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetISI_IDR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetISI_IDR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetISI_IDR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetISI_IDR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IDR.Reg, volatile.LoadUint32(&o.ISI_IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetISI_IDR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IDR.Reg) & 0x8000000) >> 27
}

// ISI.ISI_IMR: ISI Interrupt Mask Register
func (o *ISI_Type) SetISI_IMR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetISI_IMR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetISI_IMR_SRST(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetISI_IMR_SRST() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetISI_IMR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetISI_IMR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetISI_IMR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetISI_IMR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetISI_IMR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetISI_IMR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetISI_IMR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetISI_IMR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetISI_IMR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetISI_IMR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetISI_IMR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetISI_IMR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetISI_IMR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISI_IMR.Reg, volatile.LoadUint32(&o.ISI_IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetISI_IMR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISI_IMR.Reg) & 0x8000000) >> 27
}

// ISI.DMA_CHER: DMA Channel Enable Register
func (o *ISI_Type) SetDMA_CHER_P_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHER_P_CH_EN() uint32 {
	return volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHER_C_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHER_C_CH_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x2) >> 1
}

// ISI.DMA_CHDR: DMA Channel Disable Register
func (o *ISI_Type) SetDMA_CHDR_P_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHDR_P_CH_DIS() uint32 {
	return volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHDR_C_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHDR_C_CH_DIS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x2) >> 1
}

// ISI.DMA_CHSR: DMA Channel Status Register
func (o *ISI_Type) SetDMA_CHSR_P_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHSR_P_CH_S() uint32 {
	return volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHSR_C_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHSR_C_CH_S() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x2) >> 1
}

// ISI.DMA_P_ADDR: DMA Preview Base Address Register
func (o *ISI_Type) SetDMA_P_ADDR_P_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_ADDR.Reg, volatile.LoadUint32(&o.DMA_P_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_ADDR_P_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_P_CTRL: DMA Preview Control Register
func (o *ISI_Type) SetDMA_P_CTRL_P_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_P_CTRL_P_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_P_DSCR: DMA Preview Descriptor Address Register
func (o *ISI_Type) SetDMA_P_DSCR_P_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_DSCR.Reg, volatile.LoadUint32(&o.DMA_P_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_DSCR_P_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_ADDR: DMA Codec Base Address Register
func (o *ISI_Type) SetDMA_C_ADDR_C_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_ADDR.Reg, volatile.LoadUint32(&o.DMA_C_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_ADDR_C_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_CTRL: DMA Codec Control Register
func (o *ISI_Type) SetDMA_C_CTRL_C_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_C_CTRL_C_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_C_DSCR: DMA Codec Descriptor Address Register
func (o *ISI_Type) SetDMA_C_DSCR_C_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_DSCR.Reg, volatile.LoadUint32(&o.DMA_C_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_DSCR_C_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.ISI_WPCR: Write Protection Control Register
func (o *ISI_Type) SetISI_WPCR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.ISI_WPCR.Reg, volatile.LoadUint32(&o.ISI_WPCR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetISI_WPCR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.ISI_WPCR.Reg) & 0x1
}
func (o *ISI_Type) SetISI_WPCR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.ISI_WPCR.Reg, volatile.LoadUint32(&o.ISI_WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ISI_Type) GetISI_WPCR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.ISI_WPCR.Reg) & 0xffffff00) >> 8
}

// ISI.ISI_WPSR: Write Protection Status Register
func (o *ISI_Type) SetISI_WPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.ISI_WPSR.Reg, volatile.LoadUint32(&o.ISI_WPSR.Reg)&^(0xf)|value)
}
func (o *ISI_Type) GetISI_WPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.ISI_WPSR.Reg) & 0xf
}
func (o *ISI_Type) SetISI_WPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.ISI_WPSR.Reg, volatile.LoadUint32(&o.ISI_WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ISI_Type) GetISI_WPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.ISI_WPSR.Reg) & 0xffff00) >> 8
}

// Pulse Width Modulation Controller
type PWM_Type struct {
	MR    volatile.Register32 // 0x0
	ENA   volatile.Register32 // 0x4
	DIS   volatile.Register32 // 0x8
	SR    volatile.Register32 // 0xC
	IER   volatile.Register32 // 0x10
	IDR   volatile.Register32 // 0x14
	IMR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	_     [480]byte
	CMR0  volatile.Register32 // 0x200
	CDTY0 volatile.Register32 // 0x204
	CPRD0 volatile.Register32 // 0x208
	CCNT0 volatile.Register32 // 0x20C
	CUPD0 volatile.Register32 // 0x210
	_     [12]byte
	CMR1  volatile.Register32 // 0x220
	CDTY1 volatile.Register32 // 0x224
	CPRD1 volatile.Register32 // 0x228
	CCNT1 volatile.Register32 // 0x22C
	CUPD1 volatile.Register32 // 0x230
	_     [12]byte
	CMR2  volatile.Register32 // 0x240
	CDTY2 volatile.Register32 // 0x244
	CPRD2 volatile.Register32 // 0x248
	CCNT2 volatile.Register32 // 0x24C
	CUPD2 volatile.Register32 // 0x250
	_     [12]byte
	CMR3  volatile.Register32 // 0x260
	CDTY3 volatile.Register32 // 0x264
	CPRD3 volatile.Register32 // 0x268
	CCNT3 volatile.Register32 // 0x26C
	CUPD3 volatile.Register32 // 0x270
}

// PWM.MR: PWM Mode Register
func (o *PWM_Type) SetMR_DIVA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetMR_DIVA() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xff
}
func (o *PWM_Type) SetMR_PREA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetMR_PREA() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetMR_DIVB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetMR_DIVB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetMR_PREB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *PWM_Type) GetMR_PREB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}

// PWM.ENA: PWM Enable Register
func (o *PWM_Type) SetENA_CHID0(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENA_CHID0() uint32 {
	return volatile.LoadUint32(&o.ENA.Reg) & 0x1
}
func (o *PWM_Type) SetENA_CHID1(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetENA_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetENA_CHID2(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetENA_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetENA_CHID3(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetENA_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x8) >> 3
}

// PWM.DIS: PWM Disable Register
func (o *PWM_Type) SetDIS_CHID0(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetDIS_CHID0() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}
func (o *PWM_Type) SetDIS_CHID1(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetDIS_CHID1() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetDIS_CHID2(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetDIS_CHID2() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetDIS_CHID3(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetDIS_CHID3() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x8) >> 3
}

// PWM.SR: PWM Status Register
func (o *PWM_Type) SetSR_CHID0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSR_CHID0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *PWM_Type) SetSR_CHID1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSR_CHID2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSR_CHID3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}

// PWM.IER: PWM Interrupt Enable Register
func (o *PWM_Type) SetIER_CHID0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER_CHID0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PWM_Type) SetIER_CHID1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIER_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIER_CHID2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIER_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIER_CHID3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}

// PWM.IDR: PWM Interrupt Disable Register
func (o *PWM_Type) SetIDR_CHID0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR_CHID0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PWM_Type) SetIDR_CHID1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIDR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIDR_CHID2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIDR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIDR_CHID3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}

// PWM.IMR: PWM Interrupt Mask Register
func (o *PWM_Type) SetIMR_CHID0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR_CHID0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PWM_Type) SetIMR_CHID1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIMR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIMR_CHID2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIMR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIMR_CHID3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}

// PWM.ISR: PWM Interrupt Status Register
func (o *PWM_Type) SetISR_CHID0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR_CHID0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PWM_Type) SetISR_CHID1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetISR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetISR_CHID2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetISR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetISR_CHID3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}

// PWM.CMR0: PWM Channel Mode Register (ch_num = 0)
func (o *PWM_Type) SetCMR0_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR0_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0xf
}
func (o *PWM_Type) SetCMR0_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR0_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR0_CPD(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR0_CPD() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}

// PWM.CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
func (o *PWM_Type) SetCDTY0(value uint32) {
	volatile.StoreUint32(&o.CDTY0.Reg, value)
}
func (o *PWM_Type) GetCDTY0() uint32 {
	return volatile.LoadUint32(&o.CDTY0.Reg)
}

// PWM.CPRD0: PWM Channel Period Register (ch_num = 0)
func (o *PWM_Type) SetCPRD0(value uint32) {
	volatile.StoreUint32(&o.CPRD0.Reg, value)
}
func (o *PWM_Type) GetCPRD0() uint32 {
	return volatile.LoadUint32(&o.CPRD0.Reg)
}

// PWM.CCNT0: PWM Channel Counter Register (ch_num = 0)
func (o *PWM_Type) SetCCNT0(value uint32) {
	volatile.StoreUint32(&o.CCNT0.Reg, value)
}
func (o *PWM_Type) GetCCNT0() uint32 {
	return volatile.LoadUint32(&o.CCNT0.Reg)
}

// PWM.CUPD0: PWM Channel Update Register (ch_num = 0)
func (o *PWM_Type) SetCUPD0(value uint32) {
	volatile.StoreUint32(&o.CUPD0.Reg, value)
}
func (o *PWM_Type) GetCUPD0() uint32 {
	return volatile.LoadUint32(&o.CUPD0.Reg)
}

// PWM.CMR1: PWM Channel Mode Register (ch_num = 1)
func (o *PWM_Type) SetCMR1_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR1_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0xf
}
func (o *PWM_Type) SetCMR1_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR1_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR1_CPD(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR1_CPD() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}

// PWM.CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
func (o *PWM_Type) SetCDTY1(value uint32) {
	volatile.StoreUint32(&o.CDTY1.Reg, value)
}
func (o *PWM_Type) GetCDTY1() uint32 {
	return volatile.LoadUint32(&o.CDTY1.Reg)
}

// PWM.CPRD1: PWM Channel Period Register (ch_num = 1)
func (o *PWM_Type) SetCPRD1(value uint32) {
	volatile.StoreUint32(&o.CPRD1.Reg, value)
}
func (o *PWM_Type) GetCPRD1() uint32 {
	return volatile.LoadUint32(&o.CPRD1.Reg)
}

// PWM.CCNT1: PWM Channel Counter Register (ch_num = 1)
func (o *PWM_Type) SetCCNT1(value uint32) {
	volatile.StoreUint32(&o.CCNT1.Reg, value)
}
func (o *PWM_Type) GetCCNT1() uint32 {
	return volatile.LoadUint32(&o.CCNT1.Reg)
}

// PWM.CUPD1: PWM Channel Update Register (ch_num = 1)
func (o *PWM_Type) SetCUPD1(value uint32) {
	volatile.StoreUint32(&o.CUPD1.Reg, value)
}
func (o *PWM_Type) GetCUPD1() uint32 {
	return volatile.LoadUint32(&o.CUPD1.Reg)
}

// PWM.CMR2: PWM Channel Mode Register (ch_num = 2)
func (o *PWM_Type) SetCMR2_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR2_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0xf
}
func (o *PWM_Type) SetCMR2_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR2_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR2_CPD(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR2_CPD() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}

// PWM.CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
func (o *PWM_Type) SetCDTY2(value uint32) {
	volatile.StoreUint32(&o.CDTY2.Reg, value)
}
func (o *PWM_Type) GetCDTY2() uint32 {
	return volatile.LoadUint32(&o.CDTY2.Reg)
}

// PWM.CPRD2: PWM Channel Period Register (ch_num = 2)
func (o *PWM_Type) SetCPRD2(value uint32) {
	volatile.StoreUint32(&o.CPRD2.Reg, value)
}
func (o *PWM_Type) GetCPRD2() uint32 {
	return volatile.LoadUint32(&o.CPRD2.Reg)
}

// PWM.CCNT2: PWM Channel Counter Register (ch_num = 2)
func (o *PWM_Type) SetCCNT2(value uint32) {
	volatile.StoreUint32(&o.CCNT2.Reg, value)
}
func (o *PWM_Type) GetCCNT2() uint32 {
	return volatile.LoadUint32(&o.CCNT2.Reg)
}

// PWM.CUPD2: PWM Channel Update Register (ch_num = 2)
func (o *PWM_Type) SetCUPD2(value uint32) {
	volatile.StoreUint32(&o.CUPD2.Reg, value)
}
func (o *PWM_Type) GetCUPD2() uint32 {
	return volatile.LoadUint32(&o.CUPD2.Reg)
}

// PWM.CMR3: PWM Channel Mode Register (ch_num = 3)
func (o *PWM_Type) SetCMR3_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR3_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR3.Reg) & 0xf
}
func (o *PWM_Type) SetCMR3_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR3_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR3_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR3_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR3_CPD(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR3_CPD() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x400) >> 10
}

// PWM.CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
func (o *PWM_Type) SetCDTY3(value uint32) {
	volatile.StoreUint32(&o.CDTY3.Reg, value)
}
func (o *PWM_Type) GetCDTY3() uint32 {
	return volatile.LoadUint32(&o.CDTY3.Reg)
}

// PWM.CPRD3: PWM Channel Period Register (ch_num = 3)
func (o *PWM_Type) SetCPRD3(value uint32) {
	volatile.StoreUint32(&o.CPRD3.Reg, value)
}
func (o *PWM_Type) GetCPRD3() uint32 {
	return volatile.LoadUint32(&o.CPRD3.Reg)
}

// PWM.CCNT3: PWM Channel Counter Register (ch_num = 3)
func (o *PWM_Type) SetCCNT3(value uint32) {
	volatile.StoreUint32(&o.CCNT3.Reg, value)
}
func (o *PWM_Type) GetCCNT3() uint32 {
	return volatile.LoadUint32(&o.CCNT3.Reg)
}

// PWM.CUPD3: PWM Channel Update Register (ch_num = 3)
func (o *PWM_Type) SetCUPD3(value uint32) {
	volatile.StoreUint32(&o.CUPD3.Reg, value)
}
func (o *PWM_Type) GetCUPD3() uint32 {
	return volatile.LoadUint32(&o.CUPD3.Reg)
}

// Ethernet MAC 10/100
type EMAC_Type struct {
	NCR   volatile.Register32 // 0x0
	NCFG  volatile.Register32 // 0x4
	NSR   volatile.Register32 // 0x8
	_     [8]byte
	TSR   volatile.Register32 // 0x14
	RBQP  volatile.Register32 // 0x18
	TBQP  volatile.Register32 // 0x1C
	RSR   volatile.Register32 // 0x20
	ISR   volatile.Register32 // 0x24
	IER   volatile.Register32 // 0x28
	IDR   volatile.Register32 // 0x2C
	IMR   volatile.Register32 // 0x30
	MAN   volatile.Register32 // 0x34
	PTR   volatile.Register32 // 0x38
	PFR   volatile.Register32 // 0x3C
	FTO   volatile.Register32 // 0x40
	SCF   volatile.Register32 // 0x44
	MCF   volatile.Register32 // 0x48
	FRO   volatile.Register32 // 0x4C
	FCSE  volatile.Register32 // 0x50
	ALE   volatile.Register32 // 0x54
	DTF   volatile.Register32 // 0x58
	LCOL  volatile.Register32 // 0x5C
	ECOL  volatile.Register32 // 0x60
	TUND  volatile.Register32 // 0x64
	CSE   volatile.Register32 // 0x68
	RRE   volatile.Register32 // 0x6C
	ROV   volatile.Register32 // 0x70
	RSE   volatile.Register32 // 0x74
	ELE   volatile.Register32 // 0x78
	RJA   volatile.Register32 // 0x7C
	USF   volatile.Register32 // 0x80
	STE   volatile.Register32 // 0x84
	RLE   volatile.Register32 // 0x88
	_     [4]byte
	HRB   volatile.Register32 // 0x90
	HRT   volatile.Register32 // 0x94
	SA1B  volatile.Register32 // 0x98
	SA1T  volatile.Register32 // 0x9C
	SA2B  volatile.Register32 // 0xA0
	SA2T  volatile.Register32 // 0xA4
	SA3B  volatile.Register32 // 0xA8
	SA3T  volatile.Register32 // 0xAC
	SA4B  volatile.Register32 // 0xB0
	SA4T  volatile.Register32 // 0xB4
	TID   volatile.Register32 // 0xB8
	_     [4]byte
	USRIO volatile.Register32 // 0xC0
}

// EMAC.NCR: Network Control Register
func (o *EMAC_Type) SetNCR_LB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCR_LB() uint32 {
	return volatile.LoadUint32(&o.NCR.Reg) & 0x1
}
func (o *EMAC_Type) SetNCR_LLB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCR_LLB() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCR_RE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNCR_RE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetNCR_TE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCR_TE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *EMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *EMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}

// EMAC.NCFG: Network Configuration Register
func (o *EMAC_Type) SetNCFG_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCFG_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFG.Reg) & 0x1
}
func (o *EMAC_Type) SetNCFG_FD(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCFG_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCFG_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCFG_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCFG_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCFG_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCFG_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCFG_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCFG_MTI(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCFG_MTI() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCFG_UNI(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCFG_UNI() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCFG_BIG(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCFG_BIG() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCFG_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0xc00)|value<<10)
}
func (o *EMAC_Type) GetNCFG_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0xc00) >> 10
}
func (o *EMAC_Type) SetNCFG_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetNCFG_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetNCFG_PAE(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetNCFG_PAE() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetNCFG_RBOF(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0xc000)|value<<14)
}
func (o *EMAC_Type) GetNCFG_RBOF() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0xc000) >> 14
}
func (o *EMAC_Type) SetNCFG_RLCE(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x10000)|value<<16)
}
func (o *EMAC_Type) GetNCFG_RLCE() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x10000) >> 16
}
func (o *EMAC_Type) SetNCFG_DRFCS(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x20000)|value<<17)
}
func (o *EMAC_Type) GetNCFG_DRFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x20000) >> 17
}
func (o *EMAC_Type) SetNCFG_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x40000)|value<<18)
}
func (o *EMAC_Type) GetNCFG_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x40000) >> 18
}
func (o *EMAC_Type) SetNCFG_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFG.Reg, volatile.LoadUint32(&o.NCFG.Reg)&^(0x80000)|value<<19)
}
func (o *EMAC_Type) GetNCFG_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFG.Reg) & 0x80000) >> 19
}

// EMAC.NSR: Network Status Register
func (o *EMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// EMAC.TSR: Transmit Status Register
func (o *EMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *EMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetTSR_RLE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetTSR_RLE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetTSR_TGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetTSR_TGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetTSR_BEX(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetTSR_BEX() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetTSR_COMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetTSR_COMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetTSR_UND(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetTSR_UND() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40) >> 6
}

// EMAC.RBQP: Receive Buffer Queue Pointer Register
func (o *EMAC_Type) SetRBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQP.Reg, volatile.LoadUint32(&o.RBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetRBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.TBQP: Transmit Buffer Queue Pointer Register
func (o *EMAC_Type) SetTBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQP.Reg, volatile.LoadUint32(&o.TBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetTBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.RSR: Receive Status Register
func (o *EMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *EMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetRSR_OVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetRSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}

// EMAC.ISR: Interrupt Status Register
func (o *EMAC_Type) SetISR_MFD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetISR_MFD() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *EMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetISR_TUND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetISR_TUND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetISR_RLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetISR_RLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetISR_PFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetISR_PFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}

// EMAC.IER: Interrupt Enable Register
func (o *EMAC_Type) SetIER_MFD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIER_MFD() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *EMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIER_TUND(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIER_TUND() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIER_RLE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIER_RLE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIER_TXERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIER_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIER_PFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIER_PFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}

// EMAC.IDR: Interrupt Disable Register
func (o *EMAC_Type) SetIDR_MFD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIDR_MFD() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *EMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIDR_TUND(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIDR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIDR_RLE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIDR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIDR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIDR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIDR_PFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIDR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}

// EMAC.IMR: Interrupt Mask Register
func (o *EMAC_Type) SetIMR_MFD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIMR_MFD() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *EMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIMR_TUND(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIMR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIMR_RLE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIMR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIMR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIMR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIMR_PFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIMR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}

// EMAC.MAN: Phy Maintenance Register
func (o *EMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *EMAC_Type) SetMAN_CODE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *EMAC_Type) GetMAN_CODE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *EMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *EMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *EMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *EMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *EMAC_Type) SetMAN_RW(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *EMAC_Type) GetMAN_RW() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *EMAC_Type) SetMAN_SOF(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xc0000000)|value<<30)
}
func (o *EMAC_Type) GetMAN_SOF() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xc0000000) >> 30
}

// EMAC.PTR: Pause Time Register
func (o *EMAC_Type) SetPTR_PTIME(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, volatile.LoadUint32(&o.PTR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPTR_PTIME() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg) & 0xffff
}

// EMAC.PFR: Pause Frames Received Register
func (o *EMAC_Type) SetPFR_FROK(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPFR_FROK() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// EMAC.FTO: Frames Transmitted Ok Register
func (o *EMAC_Type) SetFTO_FTOK(value uint32) {
	volatile.StoreUint32(&o.FTO.Reg, volatile.LoadUint32(&o.FTO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFTO_FTOK() uint32 {
	return volatile.LoadUint32(&o.FTO.Reg) & 0xffffff
}

// EMAC.SCF: Single Collision Frames Register
func (o *EMAC_Type) SetSCF(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSCF() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0xffff
}

// EMAC.MCF: Multiple Collision Frames Register
func (o *EMAC_Type) SetMCF(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMCF() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0xffff
}

// EMAC.FRO: Frames Received Ok Register
func (o *EMAC_Type) SetFRO_FROK(value uint32) {
	volatile.StoreUint32(&o.FRO.Reg, volatile.LoadUint32(&o.FRO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFRO_FROK() uint32 {
	return volatile.LoadUint32(&o.FRO.Reg) & 0xffffff
}

// EMAC.FCSE: Frame Check Sequence Errors Register
func (o *EMAC_Type) SetFCSE(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetFCSE() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0xff
}

// EMAC.ALE: Alignment Errors Register
func (o *EMAC_Type) SetALE(value uint32) {
	volatile.StoreUint32(&o.ALE.Reg, volatile.LoadUint32(&o.ALE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetALE() uint32 {
	return volatile.LoadUint32(&o.ALE.Reg) & 0xff
}

// EMAC.DTF: Deferred Transmission Frames Register
func (o *EMAC_Type) SetDTF(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetDTF() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0xffff
}

// EMAC.LCOL: Late Collisions Register
func (o *EMAC_Type) SetLCOL(value uint32) {
	volatile.StoreUint32(&o.LCOL.Reg, volatile.LoadUint32(&o.LCOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetLCOL() uint32 {
	return volatile.LoadUint32(&o.LCOL.Reg) & 0xff
}

// EMAC.ECOL: Excessive Collisions Register
func (o *EMAC_Type) SetECOL_EXCOL(value uint32) {
	volatile.StoreUint32(&o.ECOL.Reg, volatile.LoadUint32(&o.ECOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetECOL_EXCOL() uint32 {
	return volatile.LoadUint32(&o.ECOL.Reg) & 0xff
}

// EMAC.TUND: Transmit Underrun Errors Register
func (o *EMAC_Type) SetTUND(value uint32) {
	volatile.StoreUint32(&o.TUND.Reg, volatile.LoadUint32(&o.TUND.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetTUND() uint32 {
	return volatile.LoadUint32(&o.TUND.Reg) & 0xff
}

// EMAC.CSE: Carrier Sense Errors Register
func (o *EMAC_Type) SetCSE(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetCSE() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0xff
}

// EMAC.RRE: Receive Resource Errors Register
func (o *EMAC_Type) SetRRE(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetRRE() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0xffff
}

// EMAC.ROV: Receive Overrun Errors Register
func (o *EMAC_Type) SetROV_ROVR(value uint32) {
	volatile.StoreUint32(&o.ROV.Reg, volatile.LoadUint32(&o.ROV.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetROV_ROVR() uint32 {
	return volatile.LoadUint32(&o.ROV.Reg) & 0xff
}

// EMAC.RSE: Receive Symbol Errors Register
func (o *EMAC_Type) SetRSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0xff
}

// EMAC.ELE: Excessive Length Errors Register
func (o *EMAC_Type) SetELE_EXL(value uint32) {
	volatile.StoreUint32(&o.ELE.Reg, volatile.LoadUint32(&o.ELE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetELE_EXL() uint32 {
	return volatile.LoadUint32(&o.ELE.Reg) & 0xff
}

// EMAC.RJA: Receive Jabbers Register
func (o *EMAC_Type) SetRJA_RJB(value uint32) {
	volatile.StoreUint32(&o.RJA.Reg, volatile.LoadUint32(&o.RJA.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRJA_RJB() uint32 {
	return volatile.LoadUint32(&o.RJA.Reg) & 0xff
}

// EMAC.USF: Undersize Frames Register
func (o *EMAC_Type) SetUSF(value uint32) {
	volatile.StoreUint32(&o.USF.Reg, volatile.LoadUint32(&o.USF.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetUSF() uint32 {
	return volatile.LoadUint32(&o.USF.Reg) & 0xff
}

// EMAC.STE: SQE Test Errors Register
func (o *EMAC_Type) SetSTE_SQER(value uint32) {
	volatile.StoreUint32(&o.STE.Reg, volatile.LoadUint32(&o.STE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetSTE_SQER() uint32 {
	return volatile.LoadUint32(&o.STE.Reg) & 0xff
}

// EMAC.RLE: Received Length Field Mismatch Register
func (o *EMAC_Type) SetRLE_RLFM(value uint32) {
	volatile.StoreUint32(&o.RLE.Reg, volatile.LoadUint32(&o.RLE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRLE_RLFM() uint32 {
	return volatile.LoadUint32(&o.RLE.Reg) & 0xff
}

// EMAC.HRB: Hash Register Bottom [31:0] Register
func (o *EMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *EMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// EMAC.HRT: Hash Register Top [63:32] Register
func (o *EMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *EMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// EMAC.SA1B: Specific Address 1 Bottom Register
func (o *EMAC_Type) SetSA1B(value uint32) {
	volatile.StoreUint32(&o.SA1B.Reg, value)
}
func (o *EMAC_Type) GetSA1B() uint32 {
	return volatile.LoadUint32(&o.SA1B.Reg)
}

// EMAC.SA1T: Specific Address 1 Top Register
func (o *EMAC_Type) SetSA1T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA1T.Reg, volatile.LoadUint32(&o.SA1T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA1T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA1T.Reg) & 0xffff
}

// EMAC.SA2B: Specific Address 2 Bottom Register
func (o *EMAC_Type) SetSA2B(value uint32) {
	volatile.StoreUint32(&o.SA2B.Reg, value)
}
func (o *EMAC_Type) GetSA2B() uint32 {
	return volatile.LoadUint32(&o.SA2B.Reg)
}

// EMAC.SA2T: Specific Address 2 Top Register
func (o *EMAC_Type) SetSA2T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA2T.Reg, volatile.LoadUint32(&o.SA2T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA2T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA2T.Reg) & 0xffff
}

// EMAC.SA3B: Specific Address 3 Bottom Register
func (o *EMAC_Type) SetSA3B(value uint32) {
	volatile.StoreUint32(&o.SA3B.Reg, value)
}
func (o *EMAC_Type) GetSA3B() uint32 {
	return volatile.LoadUint32(&o.SA3B.Reg)
}

// EMAC.SA3T: Specific Address 3 Top Register
func (o *EMAC_Type) SetSA3T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA3T.Reg, volatile.LoadUint32(&o.SA3T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA3T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA3T.Reg) & 0xffff
}

// EMAC.SA4B: Specific Address 4 Bottom Register
func (o *EMAC_Type) SetSA4B(value uint32) {
	volatile.StoreUint32(&o.SA4B.Reg, value)
}
func (o *EMAC_Type) GetSA4B() uint32 {
	return volatile.LoadUint32(&o.SA4B.Reg)
}

// EMAC.SA4T: Specific Address 4 Top Register
func (o *EMAC_Type) SetSA4T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA4T.Reg, volatile.LoadUint32(&o.SA4T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA4T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA4T.Reg) & 0xffff
}

// EMAC.TID: Type ID Checking Register
func (o *EMAC_Type) SetTID(value uint32) {
	volatile.StoreUint32(&o.TID.Reg, volatile.LoadUint32(&o.TID.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetTID() uint32 {
	return volatile.LoadUint32(&o.TID.Reg) & 0xffff
}

// EMAC.USRIO: User Input/Output Register
func (o *EMAC_Type) SetUSRIO_RMII(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetUSRIO_RMII() uint32 {
	return volatile.LoadUint32(&o.USRIO.Reg) & 0x1
}
func (o *EMAC_Type) SetUSRIO_CLKEN(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetUSRIO_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.USRIO.Reg) & 0x2) >> 1
}

// Advanced Encryption Standard
type AES_Type struct {
	CR     volatile.Register32 // 0x0
	MR     volatile.Register32 // 0x4
	_      [8]byte
	IER    volatile.Register32    // 0x10
	IDR    volatile.Register32    // 0x14
	IMR    volatile.Register32    // 0x18
	ISR    volatile.Register32    // 0x1C
	KEYWR  [8]volatile.Register32 // 0x20
	IDATAR [4]volatile.Register32 // 0x40
	ODATAR [4]volatile.Register32 // 0x50
	IVR    [4]volatile.Register32 // 0x60
}

// AES.CR: Control Register
func (o *AES_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *AES_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetCR_LOADSEED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *AES_Type) GetCR_LOADSEED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}

// AES.MR: Mode Register
func (o *AES_Type) SetMR_CIPHER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetMR_CIPHER() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *AES_Type) SetMR_PROCDLY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0)|value<<4)
}
func (o *AES_Type) GetMR_PROCDLY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0) >> 4
}
func (o *AES_Type) SetMR_SMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x300)|value<<8)
}
func (o *AES_Type) GetMR_SMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x300) >> 8
}
func (o *AES_Type) SetMR_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc00)|value<<10)
}
func (o *AES_Type) GetMR_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc00) >> 10
}
func (o *AES_Type) SetMR_OPMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000)|value<<12)
}
func (o *AES_Type) GetMR_OPMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000) >> 12
}
func (o *AES_Type) SetMR_LOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *AES_Type) GetMR_LOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *AES_Type) SetMR_CFBS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x70000)|value<<16)
}
func (o *AES_Type) GetMR_CFBS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x70000) >> 16
}
func (o *AES_Type) SetMR_CKEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00000)|value<<20)
}
func (o *AES_Type) GetMR_CKEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00000) >> 20
}
func (o *AES_Type) SetMR_CMTYP1(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000000)|value<<24)
}
func (o *AES_Type) GetMR_CMTYP1() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000000) >> 24
}
func (o *AES_Type) SetMR_CMTYP2(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000000)|value<<25)
}
func (o *AES_Type) GetMR_CMTYP2() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000000) >> 25
}
func (o *AES_Type) SetMR_CMTYP3(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000000)|value<<26)
}
func (o *AES_Type) GetMR_CMTYP3() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000000) >> 26
}
func (o *AES_Type) SetMR_CMTYP4(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000000)|value<<27)
}
func (o *AES_Type) GetMR_CMTYP4() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000000) >> 27
}
func (o *AES_Type) SetMR_CMTYP5(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *AES_Type) GetMR_CMTYP5() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}

// AES.IER: Interrupt Enable Register
func (o *AES_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *AES_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}

// AES.IDR: Interrupt Disable Register
func (o *AES_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *AES_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}

// AES.IMR: Interrupt Mask Register
func (o *AES_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *AES_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}

// AES.ISR: Interrupt Status Register
func (o *AES_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *AES_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetISR_URAT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf000)|value<<12)
}
func (o *AES_Type) GetISR_URAT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf000) >> 12
}

// AES.KEYWR: Key Word Register
func (o *AES_Type) SetKEYWR(idx int, value uint32) {
	volatile.StoreUint32(&o.KEYWR[idx].Reg, value)
}
func (o *AES_Type) GetKEYWR(idx int) uint32 {
	return volatile.LoadUint32(&o.KEYWR[idx].Reg)
}

// AES.IDATAR: Input Data Register
func (o *AES_Type) SetIDATAR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDATAR[idx].Reg, value)
}
func (o *AES_Type) GetIDATAR(idx int) uint32 {
	return volatile.LoadUint32(&o.IDATAR[idx].Reg)
}

// AES.ODATAR: Output Data Register
func (o *AES_Type) SetODATAR(idx int, value uint32) {
	volatile.StoreUint32(&o.ODATAR[idx].Reg, value)
}
func (o *AES_Type) GetODATAR(idx int) uint32 {
	return volatile.LoadUint32(&o.ODATAR[idx].Reg)
}

// AES.IVR: Initialization Vector Register
func (o *AES_Type) SetIVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IVR[idx].Reg, value)
}
func (o *AES_Type) GetIVR(idx int) uint32 {
	return volatile.LoadUint32(&o.IVR[idx].Reg)
}

// Triple Data Encryption Standard
type TDES_Type struct {
	CR      volatile.Register32 // 0x0
	MR      volatile.Register32 // 0x4
	_       [8]byte
	IER     volatile.Register32    // 0x10
	IDR     volatile.Register32    // 0x14
	IMR     volatile.Register32    // 0x18
	ISR     volatile.Register32    // 0x1C
	KEY1WxR [2]volatile.Register32 // 0x20
	KEY2WxR [2]volatile.Register32 // 0x28
	KEY3WxR [2]volatile.Register32 // 0x30
	_       [8]byte
	IDATAxR [2]volatile.Register32 // 0x40
	_       [8]byte
	ODATAxR [2]volatile.Register32 // 0x50
	_       [8]byte
	IVxR    [2]volatile.Register32 // 0x60
	_       [152]byte
	RPR     volatile.Register32 // 0x100
	RCR     volatile.Register32 // 0x104
	TPR     volatile.Register32 // 0x108
	TCR     volatile.Register32 // 0x10C
	RNPR    volatile.Register32 // 0x110
	RNCR    volatile.Register32 // 0x114
	TNPR    volatile.Register32 // 0x118
	TNCR    volatile.Register32 // 0x11C
	PTCR    volatile.Register32 // 0x120
	PTSR    volatile.Register32 // 0x124
}

// TDES.CR: Control Register
func (o *TDES_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TDES_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *TDES_Type) SetCR_LOADSEED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *TDES_Type) GetCR_LOADSEED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}

// TDES.MR: Mode Register
func (o *TDES_Type) SetMR_CIPHER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetMR_CIPHER() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *TDES_Type) SetMR_TDESMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetMR_TDESMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetMR_KEYMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *TDES_Type) GetMR_KEYMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *TDES_Type) SetMR_SMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x300)|value<<8)
}
func (o *TDES_Type) GetMR_SMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x300) >> 8
}
func (o *TDES_Type) SetMR_OPMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3000)|value<<12)
}
func (o *TDES_Type) GetMR_OPMOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x3000) >> 12
}
func (o *TDES_Type) SetMR_LOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8000)|value<<15)
}
func (o *TDES_Type) GetMR_LOD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8000) >> 15
}
func (o *TDES_Type) SetMR_CFBS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30000)|value<<16)
}
func (o *TDES_Type) GetMR_CFBS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30000) >> 16
}
func (o *TDES_Type) SetMR_CKEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00000)|value<<20)
}
func (o *TDES_Type) GetMR_CKEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00000) >> 20
}
func (o *TDES_Type) SetMR_CTYPE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3f000000)|value<<24)
}
func (o *TDES_Type) GetMR_CTYPE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x3f000000) >> 24
}

// TDES.IER: Interrupt Enable Register
func (o *TDES_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TDES_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TDES_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TDES_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *TDES_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *TDES_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TDES_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TDES_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}

// TDES.IDR: Interrupt Disable Register
func (o *TDES_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TDES_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TDES_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TDES_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *TDES_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *TDES_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TDES_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TDES_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}

// TDES.IMR: Interrupt Mask Register
func (o *TDES_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TDES_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TDES_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TDES_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *TDES_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *TDES_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TDES_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TDES_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}

// TDES.ISR: Interrupt Status Register
func (o *TDES_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *TDES_Type) SetISR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetISR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetISR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *TDES_Type) GetISR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *TDES_Type) SetISR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *TDES_Type) GetISR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *TDES_Type) SetISR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *TDES_Type) GetISR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *TDES_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *TDES_Type) SetISR_URAT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x3000)|value<<12)
}
func (o *TDES_Type) GetISR_URAT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x3000) >> 12
}

// TDES.KEY1WxR: Key 1 Word Register
func (o *TDES_Type) SetKEY1WxR(idx int, value uint32) {
	volatile.StoreUint32(&o.KEY1WxR[idx].Reg, value)
}
func (o *TDES_Type) GetKEY1WxR(idx int) uint32 {
	return volatile.LoadUint32(&o.KEY1WxR[idx].Reg)
}

// TDES.KEY2WxR: Key 2 Word Register
func (o *TDES_Type) SetKEY2WxR(idx int, value uint32) {
	volatile.StoreUint32(&o.KEY2WxR[idx].Reg, value)
}
func (o *TDES_Type) GetKEY2WxR(idx int) uint32 {
	return volatile.LoadUint32(&o.KEY2WxR[idx].Reg)
}

// TDES.KEY3WxR: Key 3 Word Register
func (o *TDES_Type) SetKEY3WxR(idx int, value uint32) {
	volatile.StoreUint32(&o.KEY3WxR[idx].Reg, value)
}
func (o *TDES_Type) GetKEY3WxR(idx int) uint32 {
	return volatile.LoadUint32(&o.KEY3WxR[idx].Reg)
}

// TDES.IDATAxR: Input Data Register
func (o *TDES_Type) SetIDATAxR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDATAxR[idx].Reg, value)
}
func (o *TDES_Type) GetIDATAxR(idx int) uint32 {
	return volatile.LoadUint32(&o.IDATAxR[idx].Reg)
}

// TDES.ODATAxR: Output Data Register
func (o *TDES_Type) SetODATAxR(idx int, value uint32) {
	volatile.StoreUint32(&o.ODATAxR[idx].Reg, value)
}
func (o *TDES_Type) GetODATAxR(idx int) uint32 {
	return volatile.LoadUint32(&o.ODATAxR[idx].Reg)
}

// TDES.IVxR: Initialization Vector Register
func (o *TDES_Type) SetIVxR(idx int, value uint32) {
	volatile.StoreUint32(&o.IVxR[idx].Reg, value)
}
func (o *TDES_Type) GetIVxR(idx int) uint32 {
	return volatile.LoadUint32(&o.IVxR[idx].Reg)
}

// TDES.RPR: Receive Pointer Register
func (o *TDES_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *TDES_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// TDES.RCR: Receive Counter Register
func (o *TDES_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *TDES_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// TDES.TPR: Transmit Pointer Register
func (o *TDES_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *TDES_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// TDES.TCR: Transmit Counter Register
func (o *TDES_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *TDES_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// TDES.RNPR: Receive Next Pointer Register
func (o *TDES_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *TDES_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// TDES.RNCR: Receive Next Counter Register
func (o *TDES_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *TDES_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// TDES.TNPR: Transmit Next Pointer Register
func (o *TDES_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *TDES_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// TDES.TNCR: Transmit Next Counter Register
func (o *TDES_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *TDES_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// TDES.PTCR: Transfer Control Register
func (o *TDES_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *TDES_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *TDES_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *TDES_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *TDES_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *TDES_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// TDES.PTSR: Transfer Status Register
func (o *TDES_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *TDES_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *TDES_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *TDES_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Secure Hash Algorithm
type SHA_Type struct {
	CR      volatile.Register32 // 0x0
	MR      volatile.Register32 // 0x4
	_       [8]byte
	IER     volatile.Register32 // 0x10
	IDR     volatile.Register32 // 0x14
	IMR     volatile.Register32 // 0x18
	ISR     volatile.Register32 // 0x1C
	_       [32]byte
	IDATAxR [16]volatile.Register32 // 0x40
	ODATAxR [8]volatile.Register32  // 0x80
	_       [104]byte
	TPR     volatile.Register32 // 0x108
	TCR     volatile.Register32 // 0x10C
	_       [8]byte
	TNPR    volatile.Register32 // 0x118
	TNCR    volatile.Register32 // 0x11C
	PTCR    volatile.Register32 // 0x120
	PTSR    volatile.Register32 // 0x124
}

// SHA.CR: Control Register
func (o *SHA_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SHA_Type) SetCR_FIRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *SHA_Type) GetCR_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *SHA_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// SHA.MR: Mode Register
func (o *SHA_Type) SetMR_SMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3)|value)
}
func (o *SHA_Type) GetMR_SMOD() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x3
}
func (o *SHA_Type) SetMR_PROCDLY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *SHA_Type) GetMR_PROCDLY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *SHA_Type) SetMR_ALGO(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetMR_ALGO() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}

// SHA.IER: Interrupt Enable Register
func (o *SHA_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SHA_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SHA_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SHA_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SHA_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SHA_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}

// SHA.IDR: Interrupt Disable Register
func (o *SHA_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SHA_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SHA_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SHA_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *SHA_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *SHA_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}

// SHA.IMR: Interrupt Mask Register
func (o *SHA_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SHA_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SHA_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SHA_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SHA_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SHA_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}

// SHA.ISR: Interrupt Status Register
func (o *SHA_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *SHA_Type) SetISR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *SHA_Type) GetISR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *SHA_Type) SetISR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *SHA_Type) GetISR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *SHA_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *SHA_Type) SetISR_URAT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x7000)|value<<12)
}
func (o *SHA_Type) GetISR_URAT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x7000) >> 12
}

// SHA.IDATAxR: Input Data Register
func (o *SHA_Type) SetIDATAxR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDATAxR[idx].Reg, value)
}
func (o *SHA_Type) GetIDATAxR(idx int) uint32 {
	return volatile.LoadUint32(&o.IDATAxR[idx].Reg)
}

// SHA.ODATAxR: Output Data Register
func (o *SHA_Type) SetODATAxR(idx int, value uint32) {
	volatile.StoreUint32(&o.ODATAxR[idx].Reg, value)
}
func (o *SHA_Type) GetODATAxR(idx int) uint32 {
	return volatile.LoadUint32(&o.ODATAxR[idx].Reg)
}

// SHA.TPR: Transmit Pointer Register
func (o *SHA_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *SHA_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// SHA.TCR: Transmit Counter Register
func (o *SHA_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *SHA_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// SHA.TNPR: Transmit Next Pointer Register
func (o *SHA_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *SHA_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// SHA.TNCR: Transmit Next Counter Register
func (o *SHA_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *SHA_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// SHA.PTCR: Transfer Control Register
func (o *SHA_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *SHA_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *SHA_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *SHA_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *SHA_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *SHA_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// SHA.PTSR: Transfer Status Register
func (o *SHA_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *SHA_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *SHA_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// True Random Number Generator
type TRNG_Type struct {
	CR    volatile.Register32 // 0x0
	_     [12]byte
	IER   volatile.Register32 // 0x10
	IDR   volatile.Register32 // 0x14
	IMR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	_     [48]byte
	ODATA volatile.Register32 // 0x50
}

// TRNG.CR: Control Register
func (o *TRNG_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// TRNG.IER: Interrupt Enable Register
func (o *TRNG_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// TRNG.IDR: Interrupt Disable Register
func (o *TRNG_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// TRNG.IMR: Interrupt Mask Register
func (o *TRNG_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// TRNG.ISR: Interrupt Status Register
func (o *TRNG_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// TRNG.ODATA: Output Data Register
func (o *TRNG_Type) SetODATA(value uint32) {
	volatile.StoreUint32(&o.ODATA.Reg, value)
}
func (o *TRNG_Type) GetODATA() uint32 {
	return volatile.LoadUint32(&o.ODATA.Reg)
}

// DDR_SDR SDRAM Controller 1
type EBI_Type struct {
	MR    volatile.Register32 // 0x0
	RTR   volatile.Register32 // 0x4
	CR    volatile.Register32 // 0x8
	TPR0  volatile.Register32 // 0xC
	TPR1  volatile.Register32 // 0x10
	TPR2  volatile.Register32 // 0x14
	_     [4]byte
	LPR   volatile.Register32 // 0x1C
	MD    volatile.Register32 // 0x20
	DLL   volatile.Register32 // 0x24
	_     [4]byte
	HS    volatile.Register32 // 0x2C
	_     [16]byte
	DELAY [4]volatile.Register32 // 0x40
	_     [148]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// EBI.MR: DDRSDRC Mode Register
func (o *EBI_Type) SetMR_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMR_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x7
}

// EBI.RTR: DDRSDRC Refresh Timer Register
func (o *EBI_Type) SetRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0xfff)|value)
}
func (o *EBI_Type) GetRTR_COUNT() uint32 {
	return volatile.LoadUint32(&o.RTR.Reg) & 0xfff
}

// EBI.CR: DDRSDRC Configuration Register
func (o *EBI_Type) SetCR_NC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetCR_NC() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *EBI_Type) SetCR_NR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc)|value<<2)
}
func (o *EBI_Type) GetCR_NR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc) >> 2
}
func (o *EBI_Type) SetCR_CAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetCR_CAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetCR_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *EBI_Type) GetCR_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *EBI_Type) SetCR_DIC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *EBI_Type) GetCR_DIC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *EBI_Type) SetCR_DIS_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *EBI_Type) GetCR_DIS_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *EBI_Type) SetCR_OCD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetCR_OCD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000) >> 12
}
func (o *EBI_Type) SetCR_EBISHARE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetCR_EBISHARE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetCR_ACTBST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *EBI_Type) GetCR_ACTBST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}

// EBI.TPR0: DDRSDRC Timing Parameter 0 Register
func (o *EBI_Type) SetTPR0_TRAS(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR0_TRAS() uint32 {
	return volatile.LoadUint32(&o.TPR0.Reg) & 0xf
}
func (o *EBI_Type) SetTPR0_TRCD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR0_TRCD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR0_TWR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR0_TWR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR0_TRC(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf000)|value<<12)
}
func (o *EBI_Type) GetTPR0_TRC() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf000) >> 12
}
func (o *EBI_Type) SetTPR0_TRP(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetTPR0_TRP() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetTPR0_TRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetTPR0_TRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00000) >> 20
}
func (o *EBI_Type) SetTPR0_TWTR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EBI_Type) GetTPR0_TWTR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x7000000) >> 24
}
func (o *EBI_Type) SetTPR0_REDUCE_WRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EBI_Type) GetTPR0_REDUCE_WRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x8000000) >> 27
}
func (o *EBI_Type) SetTPR0_TMRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *EBI_Type) GetTPR0_TMRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000000) >> 28
}

// EBI.TPR1: DDRSDRC Timing Parameter 1 Register
func (o *EBI_Type) SetTPR1_TRFC(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0x1f)|value)
}
func (o *EBI_Type) GetTPR1_TRFC() uint32 {
	return volatile.LoadUint32(&o.TPR1.Reg) & 0x1f
}
func (o *EBI_Type) SetTPR1_TXSNR(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetTPR1_TXSNR() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff00) >> 8
}
func (o *EBI_Type) SetTPR1_TXSRD(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *EBI_Type) GetTPR1_TXSRD() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff0000) >> 16
}
func (o *EBI_Type) SetTPR1_TXP(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetTPR1_TXP() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xf000000) >> 24
}

// EBI.TPR2: DDRSDRC Timing Parameter 2 Register
func (o *EBI_Type) SetTPR2_TXARD(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR2_TXARD() uint32 {
	return volatile.LoadUint32(&o.TPR2.Reg) & 0xf
}
func (o *EBI_Type) SetTPR2_TXARDS(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR2_TXARDS() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR2_TRPA(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR2_TRPA() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR2_TRTP(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetTPR2_TRTP() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0x7000) >> 12
}

// EBI.LPR: DDRSDRC Low-power Register
func (o *EBI_Type) SetLPR_LPCB(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetLPR_LPCB() uint32 {
	return volatile.LoadUint32(&o.LPR.Reg) & 0x3
}
func (o *EBI_Type) SetLPR_CLK_FR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetLPR_CLK_FR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetLPR_PASR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetLPR_PASR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetLPR_TCR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300)|value<<8)
}
func (o *EBI_Type) GetLPR_TCR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300) >> 8
}
func (o *EBI_Type) SetLPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0xc00)|value<<10)
}
func (o *EBI_Type) GetLPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0xc00) >> 10
}
func (o *EBI_Type) SetLPR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3000)|value<<12)
}
func (o *EBI_Type) GetLPR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x3000) >> 12
}
func (o *EBI_Type) SetLPR_APDE(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetLPR_APDE() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetLPR_UPD_MR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300000)|value<<20)
}
func (o *EBI_Type) GetLPR_UPD_MR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300000) >> 20
}

// EBI.MD: DDRSDRC Memory Device Register
func (o *EBI_Type) SetMD(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMD() uint32 {
	return volatile.LoadUint32(&o.MD.Reg) & 0x7
}
func (o *EBI_Type) SetMD_DBW(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x10)|value<<4)
}
func (o *EBI_Type) GetMD_DBW() uint32 {
	return (volatile.LoadUint32(&o.MD.Reg) & 0x10) >> 4
}

// EBI.DLL: DDRSDRC DLL Information Register
func (o *EBI_Type) SetDLL_MDINC(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetDLL_MDINC() uint32 {
	return volatile.LoadUint32(&o.DLL.Reg) & 0x1
}
func (o *EBI_Type) SetDLL_MDDEC(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x2)|value<<1)
}
func (o *EBI_Type) GetDLL_MDDEC() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0x2) >> 1
}
func (o *EBI_Type) SetDLL_MDOVF(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetDLL_MDOVF() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetDLL_MDVAL(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetDLL_MDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0xff00) >> 8
}

// EBI.HS: DDRSDRC High Speed Register
func (o *EBI_Type) SetHS_DIS_ANTICIP_READ(value uint32) {
	volatile.StoreUint32(&o.HS.Reg, volatile.LoadUint32(&o.HS.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetHS_DIS_ANTICIP_READ() uint32 {
	return (volatile.LoadUint32(&o.HS.Reg) & 0x4) >> 2
}

// EBI.DELAY: DDRSDRC Delay I/O Register
func (o *EBI_Type) SetDELAY_DELAY1(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetDELAY_DELAY1(idx int) uint32 {
	return volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf
}
func (o *EBI_Type) SetDELAY_DELAY2(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetDELAY_DELAY2(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetDELAY_DELAY3(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetDELAY_DELAY3(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetDELAY_DELAY4(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf000)|value<<12)
}
func (o *EBI_Type) GetDELAY_DELAY4(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf000) >> 12
}
func (o *EBI_Type) SetDELAY_DELAY5(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetDELAY_DELAY5(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetDELAY_DELAY6(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetDELAY_DELAY6(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf00000) >> 20
}
func (o *EBI_Type) SetDELAY_DELAY7(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetDELAY_DELAY7(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf000000) >> 24
}
func (o *EBI_Type) SetDELAY_DELAY8(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0000000)|value<<28)
}
func (o *EBI_Type) GetDELAY_DELAY8(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0000000) >> 28
}

// EBI.WPMR: DDRSDRC Write Protect Mode Register
func (o *EBI_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *EBI_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *EBI_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// EBI.WPSR: DDRSDRC Write Protect Status Register
func (o *EBI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *EBI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *EBI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// DDR_SDR SDRAM Controller 0
type DDRSDRC_Type struct {
	MR    volatile.Register32 // 0x0
	RTR   volatile.Register32 // 0x4
	CR    volatile.Register32 // 0x8
	TPR0  volatile.Register32 // 0xC
	TPR1  volatile.Register32 // 0x10
	TPR2  volatile.Register32 // 0x14
	_     [4]byte
	LPR   volatile.Register32 // 0x1C
	MD    volatile.Register32 // 0x20
	DLL   volatile.Register32 // 0x24
	_     [4]byte
	HS    volatile.Register32 // 0x2C
	_     [16]byte
	DELAY [4]volatile.Register32 // 0x40
	_     [148]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// DDRSDRC.MR: DDRSDRC Mode Register
func (o *DDRSDRC_Type) SetMR_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7)|value)
}
func (o *DDRSDRC_Type) GetMR_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x7
}

// DDRSDRC.RTR: DDRSDRC Refresh Timer Register
func (o *DDRSDRC_Type) SetRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0xfff)|value)
}
func (o *DDRSDRC_Type) GetRTR_COUNT() uint32 {
	return volatile.LoadUint32(&o.RTR.Reg) & 0xfff
}

// DDRSDRC.CR: DDRSDRC Configuration Register
func (o *DDRSDRC_Type) SetCR_NC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *DDRSDRC_Type) GetCR_NC() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *DDRSDRC_Type) SetCR_NR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc)|value<<2)
}
func (o *DDRSDRC_Type) GetCR_NR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc) >> 2
}
func (o *DDRSDRC_Type) SetCR_CAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70)|value<<4)
}
func (o *DDRSDRC_Type) GetCR_CAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70) >> 4
}
func (o *DDRSDRC_Type) SetCR_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DDRSDRC_Type) GetCR_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DDRSDRC_Type) SetCR_DIC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DDRSDRC_Type) GetCR_DIC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DDRSDRC_Type) SetCR_DIS_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DDRSDRC_Type) GetCR_DIS_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DDRSDRC_Type) SetCR_OCD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000)|value<<12)
}
func (o *DDRSDRC_Type) GetCR_OCD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000) >> 12
}
func (o *DDRSDRC_Type) SetCR_EBISHARE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DDRSDRC_Type) GetCR_EBISHARE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DDRSDRC_Type) SetCR_ACTBST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DDRSDRC_Type) GetCR_ACTBST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}

// DDRSDRC.TPR0: DDRSDRC Timing Parameter 0 Register
func (o *DDRSDRC_Type) SetTPR0_TRAS(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf)|value)
}
func (o *DDRSDRC_Type) GetTPR0_TRAS() uint32 {
	return volatile.LoadUint32(&o.TPR0.Reg) & 0xf
}
func (o *DDRSDRC_Type) SetTPR0_TRCD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0)|value<<4)
}
func (o *DDRSDRC_Type) GetTPR0_TRCD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0) >> 4
}
func (o *DDRSDRC_Type) SetTPR0_TWR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00)|value<<8)
}
func (o *DDRSDRC_Type) GetTPR0_TWR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00) >> 8
}
func (o *DDRSDRC_Type) SetTPR0_TRC(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf000)|value<<12)
}
func (o *DDRSDRC_Type) GetTPR0_TRC() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf000) >> 12
}
func (o *DDRSDRC_Type) SetTPR0_TRP(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000)|value<<16)
}
func (o *DDRSDRC_Type) GetTPR0_TRP() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000) >> 16
}
func (o *DDRSDRC_Type) SetTPR0_TRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00000)|value<<20)
}
func (o *DDRSDRC_Type) GetTPR0_TRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00000) >> 20
}
func (o *DDRSDRC_Type) SetTPR0_TWTR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x7000000)|value<<24)
}
func (o *DDRSDRC_Type) GetTPR0_TWTR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x7000000) >> 24
}
func (o *DDRSDRC_Type) SetTPR0_REDUCE_WRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *DDRSDRC_Type) GetTPR0_REDUCE_WRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x8000000) >> 27
}
func (o *DDRSDRC_Type) SetTPR0_TMRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *DDRSDRC_Type) GetTPR0_TMRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000000) >> 28
}

// DDRSDRC.TPR1: DDRSDRC Timing Parameter 1 Register
func (o *DDRSDRC_Type) SetTPR1_TRFC(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0x1f)|value)
}
func (o *DDRSDRC_Type) GetTPR1_TRFC() uint32 {
	return volatile.LoadUint32(&o.TPR1.Reg) & 0x1f
}
func (o *DDRSDRC_Type) SetTPR1_TXSNR(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff00)|value<<8)
}
func (o *DDRSDRC_Type) GetTPR1_TXSNR() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff00) >> 8
}
func (o *DDRSDRC_Type) SetTPR1_TXSRD(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *DDRSDRC_Type) GetTPR1_TXSRD() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff0000) >> 16
}
func (o *DDRSDRC_Type) SetTPR1_TXP(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xf000000)|value<<24)
}
func (o *DDRSDRC_Type) GetTPR1_TXP() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xf000000) >> 24
}

// DDRSDRC.TPR2: DDRSDRC Timing Parameter 2 Register
func (o *DDRSDRC_Type) SetTPR2_TXARD(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf)|value)
}
func (o *DDRSDRC_Type) GetTPR2_TXARD() uint32 {
	return volatile.LoadUint32(&o.TPR2.Reg) & 0xf
}
func (o *DDRSDRC_Type) SetTPR2_TXARDS(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0)|value<<4)
}
func (o *DDRSDRC_Type) GetTPR2_TXARDS() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0) >> 4
}
func (o *DDRSDRC_Type) SetTPR2_TRPA(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf00)|value<<8)
}
func (o *DDRSDRC_Type) GetTPR2_TRPA() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf00) >> 8
}
func (o *DDRSDRC_Type) SetTPR2_TRTP(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0x7000)|value<<12)
}
func (o *DDRSDRC_Type) GetTPR2_TRTP() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0x7000) >> 12
}

// DDRSDRC.LPR: DDRSDRC Low-power Register
func (o *DDRSDRC_Type) SetLPR_LPCB(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3)|value)
}
func (o *DDRSDRC_Type) GetLPR_LPCB() uint32 {
	return volatile.LoadUint32(&o.LPR.Reg) & 0x3
}
func (o *DDRSDRC_Type) SetLPR_CLK_FR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x4)|value<<2)
}
func (o *DDRSDRC_Type) GetLPR_CLK_FR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x4) >> 2
}
func (o *DDRSDRC_Type) SetLPR_PASR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x70)|value<<4)
}
func (o *DDRSDRC_Type) GetLPR_PASR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x70) >> 4
}
func (o *DDRSDRC_Type) SetLPR_TCR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300)|value<<8)
}
func (o *DDRSDRC_Type) GetLPR_TCR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300) >> 8
}
func (o *DDRSDRC_Type) SetLPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0xc00)|value<<10)
}
func (o *DDRSDRC_Type) GetLPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0xc00) >> 10
}
func (o *DDRSDRC_Type) SetLPR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3000)|value<<12)
}
func (o *DDRSDRC_Type) GetLPR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x3000) >> 12
}
func (o *DDRSDRC_Type) SetLPR_APDE(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x10000)|value<<16)
}
func (o *DDRSDRC_Type) GetLPR_APDE() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x10000) >> 16
}
func (o *DDRSDRC_Type) SetLPR_UPD_MR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300000)|value<<20)
}
func (o *DDRSDRC_Type) GetLPR_UPD_MR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300000) >> 20
}

// DDRSDRC.MD: DDRSDRC Memory Device Register
func (o *DDRSDRC_Type) SetMD(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x7)|value)
}
func (o *DDRSDRC_Type) GetMD() uint32 {
	return volatile.LoadUint32(&o.MD.Reg) & 0x7
}
func (o *DDRSDRC_Type) SetMD_DBW(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x10)|value<<4)
}
func (o *DDRSDRC_Type) GetMD_DBW() uint32 {
	return (volatile.LoadUint32(&o.MD.Reg) & 0x10) >> 4
}

// DDRSDRC.DLL: DDRSDRC DLL Information Register
func (o *DDRSDRC_Type) SetDLL_MDINC(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x1)|value)
}
func (o *DDRSDRC_Type) GetDLL_MDINC() uint32 {
	return volatile.LoadUint32(&o.DLL.Reg) & 0x1
}
func (o *DDRSDRC_Type) SetDLL_MDDEC(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x2)|value<<1)
}
func (o *DDRSDRC_Type) GetDLL_MDDEC() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0x2) >> 1
}
func (o *DDRSDRC_Type) SetDLL_MDOVF(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0x4)|value<<2)
}
func (o *DDRSDRC_Type) GetDLL_MDOVF() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0x4) >> 2
}
func (o *DDRSDRC_Type) SetDLL_MDVAL(value uint32) {
	volatile.StoreUint32(&o.DLL.Reg, volatile.LoadUint32(&o.DLL.Reg)&^(0xff00)|value<<8)
}
func (o *DDRSDRC_Type) GetDLL_MDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLL.Reg) & 0xff00) >> 8
}

// DDRSDRC.HS: DDRSDRC High Speed Register
func (o *DDRSDRC_Type) SetHS_DIS_ANTICIP_READ(value uint32) {
	volatile.StoreUint32(&o.HS.Reg, volatile.LoadUint32(&o.HS.Reg)&^(0x4)|value<<2)
}
func (o *DDRSDRC_Type) GetHS_DIS_ANTICIP_READ() uint32 {
	return (volatile.LoadUint32(&o.HS.Reg) & 0x4) >> 2
}

// DDRSDRC.DELAY: DDRSDRC Delay I/O Register
func (o *DDRSDRC_Type) SetDELAY_DELAY1(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf)|value)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY1(idx int) uint32 {
	return volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf
}
func (o *DDRSDRC_Type) SetDELAY_DELAY2(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0)|value<<4)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY2(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0) >> 4
}
func (o *DDRSDRC_Type) SetDELAY_DELAY3(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf00)|value<<8)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY3(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf00) >> 8
}
func (o *DDRSDRC_Type) SetDELAY_DELAY4(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf000)|value<<12)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY4(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf000) >> 12
}
func (o *DDRSDRC_Type) SetDELAY_DELAY5(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0000)|value<<16)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY5(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0000) >> 16
}
func (o *DDRSDRC_Type) SetDELAY_DELAY6(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf00000)|value<<20)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY6(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf00000) >> 20
}
func (o *DDRSDRC_Type) SetDELAY_DELAY7(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf000000)|value<<24)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY7(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf000000) >> 24
}
func (o *DDRSDRC_Type) SetDELAY_DELAY8(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAY[idx].Reg, volatile.LoadUint32(&o.DELAY[idx].Reg)&^(0xf0000000)|value<<28)
}
func (o *DDRSDRC_Type) GetDELAY_DELAY8(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAY[idx].Reg) & 0xf0000000) >> 28
}

// DDRSDRC.WPMR: DDRSDRC Write Protect Mode Register
func (o *DDRSDRC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *DDRSDRC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *DDRSDRC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DDRSDRC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// DDRSDRC.WPSR: DDRSDRC Write Protect Status Register
func (o *DDRSDRC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *DDRSDRC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *DDRSDRC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *DDRSDRC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Bus Matrix
type MATRIX_Type struct {
	MCFG  [11]volatile.Register32 // 0x0
	_     [20]byte
	SCFG  [8]volatile.Register32 // 0x40
	_     [32]byte
	PRAS0 volatile.Register32 // 0x80
	PRBS0 volatile.Register32 // 0x84
	PRAS1 volatile.Register32 // 0x88
	PRBS1 volatile.Register32 // 0x8C
	PRAS2 volatile.Register32 // 0x90
	PRBS2 volatile.Register32 // 0x94
	PRAS3 volatile.Register32 // 0x98
	PRBS3 volatile.Register32 // 0x9C
	PRAS4 volatile.Register32 // 0xA0
	PRBS4 volatile.Register32 // 0xA4
	PRAS5 volatile.Register32 // 0xA8
	PRBS5 volatile.Register32 // 0xAC
	PRAS6 volatile.Register32 // 0xB0
	PRBS6 volatile.Register32 // 0xB4
	PRAS7 volatile.Register32 // 0xB8
	PRBS7 volatile.Register32 // 0xBC
	_     [64]byte
	MRCR  volatile.Register32 // 0x100
	_     [224]byte
	WPMR  volatile.Register32 // 0x1E4
	WPSR  volatile.Register32 // 0x1E8
}

// MATRIX.MCFG: Master Configuration Register
func (o *MATRIX_Type) SetMCFG_ULBT(idx int, value uint32) {
	volatile.StoreUint32(&o.MCFG[idx].Reg, volatile.LoadUint32(&o.MCFG[idx].Reg)&^(0x7)|value)
}
func (o *MATRIX_Type) GetMCFG_ULBT(idx int) uint32 {
	return volatile.LoadUint32(&o.MCFG[idx].Reg) & 0x7
}

// MATRIX.SCFG: Slave Configuration Register
func (o *MATRIX_Type) SetSCFG_SLOT_CYCLE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x1ff)|value)
}
func (o *MATRIX_Type) GetSCFG_SLOT_CYCLE(idx int) uint32 {
	return volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x1ff
}
func (o *MATRIX_Type) SetSCFG_DEFMSTR_TYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetSCFG_DEFMSTR_TYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetSCFG_FIXED_DEFMSTR(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x3c0000)|value<<18)
}
func (o *MATRIX_Type) GetSCFG_FIXED_DEFMSTR(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x3c0000) >> 18
}

// MATRIX.PRAS0: Priority Register A for Slave 0
func (o *MATRIX_Type) SetPRAS0_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS0_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS0_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS0_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS0_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS0_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS0_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS0_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS0_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS0_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS0_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS0_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS0_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS0_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS0_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS0_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS0: Priority Register B for Slave 0
func (o *MATRIX_Type) SetPRBS0_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS0_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS0_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS0_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS0_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS0_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x300) >> 8
}

// MATRIX.PRAS1: Priority Register A for Slave 1
func (o *MATRIX_Type) SetPRAS1_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS1_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS1_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS1_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS1_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS1_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS1_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS1_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS1_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS1_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS1_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS1_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS1_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS1_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS1_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS1_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS1: Priority Register B for Slave 1
func (o *MATRIX_Type) SetPRBS1_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS1_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS1_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS1_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS1_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS1_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x300) >> 8
}

// MATRIX.PRAS2: Priority Register A for Slave 2
func (o *MATRIX_Type) SetPRAS2_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS2_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS2_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS2_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS2_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS2_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS2_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS2_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS2_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS2_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS2_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS2_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS2_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS2_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS2_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS2_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS2: Priority Register B for Slave 2
func (o *MATRIX_Type) SetPRBS2_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS2_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS2_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS2_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS2_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS2_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x300) >> 8
}

// MATRIX.PRAS3: Priority Register A for Slave 3
func (o *MATRIX_Type) SetPRAS3_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS3_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS3_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS3_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS3_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS3_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS3_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS3_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS3_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS3_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS3_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS3_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS3_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS3_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS3_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS3_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS3: Priority Register B for Slave 3
func (o *MATRIX_Type) SetPRBS3_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS3_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS3_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS3_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS3_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS3_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x300) >> 8
}

// MATRIX.PRAS4: Priority Register A for Slave 4
func (o *MATRIX_Type) SetPRAS4_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS4_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS4_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS4_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS4_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS4_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS4_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS4_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS4_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS4_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS4_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS4_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS4_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS4_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS4_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS4_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS4: Priority Register B for Slave 4
func (o *MATRIX_Type) SetPRBS4_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS4_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS4_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS4_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS4_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS4_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x300) >> 8
}

// MATRIX.PRAS5: Priority Register A for Slave 5
func (o *MATRIX_Type) SetPRAS5_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS5_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS5_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS5_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS5_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS5_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS5_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS5_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS5_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS5_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS5_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS5_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS5_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS5_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS5_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS5_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS5: Priority Register B for Slave 5
func (o *MATRIX_Type) SetPRBS5_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS5_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS5_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS5_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS5_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS5_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x300) >> 8
}

// MATRIX.PRAS6: Priority Register A for Slave 6
func (o *MATRIX_Type) SetPRAS6_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS6_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS6_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS6_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS6_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS6_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS6_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS6_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS6_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS6_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS6_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS6_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS6_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS6_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS6_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS6_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS6: Priority Register B for Slave 6
func (o *MATRIX_Type) SetPRBS6_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS6_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS6_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS6_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS6_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS6_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x300) >> 8
}

// MATRIX.PRAS7: Priority Register A for Slave 7
func (o *MATRIX_Type) SetPRAS7_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS7_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS7_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS7_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS7_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS7_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS7_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS7_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS7_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS7_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS7_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS7_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS7_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS7_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS7_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS7_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS7: Priority Register B for Slave 7
func (o *MATRIX_Type) SetPRBS7_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS7_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS7_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS7_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS7_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS7_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x300) >> 8
}

// MATRIX.MRCR: Master Remap Control Register
func (o *MATRIX_Type) SetMRCR_RCB0(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetMRCR_RCB0() uint32 {
	return volatile.LoadUint32(&o.MRCR.Reg) & 0x1
}
func (o *MATRIX_Type) SetMRCR_RCB1(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2)|value<<1)
}
func (o *MATRIX_Type) GetMRCR_RCB1() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2) >> 1
}
func (o *MATRIX_Type) SetMRCR_RCB2(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4)|value<<2)
}
func (o *MATRIX_Type) GetMRCR_RCB2() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4) >> 2
}
func (o *MATRIX_Type) SetMRCR_RCB3(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8)|value<<3)
}
func (o *MATRIX_Type) GetMRCR_RCB3() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8) >> 3
}
func (o *MATRIX_Type) SetMRCR_RCB4(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetMRCR_RCB4() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x10) >> 4
}
func (o *MATRIX_Type) SetMRCR_RCB5(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x20)|value<<5)
}
func (o *MATRIX_Type) GetMRCR_RCB5() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x20) >> 5
}
func (o *MATRIX_Type) SetMRCR_RCB6(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x40)|value<<6)
}
func (o *MATRIX_Type) GetMRCR_RCB6() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x40) >> 6
}
func (o *MATRIX_Type) SetMRCR_RCB7(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x80)|value<<7)
}
func (o *MATRIX_Type) GetMRCR_RCB7() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x80) >> 7
}
func (o *MATRIX_Type) SetMRCR_RCB8(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x100)|value<<8)
}
func (o *MATRIX_Type) GetMRCR_RCB8() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x100) >> 8
}
func (o *MATRIX_Type) SetMRCR_RCB9(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x200)|value<<9)
}
func (o *MATRIX_Type) GetMRCR_RCB9() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x200) >> 9
}
func (o *MATRIX_Type) SetMRCR_RCB10(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x400)|value<<10)
}
func (o *MATRIX_Type) GetMRCR_RCB10() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x400) >> 10
}

// MATRIX.WPMR: Write Protect Mode Register
func (o *MATRIX_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// MATRIX.WPSR: Write Protect Status Register
func (o *MATRIX_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// DMA Controller
type DMAC_Type struct {
	GCFG   volatile.Register32 // 0x0
	EN     volatile.Register32 // 0x4
	SREQ   volatile.Register32 // 0x8
	CREQ   volatile.Register32 // 0xC
	LAST   volatile.Register32 // 0x10
	_      [4]byte
	EBCIER volatile.Register32 // 0x18
	EBCIDR volatile.Register32 // 0x1C
	EBCIMR volatile.Register32 // 0x20
	EBCISR volatile.Register32 // 0x24
	CHER   volatile.Register32 // 0x28
	CHDR   volatile.Register32 // 0x2C
	CHSR   volatile.Register32 // 0x30
	_      [8]byte
	SADDR0 volatile.Register32 // 0x3C
	DADDR0 volatile.Register32 // 0x40
	DSCR0  volatile.Register32 // 0x44
	CTRLA0 volatile.Register32 // 0x48
	CTRLB0 volatile.Register32 // 0x4C
	CFG0   volatile.Register32 // 0x50
	_      [16]byte
	SADDR1 volatile.Register32 // 0x64
	DADDR1 volatile.Register32 // 0x68
	DSCR1  volatile.Register32 // 0x6C
	CTRLA1 volatile.Register32 // 0x70
	CTRLB1 volatile.Register32 // 0x74
	CFG1   volatile.Register32 // 0x78
	_      [16]byte
	SADDR2 volatile.Register32 // 0x8C
	DADDR2 volatile.Register32 // 0x90
	DSCR2  volatile.Register32 // 0x94
	CTRLA2 volatile.Register32 // 0x98
	CTRLB2 volatile.Register32 // 0x9C
	CFG2   volatile.Register32 // 0xA0
	_      [16]byte
	SADDR3 volatile.Register32 // 0xB4
	DADDR3 volatile.Register32 // 0xB8
	DSCR3  volatile.Register32 // 0xBC
	CTRLA3 volatile.Register32 // 0xC0
	CTRLB3 volatile.Register32 // 0xC4
	CFG3   volatile.Register32 // 0xC8
	_      [16]byte
	SADDR4 volatile.Register32 // 0xDC
	DADDR4 volatile.Register32 // 0xE0
	DSCR4  volatile.Register32 // 0xE4
	CTRLA4 volatile.Register32 // 0xE8
	CTRLB4 volatile.Register32 // 0xEC
	CFG4   volatile.Register32 // 0xF0
	_      [16]byte
	SADDR5 volatile.Register32 // 0x104
	DADDR5 volatile.Register32 // 0x108
	DSCR5  volatile.Register32 // 0x10C
	CTRLA5 volatile.Register32 // 0x110
	CTRLB5 volatile.Register32 // 0x114
	CFG5   volatile.Register32 // 0x118
	_      [16]byte
	SADDR6 volatile.Register32 // 0x12C
	DADDR6 volatile.Register32 // 0x130
	DSCR6  volatile.Register32 // 0x134
	CTRLA6 volatile.Register32 // 0x138
	CTRLB6 volatile.Register32 // 0x13C
	CFG6   volatile.Register32 // 0x140
	_      [16]byte
	SADDR7 volatile.Register32 // 0x154
	DADDR7 volatile.Register32 // 0x158
	DSCR7  volatile.Register32 // 0x15C
	CTRLA7 volatile.Register32 // 0x160
	CTRLB7 volatile.Register32 // 0x164
	CFG7   volatile.Register32 // 0x168
	_      [120]byte
	WPMR   volatile.Register32 // 0x1E4
	WPSR   volatile.Register32 // 0x1E8
}

// DMAC.GCFG: DMAC Global Configuration Register
func (o *DMAC_Type) SetGCFG_ARB_CFG(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetGCFG_ARB_CFG() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x10) >> 4
}

// DMAC.EN: DMAC Enable Register
func (o *DMAC_Type) SetEN_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEN_ENABLE() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// DMAC.SREQ: DMAC Software Single Request Register
func (o *DMAC_Type) SetSREQ_SSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetSREQ_SSREQ0() uint32 {
	return volatile.LoadUint32(&o.SREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetSREQ_DSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetSREQ_DSREQ0() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetSREQ_SSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetSREQ_SSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetSREQ_DSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetSREQ_DSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetSREQ_SSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetSREQ_SSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetSREQ_DSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetSREQ_DSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetSREQ_SSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetSREQ_SSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetSREQ_DSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetSREQ_DSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetSREQ_SSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetSREQ_SSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetSREQ_DSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetSREQ_DSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetSREQ_SSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetSREQ_SSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetSREQ_DSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetSREQ_DSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetSREQ_SSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetSREQ_SSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetSREQ_DSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetSREQ_DSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetSREQ_SSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetSREQ_SSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetSREQ_DSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetSREQ_DSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8000) >> 15
}

// DMAC.CREQ: DMAC Software Chunk Transfer Request Register
func (o *DMAC_Type) SetCREQ_SCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCREQ_SCREQ0() uint32 {
	return volatile.LoadUint32(&o.CREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetCREQ_DCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCREQ_DCREQ0() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCREQ_SCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCREQ_SCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCREQ_DCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCREQ_DCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCREQ_SCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCREQ_SCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCREQ_DCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCREQ_DCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCREQ_SCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCREQ_SCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCREQ_DCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCREQ_DCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCREQ_SCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCREQ_SCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCREQ_DCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCREQ_DCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCREQ_SCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCREQ_SCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCREQ_DCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCREQ_DCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCREQ_SCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCREQ_SCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCREQ_DCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCREQ_DCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCREQ_SCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCREQ_SCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCREQ_DCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCREQ_DCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8000) >> 15
}

// DMAC.LAST: DMAC Software Last Transfer Flag Register
func (o *DMAC_Type) SetLAST_SLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetLAST_SLAST0() uint32 {
	return volatile.LoadUint32(&o.LAST.Reg) & 0x1
}
func (o *DMAC_Type) SetLAST_DLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetLAST_DLAST0() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetLAST_SLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetLAST_SLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetLAST_DLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetLAST_DLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetLAST_SLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetLAST_SLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetLAST_DLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetLAST_DLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetLAST_SLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetLAST_SLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetLAST_DLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetLAST_DLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetLAST_SLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetLAST_SLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetLAST_DLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetLAST_DLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetLAST_SLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetLAST_SLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetLAST_DLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetLAST_DLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetLAST_SLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetLAST_SLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetLAST_DLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetLAST_DLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetLAST_SLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetLAST_SLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetLAST_DLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetLAST_DLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8000) >> 15
}

// DMAC.EBCIER: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Enable register.
func (o *DMAC_Type) SetEBCIER_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIER_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIER.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIER_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIER_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIER_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIER_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIER_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIER_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIER_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIER_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIER_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIER_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIER_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIER_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIER_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIER_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIER_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIER_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIER_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIER_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIER_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIER_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIER_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIER_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIER_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIER_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIER_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIER_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIER_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIER_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIER_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIER_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIER_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIER_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIER_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIER_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIER_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIER_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIER_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIER_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIER_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIER_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIER_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIER_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIER_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIER_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIER_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIER_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800000) >> 23
}

// DMAC.EBCIDR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Disable register.
func (o *DMAC_Type) SetEBCIDR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIDR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIDR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIDR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIDR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIDR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIDR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIDR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIDR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIDR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIDR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIDR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIDR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIDR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIDR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIDR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIDR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIDR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIDR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIDR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIDR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIDR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIDR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIDR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIDR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIDR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIDR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIDR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIDR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIDR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIDR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIDR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIDR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIDR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIDR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIDR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIDR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIDR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIDR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIDR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIDR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIDR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIDR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIDR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIDR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIDR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIDR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIDR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800000) >> 23
}

// DMAC.EBCIMR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Mask Register.
func (o *DMAC_Type) SetEBCIMR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIMR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIMR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIMR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIMR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIMR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIMR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIMR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIMR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIMR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIMR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIMR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIMR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIMR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIMR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIMR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIMR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIMR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIMR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIMR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIMR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIMR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIMR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIMR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIMR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIMR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIMR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIMR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIMR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIMR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIMR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIMR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIMR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIMR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIMR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIMR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIMR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIMR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIMR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIMR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIMR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIMR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIMR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIMR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIMR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIMR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIMR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIMR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800000) >> 23
}

// DMAC.EBCISR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Status Register.
func (o *DMAC_Type) SetEBCISR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCISR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCISR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCISR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCISR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCISR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCISR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCISR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCISR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCISR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCISR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCISR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCISR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCISR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCISR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCISR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCISR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCISR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCISR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCISR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCISR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCISR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCISR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCISR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCISR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCISR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCISR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCISR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCISR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCISR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCISR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCISR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCISR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCISR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCISR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCISR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCISR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCISR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCISR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCISR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCISR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCISR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCISR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCISR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCISR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCISR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCISR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCISR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCISR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800000) >> 23
}

// DMAC.CHER: DMAC Channel Handler Enable Register
func (o *DMAC_Type) SetCHER_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHER_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *DMAC_Type) SetCHER_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHER_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHER_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHER_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHER_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHER_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHER_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHER_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHER_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHER_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHER_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHER_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHER_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHER_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHER_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHER_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHER_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHER_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHER_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHER_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHER_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHER_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHER_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHER_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHER_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHER_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHER_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHER_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHER_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHER_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHER_KEEP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHER_KEEP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHER_KEEP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHER_KEEP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHER_KEEP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHER_KEEP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHER_KEEP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHER_KEEP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHER_KEEP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHER_KEEP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHER_KEEP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHER_KEEP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHER_KEEP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHER_KEEP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHER_KEEP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHER_KEEP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80000000) >> 31
}

// DMAC.CHDR: DMAC Channel Handler Disable Register
func (o *DMAC_Type) SetCHDR_DIS0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHDR_DIS0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHDR_DIS1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHDR_DIS1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHDR_DIS2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHDR_DIS2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHDR_DIS3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHDR_DIS3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHDR_DIS4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHDR_DIS4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHDR_DIS5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHDR_DIS5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHDR_DIS6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHDR_DIS6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHDR_DIS7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHDR_DIS7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHDR_RES0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHDR_RES0() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHDR_RES1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHDR_RES1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHDR_RES2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHDR_RES2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHDR_RES3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHDR_RES3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHDR_RES4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHDR_RES4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHDR_RES5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHDR_RES5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHDR_RES6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHDR_RES6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHDR_RES7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHDR_RES7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8000) >> 15
}

// DMAC.CHSR: DMAC Channel Handler Status Register
func (o *DMAC_Type) SetCHSR_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHSR_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHSR_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHSR_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHSR_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHSR_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHSR_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHSR_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHSR_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHSR_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHSR_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHSR_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHSR_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHSR_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHSR_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHSR_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHSR_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHSR_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHSR_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHSR_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHSR_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHSR_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHSR_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHSR_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHSR_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHSR_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHSR_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHSR_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHSR_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHSR_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHSR_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHSR_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHSR_EMPT0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCHSR_EMPT0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCHSR_EMPT1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetCHSR_EMPT1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetCHSR_EMPT2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetCHSR_EMPT2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetCHSR_EMPT3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetCHSR_EMPT3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetCHSR_EMPT4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCHSR_EMPT4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCHSR_EMPT5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCHSR_EMPT5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCHSR_EMPT6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCHSR_EMPT6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCHSR_EMPT7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetCHSR_EMPT7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetCHSR_STAL0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHSR_STAL0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHSR_STAL1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHSR_STAL1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHSR_STAL2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHSR_STAL2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHSR_STAL3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHSR_STAL3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHSR_STAL4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHSR_STAL4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHSR_STAL5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHSR_STAL5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHSR_STAL6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHSR_STAL6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHSR_STAL7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHSR_STAL7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000000) >> 31
}

// DMAC.SADDR0: DMAC Channel Source Address Register (ch_num = 0)
func (o *DMAC_Type) SetSADDR0(value uint32) {
	volatile.StoreUint32(&o.SADDR0.Reg, value)
}
func (o *DMAC_Type) GetSADDR0() uint32 {
	return volatile.LoadUint32(&o.SADDR0.Reg)
}

// DMAC.DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
func (o *DMAC_Type) SetDADDR0(value uint32) {
	volatile.StoreUint32(&o.DADDR0.Reg, value)
}
func (o *DMAC_Type) GetDADDR0() uint32 {
	return volatile.LoadUint32(&o.DADDR0.Reg)
}

// DMAC.DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
func (o *DMAC_Type) SetDSCR0_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR0_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR0.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR0_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR0_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR0.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA0: DMAC Channel Control A Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLA0_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA0_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA0.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA0_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA0_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA0_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA0_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA0_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA0_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA0_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA0_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA0_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA0_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB0: DMAC Channel Control B Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLB0_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB0_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB0_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB0_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB0_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB0_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB0_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB0_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB0_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB0_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB0_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB0_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB0_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB0_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB0_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB0_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB0_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB0_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x80000000) >> 31
}

// DMAC.CFG0: DMAC Channel Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetCFG0_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG0_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG0.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG0_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG0_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG0_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG0_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG0_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG0_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG0_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG0_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG0_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG0_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG0_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG0_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG0_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG0_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG0_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG0_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG0_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG0_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG0_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG0_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR1: DMAC Channel Source Address Register (ch_num = 1)
func (o *DMAC_Type) SetSADDR1(value uint32) {
	volatile.StoreUint32(&o.SADDR1.Reg, value)
}
func (o *DMAC_Type) GetSADDR1() uint32 {
	return volatile.LoadUint32(&o.SADDR1.Reg)
}

// DMAC.DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
func (o *DMAC_Type) SetDADDR1(value uint32) {
	volatile.StoreUint32(&o.DADDR1.Reg, value)
}
func (o *DMAC_Type) GetDADDR1() uint32 {
	return volatile.LoadUint32(&o.DADDR1.Reg)
}

// DMAC.DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
func (o *DMAC_Type) SetDSCR1_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR1_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR1.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR1_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR1_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR1.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA1: DMAC Channel Control A Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLA1_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA1_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA1.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA1_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA1_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA1_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA1_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA1_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA1_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA1_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA1_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA1_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA1_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB1: DMAC Channel Control B Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLB1_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB1_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB1_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB1_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB1_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB1_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB1_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB1_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB1_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB1_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB1_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB1_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB1_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB1_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB1_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB1_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB1_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB1_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x80000000) >> 31
}

// DMAC.CFG1: DMAC Channel Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetCFG1_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG1_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG1_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG1_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG1_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG1_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG1_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG1_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG1_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG1_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG1_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG1_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG1_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG1_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG1_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG1_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG1_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG1_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG1_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG1_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG1_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR2: DMAC Channel Source Address Register (ch_num = 2)
func (o *DMAC_Type) SetSADDR2(value uint32) {
	volatile.StoreUint32(&o.SADDR2.Reg, value)
}
func (o *DMAC_Type) GetSADDR2() uint32 {
	return volatile.LoadUint32(&o.SADDR2.Reg)
}

// DMAC.DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
func (o *DMAC_Type) SetDADDR2(value uint32) {
	volatile.StoreUint32(&o.DADDR2.Reg, value)
}
func (o *DMAC_Type) GetDADDR2() uint32 {
	return volatile.LoadUint32(&o.DADDR2.Reg)
}

// DMAC.DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
func (o *DMAC_Type) SetDSCR2_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR2_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR2.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR2_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR2_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR2.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA2: DMAC Channel Control A Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLA2_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA2_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA2.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA2_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA2_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA2_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA2_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA2_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA2_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA2_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA2_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA2_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA2_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB2: DMAC Channel Control B Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLB2_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB2_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB2_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB2_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB2_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB2_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB2_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB2_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB2_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB2_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB2_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB2_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB2_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB2_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB2_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB2_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB2_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB2_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x80000000) >> 31
}

// DMAC.CFG2: DMAC Channel Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetCFG2_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG2_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG2_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG2_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG2_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG2_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG2_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG2_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG2_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG2_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG2_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG2_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG2_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG2_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG2_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG2_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG2_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG2_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG2_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG2_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG2_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG2_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR3: DMAC Channel Source Address Register (ch_num = 3)
func (o *DMAC_Type) SetSADDR3(value uint32) {
	volatile.StoreUint32(&o.SADDR3.Reg, value)
}
func (o *DMAC_Type) GetSADDR3() uint32 {
	return volatile.LoadUint32(&o.SADDR3.Reg)
}

// DMAC.DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
func (o *DMAC_Type) SetDADDR3(value uint32) {
	volatile.StoreUint32(&o.DADDR3.Reg, value)
}
func (o *DMAC_Type) GetDADDR3() uint32 {
	return volatile.LoadUint32(&o.DADDR3.Reg)
}

// DMAC.DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
func (o *DMAC_Type) SetDSCR3_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR3_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR3.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR3_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR3_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR3.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA3: DMAC Channel Control A Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLA3_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA3_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA3.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA3_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA3_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA3_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA3_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA3_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA3_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA3_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA3_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA3_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA3_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB3: DMAC Channel Control B Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLB3_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB3_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB3_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB3_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB3_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB3_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB3_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB3_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB3_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB3_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB3_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB3_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB3_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB3_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB3_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB3_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB3_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB3_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x80000000) >> 31
}

// DMAC.CFG3: DMAC Channel Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetCFG3_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG3_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG3.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG3_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG3_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG3_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG3_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG3_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG3_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG3_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG3_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG3_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG3_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG3_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG3_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG3_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG3_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG3_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG3_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG3_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG3_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG3_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG3_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR4: DMAC Channel Source Address Register (ch_num = 4)
func (o *DMAC_Type) SetSADDR4(value uint32) {
	volatile.StoreUint32(&o.SADDR4.Reg, value)
}
func (o *DMAC_Type) GetSADDR4() uint32 {
	return volatile.LoadUint32(&o.SADDR4.Reg)
}

// DMAC.DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
func (o *DMAC_Type) SetDADDR4(value uint32) {
	volatile.StoreUint32(&o.DADDR4.Reg, value)
}
func (o *DMAC_Type) GetDADDR4() uint32 {
	return volatile.LoadUint32(&o.DADDR4.Reg)
}

// DMAC.DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
func (o *DMAC_Type) SetDSCR4_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR4_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR4.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR4_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR4_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR4.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA4: DMAC Channel Control A Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLA4_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA4_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA4.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA4_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA4_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA4_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA4_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA4_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA4_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA4_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA4_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA4_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA4_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB4: DMAC Channel Control B Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLB4_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB4_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB4_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB4_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB4_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB4_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB4_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB4_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB4_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB4_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB4_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB4_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB4_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB4_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB4_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB4_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB4_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB4_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x80000000) >> 31
}

// DMAC.CFG4: DMAC Channel Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetCFG4_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG4_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG4.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG4_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG4_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG4_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG4_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG4_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG4_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG4_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG4_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG4_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG4_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG4_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG4_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG4_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG4_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG4_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG4_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG4_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG4_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG4_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG4_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR5: DMAC Channel Source Address Register (ch_num = 5)
func (o *DMAC_Type) SetSADDR5(value uint32) {
	volatile.StoreUint32(&o.SADDR5.Reg, value)
}
func (o *DMAC_Type) GetSADDR5() uint32 {
	return volatile.LoadUint32(&o.SADDR5.Reg)
}

// DMAC.DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
func (o *DMAC_Type) SetDADDR5(value uint32) {
	volatile.StoreUint32(&o.DADDR5.Reg, value)
}
func (o *DMAC_Type) GetDADDR5() uint32 {
	return volatile.LoadUint32(&o.DADDR5.Reg)
}

// DMAC.DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
func (o *DMAC_Type) SetDSCR5_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR5_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR5.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR5_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR5_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR5.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA5: DMAC Channel Control A Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLA5_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA5_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA5.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA5_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA5_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA5_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA5_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA5_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA5_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA5_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA5_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA5_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA5_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB5: DMAC Channel Control B Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLB5_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB5_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB5_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB5_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB5_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB5_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB5_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB5_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB5_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB5_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB5_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB5_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB5_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB5_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB5_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB5_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB5_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB5_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x80000000) >> 31
}

// DMAC.CFG5: DMAC Channel Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetCFG5_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG5_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG5.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG5_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG5_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG5_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG5_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG5_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG5_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG5_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG5_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG5_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG5_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG5_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG5_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG5_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG5_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG5_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG5_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG5_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG5_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG5_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG5_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR6: DMAC Channel Source Address Register (ch_num = 6)
func (o *DMAC_Type) SetSADDR6(value uint32) {
	volatile.StoreUint32(&o.SADDR6.Reg, value)
}
func (o *DMAC_Type) GetSADDR6() uint32 {
	return volatile.LoadUint32(&o.SADDR6.Reg)
}

// DMAC.DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
func (o *DMAC_Type) SetDADDR6(value uint32) {
	volatile.StoreUint32(&o.DADDR6.Reg, value)
}
func (o *DMAC_Type) GetDADDR6() uint32 {
	return volatile.LoadUint32(&o.DADDR6.Reg)
}

// DMAC.DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
func (o *DMAC_Type) SetDSCR6_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR6_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR6.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR6_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR6_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR6.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA6: DMAC Channel Control A Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLA6_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA6_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA6.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA6_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA6_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA6_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA6_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA6_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA6_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA6_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA6_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA6_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA6_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB6: DMAC Channel Control B Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLB6_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB6_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB6_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB6_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB6_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB6_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB6_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB6_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB6_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB6_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB6_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB6_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB6_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB6_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB6_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB6_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB6_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB6_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x80000000) >> 31
}

// DMAC.CFG6: DMAC Channel Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetCFG6_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG6_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG6.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG6_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG6_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG6_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG6_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG6_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG6_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG6_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG6_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG6_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG6_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG6_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG6_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG6_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG6_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG6_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG6_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG6_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG6_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG6_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG6_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x30000000) >> 28
}

// DMAC.SADDR7: DMAC Channel Source Address Register (ch_num = 7)
func (o *DMAC_Type) SetSADDR7(value uint32) {
	volatile.StoreUint32(&o.SADDR7.Reg, value)
}
func (o *DMAC_Type) GetSADDR7() uint32 {
	return volatile.LoadUint32(&o.SADDR7.Reg)
}

// DMAC.DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
func (o *DMAC_Type) SetDADDR7(value uint32) {
	volatile.StoreUint32(&o.DADDR7.Reg, value)
}
func (o *DMAC_Type) GetDADDR7() uint32 {
	return volatile.LoadUint32(&o.DADDR7.Reg)
}

// DMAC.DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
func (o *DMAC_Type) SetDSCR7_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR7_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR7.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR7_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR7_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR7.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA7: DMAC Channel Control A Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLA7_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA7_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA7.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA7_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA7_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA7_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA7_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA7_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA7_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA7_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA7_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA7_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA7_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB7: DMAC Channel Control B Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLB7_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB7_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB7_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB7_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB7_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB7_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB7_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB7_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB7_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0xe00000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB7_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0xe00000) >> 21
}
func (o *DMAC_Type) SetCTRLB7_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB7_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB7_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB7_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB7_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB7_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB7_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB7_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x80000000) >> 31
}

// DMAC.CFG7: DMAC Channel Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetCFG7_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG7_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG7.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG7_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG7_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG7_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG7_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG7_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG7_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG7_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG7_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG7_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG7_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG7_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG7_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG7_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG7_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG7_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG7_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG7_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG7_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG7_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG7_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x30000000) >> 28
}

// DMAC.WPMR: Write Protect Mode Register
func (o *DMAC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DMAC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// DMAC.WPSR: Write Protect Status Register
func (o *DMAC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *DMAC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Debug Unit
type DBGU_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	_    [28]byte
	CIDR volatile.Register32 // 0x40
	EXID volatile.Register32 // 0x44
	FNR  volatile.Register32 // 0x48
	_    [180]byte
	RPR  volatile.Register32 // 0x100
	RCR  volatile.Register32 // 0x104
	TPR  volatile.Register32 // 0x108
	TCR  volatile.Register32 // 0x10C
	RNPR volatile.Register32 // 0x110
	RNCR volatile.Register32 // 0x114
	TNPR volatile.Register32 // 0x118
	TNCR volatile.Register32 // 0x11C
	PTCR volatile.Register32 // 0x120
	PTSR volatile.Register32 // 0x124
}

// DBGU.CR: Control Register
func (o *DBGU_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGU_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGU_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DBGU_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// DBGU.MR: Mode Register
func (o *DBGU_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *DBGU_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *DBGU_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *DBGU_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// DBGU.IER: Interrupt Enable Register
func (o *DBGU_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *DBGU_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIER_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetIER_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetIER_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetIER_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIER_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *DBGU_Type) GetIER_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *DBGU_Type) SetIER_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *DBGU_Type) GetIER_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *DBGU_Type) SetIER_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIER_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIER_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIER_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// DBGU.IDR: Interrupt Disable Register
func (o *DBGU_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *DBGU_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIDR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetIDR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetIDR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetIDR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIDR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *DBGU_Type) GetIDR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *DBGU_Type) SetIDR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *DBGU_Type) GetIDR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *DBGU_Type) SetIDR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIDR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIDR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIDR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// DBGU.IMR: Interrupt Mask Register
func (o *DBGU_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *DBGU_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIMR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetIMR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetIMR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetIMR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIMR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *DBGU_Type) GetIMR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *DBGU_Type) SetIMR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *DBGU_Type) GetIMR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *DBGU_Type) SetIMR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIMR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIMR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIMR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// DBGU.SR: Status Register
func (o *DBGU_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *DBGU_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetSR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetSR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetSR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetSR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetSR_TXBUFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *DBGU_Type) GetSR_TXBUFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *DBGU_Type) SetSR_RXBUFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *DBGU_Type) GetSR_RXBUFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *DBGU_Type) SetSR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetSR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetSR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetSR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DBGU.RHR: Receive Holding Register
func (o *DBGU_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// DBGU.THR: Transmit Holding Register
func (o *DBGU_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// DBGU.BRGR: Baud Rate Generator Register
func (o *DBGU_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// DBGU.CIDR: Chip ID Register
func (o *DBGU_Type) SetCIDR_VERSION(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x1f)|value)
}
func (o *DBGU_Type) GetCIDR_VERSION() uint32 {
	return volatile.LoadUint32(&o.CIDR.Reg) & 0x1f
}
func (o *DBGU_Type) SetCIDR_EPROC(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xe0)|value<<5)
}
func (o *DBGU_Type) GetCIDR_EPROC() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xe0) >> 5
}
func (o *DBGU_Type) SetCIDR_NVPSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf00)|value<<8)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf00) >> 8
}
func (o *DBGU_Type) SetCIDR_NVPSIZ2(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf000)|value<<12)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ2() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf000) >> 12
}
func (o *DBGU_Type) SetCIDR_SRAMSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf0000)|value<<16)
}
func (o *DBGU_Type) GetCIDR_SRAMSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf0000) >> 16
}
func (o *DBGU_Type) SetCIDR_ARCH(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xff00000)|value<<20)
}
func (o *DBGU_Type) GetCIDR_ARCH() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xff00000) >> 20
}
func (o *DBGU_Type) SetCIDR_NVPTYP(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x70000000)|value<<28)
}
func (o *DBGU_Type) GetCIDR_NVPTYP() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x70000000) >> 28
}
func (o *DBGU_Type) SetCIDR_EXT(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetCIDR_EXT() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x80000000) >> 31
}

// DBGU.EXID: Chip ID Extension Register
func (o *DBGU_Type) SetEXID(value uint32) {
	volatile.StoreUint32(&o.EXID.Reg, value)
}
func (o *DBGU_Type) GetEXID() uint32 {
	return volatile.LoadUint32(&o.EXID.Reg)
}

// DBGU.FNR: Force NTRST Register
func (o *DBGU_Type) SetFNR_FNTRST(value uint32) {
	volatile.StoreUint32(&o.FNR.Reg, volatile.LoadUint32(&o.FNR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetFNR_FNTRST() uint32 {
	return volatile.LoadUint32(&o.FNR.Reg) & 0x1
}

// DBGU.RPR: Receive Pointer Register
func (o *DBGU_Type) SetRPR(value uint32) {
	volatile.StoreUint32(&o.RPR.Reg, value)
}
func (o *DBGU_Type) GetRPR() uint32 {
	return volatile.LoadUint32(&o.RPR.Reg)
}

// DBGU.RCR: Receive Counter Register
func (o *DBGU_Type) SetRCR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetRCR_RXCTR() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xffff
}

// DBGU.TPR: Transmit Pointer Register
func (o *DBGU_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, value)
}
func (o *DBGU_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg)
}

// DBGU.TCR: Transmit Counter Register
func (o *DBGU_Type) SetTCR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetTCR_TXCTR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xffff
}

// DBGU.RNPR: Receive Next Pointer Register
func (o *DBGU_Type) SetRNPR(value uint32) {
	volatile.StoreUint32(&o.RNPR.Reg, value)
}
func (o *DBGU_Type) GetRNPR() uint32 {
	return volatile.LoadUint32(&o.RNPR.Reg)
}

// DBGU.RNCR: Receive Next Counter Register
func (o *DBGU_Type) SetRNCR_RXNCTR(value uint32) {
	volatile.StoreUint32(&o.RNCR.Reg, volatile.LoadUint32(&o.RNCR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetRNCR_RXNCTR() uint32 {
	return volatile.LoadUint32(&o.RNCR.Reg) & 0xffff
}

// DBGU.TNPR: Transmit Next Pointer Register
func (o *DBGU_Type) SetTNPR(value uint32) {
	volatile.StoreUint32(&o.TNPR.Reg, value)
}
func (o *DBGU_Type) GetTNPR() uint32 {
	return volatile.LoadUint32(&o.TNPR.Reg)
}

// DBGU.TNCR: Transmit Next Counter Register
func (o *DBGU_Type) SetTNCR_TXNCTR(value uint32) {
	volatile.StoreUint32(&o.TNCR.Reg, volatile.LoadUint32(&o.TNCR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetTNCR_TXNCTR() uint32 {
	return volatile.LoadUint32(&o.TNCR.Reg) & 0xffff
}

// DBGU.PTCR: Transfer Control Register
func (o *DBGU_Type) SetPTCR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetPTCR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTCR.Reg) & 0x1
}
func (o *DBGU_Type) SetPTCR_RXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetPTCR_RXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetPTCR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x100)|value<<8)
}
func (o *DBGU_Type) GetPTCR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x100) >> 8
}
func (o *DBGU_Type) SetPTCR_TXTDIS(value uint32) {
	volatile.StoreUint32(&o.PTCR.Reg, volatile.LoadUint32(&o.PTCR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetPTCR_TXTDIS() uint32 {
	return (volatile.LoadUint32(&o.PTCR.Reg) & 0x200) >> 9
}

// DBGU.PTSR: Transfer Status Register
func (o *DBGU_Type) SetPTSR_RXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetPTSR_RXTEN() uint32 {
	return volatile.LoadUint32(&o.PTSR.Reg) & 0x1
}
func (o *DBGU_Type) SetPTSR_TXTEN(value uint32) {
	volatile.StoreUint32(&o.PTSR.Reg, volatile.LoadUint32(&o.PTSR.Reg)&^(0x100)|value<<8)
}
func (o *DBGU_Type) GetPTSR_TXTEN() uint32 {
	return (volatile.LoadUint32(&o.PTSR.Reg) & 0x100) >> 8
}

// Advanced Interrupt Controller
type AIC_Type struct {
	SMR   [32]volatile.Register32 // 0x0
	SVR   [32]volatile.Register32 // 0x80
	IVR   volatile.Register32     // 0x100
	FVR   volatile.Register32     // 0x104
	ISR   volatile.Register32     // 0x108
	IPR   volatile.Register32     // 0x10C
	IMR   volatile.Register32     // 0x110
	CISR  volatile.Register32     // 0x114
	_     [8]byte
	IECR  volatile.Register32 // 0x120
	IDCR  volatile.Register32 // 0x124
	ICCR  volatile.Register32 // 0x128
	ISCR  volatile.Register32 // 0x12C
	EOICR volatile.Register32 // 0x130
	SPU   volatile.Register32 // 0x134
	DCR   volatile.Register32 // 0x138
	_     [4]byte
	FFER  volatile.Register32 // 0x140
	FFDR  volatile.Register32 // 0x144
	FFSR  volatile.Register32 // 0x148
}

// AIC.SMR: Source Mode Register
func (o *AIC_Type) SetSMR_PRIOR(idx int, value uint32) {
	volatile.StoreUint32(&o.SMR[idx].Reg, volatile.LoadUint32(&o.SMR[idx].Reg)&^(0x7)|value)
}
func (o *AIC_Type) GetSMR_PRIOR(idx int) uint32 {
	return volatile.LoadUint32(&o.SMR[idx].Reg) & 0x7
}
func (o *AIC_Type) SetSMR_SRCTYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.SMR[idx].Reg, volatile.LoadUint32(&o.SMR[idx].Reg)&^(0x60)|value<<5)
}
func (o *AIC_Type) GetSMR_SRCTYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.SMR[idx].Reg) & 0x60) >> 5
}

// AIC.SVR: Source Vector Register
func (o *AIC_Type) SetSVR(idx int, value uint32) {
	volatile.StoreUint32(&o.SVR[idx].Reg, value)
}
func (o *AIC_Type) GetSVR(idx int) uint32 {
	return volatile.LoadUint32(&o.SVR[idx].Reg)
}

// AIC.IVR: Interrupt Vector Register
func (o *AIC_Type) SetIVR(value uint32) {
	volatile.StoreUint32(&o.IVR.Reg, value)
}
func (o *AIC_Type) GetIVR() uint32 {
	return volatile.LoadUint32(&o.IVR.Reg)
}

// AIC.FVR: FIQ Interrupt Vector Register
func (o *AIC_Type) SetFVR(value uint32) {
	volatile.StoreUint32(&o.FVR.Reg, value)
}
func (o *AIC_Type) GetFVR() uint32 {
	return volatile.LoadUint32(&o.FVR.Reg)
}

// AIC.ISR: Interrupt Status Register
func (o *AIC_Type) SetISR_IRQID(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1f)|value)
}
func (o *AIC_Type) GetISR_IRQID() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1f
}

// AIC.IPR: Interrupt Pending Register
func (o *AIC_Type) SetIPR_FIQ(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR_FIQ() uint32 {
	return volatile.LoadUint32(&o.IPR.Reg) & 0x1
}
func (o *AIC_Type) SetIPR_SYS(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR_SYS() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR_PID2(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR_PID2() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR_PID3(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR_PID3() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR_PID4(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR_PID4() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR_PID5(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR_PID5() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR_PID6(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR_PID6() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR_PID7(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR_PID7() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR_PID8(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR_PID8() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR_PID9(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR_PID9() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR_PID10(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR_PID10() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR_PID11(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR_PID11() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR_PID12(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR_PID12() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR_PID13(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR_PID13() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR_PID14(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR_PID14() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR_PID15(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR_PID15() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR_PID16(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR_PID16() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR_PID17(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR_PID17() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR_PID18(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR_PID18() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR_PID19(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR_PID19() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR_PID20(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR_PID20() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR_PID21(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR_PID21() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR_PID22(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR_PID22() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR_PID23(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR_PID23() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR_PID24(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR_PID24() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR_PID25(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR_PID25() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR_PID26(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR_PID26() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR_PID27(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR_PID27() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR_PID28(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR_PID28() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR_PID29(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR_PID29() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR_PID30(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR_PID30() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR_PID31(value uint32) {
	volatile.StoreUint32(&o.IPR.Reg, volatile.LoadUint32(&o.IPR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR_PID31() uint32 {
	return (volatile.LoadUint32(&o.IPR.Reg) & 0x80000000) >> 31
}

// AIC.IMR: Interrupt Mask Register
func (o *AIC_Type) SetIMR_FIQ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIMR_FIQ() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *AIC_Type) SetIMR_SYS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIMR_SYS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIMR_PID2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIMR_PID2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIMR_PID3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIMR_PID3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIMR_PID4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIMR_PID4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIMR_PID5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIMR_PID5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIMR_PID6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIMR_PID6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIMR_PID7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIMR_PID7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIMR_PID8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIMR_PID8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIMR_PID9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIMR_PID9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIMR_PID10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIMR_PID10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIMR_PID11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIMR_PID11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIMR_PID12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIMR_PID12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIMR_PID13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIMR_PID13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIMR_PID14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIMR_PID14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIMR_PID15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIMR_PID15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIMR_PID16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIMR_PID16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIMR_PID17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIMR_PID17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIMR_PID18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIMR_PID18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIMR_PID19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIMR_PID19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIMR_PID20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIMR_PID20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIMR_PID21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIMR_PID21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIMR_PID22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIMR_PID22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIMR_PID23(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIMR_PID23() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIMR_PID24(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIMR_PID24() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIMR_PID25(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIMR_PID25() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIMR_PID26(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIMR_PID26() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIMR_PID27(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIMR_PID27() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIMR_PID28(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIMR_PID28() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIMR_PID29(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIMR_PID29() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIMR_PID30(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIMR_PID30() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIMR_PID31(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIMR_PID31() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// AIC.CISR: Core Interrupt Status Register
func (o *AIC_Type) SetCISR_NFIQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetCISR_NFIQ() uint32 {
	return volatile.LoadUint32(&o.CISR.Reg) & 0x1
}
func (o *AIC_Type) SetCISR_NIRQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetCISR_NIRQ() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x2) >> 1
}

// AIC.IECR: Interrupt Enable Command Register
func (o *AIC_Type) SetIECR_FIQ(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIECR_FIQ() uint32 {
	return volatile.LoadUint32(&o.IECR.Reg) & 0x1
}
func (o *AIC_Type) SetIECR_SYS(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIECR_SYS() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIECR_PID2(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIECR_PID2() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIECR_PID3(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIECR_PID3() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIECR_PID4(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIECR_PID4() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIECR_PID5(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIECR_PID5() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIECR_PID6(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIECR_PID6() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIECR_PID7(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIECR_PID7() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIECR_PID8(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIECR_PID8() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIECR_PID9(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIECR_PID9() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIECR_PID10(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIECR_PID10() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIECR_PID11(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIECR_PID11() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIECR_PID12(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIECR_PID12() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIECR_PID13(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIECR_PID13() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIECR_PID14(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIECR_PID14() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIECR_PID15(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIECR_PID15() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIECR_PID16(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIECR_PID16() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIECR_PID17(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIECR_PID17() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIECR_PID18(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIECR_PID18() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIECR_PID19(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIECR_PID19() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIECR_PID20(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIECR_PID20() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIECR_PID21(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIECR_PID21() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIECR_PID22(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIECR_PID22() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIECR_PID23(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIECR_PID23() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIECR_PID24(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIECR_PID24() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIECR_PID25(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIECR_PID25() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIECR_PID26(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIECR_PID26() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIECR_PID27(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIECR_PID27() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIECR_PID28(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIECR_PID28() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIECR_PID29(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIECR_PID29() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIECR_PID30(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIECR_PID30() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIECR_PID31(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIECR_PID31() uint32 {
	return (volatile.LoadUint32(&o.IECR.Reg) & 0x80000000) >> 31
}

// AIC.IDCR: Interrupt Disable Command Register
func (o *AIC_Type) SetIDCR_FIQ(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIDCR_FIQ() uint32 {
	return volatile.LoadUint32(&o.IDCR.Reg) & 0x1
}
func (o *AIC_Type) SetIDCR_SYS(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIDCR_SYS() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIDCR_PID2(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIDCR_PID2() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIDCR_PID3(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIDCR_PID3() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIDCR_PID4(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIDCR_PID4() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIDCR_PID5(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIDCR_PID5() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIDCR_PID6(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIDCR_PID6() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIDCR_PID7(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIDCR_PID7() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIDCR_PID8(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIDCR_PID8() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIDCR_PID9(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIDCR_PID9() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIDCR_PID10(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIDCR_PID10() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIDCR_PID11(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIDCR_PID11() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIDCR_PID12(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIDCR_PID12() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIDCR_PID13(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIDCR_PID13() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIDCR_PID14(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIDCR_PID14() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIDCR_PID15(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIDCR_PID15() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIDCR_PID16(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIDCR_PID16() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIDCR_PID17(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIDCR_PID17() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIDCR_PID18(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIDCR_PID18() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIDCR_PID19(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIDCR_PID19() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIDCR_PID20(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIDCR_PID20() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIDCR_PID21(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIDCR_PID21() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIDCR_PID22(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIDCR_PID22() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIDCR_PID23(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIDCR_PID23() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIDCR_PID24(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIDCR_PID24() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIDCR_PID25(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIDCR_PID25() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIDCR_PID26(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIDCR_PID26() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIDCR_PID27(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIDCR_PID27() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIDCR_PID28(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIDCR_PID28() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIDCR_PID29(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIDCR_PID29() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIDCR_PID30(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIDCR_PID30() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIDCR_PID31(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIDCR_PID31() uint32 {
	return (volatile.LoadUint32(&o.IDCR.Reg) & 0x80000000) >> 31
}

// AIC.ICCR: Interrupt Clear Command Register
func (o *AIC_Type) SetICCR_FIQ(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetICCR_FIQ() uint32 {
	return volatile.LoadUint32(&o.ICCR.Reg) & 0x1
}
func (o *AIC_Type) SetICCR_SYS(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetICCR_SYS() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetICCR_PID2(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetICCR_PID2() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetICCR_PID3(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetICCR_PID3() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetICCR_PID4(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetICCR_PID4() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetICCR_PID5(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetICCR_PID5() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetICCR_PID6(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetICCR_PID6() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetICCR_PID7(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetICCR_PID7() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetICCR_PID8(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetICCR_PID8() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetICCR_PID9(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetICCR_PID9() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetICCR_PID10(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetICCR_PID10() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetICCR_PID11(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetICCR_PID11() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetICCR_PID12(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetICCR_PID12() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetICCR_PID13(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetICCR_PID13() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetICCR_PID14(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetICCR_PID14() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetICCR_PID15(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetICCR_PID15() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetICCR_PID16(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetICCR_PID16() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetICCR_PID17(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetICCR_PID17() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetICCR_PID18(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetICCR_PID18() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetICCR_PID19(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetICCR_PID19() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetICCR_PID20(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetICCR_PID20() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetICCR_PID21(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetICCR_PID21() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetICCR_PID22(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetICCR_PID22() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetICCR_PID23(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetICCR_PID23() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetICCR_PID24(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetICCR_PID24() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetICCR_PID25(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetICCR_PID25() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetICCR_PID26(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetICCR_PID26() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetICCR_PID27(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetICCR_PID27() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetICCR_PID28(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetICCR_PID28() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetICCR_PID29(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetICCR_PID29() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetICCR_PID30(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetICCR_PID30() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetICCR_PID31(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetICCR_PID31() uint32 {
	return (volatile.LoadUint32(&o.ICCR.Reg) & 0x80000000) >> 31
}

// AIC.ISCR: Interrupt Set Command Register
func (o *AIC_Type) SetISCR_FIQ(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetISCR_FIQ() uint32 {
	return volatile.LoadUint32(&o.ISCR.Reg) & 0x1
}
func (o *AIC_Type) SetISCR_SYS(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetISCR_SYS() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetISCR_PID2(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetISCR_PID2() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetISCR_PID3(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetISCR_PID3() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetISCR_PID4(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetISCR_PID4() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetISCR_PID5(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetISCR_PID5() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetISCR_PID6(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetISCR_PID6() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetISCR_PID7(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetISCR_PID7() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetISCR_PID8(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetISCR_PID8() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetISCR_PID9(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetISCR_PID9() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetISCR_PID10(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetISCR_PID10() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetISCR_PID11(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetISCR_PID11() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetISCR_PID12(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetISCR_PID12() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetISCR_PID13(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetISCR_PID13() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetISCR_PID14(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetISCR_PID14() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetISCR_PID15(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetISCR_PID15() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetISCR_PID16(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetISCR_PID16() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetISCR_PID17(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetISCR_PID17() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetISCR_PID18(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetISCR_PID18() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetISCR_PID19(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetISCR_PID19() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetISCR_PID20(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetISCR_PID20() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetISCR_PID21(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetISCR_PID21() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetISCR_PID22(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetISCR_PID22() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetISCR_PID23(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetISCR_PID23() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetISCR_PID24(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetISCR_PID24() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetISCR_PID25(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetISCR_PID25() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetISCR_PID26(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetISCR_PID26() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetISCR_PID27(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetISCR_PID27() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetISCR_PID28(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetISCR_PID28() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetISCR_PID29(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetISCR_PID29() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetISCR_PID30(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetISCR_PID30() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetISCR_PID31(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetISCR_PID31() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x80000000) >> 31
}

// AIC.SPU: Spurious Interrupt Vector Register
func (o *AIC_Type) SetSPU(value uint32) {
	volatile.StoreUint32(&o.SPU.Reg, value)
}
func (o *AIC_Type) GetSPU() uint32 {
	return volatile.LoadUint32(&o.SPU.Reg)
}

// AIC.DCR: Debug Control Register
func (o *AIC_Type) SetDCR_PROT(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetDCR_PROT() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1
}
func (o *AIC_Type) SetDCR_GMSK(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetDCR_GMSK() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x2) >> 1
}

// AIC.FFER: Fast Forcing Enable Register
func (o *AIC_Type) SetFFER_SYS(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetFFER_SYS() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetFFER_PID2(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetFFER_PID2() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetFFER_PID3(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetFFER_PID3() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetFFER_PID4(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetFFER_PID4() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetFFER_PID5(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetFFER_PID5() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetFFER_PID6(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetFFER_PID6() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetFFER_PID7(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetFFER_PID7() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetFFER_PID8(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetFFER_PID8() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetFFER_PID9(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetFFER_PID9() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetFFER_PID10(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetFFER_PID10() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetFFER_PID11(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetFFER_PID11() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetFFER_PID12(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetFFER_PID12() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetFFER_PID13(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetFFER_PID13() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetFFER_PID14(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetFFER_PID14() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetFFER_PID15(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetFFER_PID15() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetFFER_PID16(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetFFER_PID16() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetFFER_PID17(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetFFER_PID17() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetFFER_PID18(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetFFER_PID18() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetFFER_PID19(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetFFER_PID19() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetFFER_PID20(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetFFER_PID20() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetFFER_PID21(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetFFER_PID21() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetFFER_PID22(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetFFER_PID22() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetFFER_PID23(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetFFER_PID23() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetFFER_PID24(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetFFER_PID24() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetFFER_PID25(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetFFER_PID25() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetFFER_PID26(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetFFER_PID26() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetFFER_PID27(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetFFER_PID27() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetFFER_PID28(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetFFER_PID28() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetFFER_PID29(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetFFER_PID29() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetFFER_PID30(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetFFER_PID30() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetFFER_PID31(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetFFER_PID31() uint32 {
	return (volatile.LoadUint32(&o.FFER.Reg) & 0x80000000) >> 31
}

// AIC.FFDR: Fast Forcing Disable Register
func (o *AIC_Type) SetFFDR_SYS(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetFFDR_SYS() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetFFDR_PID2(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetFFDR_PID2() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetFFDR_PID3(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetFFDR_PID3() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetFFDR_PID4(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetFFDR_PID4() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetFFDR_PID5(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetFFDR_PID5() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetFFDR_PID6(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetFFDR_PID6() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetFFDR_PID7(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetFFDR_PID7() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetFFDR_PID8(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetFFDR_PID8() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetFFDR_PID9(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetFFDR_PID9() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetFFDR_PID10(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetFFDR_PID10() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetFFDR_PID11(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetFFDR_PID11() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetFFDR_PID12(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetFFDR_PID12() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetFFDR_PID13(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetFFDR_PID13() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetFFDR_PID14(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetFFDR_PID14() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetFFDR_PID15(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetFFDR_PID15() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetFFDR_PID16(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetFFDR_PID16() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetFFDR_PID17(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetFFDR_PID17() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetFFDR_PID18(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetFFDR_PID18() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetFFDR_PID19(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetFFDR_PID19() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetFFDR_PID20(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetFFDR_PID20() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetFFDR_PID21(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetFFDR_PID21() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetFFDR_PID22(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetFFDR_PID22() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetFFDR_PID23(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetFFDR_PID23() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetFFDR_PID24(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetFFDR_PID24() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetFFDR_PID25(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetFFDR_PID25() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetFFDR_PID26(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetFFDR_PID26() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetFFDR_PID27(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetFFDR_PID27() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetFFDR_PID28(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetFFDR_PID28() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetFFDR_PID29(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetFFDR_PID29() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetFFDR_PID30(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetFFDR_PID30() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetFFDR_PID31(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetFFDR_PID31() uint32 {
	return (volatile.LoadUint32(&o.FFDR.Reg) & 0x80000000) >> 31
}

// AIC.FFSR: Fast Forcing Status Register
func (o *AIC_Type) SetFFSR_SYS(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetFFSR_SYS() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetFFSR_PID2(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetFFSR_PID2() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetFFSR_PID3(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetFFSR_PID3() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetFFSR_PID4(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetFFSR_PID4() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetFFSR_PID5(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetFFSR_PID5() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetFFSR_PID6(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetFFSR_PID6() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetFFSR_PID7(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetFFSR_PID7() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetFFSR_PID8(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetFFSR_PID8() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetFFSR_PID9(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetFFSR_PID9() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetFFSR_PID10(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetFFSR_PID10() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetFFSR_PID11(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetFFSR_PID11() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetFFSR_PID12(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetFFSR_PID12() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetFFSR_PID13(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetFFSR_PID13() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetFFSR_PID14(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetFFSR_PID14() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetFFSR_PID15(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetFFSR_PID15() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetFFSR_PID16(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetFFSR_PID16() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetFFSR_PID17(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetFFSR_PID17() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetFFSR_PID18(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetFFSR_PID18() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetFFSR_PID19(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetFFSR_PID19() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetFFSR_PID20(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetFFSR_PID20() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetFFSR_PID21(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetFFSR_PID21() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetFFSR_PID22(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetFFSR_PID22() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetFFSR_PID23(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetFFSR_PID23() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetFFSR_PID24(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetFFSR_PID24() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetFFSR_PID25(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetFFSR_PID25() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetFFSR_PID26(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetFFSR_PID26() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetFFSR_PID27(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetFFSR_PID27() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetFFSR_PID28(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetFFSR_PID28() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetFFSR_PID29(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetFFSR_PID29() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetFFSR_PID30(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetFFSR_PID30() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetFFSR_PID31(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetFFSR_PID31() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x80000000) >> 31
}

// Parallel Input/Output Controller A
type PIO_Type struct {
	PER    volatile.Register32 // 0x0
	PDR    volatile.Register32 // 0x4
	PSR    volatile.Register32 // 0x8
	_      [4]byte
	OER    volatile.Register32 // 0x10
	ODR    volatile.Register32 // 0x14
	OSR    volatile.Register32 // 0x18
	_      [4]byte
	IFER   volatile.Register32 // 0x20
	IFDR   volatile.Register32 // 0x24
	IFSR   volatile.Register32 // 0x28
	_      [4]byte
	SODR   volatile.Register32 // 0x30
	CODR   volatile.Register32 // 0x34
	ODSR   volatile.Register32 // 0x38
	PDSR   volatile.Register32 // 0x3C
	IER    volatile.Register32 // 0x40
	IDR    volatile.Register32 // 0x44
	IMR    volatile.Register32 // 0x48
	ISR    volatile.Register32 // 0x4C
	MDER   volatile.Register32 // 0x50
	MDDR   volatile.Register32 // 0x54
	MDSR   volatile.Register32 // 0x58
	_      [4]byte
	PUDR   volatile.Register32 // 0x60
	PUER   volatile.Register32 // 0x64
	PUSR   volatile.Register32 // 0x68
	_      [4]byte
	ASR    volatile.Register32 // 0x70
	BSR    volatile.Register32 // 0x74
	ABSR   volatile.Register32 // 0x78
	_      [36]byte
	OWER   volatile.Register32 // 0xA0
	OWDR   volatile.Register32 // 0xA4
	OWSR   volatile.Register32 // 0xA8
	_      [20]byte
	DELAYR [4]volatile.Register32 // 0xC0
	_      [20]byte
	WPMR   volatile.Register32 // 0xE4
	WPSR   volatile.Register32 // 0xE8
}

// PIO.PER: PIO Enable Register
func (o *PIO_Type) SetPER_P0(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPER_P0() uint32 {
	return volatile.LoadUint32(&o.PER.Reg) & 0x1
}
func (o *PIO_Type) SetPER_P1(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPER_P1() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPER_P2(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPER_P2() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPER_P3(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPER_P3() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPER_P4(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPER_P4() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPER_P5(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPER_P5() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPER_P6(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPER_P6() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPER_P7(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPER_P7() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPER_P8(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPER_P8() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPER_P9(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPER_P9() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPER_P10(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPER_P10() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPER_P11(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPER_P11() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPER_P12(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPER_P12() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPER_P13(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPER_P13() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPER_P14(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPER_P14() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPER_P15(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPER_P15() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPER_P16(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPER_P16() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPER_P17(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPER_P17() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPER_P18(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPER_P18() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPER_P19(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPER_P19() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPER_P20(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPER_P20() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPER_P21(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPER_P21() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPER_P22(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPER_P22() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPER_P23(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPER_P23() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPER_P24(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPER_P24() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPER_P25(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPER_P25() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPER_P26(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPER_P26() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPER_P27(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPER_P27() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPER_P28(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPER_P28() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPER_P29(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPER_P29() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPER_P30(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPER_P30() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPER_P31(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPER_P31() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000000) >> 31
}

// PIO.PDR: PIO Disable Register
func (o *PIO_Type) SetPDR_P0(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDR_P0() uint32 {
	return volatile.LoadUint32(&o.PDR.Reg) & 0x1
}
func (o *PIO_Type) SetPDR_P1(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDR_P2(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDR_P3(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDR_P4(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDR_P5(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDR_P6(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDR_P7(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDR_P8(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDR_P9(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDR_P10(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDR_P11(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDR_P12(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDR_P13(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDR_P14(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDR_P15(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDR_P16(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDR_P17(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDR_P18(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDR_P19(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDR_P20(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDR_P21(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDR_P22(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDR_P23(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDR_P24(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDR_P25(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDR_P26(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDR_P27(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDR_P28(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDR_P29(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDR_P30(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDR_P31(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000000) >> 31
}

// PIO.PSR: PIO Status Register
func (o *PIO_Type) SetPSR_P0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPSR_P0() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}
func (o *PIO_Type) SetPSR_P1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPSR_P2(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPSR_P3(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPSR_P4(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPSR_P5(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPSR_P6(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPSR_P7(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPSR_P8(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPSR_P9(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPSR_P10(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPSR_P11(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPSR_P12(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPSR_P13(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPSR_P14(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPSR_P15(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPSR_P16(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPSR_P17(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPSR_P18(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPSR_P19(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPSR_P20(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPSR_P21(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPSR_P22(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPSR_P23(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPSR_P24(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPSR_P25(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPSR_P26(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPSR_P27(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPSR_P28(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPSR_P29(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPSR_P30(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPSR_P31(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000000) >> 31
}

// PIO.OER: Output Enable Register
func (o *PIO_Type) SetOER_P0(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOER_P0() uint32 {
	return volatile.LoadUint32(&o.OER.Reg) & 0x1
}
func (o *PIO_Type) SetOER_P1(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOER_P1() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOER_P2(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOER_P2() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOER_P3(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOER_P3() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOER_P4(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOER_P4() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOER_P5(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOER_P5() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOER_P6(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOER_P6() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOER_P7(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOER_P7() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOER_P8(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOER_P8() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOER_P9(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOER_P9() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOER_P10(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOER_P10() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOER_P11(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOER_P11() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOER_P12(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOER_P12() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOER_P13(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOER_P13() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOER_P14(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOER_P14() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOER_P15(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOER_P15() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOER_P16(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOER_P16() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOER_P17(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOER_P17() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOER_P18(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOER_P18() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOER_P19(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOER_P19() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOER_P20(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOER_P20() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOER_P21(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOER_P21() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOER_P22(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOER_P22() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOER_P23(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOER_P23() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOER_P24(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOER_P24() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOER_P25(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOER_P25() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOER_P26(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOER_P26() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOER_P27(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOER_P27() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOER_P28(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOER_P28() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOER_P29(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOER_P29() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOER_P30(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOER_P30() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOER_P31(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOER_P31() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000000) >> 31
}

// PIO.ODR: Output Disable Register
func (o *PIO_Type) SetODR_P0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODR_P0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}
func (o *PIO_Type) SetODR_P1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODR_P2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODR_P3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODR_P4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODR_P5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODR_P6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODR_P7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODR_P8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODR_P9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODR_P10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODR_P11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODR_P12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODR_P13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODR_P14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODR_P15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODR_P16(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODR_P17(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODR_P18(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODR_P19(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODR_P20(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODR_P21(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODR_P22(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODR_P23(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODR_P24(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODR_P25(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODR_P26(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODR_P27(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODR_P28(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODR_P29(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODR_P30(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODR_P31(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000000) >> 31
}

// PIO.OSR: Output Status Register
func (o *PIO_Type) SetOSR_P0(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOSR_P0() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *PIO_Type) SetOSR_P1(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOSR_P2(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOSR_P3(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOSR_P4(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOSR_P5(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOSR_P6(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOSR_P7(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOSR_P8(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOSR_P9(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOSR_P10(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOSR_P11(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOSR_P12(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOSR_P13(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOSR_P14(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOSR_P15(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOSR_P16(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOSR_P17(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOSR_P18(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOSR_P19(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOSR_P20(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOSR_P21(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOSR_P22(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOSR_P23(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOSR_P24(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOSR_P25(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOSR_P26(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOSR_P27(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOSR_P28(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOSR_P29(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOSR_P30(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOSR_P31(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000000) >> 31
}

// PIO.IFER: Glitch Input Filter Enable Register
func (o *PIO_Type) SetIFER_P0(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFER_P0() uint32 {
	return volatile.LoadUint32(&o.IFER.Reg) & 0x1
}
func (o *PIO_Type) SetIFER_P1(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFER_P2(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFER_P3(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFER_P4(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFER_P5(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFER_P6(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFER_P7(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFER_P8(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFER_P9(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFER_P10(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFER_P11(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFER_P12(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFER_P13(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFER_P14(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFER_P15(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFER_P16(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFER_P17(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFER_P18(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFER_P19(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFER_P20(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFER_P21(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFER_P22(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFER_P23(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFER_P24(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFER_P25(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFER_P26(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFER_P27(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFER_P28(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFER_P29(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFER_P30(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFER_P31(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000000) >> 31
}

// PIO.IFDR: Glitch Input Filter Disable Register
func (o *PIO_Type) SetIFDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSR: Glitch Input Filter Status Register
func (o *PIO_Type) SetIFSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000000) >> 31
}

// PIO.SODR: Set Output Data Register
func (o *PIO_Type) SetSODR_P0(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSODR_P0() uint32 {
	return volatile.LoadUint32(&o.SODR.Reg) & 0x1
}
func (o *PIO_Type) SetSODR_P1(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSODR_P1() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSODR_P2(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSODR_P2() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSODR_P3(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSODR_P3() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSODR_P4(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSODR_P4() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSODR_P5(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSODR_P5() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSODR_P6(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSODR_P6() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSODR_P7(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSODR_P7() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSODR_P8(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSODR_P8() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSODR_P9(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSODR_P9() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSODR_P10(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSODR_P10() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSODR_P11(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSODR_P11() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSODR_P12(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSODR_P12() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSODR_P13(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSODR_P13() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSODR_P14(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSODR_P14() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSODR_P15(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSODR_P15() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSODR_P16(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSODR_P16() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSODR_P17(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSODR_P17() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSODR_P18(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSODR_P18() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSODR_P19(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSODR_P19() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSODR_P20(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSODR_P20() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSODR_P21(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSODR_P21() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSODR_P22(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSODR_P22() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSODR_P23(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSODR_P23() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSODR_P24(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSODR_P24() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSODR_P25(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSODR_P25() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSODR_P26(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSODR_P26() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSODR_P27(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSODR_P27() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSODR_P28(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSODR_P28() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSODR_P29(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSODR_P29() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSODR_P30(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSODR_P30() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSODR_P31(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSODR_P31() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000000) >> 31
}

// PIO.CODR: Clear Output Data Register
func (o *PIO_Type) SetCODR_P0(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetCODR_P0() uint32 {
	return volatile.LoadUint32(&o.CODR.Reg) & 0x1
}
func (o *PIO_Type) SetCODR_P1(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetCODR_P1() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetCODR_P2(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetCODR_P2() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetCODR_P3(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetCODR_P3() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetCODR_P4(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetCODR_P4() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetCODR_P5(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetCODR_P5() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetCODR_P6(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetCODR_P6() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetCODR_P7(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetCODR_P7() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetCODR_P8(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetCODR_P8() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetCODR_P9(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetCODR_P9() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetCODR_P10(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetCODR_P10() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetCODR_P11(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetCODR_P11() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetCODR_P12(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetCODR_P12() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetCODR_P13(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetCODR_P13() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetCODR_P14(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetCODR_P14() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetCODR_P15(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetCODR_P15() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetCODR_P16(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetCODR_P16() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetCODR_P17(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetCODR_P17() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetCODR_P18(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetCODR_P18() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetCODR_P19(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetCODR_P19() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetCODR_P20(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetCODR_P20() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetCODR_P21(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetCODR_P21() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetCODR_P22(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetCODR_P22() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetCODR_P23(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetCODR_P23() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetCODR_P24(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetCODR_P24() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetCODR_P25(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetCODR_P25() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetCODR_P26(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetCODR_P26() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetCODR_P27(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetCODR_P27() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetCODR_P28(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetCODR_P28() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetCODR_P29(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetCODR_P29() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetCODR_P30(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetCODR_P30() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetCODR_P31(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetCODR_P31() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000000) >> 31
}

// PIO.ODSR: Output Data Status Register
func (o *PIO_Type) SetODSR_P0(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODSR_P0() uint32 {
	return volatile.LoadUint32(&o.ODSR.Reg) & 0x1
}
func (o *PIO_Type) SetODSR_P1(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODSR_P2(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODSR_P3(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODSR_P4(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODSR_P5(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODSR_P6(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODSR_P7(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODSR_P8(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODSR_P9(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODSR_P10(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODSR_P11(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODSR_P12(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODSR_P13(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODSR_P14(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODSR_P15(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODSR_P16(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODSR_P17(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODSR_P18(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODSR_P19(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODSR_P20(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODSR_P21(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODSR_P22(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODSR_P23(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODSR_P24(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODSR_P25(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODSR_P26(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODSR_P27(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODSR_P28(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODSR_P29(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODSR_P30(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODSR_P31(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000000) >> 31
}

// PIO.PDSR: Pin Data Status Register
func (o *PIO_Type) SetPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000000) >> 31
}

// PIO.IER: Interrupt Enable Register
func (o *PIO_Type) SetIER_P0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIER_P0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PIO_Type) SetIER_P1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIER_P1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIER_P2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIER_P2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIER_P3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIER_P3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIER_P4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIER_P4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIER_P5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIER_P5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIER_P6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIER_P6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIER_P7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIER_P7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIER_P8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIER_P8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIER_P9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIER_P9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIER_P10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIER_P10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIER_P11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIER_P11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIER_P12(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIER_P12() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIER_P13(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIER_P13() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIER_P14(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIER_P14() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIER_P15(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIER_P15() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIER_P16(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIER_P16() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIER_P17(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIER_P17() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIER_P18(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIER_P18() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIER_P19(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIER_P19() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIER_P20(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIER_P20() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIER_P21(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIER_P21() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIER_P22(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIER_P22() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIER_P23(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIER_P23() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIER_P24(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIER_P24() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIER_P25(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIER_P25() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIER_P26(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIER_P26() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIER_P27(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIER_P27() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIER_P28(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIER_P28() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIER_P29(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIER_P29() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIER_P30(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIER_P30() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIER_P31(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIER_P31() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// PIO.IDR: Interrupt Disable Register
func (o *PIO_Type) SetIDR_P0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIDR_P0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PIO_Type) SetIDR_P1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIDR_P2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIDR_P3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIDR_P4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIDR_P5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIDR_P6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIDR_P7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIDR_P8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIDR_P9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIDR_P10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIDR_P11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIDR_P12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIDR_P13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIDR_P14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIDR_P15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIDR_P16(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIDR_P17(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIDR_P18(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIDR_P19(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIDR_P20(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIDR_P21(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIDR_P22(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIDR_P23(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIDR_P24(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIDR_P25(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIDR_P26(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIDR_P27(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIDR_P28(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIDR_P29(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIDR_P30(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIDR_P31(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// PIO.IMR: Interrupt Mask Register
func (o *PIO_Type) SetIMR_P0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIMR_P0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PIO_Type) SetIMR_P1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIMR_P1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIMR_P2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIMR_P2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIMR_P3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIMR_P3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIMR_P4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIMR_P4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIMR_P5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIMR_P5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIMR_P6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIMR_P6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIMR_P7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIMR_P7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIMR_P8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIMR_P8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIMR_P9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIMR_P9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIMR_P10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIMR_P10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIMR_P11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIMR_P11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIMR_P12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIMR_P12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIMR_P13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIMR_P13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIMR_P14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIMR_P14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIMR_P15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIMR_P15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIMR_P16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIMR_P16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIMR_P17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIMR_P17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIMR_P18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIMR_P18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIMR_P19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIMR_P19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIMR_P20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIMR_P20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIMR_P21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIMR_P21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIMR_P22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIMR_P22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIMR_P23(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIMR_P23() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIMR_P24(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIMR_P24() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIMR_P25(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIMR_P25() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIMR_P26(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIMR_P26() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIMR_P27(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIMR_P27() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIMR_P28(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIMR_P28() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIMR_P29(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIMR_P29() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIMR_P30(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIMR_P30() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIMR_P31(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIMR_P31() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// PIO.ISR: Interrupt Status Register
func (o *PIO_Type) SetISR_P0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetISR_P0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PIO_Type) SetISR_P1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetISR_P1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetISR_P2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetISR_P2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetISR_P3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetISR_P3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetISR_P4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetISR_P4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetISR_P5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetISR_P5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetISR_P6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetISR_P6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetISR_P7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetISR_P7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetISR_P8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetISR_P8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetISR_P9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetISR_P9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetISR_P10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetISR_P10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetISR_P11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetISR_P11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetISR_P12(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetISR_P12() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetISR_P13(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetISR_P13() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetISR_P14(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetISR_P14() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetISR_P15(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetISR_P15() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetISR_P16(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetISR_P16() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetISR_P17(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetISR_P17() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetISR_P18(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetISR_P18() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetISR_P19(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetISR_P19() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetISR_P20(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetISR_P20() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetISR_P21(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetISR_P21() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetISR_P22(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetISR_P22() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetISR_P23(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetISR_P23() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetISR_P24(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetISR_P24() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetISR_P25(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetISR_P25() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetISR_P26(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetISR_P26() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetISR_P27(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetISR_P27() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetISR_P28(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetISR_P28() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetISR_P29(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetISR_P29() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetISR_P30(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetISR_P30() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetISR_P31(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetISR_P31() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// PIO.MDER: Multi-driver Enable Register
func (o *PIO_Type) SetMDER_P0(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDER_P0() uint32 {
	return volatile.LoadUint32(&o.MDER.Reg) & 0x1
}
func (o *PIO_Type) SetMDER_P1(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDER_P1() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDER_P2(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDER_P2() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDER_P3(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDER_P3() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDER_P4(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDER_P4() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDER_P5(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDER_P5() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDER_P6(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDER_P6() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDER_P7(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDER_P7() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDER_P8(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDER_P8() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDER_P9(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDER_P9() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDER_P10(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDER_P10() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDER_P11(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDER_P11() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDER_P12(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDER_P12() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDER_P13(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDER_P13() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDER_P14(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDER_P14() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDER_P15(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDER_P15() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDER_P16(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDER_P16() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDER_P17(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDER_P17() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDER_P18(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDER_P18() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDER_P19(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDER_P19() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDER_P20(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDER_P20() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDER_P21(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDER_P21() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDER_P22(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDER_P22() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDER_P23(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDER_P23() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDER_P24(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDER_P24() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDER_P25(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDER_P25() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDER_P26(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDER_P26() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDER_P27(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDER_P27() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDER_P28(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDER_P28() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDER_P29(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDER_P29() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDER_P30(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDER_P30() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDER_P31(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDER_P31() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000000) >> 31
}

// PIO.MDDR: Multi-driver Disable Register
func (o *PIO_Type) SetMDDR_P0(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDDR_P0() uint32 {
	return volatile.LoadUint32(&o.MDDR.Reg) & 0x1
}
func (o *PIO_Type) SetMDDR_P1(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDDR_P2(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDDR_P3(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDDR_P4(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDDR_P5(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDDR_P6(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDDR_P7(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDDR_P8(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDDR_P9(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDDR_P10(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDDR_P11(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDDR_P12(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDDR_P13(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDDR_P14(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDDR_P15(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDDR_P16(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDDR_P17(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDDR_P18(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDDR_P19(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDDR_P20(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDDR_P21(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDDR_P22(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDDR_P23(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDDR_P24(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDDR_P25(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDDR_P26(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDDR_P27(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDDR_P28(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDDR_P29(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDDR_P30(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDDR_P31(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000000) >> 31
}

// PIO.MDSR: Multi-driver Status Register
func (o *PIO_Type) SetMDSR_P0(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDSR_P0() uint32 {
	return volatile.LoadUint32(&o.MDSR.Reg) & 0x1
}
func (o *PIO_Type) SetMDSR_P1(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDSR_P2(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDSR_P3(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDSR_P4(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDSR_P5(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDSR_P6(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDSR_P7(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDSR_P8(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDSR_P9(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDSR_P10(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDSR_P11(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDSR_P12(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDSR_P13(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDSR_P14(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDSR_P15(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDSR_P16(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDSR_P17(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDSR_P18(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDSR_P19(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDSR_P20(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDSR_P21(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDSR_P22(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDSR_P23(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDSR_P24(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDSR_P25(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDSR_P26(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDSR_P27(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDSR_P28(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDSR_P29(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDSR_P30(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDSR_P31(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000000) >> 31
}

// PIO.PUDR: Pull-up Disable Register
func (o *PIO_Type) SetPUDR_P0(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUDR_P0() uint32 {
	return volatile.LoadUint32(&o.PUDR.Reg) & 0x1
}
func (o *PIO_Type) SetPUDR_P1(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUDR_P2(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUDR_P3(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUDR_P4(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUDR_P5(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUDR_P6(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUDR_P7(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUDR_P8(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUDR_P9(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUDR_P10(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUDR_P11(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUDR_P12(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUDR_P13(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUDR_P14(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUDR_P15(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUDR_P16(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUDR_P17(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUDR_P18(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUDR_P19(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUDR_P20(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUDR_P21(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUDR_P22(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUDR_P23(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUDR_P24(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUDR_P25(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUDR_P26(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUDR_P27(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUDR_P28(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUDR_P29(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUDR_P30(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUDR_P31(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000000) >> 31
}

// PIO.PUER: Pull-up Enable Register
func (o *PIO_Type) SetPUER_P0(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUER_P0() uint32 {
	return volatile.LoadUint32(&o.PUER.Reg) & 0x1
}
func (o *PIO_Type) SetPUER_P1(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUER_P1() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUER_P2(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUER_P2() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUER_P3(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUER_P3() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUER_P4(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUER_P4() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUER_P5(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUER_P5() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUER_P6(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUER_P6() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUER_P7(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUER_P7() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUER_P8(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUER_P8() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUER_P9(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUER_P9() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUER_P10(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUER_P10() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUER_P11(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUER_P11() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUER_P12(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUER_P12() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUER_P13(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUER_P13() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUER_P14(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUER_P14() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUER_P15(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUER_P15() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUER_P16(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUER_P16() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUER_P17(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUER_P17() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUER_P18(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUER_P18() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUER_P19(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUER_P19() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUER_P20(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUER_P20() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUER_P21(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUER_P21() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUER_P22(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUER_P22() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUER_P23(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUER_P23() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUER_P24(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUER_P24() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUER_P25(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUER_P25() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUER_P26(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUER_P26() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUER_P27(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUER_P27() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUER_P28(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUER_P28() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUER_P29(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUER_P29() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUER_P30(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUER_P30() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUER_P31(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUER_P31() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000000) >> 31
}

// PIO.PUSR: Pad Pull-up Status Register
func (o *PIO_Type) SetPUSR_P0(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUSR_P0() uint32 {
	return volatile.LoadUint32(&o.PUSR.Reg) & 0x1
}
func (o *PIO_Type) SetPUSR_P1(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUSR_P2(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUSR_P3(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUSR_P4(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUSR_P5(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUSR_P6(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUSR_P7(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUSR_P8(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUSR_P9(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUSR_P10(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUSR_P11(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUSR_P12(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUSR_P13(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUSR_P14(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUSR_P15(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUSR_P16(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUSR_P17(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUSR_P18(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUSR_P19(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUSR_P20(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUSR_P21(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUSR_P22(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUSR_P23(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUSR_P24(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUSR_P25(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUSR_P26(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUSR_P27(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUSR_P28(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUSR_P29(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUSR_P30(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUSR_P31(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000000) >> 31
}

// PIO.ASR: Peripheral A Select Register
func (o *PIO_Type) SetASR_P0(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetASR_P0() uint32 {
	return volatile.LoadUint32(&o.ASR.Reg) & 0x1
}
func (o *PIO_Type) SetASR_P1(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetASR_P1() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetASR_P2(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetASR_P2() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetASR_P3(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetASR_P3() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetASR_P4(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetASR_P4() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetASR_P5(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetASR_P5() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetASR_P6(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetASR_P6() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetASR_P7(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetASR_P7() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetASR_P8(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetASR_P8() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetASR_P9(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetASR_P9() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetASR_P10(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetASR_P10() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetASR_P11(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetASR_P11() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetASR_P12(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetASR_P12() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetASR_P13(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetASR_P13() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetASR_P14(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetASR_P14() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetASR_P15(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetASR_P15() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetASR_P16(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetASR_P16() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetASR_P17(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetASR_P17() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetASR_P18(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetASR_P18() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetASR_P19(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetASR_P19() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetASR_P20(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetASR_P20() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetASR_P21(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetASR_P21() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetASR_P22(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetASR_P22() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetASR_P23(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetASR_P23() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetASR_P24(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetASR_P24() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetASR_P25(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetASR_P25() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetASR_P26(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetASR_P26() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetASR_P27(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetASR_P27() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetASR_P28(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetASR_P28() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetASR_P29(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetASR_P29() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetASR_P30(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetASR_P30() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetASR_P31(value uint32) {
	volatile.StoreUint32(&o.ASR.Reg, volatile.LoadUint32(&o.ASR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetASR_P31() uint32 {
	return (volatile.LoadUint32(&o.ASR.Reg) & 0x80000000) >> 31
}

// PIO.BSR: Peripheral B Select Register
func (o *PIO_Type) SetBSR_P0(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetBSR_P0() uint32 {
	return volatile.LoadUint32(&o.BSR.Reg) & 0x1
}
func (o *PIO_Type) SetBSR_P1(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetBSR_P1() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetBSR_P2(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetBSR_P2() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetBSR_P3(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetBSR_P3() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetBSR_P4(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetBSR_P4() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetBSR_P5(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetBSR_P5() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetBSR_P6(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetBSR_P6() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetBSR_P7(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetBSR_P7() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetBSR_P8(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetBSR_P8() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetBSR_P9(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetBSR_P9() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetBSR_P10(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetBSR_P10() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetBSR_P11(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetBSR_P11() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetBSR_P12(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetBSR_P12() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetBSR_P13(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetBSR_P13() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetBSR_P14(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetBSR_P14() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetBSR_P15(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetBSR_P15() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetBSR_P16(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetBSR_P16() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetBSR_P17(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetBSR_P17() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetBSR_P18(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetBSR_P18() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetBSR_P19(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetBSR_P19() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetBSR_P20(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetBSR_P20() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetBSR_P21(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetBSR_P21() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetBSR_P22(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetBSR_P22() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetBSR_P23(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetBSR_P23() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetBSR_P24(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetBSR_P24() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetBSR_P25(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetBSR_P25() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetBSR_P26(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetBSR_P26() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetBSR_P27(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetBSR_P27() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetBSR_P28(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetBSR_P28() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetBSR_P29(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetBSR_P29() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetBSR_P30(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetBSR_P30() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetBSR_P31(value uint32) {
	volatile.StoreUint32(&o.BSR.Reg, volatile.LoadUint32(&o.BSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetBSR_P31() uint32 {
	return (volatile.LoadUint32(&o.BSR.Reg) & 0x80000000) >> 31
}

// PIO.ABSR: AB Status Register
func (o *PIO_Type) SetABSR_P0(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetABSR_P0() uint32 {
	return volatile.LoadUint32(&o.ABSR.Reg) & 0x1
}
func (o *PIO_Type) SetABSR_P1(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetABSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetABSR_P2(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetABSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetABSR_P3(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetABSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetABSR_P4(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetABSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetABSR_P5(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetABSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetABSR_P6(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetABSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetABSR_P7(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetABSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetABSR_P8(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetABSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetABSR_P9(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetABSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetABSR_P10(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetABSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetABSR_P11(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetABSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetABSR_P12(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetABSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetABSR_P13(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetABSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetABSR_P14(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetABSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetABSR_P15(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetABSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetABSR_P16(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetABSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetABSR_P17(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetABSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetABSR_P18(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetABSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetABSR_P19(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetABSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetABSR_P20(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetABSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetABSR_P21(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetABSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetABSR_P22(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetABSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetABSR_P23(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetABSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetABSR_P24(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetABSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetABSR_P25(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetABSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetABSR_P26(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetABSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetABSR_P27(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetABSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetABSR_P28(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetABSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetABSR_P29(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetABSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetABSR_P30(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetABSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetABSR_P31(value uint32) {
	volatile.StoreUint32(&o.ABSR.Reg, volatile.LoadUint32(&o.ABSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetABSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ABSR.Reg) & 0x80000000) >> 31
}

// PIO.OWER: Output Write Enable
func (o *PIO_Type) SetOWER_P0(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWER_P0() uint32 {
	return volatile.LoadUint32(&o.OWER.Reg) & 0x1
}
func (o *PIO_Type) SetOWER_P1(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWER_P1() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWER_P2(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWER_P2() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWER_P3(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWER_P3() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWER_P4(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWER_P4() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWER_P5(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWER_P5() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWER_P6(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWER_P6() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWER_P7(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWER_P7() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWER_P8(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWER_P8() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWER_P9(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWER_P9() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWER_P10(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWER_P10() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWER_P11(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWER_P11() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWER_P12(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWER_P12() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWER_P13(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWER_P13() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWER_P14(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWER_P14() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWER_P15(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWER_P15() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWER_P16(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWER_P16() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWER_P17(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWER_P17() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWER_P18(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWER_P18() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWER_P19(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWER_P19() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWER_P20(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWER_P20() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWER_P21(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWER_P21() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWER_P22(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWER_P22() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWER_P23(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWER_P23() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWER_P24(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWER_P24() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWER_P25(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWER_P25() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWER_P26(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWER_P26() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWER_P27(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWER_P27() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWER_P28(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWER_P28() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWER_P29(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWER_P29() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWER_P30(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWER_P30() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWER_P31(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWER_P31() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000000) >> 31
}

// PIO.OWDR: Output Write Disable
func (o *PIO_Type) SetOWDR_P0(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWDR_P0() uint32 {
	return volatile.LoadUint32(&o.OWDR.Reg) & 0x1
}
func (o *PIO_Type) SetOWDR_P1(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWDR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWDR_P2(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWDR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWDR_P3(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWDR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWDR_P4(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWDR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWDR_P5(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWDR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWDR_P6(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWDR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWDR_P7(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWDR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWDR_P8(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWDR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWDR_P9(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWDR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWDR_P10(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWDR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWDR_P11(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWDR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWDR_P12(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWDR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWDR_P13(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWDR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWDR_P14(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWDR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWDR_P15(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWDR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWDR_P16(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWDR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWDR_P17(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWDR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWDR_P18(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWDR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWDR_P19(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWDR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWDR_P20(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWDR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWDR_P21(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWDR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWDR_P22(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWDR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWDR_P23(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWDR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWDR_P24(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWDR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWDR_P25(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWDR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWDR_P26(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWDR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWDR_P27(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWDR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWDR_P28(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWDR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWDR_P29(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWDR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWDR_P30(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWDR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWDR_P31(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWDR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000000) >> 31
}

// PIO.OWSR: Output Write Status Register
func (o *PIO_Type) SetOWSR_P0(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWSR_P0() uint32 {
	return volatile.LoadUint32(&o.OWSR.Reg) & 0x1
}
func (o *PIO_Type) SetOWSR_P1(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWSR_P2(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWSR_P3(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWSR_P4(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWSR_P5(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWSR_P6(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWSR_P7(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWSR_P8(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWSR_P9(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWSR_P10(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWSR_P11(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWSR_P12(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWSR_P13(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWSR_P14(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWSR_P15(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWSR_P16(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWSR_P17(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWSR_P18(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWSR_P19(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWSR_P20(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWSR_P21(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWSR_P22(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWSR_P23(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWSR_P24(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWSR_P25(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWSR_P26(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWSR_P27(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWSR_P28(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWSR_P29(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWSR_P30(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWSR_P31(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000000) >> 31
}

// PIO.DELAYR: I/O Delay Register
func (o *PIO_Type) SetDELAYR_Delay0(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf)|value)
}
func (o *PIO_Type) GetDELAYR_Delay0(idx int) uint32 {
	return volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf
}
func (o *PIO_Type) SetDELAYR_Delay1(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf0)|value<<4)
}
func (o *PIO_Type) GetDELAYR_Delay1(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf0) >> 4
}
func (o *PIO_Type) SetDELAYR_Delay2(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf00)|value<<8)
}
func (o *PIO_Type) GetDELAYR_Delay2(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf00) >> 8
}
func (o *PIO_Type) SetDELAYR_Delay3(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf000)|value<<12)
}
func (o *PIO_Type) GetDELAYR_Delay3(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf000) >> 12
}
func (o *PIO_Type) SetDELAYR_Delay4(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf0000)|value<<16)
}
func (o *PIO_Type) GetDELAYR_Delay4(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf0000) >> 16
}
func (o *PIO_Type) SetDELAYR_Delay5(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf00000)|value<<20)
}
func (o *PIO_Type) GetDELAYR_Delay5(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf00000) >> 20
}
func (o *PIO_Type) SetDELAYR_Delay6(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf000000)|value<<24)
}
func (o *PIO_Type) GetDELAYR_Delay6(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf000000) >> 24
}
func (o *PIO_Type) SetDELAYR_Delay7(idx int, value uint32) {
	volatile.StoreUint32(&o.DELAYR[idx].Reg, volatile.LoadUint32(&o.DELAYR[idx].Reg)&^(0xf0000000)|value<<28)
}
func (o *PIO_Type) GetDELAYR_Delay7(idx int) uint32 {
	return (volatile.LoadUint32(&o.DELAYR[idx].Reg) & 0xf0000000) >> 28
}

// PIO.WPMR: Write Protect Mode Register
func (o *PIO_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PIO_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PIO_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PIO.WPSR: Write Protect Status Register
func (o *PIO_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PIO_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PIO_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Power Management Controller
type PMC_Type struct {
	PMC_SCER   volatile.Register32 // 0x0
	PMC_SCDR   volatile.Register32 // 0x4
	PMC_SCSR   volatile.Register32 // 0x8
	_          [4]byte
	PMC_PCER   volatile.Register32 // 0x10
	PMC_PCDR   volatile.Register32 // 0x14
	PMC_PCSR   volatile.Register32 // 0x18
	CKGR_UCKR  volatile.Register32 // 0x1C
	CKGR_MOR   volatile.Register32 // 0x20
	CKGR_MCFR  volatile.Register32 // 0x24
	CKGR_PLLAR volatile.Register32 // 0x28
	_          [4]byte
	PMC_MCKR   volatile.Register32 // 0x30
	_          [4]byte
	PMC_USB    volatile.Register32 // 0x38
	_          [4]byte
	PMC_PCK    [2]volatile.Register32 // 0x40
	_          [24]byte
	PMC_IER    volatile.Register32 // 0x60
	PMC_IDR    volatile.Register32 // 0x64
	PMC_SR     volatile.Register32 // 0x68
	PMC_IMR    volatile.Register32 // 0x6C
}

// PMC.PMC_SCER: System Clock Enable Register
func (o *PMC_Type) SetPMC_SCER_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCER_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCER_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCER_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCER_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCER_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCER_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCER_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x200) >> 9
}

// PMC.PMC_SCDR: System Clock Disable Register
func (o *PMC_Type) SetPMC_SCDR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCDR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCDR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCDR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCDR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCDR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCDR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCDR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCDR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCDR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x200) >> 9
}

// PMC.PMC_SCSR: System Clock Status Register
func (o *PMC_Type) SetPMC_SCSR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCSR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCSR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCSR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCSR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCSR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCSR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCSR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCSR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCSR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x200) >> 9
}

// PMC.PMC_PCER: Peripheral Clock Enable Register
func (o *PMC_Type) SetPMC_PCER_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCER_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCER_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCER_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCER_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCER_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCER_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCER_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCER_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCER_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCER_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCER_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCER_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCER_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCER_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCER_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCER_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCER_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCER_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCER_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCER_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCER_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCER_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCER_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCER_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCER_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCER_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCER_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCER_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCER_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCER_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCER_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCER_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCER_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCER_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCER_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCER_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCER_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCER_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCER_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCER_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCER_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCER_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCER_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCER_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCER_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCER_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCER_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCER_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCER_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCER_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCER_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCER_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCER_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCER_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCER_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCER_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCER_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCER_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER.Reg, volatile.LoadUint32(&o.PMC_PCER.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCER_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCDR: Peripheral Clock Disable Register
func (o *PMC_Type) SetPMC_PCDR_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCDR_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCDR_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCDR_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCDR_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCDR_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCDR_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCDR_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCDR_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCDR_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCDR_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCDR_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCDR_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCDR_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCDR_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCDR_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCDR_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCDR_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCDR_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCDR_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCDR_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCDR_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCDR_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCDR_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCDR_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCDR_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCDR_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCDR_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCDR_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCDR_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCDR_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCDR_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCDR_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCDR_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCDR_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCDR_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCDR_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCDR_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCDR_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCDR_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCDR_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCDR_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCDR_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCDR_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCDR_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCDR_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCDR_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCDR_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCDR_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCDR_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCDR_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCDR_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCDR_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCDR_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCDR_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCDR_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCDR_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCDR_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCDR_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR.Reg, volatile.LoadUint32(&o.PMC_PCDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCDR_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCSR: Peripheral Clock Status Register
func (o *PMC_Type) SetPMC_PCSR_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCSR_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCSR_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCSR_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCSR_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCSR_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCSR_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCSR_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCSR_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCSR_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCSR_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCSR_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCSR_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCSR_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCSR_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCSR_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCSR_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCSR_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCSR_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCSR_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCSR_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCSR_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCSR_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCSR_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCSR_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCSR_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCSR_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCSR_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCSR_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCSR_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCSR_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCSR_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCSR_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCSR_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCSR_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCSR_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCSR_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCSR_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCSR_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCSR_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCSR_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCSR_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCSR_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCSR_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCSR_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCSR_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCSR_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCSR_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCSR_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCSR_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCSR_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCSR_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCSR_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCSR_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCSR_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCSR_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCSR_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCSR_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCSR_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR.Reg, volatile.LoadUint32(&o.PMC_PCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCSR_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR.Reg) & 0x80000000) >> 31
}

// PMC.CKGR_UCKR: UTMI Clock Register
func (o *PMC_Type) SetCKGR_UCKR_UPLLEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetCKGR_UCKR_PLLCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf00000)|value<<20)
}
func (o *PMC_Type) GetCKGR_UCKR_PLLCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf00000) >> 20
}
func (o *PMC_Type) SetCKGR_UCKR_BIASEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_UCKR_BIASCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf0000000) >> 28
}

// PMC.CKGR_MOR: Main Oscillator Register
func (o *PMC_Type) SetCKGR_MOR_MOSCEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCEN() uint32 {
	return volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1
}
func (o *PMC_Type) SetCKGR_MOR_OSCBYPASS(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetCKGR_MOR_OSCBYPASS() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetCKGR_MOR_OSCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff00)|value<<8)
}
func (o *PMC_Type) GetCKGR_MOR_OSCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff00) >> 8
}

// PMC.CKGR_MCFR: Main Clock Frequency Register
func (o *PMC_Type) SetCKGR_MCFR_MAINF(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0xffff)|value)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINF() uint32 {
	return volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0xffff
}
func (o *PMC_Type) SetCKGR_MCFR_MAINRDY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINRDY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x10000) >> 16
}

// PMC.CKGR_PLLAR: PLLA Register
func (o *PMC_Type) SetCKGR_PLLAR_DIVA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xff)|value)
}
func (o *PMC_Type) GetCKGR_PLLAR_DIVA() uint32 {
	return volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xff
}
func (o *PMC_Type) SetCKGR_PLLAR_PLLACOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x3f00)|value<<8)
}
func (o *PMC_Type) GetCKGR_PLLAR_PLLACOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x3f00) >> 8
}
func (o *PMC_Type) SetCKGR_PLLAR_OUTA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xc000)|value<<14)
}
func (o *PMC_Type) GetCKGR_PLLAR_OUTA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xc000) >> 14
}
func (o *PMC_Type) SetCKGR_PLLAR_MULA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_PLLAR_MULA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xff0000) >> 16
}
func (o *PMC_Type) SetCKGR_PLLAR_STUCKTO1(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetCKGR_PLLAR_STUCKTO1() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x20000000) >> 29
}

// PMC.PMC_MCKR: Master Clock Register
func (o *PMC_Type) SetPMC_MCKR_CSS(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetPMC_MCKR_CSS() uint32 {
	return volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x3
}
func (o *PMC_Type) SetPMC_MCKR_PRES(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x1c)|value<<2)
}
func (o *PMC_Type) GetPMC_MCKR_PRES() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x1c) >> 2
}
func (o *PMC_Type) SetPMC_MCKR_MDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x300)|value<<8)
}
func (o *PMC_Type) GetPMC_MCKR_MDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x300) >> 8
}
func (o *PMC_Type) SetPMC_MCKR_PLLADIV2(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_MCKR_PLLADIV2() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x1000) >> 12
}

// PMC.PMC_USB: USB Clock Register
func (o *PMC_Type) SetPMC_USB_USBS(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_USB_USBS() uint32 {
	return volatile.LoadUint32(&o.PMC_USB.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_USB_USBDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0xf00)|value<<8)
}
func (o *PMC_Type) GetPMC_USB_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_USB.Reg) & 0xf00) >> 8
}

// PMC.PMC_PCK: Programmable Clock 0 Register
func (o *PMC_Type) SetPMC_PCK_CSS(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetPMC_PCK_CSS(idx int) uint32 {
	return volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x3
}
func (o *PMC_Type) SetPMC_PCK_PRES(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x1c)|value<<2)
}
func (o *PMC_Type) GetPMC_PCK_PRES(idx int) uint32 {
	return (volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x1c) >> 2
}
func (o *PMC_Type) SetPMC_PCK_SLCKMCK(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCK_SLCKMCK(idx int) uint32 {
	return (volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x100) >> 8
}

// PMC.PMC_IER: Interrupt Enable Register
func (o *PMC_Type) SetPMC_IER_MOSCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IER_MOSCS() uint32 {
	return volatile.LoadUint32(&o.PMC_IER.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IER_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IER_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IER_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IER_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IER_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IER_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IER_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IER_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x200) >> 9
}

// PMC.PMC_IDR: Interrupt Disable Register
func (o *PMC_Type) SetPMC_IDR_MOSCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IDR_MOSCS() uint32 {
	return volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IDR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IDR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IDR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IDR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IDR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IDR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x200) >> 9
}

// PMC.PMC_SR: Status Register
func (o *PMC_Type) SetPMC_SR_MOSCS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SR_MOSCS() uint32 {
	return volatile.LoadUint32(&o.PMC_SR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_SR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_SR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_SR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_SR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x200) >> 9
}

// PMC.PMC_IMR: Interrupt Mask Register
func (o *PMC_Type) SetPMC_IMR_MOSCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IMR_MOSCS() uint32 {
	return volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IMR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IMR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IMR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IMR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IMR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IMR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x200) >> 9
}

// Reset Controller
type SYSC_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	MR volatile.Register32 // 0x8
}

// SYSC.CR: Control Register
func (o *SYSC_Type) SetCR_PROCRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetCR_PROCRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SYSC_Type) SetCR_PERRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetCR_PERRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetCR_EXTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetCR_EXTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// SYSC.SR: Status Register
func (o *SYSC_Type) SetSR_URSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSR_URSTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SYSC_Type) SetSR_RSTTYP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x700)|value<<8)
}
func (o *SYSC_Type) GetSR_RSTTYP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x700) >> 8
}
func (o *SYSC_Type) SetSR_NRSTL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetSR_NRSTL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SYSC_Type) SetSR_SRCMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetSR_SRCMP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SYSC.MR: Mode Register
func (o *SYSC_Type) SetMR_URSTEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetMR_URSTEN() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *SYSC_Type) SetMR_URSTIEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *SYSC_Type) GetMR_URSTIEN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *SYSC_Type) SetMR_ERSTL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *SYSC_Type) GetMR_ERSTL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *SYSC_Type) SetMR_KEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// Real-time Clock
type RTC_Type struct {
	CR     volatile.Register32 // 0x0
	MR     volatile.Register32 // 0x4
	TIMR   volatile.Register32 // 0x8
	CALR   volatile.Register32 // 0xC
	TIMALR volatile.Register32 // 0x10
	CALALR volatile.Register32 // 0x14
	SR     volatile.Register32 // 0x18
	SCCR   volatile.Register32 // 0x1C
	IER    volatile.Register32 // 0x20
	IDR    volatile.Register32 // 0x24
	IMR    volatile.Register32 // 0x28
	VER    volatile.Register32 // 0x2C
}

// RTC.CR: Control Register
func (o *RTC_Type) SetCR_UPDTIM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCR_UPDTIM() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RTC_Type) SetCR_UPDCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCR_UPDCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCR_TIMEVSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *RTC_Type) GetCR_TIMEVSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *RTC_Type) SetCR_CALEVSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *RTC_Type) GetCR_CALEVSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}

// RTC.MR: Mode Register
func (o *RTC_Type) SetMR_HRMOD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetMR_HRMOD() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}

// RTC.TIMR: Time Register
func (o *RTC_Type) SetTIMR_SEC(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetTIMR_SEC() uint32 {
	return volatile.LoadUint32(&o.TIMR.Reg) & 0x7f
}
func (o *RTC_Type) SetTIMR_MIN(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x7f00)|value<<8)
}
func (o *RTC_Type) GetTIMR_MIN() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x7f00) >> 8
}
func (o *RTC_Type) SetTIMR_HOUR(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x3f0000)|value<<16)
}
func (o *RTC_Type) GetTIMR_HOUR() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x3f0000) >> 16
}
func (o *RTC_Type) SetTIMR_AMPM(value uint32) {
	volatile.StoreUint32(&o.TIMR.Reg, volatile.LoadUint32(&o.TIMR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTIMR_AMPM() uint32 {
	return (volatile.LoadUint32(&o.TIMR.Reg) & 0x400000) >> 22
}

// RTC.CALR: Calendar Register
func (o *RTC_Type) SetCALR_CENT(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetCALR_CENT() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x7f
}
func (o *RTC_Type) SetCALR_YEAR(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetCALR_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetCALR_MONTH(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCALR_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCALR_DAY(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0xe00000)|value<<21)
}
func (o *RTC_Type) GetCALR_DAY() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0xe00000) >> 21
}
func (o *RTC_Type) SetCALR_DATE(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetCALR_DATE() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x3f000000) >> 24
}

// RTC.TIMALR: Time Alarm Register
func (o *RTC_Type) SetTIMALR_SEC(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetTIMALR_SEC() uint32 {
	return volatile.LoadUint32(&o.TIMALR.Reg) & 0x7f
}
func (o *RTC_Type) SetTIMALR_SECEN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetTIMALR_SECEN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetTIMALR_MIN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x7f00)|value<<8)
}
func (o *RTC_Type) GetTIMALR_MIN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x7f00) >> 8
}
func (o *RTC_Type) SetTIMALR_MINEN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetTIMALR_MINEN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetTIMALR_HOUR(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x3f0000)|value<<16)
}
func (o *RTC_Type) GetTIMALR_HOUR() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x3f0000) >> 16
}
func (o *RTC_Type) SetTIMALR_AMPM(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTIMALR_AMPM() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTIMALR_HOUREN(value uint32) {
	volatile.StoreUint32(&o.TIMALR.Reg, volatile.LoadUint32(&o.TIMALR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetTIMALR_HOUREN() uint32 {
	return (volatile.LoadUint32(&o.TIMALR.Reg) & 0x800000) >> 23
}

// RTC.CALALR: Calendar Alarm Register
func (o *RTC_Type) SetCALALR_MONTH(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCALALR_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCALALR_MTHEN(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCALALR_MTHEN() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCALALR_DATE(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetCALALR_DATE() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetCALALR_DATEEN(value uint32) {
	volatile.StoreUint32(&o.CALALR.Reg, volatile.LoadUint32(&o.CALALR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetCALALR_DATEEN() uint32 {
	return (volatile.LoadUint32(&o.CALALR.Reg) & 0x80000000) >> 31
}

// RTC.SR: Status Register
func (o *RTC_Type) SetSR_ACKUPD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_ACKUPD() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTC_Type) SetSR_ALARM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_ALARM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_SEC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_SEC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_TIMEV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSR_TIMEV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSR_CALEV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_CALEV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}

// RTC.SCCR: Status Clear Command Register
func (o *RTC_Type) SetSCCR_ACKCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSCCR_ACKCLR() uint32 {
	return volatile.LoadUint32(&o.SCCR.Reg) & 0x1
}
func (o *RTC_Type) SetSCCR_ALRCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSCCR_ALRCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSCCR_SECCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSCCR_SECCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSCCR_TIMCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSCCR_TIMCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSCCR_CALCLR(value uint32) {
	volatile.StoreUint32(&o.SCCR.Reg, volatile.LoadUint32(&o.SCCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSCCR_CALCLR() uint32 {
	return (volatile.LoadUint32(&o.SCCR.Reg) & 0x10) >> 4
}

// RTC.IER: Interrupt Enable Register
func (o *RTC_Type) SetIER_ACKEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIER_ACKEN() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *RTC_Type) SetIER_ALREN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIER_ALREN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIER_SECEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIER_SECEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIER_TIMEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIER_TIMEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIER_CALEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIER_CALEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}

// RTC.IDR: Interrupt Disable Register
func (o *RTC_Type) SetIDR_ACKDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIDR_ACKDIS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *RTC_Type) SetIDR_ALRDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIDR_ALRDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIDR_SECDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIDR_SECDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIDR_TIMDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIDR_TIMDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIDR_CALDIS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIDR_CALDIS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}

// RTC.IMR: Interrupt Mask Register
func (o *RTC_Type) SetIMR_ACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIMR_ACK() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *RTC_Type) SetIMR_ALR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIMR_ALR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIMR_SEC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIMR_SEC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIMR_TIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIMR_TIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIMR_CAL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIMR_CAL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}

// RTC.VER: Valid Entry Register
func (o *RTC_Type) SetVER_NVTIM(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetVER_NVTIM() uint32 {
	return volatile.LoadUint32(&o.VER.Reg) & 0x1
}
func (o *RTC_Type) SetVER_NVCAL(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetVER_NVCAL() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetVER_NVTIMALR(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetVER_NVTIMALR() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetVER_NVCALALR(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetVER_NVCALALR() uint32 {
	return (volatile.LoadUint32(&o.VER.Reg) & 0x8) >> 3
}

// Constants for LCDC: LCD Controller
const (
	// DMABADDR1: DMA Base Address Register 1
	// Position of BADDR_U field.
	LCDC_DMABADDR1_BADDR_U_Pos = 0x2
	// Bit mask of BADDR_U field.
	LCDC_DMABADDR1_BADDR_U_Msk = 0xfffffffc

	// DMABADDR2: DMA Base Address Register 2
	// Position of BADDR_L field.
	LCDC_DMABADDR2_BADDR_L_Pos = 0x0
	// Bit mask of BADDR_L field.
	LCDC_DMABADDR2_BADDR_L_Msk = 0xffffffff

	// DMAFRMPT1: DMA Frame Pointer Register 1
	// Position of FRMPT_U field.
	LCDC_DMAFRMPT1_FRMPT_U_Pos = 0x0
	// Bit mask of FRMPT_U field.
	LCDC_DMAFRMPT1_FRMPT_U_Msk = 0x7fffff

	// DMAFRMPT2: DMA Frame Pointer Register 2
	// Position of FRMPT_L field.
	LCDC_DMAFRMPT2_FRMPT_L_Pos = 0x0
	// Bit mask of FRMPT_L field.
	LCDC_DMAFRMPT2_FRMPT_L_Msk = 0x7fffff

	// DMAFRMADD1: DMA Frame Address Register 1
	// Position of FRMADD_U field.
	LCDC_DMAFRMADD1_FRMADD_U_Pos = 0x0
	// Bit mask of FRMADD_U field.
	LCDC_DMAFRMADD1_FRMADD_U_Msk = 0xffffffff

	// DMAFRMADD2: DMA Frame Address Register 2
	// Position of FRMADD_L field.
	LCDC_DMAFRMADD2_FRMADD_L_Pos = 0x0
	// Bit mask of FRMADD_L field.
	LCDC_DMAFRMADD2_FRMADD_L_Msk = 0xffffffff

	// DMAFRMCFG: DMA Frame Configuration Register
	// Position of FRMSIZE field.
	LCDC_DMAFRMCFG_FRMSIZE_Pos = 0x0
	// Bit mask of FRMSIZE field.
	LCDC_DMAFRMCFG_FRMSIZE_Msk = 0x7fffff
	// Position of BRSTLN field.
	LCDC_DMAFRMCFG_BRSTLN_Pos = 0x18
	// Bit mask of BRSTLN field.
	LCDC_DMAFRMCFG_BRSTLN_Msk = 0x7f000000

	// DMACON: DMA Control Register
	// Position of DMAEN field.
	LCDC_DMACON_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	LCDC_DMACON_DMAEN_Msk = 0x1
	// Bit DMAEN.
	LCDC_DMACON_DMAEN = 0x1
	// Position of DMARST field.
	LCDC_DMACON_DMARST_Pos = 0x1
	// Bit mask of DMARST field.
	LCDC_DMACON_DMARST_Msk = 0x2
	// Bit DMARST.
	LCDC_DMACON_DMARST = 0x2
	// Position of DMABUSY field.
	LCDC_DMACON_DMABUSY_Pos = 0x2
	// Bit mask of DMABUSY field.
	LCDC_DMACON_DMABUSY_Msk = 0x4
	// Bit DMABUSY.
	LCDC_DMACON_DMABUSY = 0x4
	// Position of DMAUPDT field.
	LCDC_DMACON_DMAUPDT_Pos = 0x3
	// Bit mask of DMAUPDT field.
	LCDC_DMACON_DMAUPDT_Msk = 0x8
	// Bit DMAUPDT.
	LCDC_DMACON_DMAUPDT = 0x8
	// Position of DMA2DEN field.
	LCDC_DMACON_DMA2DEN_Pos = 0x4
	// Bit mask of DMA2DEN field.
	LCDC_DMACON_DMA2DEN_Msk = 0x10
	// Bit DMA2DEN.
	LCDC_DMACON_DMA2DEN = 0x10

	// DMA2DCFG: DMA Control Register
	// Position of ADDRINC field.
	LCDC_DMA2DCFG_ADDRINC_Pos = 0x0
	// Bit mask of ADDRINC field.
	LCDC_DMA2DCFG_ADDRINC_Msk = 0xffff
	// Position of PIXELOFF field.
	LCDC_DMA2DCFG_PIXELOFF_Pos = 0x18
	// Bit mask of PIXELOFF field.
	LCDC_DMA2DCFG_PIXELOFF_Msk = 0x1f000000

	// LCDCON1: LCD Control Register 1
	// Position of BYPASS field.
	LCDC_LCDCON1_BYPASS_Pos = 0x0
	// Bit mask of BYPASS field.
	LCDC_LCDCON1_BYPASS_Msk = 0x1
	// Bit BYPASS.
	LCDC_LCDCON1_BYPASS = 0x1
	// Position of CLKVAL field.
	LCDC_LCDCON1_CLKVAL_Pos = 0xc
	// Bit mask of CLKVAL field.
	LCDC_LCDCON1_CLKVAL_Msk = 0x1ff000
	// Position of LINECNT field.
	LCDC_LCDCON1_LINECNT_Pos = 0x15
	// Bit mask of LINECNT field.
	LCDC_LCDCON1_LINECNT_Msk = 0xffe00000

	// LCDCON2: LCD Control Register 2
	// Position of DISTYPE field.
	LCDC_LCDCON2_DISTYPE_Pos = 0x0
	// Bit mask of DISTYPE field.
	LCDC_LCDCON2_DISTYPE_Msk = 0x3
	// Position of SCANMOD field.
	LCDC_LCDCON2_SCANMOD_Pos = 0x2
	// Bit mask of SCANMOD field.
	LCDC_LCDCON2_SCANMOD_Msk = 0x4
	// Bit SCANMOD.
	LCDC_LCDCON2_SCANMOD = 0x4
	// Position of IFWIDTH field.
	LCDC_LCDCON2_IFWIDTH_Pos = 0x3
	// Bit mask of IFWIDTH field.
	LCDC_LCDCON2_IFWIDTH_Msk = 0x18
	// Position of PIXELSIZE field.
	LCDC_LCDCON2_PIXELSIZE_Pos = 0x5
	// Bit mask of PIXELSIZE field.
	LCDC_LCDCON2_PIXELSIZE_Msk = 0xe0
	// Position of INVVD field.
	LCDC_LCDCON2_INVVD_Pos = 0x8
	// Bit mask of INVVD field.
	LCDC_LCDCON2_INVVD_Msk = 0x100
	// Bit INVVD.
	LCDC_LCDCON2_INVVD = 0x100
	// Position of INVFRAME field.
	LCDC_LCDCON2_INVFRAME_Pos = 0x9
	// Bit mask of INVFRAME field.
	LCDC_LCDCON2_INVFRAME_Msk = 0x200
	// Bit INVFRAME.
	LCDC_LCDCON2_INVFRAME = 0x200
	// Position of INVLINE field.
	LCDC_LCDCON2_INVLINE_Pos = 0xa
	// Bit mask of INVLINE field.
	LCDC_LCDCON2_INVLINE_Msk = 0x400
	// Bit INVLINE.
	LCDC_LCDCON2_INVLINE = 0x400
	// Position of INVCLK field.
	LCDC_LCDCON2_INVCLK_Pos = 0xb
	// Bit mask of INVCLK field.
	LCDC_LCDCON2_INVCLK_Msk = 0x800
	// Bit INVCLK.
	LCDC_LCDCON2_INVCLK = 0x800
	// Position of INVDVAL field.
	LCDC_LCDCON2_INVDVAL_Pos = 0xc
	// Bit mask of INVDVAL field.
	LCDC_LCDCON2_INVDVAL_Msk = 0x1000
	// Bit INVDVAL.
	LCDC_LCDCON2_INVDVAL = 0x1000
	// Position of CLKMOD field.
	LCDC_LCDCON2_CLKMOD_Pos = 0xf
	// Bit mask of CLKMOD field.
	LCDC_LCDCON2_CLKMOD_Msk = 0x8000
	// Bit CLKMOD.
	LCDC_LCDCON2_CLKMOD = 0x8000
	// Position of MEMOR field.
	LCDC_LCDCON2_MEMOR_Pos = 0x1e
	// Bit mask of MEMOR field.
	LCDC_LCDCON2_MEMOR_Msk = 0xc0000000

	// LCDTIM1: LCD Timing Register 1
	// Position of VFP field.
	LCDC_LCDTIM1_VFP_Pos = 0x0
	// Bit mask of VFP field.
	LCDC_LCDTIM1_VFP_Msk = 0xff
	// Position of VBP field.
	LCDC_LCDTIM1_VBP_Pos = 0x8
	// Bit mask of VBP field.
	LCDC_LCDTIM1_VBP_Msk = 0xff00
	// Position of VPW field.
	LCDC_LCDTIM1_VPW_Pos = 0x10
	// Bit mask of VPW field.
	LCDC_LCDTIM1_VPW_Msk = 0x3f0000
	// Position of VHDLY field.
	LCDC_LCDTIM1_VHDLY_Pos = 0x18
	// Bit mask of VHDLY field.
	LCDC_LCDTIM1_VHDLY_Msk = 0xf000000
	// Position of STUCKTO1 field.
	LCDC_LCDTIM1_STUCKTO1_Pos = 0x1f
	// Bit mask of STUCKTO1 field.
	LCDC_LCDTIM1_STUCKTO1_Msk = 0x80000000
	// Bit STUCKTO1.
	LCDC_LCDTIM1_STUCKTO1 = 0x80000000

	// LCDTIM2: LCD Timing Register 2
	// Position of HBP field.
	LCDC_LCDTIM2_HBP_Pos = 0x0
	// Bit mask of HBP field.
	LCDC_LCDTIM2_HBP_Msk = 0xff
	// Position of HPW field.
	LCDC_LCDTIM2_HPW_Pos = 0x8
	// Bit mask of HPW field.
	LCDC_LCDTIM2_HPW_Msk = 0x3f00
	// Position of HFP field.
	LCDC_LCDTIM2_HFP_Pos = 0x15
	// Bit mask of HFP field.
	LCDC_LCDTIM2_HFP_Msk = 0xffe00000

	// LCDFRMCFG: LCD Frame Configuration Register
	// Position of LINEVAL field.
	LCDC_LCDFRMCFG_LINEVAL_Pos = 0x0
	// Bit mask of LINEVAL field.
	LCDC_LCDFRMCFG_LINEVAL_Msk = 0x7ff
	// Position of LINESIZE field.
	LCDC_LCDFRMCFG_LINESIZE_Pos = 0x15
	// Bit mask of LINESIZE field.
	LCDC_LCDFRMCFG_LINESIZE_Msk = 0xffe00000

	// LCDFIFO: LCD FIFO Register
	// Position of FIFOTH field.
	LCDC_LCDFIFO_FIFOTH_Pos = 0x0
	// Bit mask of FIFOTH field.
	LCDC_LCDFIFO_FIFOTH_Msk = 0xffff

	// DP1_2: Dithering Pattern DP1_2
	// Position of DP1_2 field.
	LCDC_DP1_2_DP1_2_Pos = 0x0
	// Bit mask of DP1_2 field.
	LCDC_DP1_2_DP1_2_Msk = 0xff

	// DP4_7: Dithering Pattern DP4_7
	// Position of DP4_7 field.
	LCDC_DP4_7_DP4_7_Pos = 0x0
	// Bit mask of DP4_7 field.
	LCDC_DP4_7_DP4_7_Msk = 0xfffffff

	// DP3_5: Dithering Pattern DP3_5
	// Position of DP3_5 field.
	LCDC_DP3_5_DP3_5_Pos = 0x0
	// Bit mask of DP3_5 field.
	LCDC_DP3_5_DP3_5_Msk = 0xfffff

	// DP2_3: Dithering Pattern DP2_3
	// Position of DP2_3 field.
	LCDC_DP2_3_DP2_3_Pos = 0x0
	// Bit mask of DP2_3 field.
	LCDC_DP2_3_DP2_3_Msk = 0xfff

	// DP5_7: Dithering Pattern DP5_7
	// Position of DP5_7 field.
	LCDC_DP5_7_DP5_7_Pos = 0x0
	// Bit mask of DP5_7 field.
	LCDC_DP5_7_DP5_7_Msk = 0xfffffff

	// DP3_4: Dithering Pattern DP3_4
	// Position of DP3_4 field.
	LCDC_DP3_4_DP3_4_Pos = 0x0
	// Bit mask of DP3_4 field.
	LCDC_DP3_4_DP3_4_Msk = 0xffff

	// DP4_5: Dithering Pattern DP4_5
	// Position of DP4_5 field.
	LCDC_DP4_5_DP4_5_Pos = 0x0
	// Bit mask of DP4_5 field.
	LCDC_DP4_5_DP4_5_Msk = 0xfffff

	// DP6_7: Dithering Pattern DP6_7
	// Position of DP6_7 field.
	LCDC_DP6_7_DP6_7_Pos = 0x0
	// Bit mask of DP6_7 field.
	LCDC_DP6_7_DP6_7_Msk = 0xfffffff

	// PWRCON: Power Control Register
	// Position of LCD_PWR field.
	LCDC_PWRCON_LCD_PWR_Pos = 0x0
	// Bit mask of LCD_PWR field.
	LCDC_PWRCON_LCD_PWR_Msk = 0x1
	// Bit LCD_PWR.
	LCDC_PWRCON_LCD_PWR = 0x1
	// Position of GUARD_TIME field.
	LCDC_PWRCON_GUARD_TIME_Pos = 0x1
	// Bit mask of GUARD_TIME field.
	LCDC_PWRCON_GUARD_TIME_Msk = 0xfe
	// Position of LCD_BUSY field.
	LCDC_PWRCON_LCD_BUSY_Pos = 0x1f
	// Bit mask of LCD_BUSY field.
	LCDC_PWRCON_LCD_BUSY_Msk = 0x80000000
	// Bit LCD_BUSY.
	LCDC_PWRCON_LCD_BUSY = 0x80000000

	// CONTRAST_CTR: Contrast Control Register
	// Position of PS field.
	LCDC_CONTRAST_CTR_PS_Pos = 0x0
	// Bit mask of PS field.
	LCDC_CONTRAST_CTR_PS_Msk = 0x3
	// Position of POL field.
	LCDC_CONTRAST_CTR_POL_Pos = 0x2
	// Bit mask of POL field.
	LCDC_CONTRAST_CTR_POL_Msk = 0x4
	// Bit POL.
	LCDC_CONTRAST_CTR_POL = 0x4
	// Position of ENA field.
	LCDC_CONTRAST_CTR_ENA_Pos = 0x3
	// Bit mask of ENA field.
	LCDC_CONTRAST_CTR_ENA_Msk = 0x8
	// Bit ENA.
	LCDC_CONTRAST_CTR_ENA = 0x8

	// LCD_IER: LCD Interrupt Enable Register
	// Position of LNIE field.
	LCDC_LCD_IER_LNIE_Pos = 0x0
	// Bit mask of LNIE field.
	LCDC_LCD_IER_LNIE_Msk = 0x1
	// Bit LNIE.
	LCDC_LCD_IER_LNIE = 0x1
	// Position of LSTLNIE field.
	LCDC_LCD_IER_LSTLNIE_Pos = 0x1
	// Bit mask of LSTLNIE field.
	LCDC_LCD_IER_LSTLNIE_Msk = 0x2
	// Bit LSTLNIE.
	LCDC_LCD_IER_LSTLNIE = 0x2
	// Position of EOFIE field.
	LCDC_LCD_IER_EOFIE_Pos = 0x2
	// Bit mask of EOFIE field.
	LCDC_LCD_IER_EOFIE_Msk = 0x4
	// Bit EOFIE.
	LCDC_LCD_IER_EOFIE = 0x4
	// Position of UFLWIE field.
	LCDC_LCD_IER_UFLWIE_Pos = 0x4
	// Bit mask of UFLWIE field.
	LCDC_LCD_IER_UFLWIE_Msk = 0x10
	// Bit UFLWIE.
	LCDC_LCD_IER_UFLWIE = 0x10
	// Position of OWRIE field.
	LCDC_LCD_IER_OWRIE_Pos = 0x5
	// Bit mask of OWRIE field.
	LCDC_LCD_IER_OWRIE_Msk = 0x20
	// Bit OWRIE.
	LCDC_LCD_IER_OWRIE = 0x20
	// Position of MERIE field.
	LCDC_LCD_IER_MERIE_Pos = 0x6
	// Bit mask of MERIE field.
	LCDC_LCD_IER_MERIE_Msk = 0x40
	// Bit MERIE.
	LCDC_LCD_IER_MERIE = 0x40

	// LCD_IDR: LCD Interrupt Disable Register
	// Position of LNID field.
	LCDC_LCD_IDR_LNID_Pos = 0x0
	// Bit mask of LNID field.
	LCDC_LCD_IDR_LNID_Msk = 0x1
	// Bit LNID.
	LCDC_LCD_IDR_LNID = 0x1
	// Position of LSTLNID field.
	LCDC_LCD_IDR_LSTLNID_Pos = 0x1
	// Bit mask of LSTLNID field.
	LCDC_LCD_IDR_LSTLNID_Msk = 0x2
	// Bit LSTLNID.
	LCDC_LCD_IDR_LSTLNID = 0x2
	// Position of EOFID field.
	LCDC_LCD_IDR_EOFID_Pos = 0x2
	// Bit mask of EOFID field.
	LCDC_LCD_IDR_EOFID_Msk = 0x4
	// Bit EOFID.
	LCDC_LCD_IDR_EOFID = 0x4
	// Position of UFLWID field.
	LCDC_LCD_IDR_UFLWID_Pos = 0x4
	// Bit mask of UFLWID field.
	LCDC_LCD_IDR_UFLWID_Msk = 0x10
	// Bit UFLWID.
	LCDC_LCD_IDR_UFLWID = 0x10
	// Position of OWRID field.
	LCDC_LCD_IDR_OWRID_Pos = 0x5
	// Bit mask of OWRID field.
	LCDC_LCD_IDR_OWRID_Msk = 0x20
	// Bit OWRID.
	LCDC_LCD_IDR_OWRID = 0x20
	// Position of MERID field.
	LCDC_LCD_IDR_MERID_Pos = 0x6
	// Bit mask of MERID field.
	LCDC_LCD_IDR_MERID_Msk = 0x40
	// Bit MERID.
	LCDC_LCD_IDR_MERID = 0x40

	// LCD_IMR: LCD Interrupt Mask Register
	// Position of LNIM field.
	LCDC_LCD_IMR_LNIM_Pos = 0x0
	// Bit mask of LNIM field.
	LCDC_LCD_IMR_LNIM_Msk = 0x1
	// Bit LNIM.
	LCDC_LCD_IMR_LNIM = 0x1
	// Position of LSTLNIM field.
	LCDC_LCD_IMR_LSTLNIM_Pos = 0x1
	// Bit mask of LSTLNIM field.
	LCDC_LCD_IMR_LSTLNIM_Msk = 0x2
	// Bit LSTLNIM.
	LCDC_LCD_IMR_LSTLNIM = 0x2
	// Position of EOFIM field.
	LCDC_LCD_IMR_EOFIM_Pos = 0x2
	// Bit mask of EOFIM field.
	LCDC_LCD_IMR_EOFIM_Msk = 0x4
	// Bit EOFIM.
	LCDC_LCD_IMR_EOFIM = 0x4
	// Position of UFLWIM field.
	LCDC_LCD_IMR_UFLWIM_Pos = 0x4
	// Bit mask of UFLWIM field.
	LCDC_LCD_IMR_UFLWIM_Msk = 0x10
	// Bit UFLWIM.
	LCDC_LCD_IMR_UFLWIM = 0x10
	// Position of OWRIM field.
	LCDC_LCD_IMR_OWRIM_Pos = 0x5
	// Bit mask of OWRIM field.
	LCDC_LCD_IMR_OWRIM_Msk = 0x20
	// Bit OWRIM.
	LCDC_LCD_IMR_OWRIM = 0x20
	// Position of MERIM field.
	LCDC_LCD_IMR_MERIM_Pos = 0x6
	// Bit mask of MERIM field.
	LCDC_LCD_IMR_MERIM_Msk = 0x40
	// Bit MERIM.
	LCDC_LCD_IMR_MERIM = 0x40

	// LCD_ISR: LCD Interrupt Status Register
	// Position of LNIS field.
	LCDC_LCD_ISR_LNIS_Pos = 0x0
	// Bit mask of LNIS field.
	LCDC_LCD_ISR_LNIS_Msk = 0x1
	// Bit LNIS.
	LCDC_LCD_ISR_LNIS = 0x1
	// Position of LSTLNIS field.
	LCDC_LCD_ISR_LSTLNIS_Pos = 0x1
	// Bit mask of LSTLNIS field.
	LCDC_LCD_ISR_LSTLNIS_Msk = 0x2
	// Bit LSTLNIS.
	LCDC_LCD_ISR_LSTLNIS = 0x2
	// Position of EOFIS field.
	LCDC_LCD_ISR_EOFIS_Pos = 0x2
	// Bit mask of EOFIS field.
	LCDC_LCD_ISR_EOFIS_Msk = 0x4
	// Bit EOFIS.
	LCDC_LCD_ISR_EOFIS = 0x4
	// Position of UFLWIS field.
	LCDC_LCD_ISR_UFLWIS_Pos = 0x4
	// Bit mask of UFLWIS field.
	LCDC_LCD_ISR_UFLWIS_Msk = 0x10
	// Bit UFLWIS.
	LCDC_LCD_ISR_UFLWIS = 0x10
	// Position of OWRIS field.
	LCDC_LCD_ISR_OWRIS_Pos = 0x5
	// Bit mask of OWRIS field.
	LCDC_LCD_ISR_OWRIS_Msk = 0x20
	// Bit OWRIS.
	LCDC_LCD_ISR_OWRIS = 0x20
	// Position of MERIS field.
	LCDC_LCD_ISR_MERIS_Pos = 0x6
	// Bit mask of MERIS field.
	LCDC_LCD_ISR_MERIS_Msk = 0x40
	// Bit MERIS.
	LCDC_LCD_ISR_MERIS = 0x40

	// LCD_ICR: LCD Interrupt Clear Register
	// Position of LNIC field.
	LCDC_LCD_ICR_LNIC_Pos = 0x0
	// Bit mask of LNIC field.
	LCDC_LCD_ICR_LNIC_Msk = 0x1
	// Bit LNIC.
	LCDC_LCD_ICR_LNIC = 0x1
	// Position of LSTLNIC field.
	LCDC_LCD_ICR_LSTLNIC_Pos = 0x1
	// Bit mask of LSTLNIC field.
	LCDC_LCD_ICR_LSTLNIC_Msk = 0x2
	// Bit LSTLNIC.
	LCDC_LCD_ICR_LSTLNIC = 0x2
	// Position of EOFIC field.
	LCDC_LCD_ICR_EOFIC_Pos = 0x2
	// Bit mask of EOFIC field.
	LCDC_LCD_ICR_EOFIC_Msk = 0x4
	// Bit EOFIC.
	LCDC_LCD_ICR_EOFIC = 0x4
	// Position of UFLWIC field.
	LCDC_LCD_ICR_UFLWIC_Pos = 0x4
	// Bit mask of UFLWIC field.
	LCDC_LCD_ICR_UFLWIC_Msk = 0x10
	// Bit UFLWIC.
	LCDC_LCD_ICR_UFLWIC = 0x10
	// Position of OWRIC field.
	LCDC_LCD_ICR_OWRIC_Pos = 0x5
	// Bit mask of OWRIC field.
	LCDC_LCD_ICR_OWRIC_Msk = 0x20
	// Bit OWRIC.
	LCDC_LCD_ICR_OWRIC = 0x20
	// Position of MERIC field.
	LCDC_LCD_ICR_MERIC_Pos = 0x6
	// Bit mask of MERIC field.
	LCDC_LCD_ICR_MERIC_Msk = 0x40
	// Bit MERIC.
	LCDC_LCD_ICR_MERIC = 0x40

	// LCD_ITR: LCD Interrupt Test Register
	// Position of LNIT field.
	LCDC_LCD_ITR_LNIT_Pos = 0x0
	// Bit mask of LNIT field.
	LCDC_LCD_ITR_LNIT_Msk = 0x1
	// Bit LNIT.
	LCDC_LCD_ITR_LNIT = 0x1
	// Position of LSTLNIT field.
	LCDC_LCD_ITR_LSTLNIT_Pos = 0x1
	// Bit mask of LSTLNIT field.
	LCDC_LCD_ITR_LSTLNIT_Msk = 0x2
	// Bit LSTLNIT.
	LCDC_LCD_ITR_LSTLNIT = 0x2
	// Position of EOFIT field.
	LCDC_LCD_ITR_EOFIT_Pos = 0x2
	// Bit mask of EOFIT field.
	LCDC_LCD_ITR_EOFIT_Msk = 0x4
	// Bit EOFIT.
	LCDC_LCD_ITR_EOFIT = 0x4
	// Position of UFLWIT field.
	LCDC_LCD_ITR_UFLWIT_Pos = 0x4
	// Bit mask of UFLWIT field.
	LCDC_LCD_ITR_UFLWIT_Msk = 0x10
	// Bit UFLWIT.
	LCDC_LCD_ITR_UFLWIT = 0x10
	// Position of OWRIT field.
	LCDC_LCD_ITR_OWRIT_Pos = 0x5
	// Bit mask of OWRIT field.
	LCDC_LCD_ITR_OWRIT_Msk = 0x20
	// Bit OWRIT.
	LCDC_LCD_ITR_OWRIT = 0x20
	// Position of MERIT field.
	LCDC_LCD_ITR_MERIT_Pos = 0x6
	// Bit mask of MERIT field.
	LCDC_LCD_ITR_MERIT_Msk = 0x40
	// Bit MERIT.
	LCDC_LCD_ITR_MERIT = 0x40

	// LCD_IRR: LCD Interrupt Raw Status Register
	// Position of LNIR field.
	LCDC_LCD_IRR_LNIR_Pos = 0x0
	// Bit mask of LNIR field.
	LCDC_LCD_IRR_LNIR_Msk = 0x1
	// Bit LNIR.
	LCDC_LCD_IRR_LNIR = 0x1
	// Position of LSTLNIR field.
	LCDC_LCD_IRR_LSTLNIR_Pos = 0x1
	// Bit mask of LSTLNIR field.
	LCDC_LCD_IRR_LSTLNIR_Msk = 0x2
	// Bit LSTLNIR.
	LCDC_LCD_IRR_LSTLNIR = 0x2
	// Position of EOFIR field.
	LCDC_LCD_IRR_EOFIR_Pos = 0x2
	// Bit mask of EOFIR field.
	LCDC_LCD_IRR_EOFIR_Msk = 0x4
	// Bit EOFIR.
	LCDC_LCD_IRR_EOFIR = 0x4
	// Position of UFLWIR field.
	LCDC_LCD_IRR_UFLWIR_Pos = 0x4
	// Bit mask of UFLWIR field.
	LCDC_LCD_IRR_UFLWIR_Msk = 0x10
	// Bit UFLWIR.
	LCDC_LCD_IRR_UFLWIR = 0x10
	// Position of OWRIR field.
	LCDC_LCD_IRR_OWRIR_Pos = 0x5
	// Bit mask of OWRIR field.
	LCDC_LCD_IRR_OWRIR_Msk = 0x20
	// Bit OWRIR.
	LCDC_LCD_IRR_OWRIR = 0x20
	// Position of MERIR field.
	LCDC_LCD_IRR_MERIR_Pos = 0x6
	// Bit mask of MERIR field.
	LCDC_LCD_IRR_MERIR_Msk = 0x40
	// Bit MERIR.
	LCDC_LCD_IRR_MERIR = 0x40

	// LCD_WPSR: Write Protection Status Register
	// Position of WPVS field.
	LCDC_LCD_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	LCDC_LCD_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	LCDC_LCD_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	LCDC_LCD_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	LCDC_LCD_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for VDEC: Video Decoder
const (
	// IDR: ID Register
	// Position of BUILD_VER field.
	VDEC_IDR_BUILD_VER_Pos = 0x0
	// Bit mask of BUILD_VER field.
	VDEC_IDR_BUILD_VER_Msk = 0xf
	// Position of MINOR_VER field.
	VDEC_IDR_MINOR_VER_Pos = 0x4
	// Bit mask of MINOR_VER field.
	VDEC_IDR_MINOR_VER_Msk = 0xff0
	// Position of MAJOR_VER field.
	VDEC_IDR_MAJOR_VER_Pos = 0xc
	// Bit mask of MAJOR_VER field.
	VDEC_IDR_MAJOR_VER_Msk = 0xf000
	// Position of PROD_ID field.
	VDEC_IDR_PROD_ID_Pos = 0x10
	// Bit mask of PROD_ID field.
	VDEC_IDR_PROD_ID_Msk = 0xffff0000

	// DIR: Decoder Interrupt Register
	// Position of DE field.
	VDEC_DIR_DE_Pos = 0x0
	// Bit mask of DE field.
	VDEC_DIR_DE_Msk = 0x1
	// Bit DE.
	VDEC_DIR_DE = 0x1
	// Position of ID field.
	VDEC_DIR_ID_Pos = 0x4
	// Bit mask of ID field.
	VDEC_DIR_ID_Msk = 0x10
	// Bit ID.
	VDEC_DIR_ID = 0x10
	// Position of ISET field.
	VDEC_DIR_ISET_Pos = 0x8
	// Bit mask of ISET field.
	VDEC_DIR_ISET_Msk = 0x100
	// Bit ISET.
	VDEC_DIR_ISET = 0x100
	// Position of DR field.
	VDEC_DIR_DR_Pos = 0xc
	// Bit mask of DR field.
	VDEC_DIR_DR_Msk = 0x1000
	// Bit DR.
	VDEC_DIR_DR = 0x1000
	// Position of BE field.
	VDEC_DIR_BE_Pos = 0xd
	// Bit mask of BE field.
	VDEC_DIR_BE_Msk = 0x2000
	// Bit BE.
	VDEC_DIR_BE = 0x2000
	// Position of SBE field.
	VDEC_DIR_SBE_Pos = 0xe
	// Bit mask of SBE field.
	VDEC_DIR_SBE_Msk = 0x4000
	// Bit SBE.
	VDEC_DIR_SBE = 0x4000
	// Position of ASOD field.
	VDEC_DIR_ASOD_Pos = 0xf
	// Bit mask of ASOD field.
	VDEC_DIR_ASOD_Msk = 0x8000
	// Bit ASOD.
	VDEC_DIR_ASOD = 0x8000
	// Position of ISE field.
	VDEC_DIR_ISE_Pos = 0x10
	// Bit mask of ISE field.
	VDEC_DIR_ISE_Msk = 0x10000
	// Bit ISE.
	VDEC_DIR_ISE = 0x10000
	// Position of JPEGSD field.
	VDEC_DIR_JPEGSD_Pos = 0x11
	// Bit mask of JPEGSD field.
	VDEC_DIR_JPEGSD_Msk = 0x20000
	// Bit JPEGSD.
	VDEC_DIR_JPEGSD = 0x20000
	// Position of TO field.
	VDEC_DIR_TO_Pos = 0x12
	// Bit mask of TO field.
	VDEC_DIR_TO_Msk = 0x40000
	// Bit TO.
	VDEC_DIR_TO = 0x40000

	// DDCR: Decoder Device Configuration Register
	// Position of MAX_BURST_LEN field.
	VDEC_DDCR_MAX_BURST_LEN_Pos = 0x0
	// Bit mask of MAX_BURST_LEN field.
	VDEC_DDCR_MAX_BURST_LEN_Msk = 0x1f
	// Position of PRIOR field.
	VDEC_DDCR_PRIOR_Pos = 0x5
	// Bit mask of PRIOR field.
	VDEC_DDCR_PRIOR_Msk = 0xe0
	// Position of DO_LE field.
	VDEC_DDCR_DO_LE_Pos = 0x8
	// Bit mask of DO_LE field.
	VDEC_DDCR_DO_LE_Msk = 0x100
	// Bit DO_LE.
	VDEC_DDCR_DO_LE = 0x100
	// Position of INTCE_LE field.
	VDEC_DDCR_INTCE_LE_Pos = 0x9
	// Bit mask of INTCE_LE field.
	VDEC_DDCR_INTCE_LE_Msk = 0x200
	// Bit INTCE_LE.
	VDEC_DDCR_INTCE_LE = 0x200
	// Position of DDCGE field.
	VDEC_DDCR_DDCGE_Pos = 0xa
	// Bit mask of DDCGE field.
	VDEC_DDCR_DDCGE_Msk = 0x400
	// Bit DDCGE.
	VDEC_DDCR_DDCGE = 0x400
	// Position of LAT_COMP field.
	VDEC_DDCR_LAT_COMP_Pos = 0xb
	// Bit mask of LAT_COMP field.
	VDEC_DDCR_LAT_COMP_Msk = 0x1f800
	// Position of DOPF field.
	VDEC_DDCR_DOPF_Pos = 0x11
	// Bit mask of DOPF field.
	VDEC_DDCR_DOPF_Msk = 0x20000
	// Bit DOPF.
	VDEC_DDCR_DOPF = 0x20000
	// Position of AHB_BURST field.
	VDEC_DDCR_AHB_BURST_Pos = 0x12
	// Bit mask of AHB_BURST field.
	VDEC_DDCR_AHB_BURST_Msk = 0x40000
	// Bit AHB_BURST.
	VDEC_DDCR_AHB_BURST = 0x40000
	// Position of DI_LE field.
	VDEC_DDCR_DI_LE_Pos = 0x15
	// Bit mask of DI_LE field.
	VDEC_DDCR_DI_LE_Msk = 0x200000
	// Bit DI_LE.
	VDEC_DDCR_DI_LE = 0x200000
	// Position of HTI field.
	VDEC_DDCR_HTI_Pos = 0x17
	// Bit mask of HTI field.
	VDEC_DDCR_HTI_Msk = 0x800000
	// Bit HTI.
	VDEC_DDCR_HTI = 0x800000

	// CTLR0: Decoder Control Register 0
	// Position of HLOCK field.
	VDEC_CTLR0_HLOCK_Pos = 0x8
	// Bit mask of HLOCK field.
	VDEC_CTLR0_HLOCK_Msk = 0x100
	// Bit HLOCK.
	VDEC_CTLR0_HLOCK = 0x100
	// Position of REFFIRST field.
	VDEC_CTLR0_REFFIRST_Pos = 0xb
	// Bit mask of REFFIRST field.
	VDEC_CTLR0_REFFIRST_Msk = 0x800
	// Bit REFFIRST.
	VDEC_CTLR0_REFFIRST = 0x800
	// Position of MV field.
	VDEC_CTLR0_MV_Pos = 0xc
	// Bit mask of MV field.
	VDEC_CTLR0_MV_Msk = 0x1000
	// Bit MV.
	VDEC_CTLR0_MV = 0x1000
	// Position of QUANT field.
	VDEC_CTLR0_QUANT_Pos = 0xd
	// Bit mask of QUANT field.
	VDEC_CTLR0_QUANT_Msk = 0x2000
	// Bit QUANT.
	VDEC_CTLR0_QUANT = 0x2000
	// Position of FILTDIS field.
	VDEC_CTLR0_FILTDIS_Pos = 0xe
	// Bit mask of FILTDIS field.
	VDEC_CTLR0_FILTDIS_Msk = 0x4000
	// Bit FILTDIS.
	VDEC_CTLR0_FILTDIS = 0x4000
	// Position of OUTDIS field.
	VDEC_CTLR0_OUTDIS_Pos = 0xf
	// Bit mask of OUTDIS field.
	VDEC_CTLR0_OUTDIS_Msk = 0x8000
	// Bit OUTDIS.
	VDEC_CTLR0_OUTDIS = 0x8000
	// Position of REFFIELD field.
	VDEC_CTLR0_REFFIELD_Pos = 0x10
	// Bit mask of REFFIELD field.
	VDEC_CTLR0_REFFIELD_Msk = 0x10000
	// Bit REFFIELD.
	VDEC_CTLR0_REFFIELD = 0x10000
	// Position of FORWMODE field.
	VDEC_CTLR0_FORWMODE_Pos = 0x12
	// Bit mask of FORWMODE field.
	VDEC_CTLR0_FORWMODE_Msk = 0x40000
	// Bit FORWMODE.
	VDEC_CTLR0_FORWMODE = 0x40000
	// Position of PICFIELD field.
	VDEC_CTLR0_PICFIELD_Pos = 0x13
	// Bit mask of PICFIELD field.
	VDEC_CTLR0_PICFIELD_Msk = 0x80000
	// Bit PICFIELD.
	VDEC_CTLR0_PICFIELD = 0x80000
	// Position of PICTYPE field.
	VDEC_CTLR0_PICTYPE_Pos = 0x14
	// Bit mask of PICTYPE field.
	VDEC_CTLR0_PICTYPE_Msk = 0x100000
	// Bit PICTYPE.
	VDEC_CTLR0_PICTYPE = 0x100000
	// Position of PICBEN field.
	VDEC_CTLR0_PICBEN_Pos = 0x15
	// Bit mask of PICBEN field.
	VDEC_CTLR0_PICBEN_Msk = 0x200000
	// Bit PICBEN.
	VDEC_CTLR0_PICBEN = 0x200000
	// Position of PICSTRUCT field.
	VDEC_CTLR0_PICSTRUCT_Pos = 0x16
	// Bit mask of PICSTRUCT field.
	VDEC_CTLR0_PICSTRUCT_Msk = 0x400000
	// Bit PICSTRUCT.
	VDEC_CTLR0_PICSTRUCT = 0x400000
	// Position of PICMODE field.
	VDEC_CTLR0_PICMODE_Pos = 0x17
	// Bit mask of PICMODE field.
	VDEC_CTLR0_PICMODE_Msk = 0x800000
	// Bit PICMODE.
	VDEC_CTLR0_PICMODE = 0x800000
	// Position of RLCEN field.
	VDEC_CTLR0_RLCEN_Pos = 0x1b
	// Bit mask of RLCEN field.
	VDEC_CTLR0_RLCEN_Msk = 0x8000000
	// Bit RLCEN.
	VDEC_CTLR0_RLCEN = 0x8000000
	// Position of DEC_MODE field.
	VDEC_CTLR0_DEC_MODE_Pos = 0x1c
	// Bit mask of DEC_MODE field.
	VDEC_CTLR0_DEC_MODE_Msk = 0xf0000000

	// CTLR1: Decoder Control Register 1
	// Position of REF_FRAMES field.
	VDEC_CTLR1_REF_FRAMES_Pos = 0x0
	// Bit mask of REF_FRAMES field.
	VDEC_CTLR1_REF_FRAMES_Msk = 0x1f
	// Position of TOPF field.
	VDEC_CTLR1_TOPF_Pos = 0x5
	// Bit mask of TOPF field.
	VDEC_CTLR1_TOPF_Msk = 0x20
	// Bit TOPF.
	VDEC_CTLR1_TOPF = 0x20
	// Position of AVSM field.
	VDEC_CTLR1_AVSM_Pos = 0x6
	// Bit mask of AVSM field.
	VDEC_CTLR1_AVSM_Msk = 0x40
	// Bit AVSM.
	VDEC_CTLR1_AVSM = 0x40
	// Position of HEIGHT_OFF field.
	VDEC_CTLR1_HEIGHT_OFF_Pos = 0x7
	// Bit mask of HEIGHT_OFF field.
	VDEC_CTLR1_HEIGHT_OFF_Msk = 0x780
	// Position of PIC_HEIGHT field.
	VDEC_CTLR1_PIC_HEIGHT_Pos = 0xb
	// Bit mask of PIC_HEIGHT field.
	VDEC_CTLR1_PIC_HEIGHT_Msk = 0x7f800
	// Position of WIDTH_OFF field.
	VDEC_CTLR1_WIDTH_OFF_Pos = 0x13
	// Bit mask of WIDTH_OFF field.
	VDEC_CTLR1_WIDTH_OFF_Msk = 0x780000
	// Position of PIC_WIDTH field.
	VDEC_CTLR1_PIC_WIDTH_Pos = 0x17
	// Bit mask of PIC_WIDTH field.
	VDEC_CTLR1_PIC_WIDTH_Msk = 0xff800000

	// CTLR2: Decoder Control Register 2
	// Position of FIELDPIC field.
	VDEC_CTLR2_FIELDPIC_Pos = 0x0
	// Bit mask of FIELDPIC field.
	VDEC_CTLR2_FIELDPIC_Msk = 0x1
	// Bit FIELDPIC.
	VDEC_CTLR2_FIELDPIC = 0x1
	// Position of QP_FILT_CR_OFF field.
	VDEC_CTLR2_QP_FILT_CR_OFF_Pos = 0xe
	// Bit mask of QP_FILT_CR_OFF field.
	VDEC_CTLR2_QP_FILT_CR_OFF_Msk = 0x7c000
	// Position of QP_FILT_CB_OFF field.
	VDEC_CTLR2_QP_FILT_CB_OFF_Pos = 0x13
	// Bit mask of QP_FILT_CB_OFF field.
	VDEC_CTLR2_QP_FILT_CB_OFF_Msk = 0xf80000
	// Position of STREAM_START_BIT field.
	VDEC_CTLR2_STREAM_START_BIT_Pos = 0x1a
	// Bit mask of STREAM_START_BIT field.
	VDEC_CTLR2_STREAM_START_BIT_Msk = 0xfc000000

	// CTLR3: Decoder Control Register 3
	// Position of STREAM_LEN field.
	VDEC_CTLR3_STREAM_LEN_Pos = 0x0
	// Bit mask of STREAM_LEN field.
	VDEC_CTLR3_STREAM_LEN_Msk = 0xffffff
	// Position of INIT_QP field.
	VDEC_CTLR3_INIT_QP_Pos = 0x19
	// Bit mask of INIT_QP field.
	VDEC_CTLR3_INIT_QP_Msk = 0x7e000000
	// Position of ST_COD_EN field.
	VDEC_CTLR3_ST_COD_EN_Pos = 0x1f
	// Bit mask of ST_COD_EN field.
	VDEC_CTLR3_ST_COD_EN_Msk = 0x80000000
	// Bit ST_COD_EN.
	VDEC_CTLR3_ST_COD_EN = 0x80000000

	// CTLR4: Decoder Control Register 4
	// Position of FRAME_NUM field.
	VDEC_CTLR4_FRAME_NUM_Pos = 0x0
	// Bit mask of FRAME_NUM field.
	VDEC_CTLR4_FRAME_NUM_Msk = 0xffff
	// Position of FRAME_NUM_LEN field.
	VDEC_CTLR4_FRAME_NUM_LEN_Pos = 0x10
	// Bit mask of FRAME_NUM_LEN field.
	VDEC_CTLR4_FRAME_NUM_LEN_Msk = 0x1f0000
	// Position of W_BIPR field.
	VDEC_CTLR4_W_BIPR_Pos = 0x1a
	// Bit mask of W_BIPR field.
	VDEC_CTLR4_W_BIPR_Msk = 0xc000000
	// Position of W_PRED field.
	VDEC_CTLR4_W_PRED_Pos = 0x1c
	// Bit mask of W_PRED field.
	VDEC_CTLR4_W_PRED_Msk = 0x10000000
	// Bit W_PRED.
	VDEC_CTLR4_W_PRED = 0x10000000
	// Position of DIRMV_PRED field.
	VDEC_CTLR4_DIRMV_PRED_Pos = 0x1d
	// Bit mask of DIRMV_PRED field.
	VDEC_CTLR4_DIRMV_PRED_Msk = 0x20000000
	// Bit DIRMV_PRED.
	VDEC_CTLR4_DIRMV_PRED = 0x20000000
	// Position of BW field.
	VDEC_CTLR4_BW_Pos = 0x1e
	// Bit mask of BW field.
	VDEC_CTLR4_BW_Msk = 0x40000000
	// Bit BW.
	VDEC_CTLR4_BW = 0x40000000
	// Position of CABAC field.
	VDEC_CTLR4_CABAC_Pos = 0x1f
	// Bit mask of CABAC field.
	VDEC_CTLR4_CABAC_Msk = 0x80000000
	// Bit CABAC.
	VDEC_CTLR4_CABAC = 0x80000000

	// CTLR5: Decoder Control Register 5
	// Position of IDR_PIC_ID field.
	VDEC_CTLR5_IDR_PIC_ID_Pos = 0x0
	// Bit mask of IDR_PIC_ID field.
	VDEC_CTLR5_IDR_PIC_ID_Msk = 0xffff
	// Position of IDREN field.
	VDEC_CTLR5_IDREN_Pos = 0x10
	// Bit mask of IDREN field.
	VDEC_CTLR5_IDREN_Msk = 0x10000
	// Bit IDREN.
	VDEC_CTLR5_IDREN = 0x10000
	// Position of REF_PIC_LEN field.
	VDEC_CTLR5_REF_PIC_LEN_Pos = 0x11
	// Bit mask of REF_PIC_LEN field.
	VDEC_CTLR5_REF_PIC_LEN_Msk = 0xffe0000
	// Position of EIGHT58 field.
	VDEC_CTLR5_EIGHT58_Pos = 0x1c
	// Bit mask of EIGHT58 field.
	VDEC_CTLR5_EIGHT58_Msk = 0x10000000
	// Bit EIGHT58.
	VDEC_CTLR5_EIGHT58 = 0x10000000
	// Position of RD_PIC field.
	VDEC_CTLR5_RD_PIC_Pos = 0x1d
	// Bit mask of RD_PIC field.
	VDEC_CTLR5_RD_PIC_Msk = 0x20000000
	// Bit RD_PIC.
	VDEC_CTLR5_RD_PIC = 0x20000000
	// Position of FILT_CTRL field.
	VDEC_CTLR5_FILT_CTRL_Pos = 0x1e
	// Bit mask of FILT_CTRL field.
	VDEC_CTLR5_FILT_CTRL_Msk = 0x40000000
	// Bit FILT_CTRL.
	VDEC_CTLR5_FILT_CTRL = 0x40000000
	// Position of CONS_INTRA field.
	VDEC_CTLR5_CONS_INTRA_Pos = 0x1f
	// Bit mask of CONS_INTRA field.
	VDEC_CTLR5_CONS_INTRA_Msk = 0x80000000
	// Bit CONS_INTRA.
	VDEC_CTLR5_CONS_INTRA = 0x80000000

	// CTLR6: Decoder Control Register 6
	// Position of POC_LEN field.
	VDEC_CTLR6_POC_LEN_Pos = 0x0
	// Bit mask of POC_LEN field.
	VDEC_CTLR6_POC_LEN_Msk = 0xff
	// Position of REF_IDX0 field.
	VDEC_CTLR6_REF_IDX0_Pos = 0xe
	// Bit mask of REF_IDX0 field.
	VDEC_CTLR6_REF_IDX0_Msk = 0x7c000
	// Position of REF_IDX1 field.
	VDEC_CTLR6_REF_IDX1_Pos = 0x13
	// Bit mask of REF_IDX1 field.
	VDEC_CTLR6_REF_IDX1_Msk = 0xf80000
	// Position of PPS_ID field.
	VDEC_CTLR6_PPS_ID_Pos = 0x18
	// Bit mask of PPS_ID field.
	VDEC_CTLR6_PPS_ID_Msk = 0xff000000

	// DMVBA: Base Address for Differential Motion Vector
	// Position of MV_CONTROL_BASE field.
	VDEC_DMVBA_MV_CONTROL_BASE_Pos = 0x2
	// Bit mask of MV_CONTROL_BASE field.
	VDEC_DMVBA_MV_CONTROL_BASE_Msk = 0xfffffffc

	// CTLR7: Decoder Control Register 7
	// Position of BA field.
	VDEC_CTLR7_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_CTLR7_BA_Msk = 0xfffffffc

	// RLCVLCBA: RLC/VLC Data Base Address
	// Position of BA field.
	VDEC_RLCVLCBA_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_RLCVLCBA_BA_Msk = 0xfffffffc

	// PICTBA: Decoded Picture Base Address
	// Position of BA field.
	VDEC_PICTBA_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_PICTBA_BA_Msk = 0xfffffffc

	// PIDXBA: Reference Picture Index 0 Base Address
	// Position of BA field.
	VDEC_PIDXBA_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_PIDXBA_BA_Msk = 0xfffffffc

	// PNR0: Reference Picture Numbers Register 0
	// Position of REFER0 field.
	VDEC_PNR0_REFER0_Pos = 0x0
	// Bit mask of REFER0 field.
	VDEC_PNR0_REFER0_Msk = 0xffff
	// Position of REFER1 field.
	VDEC_PNR0_REFER1_Pos = 0x10
	// Bit mask of REFER1 field.
	VDEC_PNR0_REFER1_Msk = 0xffff0000

	// PNR1: Reference Picture Numbers Register 1
	// Position of REFER2 field.
	VDEC_PNR1_REFER2_Pos = 0x0
	// Bit mask of REFER2 field.
	VDEC_PNR1_REFER2_Msk = 0xffff
	// Position of REFER3 field.
	VDEC_PNR1_REFER3_Pos = 0x10
	// Bit mask of REFER3 field.
	VDEC_PNR1_REFER3_Msk = 0xffff0000

	// PNR3: Reference Picture Numbers Register 3
	// Position of REFER4 field.
	VDEC_PNR3_REFER4_Pos = 0x0
	// Bit mask of REFER4 field.
	VDEC_PNR3_REFER4_Msk = 0xffff
	// Position of REFER5 field.
	VDEC_PNR3_REFER5_Pos = 0x10
	// Bit mask of REFER5 field.
	VDEC_PNR3_REFER5_Msk = 0xffff0000

	// PNR4: Reference Picture Numbers Register 4
	// Position of REFER8 field.
	VDEC_PNR4_REFER8_Pos = 0x0
	// Bit mask of REFER8 field.
	VDEC_PNR4_REFER8_Msk = 0xffff
	// Position of REFER9 field.
	VDEC_PNR4_REFER9_Pos = 0x10
	// Bit mask of REFER9 field.
	VDEC_PNR4_REFER9_Msk = 0xffff0000

	// PNR5: Reference Picture Numbers Register 5
	// Position of REFER10 field.
	VDEC_PNR5_REFER10_Pos = 0x0
	// Bit mask of REFER10 field.
	VDEC_PNR5_REFER10_Msk = 0xffff
	// Position of REFER11 field.
	VDEC_PNR5_REFER11_Pos = 0x10
	// Bit mask of REFER11 field.
	VDEC_PNR5_REFER11_Msk = 0xffff0000

	// PNR6: Reference Picture Numbers Register 6
	// Position of REFER12 field.
	VDEC_PNR6_REFER12_Pos = 0x0
	// Bit mask of REFER12 field.
	VDEC_PNR6_REFER12_Msk = 0xffff
	// Position of REFER13 field.
	VDEC_PNR6_REFER13_Pos = 0x10
	// Bit mask of REFER13 field.
	VDEC_PNR6_REFER13_Msk = 0xffff0000

	// PNR7: Reference Picture Numbers Register 7
	// Position of REFER14 field.
	VDEC_PNR7_REFER14_Pos = 0x0
	// Bit mask of REFER14 field.
	VDEC_PNR7_REFER14_Msk = 0xffff
	// Position of REFER15 field.
	VDEC_PNR7_REFER15_Pos = 0x10
	// Bit mask of REFER15 field.
	VDEC_PNR7_REFER15_Msk = 0xffff0000

	// PLTFR: Reference Picture Long Term Flag Register
	// Position of LTF field.
	VDEC_PLTFR_LTF_Pos = 0x0
	// Bit mask of LTF field.
	VDEC_PLTFR_LTF_Msk = 0xffffffff

	// SDTBA: Standard Dependent Tables Base Address
	// Position of BA field.
	VDEC_SDTBA_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_SDTBA_BA_Msk = 0xfffffffc

	// DMMVBA: Direct Mode Motion Vector Base Address
	// Position of BA field.
	VDEC_DMMVBA_BA_Pos = 0x2
	// Bit mask of BA field.
	VDEC_DMMVBA_BA_Msk = 0xfffffffc

	// IRPLR0: H264 Initial Reference Picture List Register 0
	// Position of IREFL_FW0 field.
	VDEC_IRPLR0_IREFL_FW0_Pos = 0x0
	// Bit mask of IREFL_FW0 field.
	VDEC_IRPLR0_IREFL_FW0_Msk = 0x1f
	// Position of IREFL_BW0 field.
	VDEC_IRPLR0_IREFL_BW0_Pos = 0x5
	// Bit mask of IREFL_BW0 field.
	VDEC_IRPLR0_IREFL_BW0_Msk = 0x3e0
	// Position of IREFL_FW1 field.
	VDEC_IRPLR0_IREFL_FW1_Pos = 0xa
	// Bit mask of IREFL_FW1 field.
	VDEC_IRPLR0_IREFL_FW1_Msk = 0x7c00
	// Position of IREFL_BW1 field.
	VDEC_IRPLR0_IREFL_BW1_Pos = 0xf
	// Bit mask of IREFL_BW1 field.
	VDEC_IRPLR0_IREFL_BW1_Msk = 0xf8000
	// Position of IREFL_FW2 field.
	VDEC_IRPLR0_IREFL_FW2_Pos = 0x14
	// Bit mask of IREFL_FW2 field.
	VDEC_IRPLR0_IREFL_FW2_Msk = 0x1f00000
	// Position of IREFL_BW2 field.
	VDEC_IRPLR0_IREFL_BW2_Pos = 0x19
	// Bit mask of IREFL_BW2 field.
	VDEC_IRPLR0_IREFL_BW2_Msk = 0x3e000000

	// IRPLR1: H264 Initial Reference Picture List Register 1
	// Position of IREFL_FW3 field.
	VDEC_IRPLR1_IREFL_FW3_Pos = 0x0
	// Bit mask of IREFL_FW3 field.
	VDEC_IRPLR1_IREFL_FW3_Msk = 0x1f
	// Position of IREFL_BW3 field.
	VDEC_IRPLR1_IREFL_BW3_Pos = 0x5
	// Bit mask of IREFL_BW3 field.
	VDEC_IRPLR1_IREFL_BW3_Msk = 0x3e0
	// Position of IREFL_FW4 field.
	VDEC_IRPLR1_IREFL_FW4_Pos = 0xa
	// Bit mask of IREFL_FW4 field.
	VDEC_IRPLR1_IREFL_FW4_Msk = 0x7c00
	// Position of IREFL_BW4 field.
	VDEC_IRPLR1_IREFL_BW4_Pos = 0xf
	// Bit mask of IREFL_BW4 field.
	VDEC_IRPLR1_IREFL_BW4_Msk = 0xf8000
	// Position of IREFL_FW5 field.
	VDEC_IRPLR1_IREFL_FW5_Pos = 0x14
	// Bit mask of IREFL_FW5 field.
	VDEC_IRPLR1_IREFL_FW5_Msk = 0x1f00000
	// Position of IREFL_BW5 field.
	VDEC_IRPLR1_IREFL_BW5_Pos = 0x19
	// Bit mask of IREFL_BW5 field.
	VDEC_IRPLR1_IREFL_BW5_Msk = 0x3e000000

	// IRPLR2: H264 Initial Reference Picture List Register 2
	// Position of IREFL_FW6 field.
	VDEC_IRPLR2_IREFL_FW6_Pos = 0x0
	// Bit mask of IREFL_FW6 field.
	VDEC_IRPLR2_IREFL_FW6_Msk = 0x1f
	// Position of IREFL_BW6 field.
	VDEC_IRPLR2_IREFL_BW6_Pos = 0x5
	// Bit mask of IREFL_BW6 field.
	VDEC_IRPLR2_IREFL_BW6_Msk = 0x3e0
	// Position of IREFL_FW7 field.
	VDEC_IRPLR2_IREFL_FW7_Pos = 0xa
	// Bit mask of IREFL_FW7 field.
	VDEC_IRPLR2_IREFL_FW7_Msk = 0x7c00
	// Position of IREFL_BW7 field.
	VDEC_IRPLR2_IREFL_BW7_Pos = 0xf
	// Bit mask of IREFL_BW7 field.
	VDEC_IRPLR2_IREFL_BW7_Msk = 0xf8000
	// Position of IREFL_FW8 field.
	VDEC_IRPLR2_IREFL_FW8_Pos = 0x14
	// Bit mask of IREFL_FW8 field.
	VDEC_IRPLR2_IREFL_FW8_Msk = 0x1f00000
	// Position of IREFL_BW8 field.
	VDEC_IRPLR2_IREFL_BW8_Pos = 0x19
	// Bit mask of IREFL_BW8 field.
	VDEC_IRPLR2_IREFL_BW8_Msk = 0x3e000000

	// IRPLR3: H264 Initial Reference Picture List Register 3
	// Position of IREFL_FW9 field.
	VDEC_IRPLR3_IREFL_FW9_Pos = 0x0
	// Bit mask of IREFL_FW9 field.
	VDEC_IRPLR3_IREFL_FW9_Msk = 0x1f
	// Position of IREFL_BW9 field.
	VDEC_IRPLR3_IREFL_BW9_Pos = 0x5
	// Bit mask of IREFL_BW9 field.
	VDEC_IRPLR3_IREFL_BW9_Msk = 0x3e0
	// Position of IREFL_FW10 field.
	VDEC_IRPLR3_IREFL_FW10_Pos = 0xa
	// Bit mask of IREFL_FW10 field.
	VDEC_IRPLR3_IREFL_FW10_Msk = 0x7c00
	// Position of IREFL_BW10 field.
	VDEC_IRPLR3_IREFL_BW10_Pos = 0xf
	// Bit mask of IREFL_BW10 field.
	VDEC_IRPLR3_IREFL_BW10_Msk = 0xf8000
	// Position of IREFL_FW11 field.
	VDEC_IRPLR3_IREFL_FW11_Pos = 0x14
	// Bit mask of IREFL_FW11 field.
	VDEC_IRPLR3_IREFL_FW11_Msk = 0x1f00000
	// Position of IREFL_BW11 field.
	VDEC_IRPLR3_IREFL_BW11_Pos = 0x19
	// Bit mask of IREFL_BW11 field.
	VDEC_IRPLR3_IREFL_BW11_Msk = 0x3e000000

	// IRPLR4: H264 Initial Reference Picture List Register 4
	// Position of IREFL_FW12 field.
	VDEC_IRPLR4_IREFL_FW12_Pos = 0x0
	// Bit mask of IREFL_FW12 field.
	VDEC_IRPLR4_IREFL_FW12_Msk = 0x1f
	// Position of IREFL_BW12 field.
	VDEC_IRPLR4_IREFL_BW12_Pos = 0x5
	// Bit mask of IREFL_BW12 field.
	VDEC_IRPLR4_IREFL_BW12_Msk = 0x3e0
	// Position of IREFL_FW13 field.
	VDEC_IRPLR4_IREFL_FW13_Pos = 0xa
	// Bit mask of IREFL_FW13 field.
	VDEC_IRPLR4_IREFL_FW13_Msk = 0x7c00
	// Position of IREFL_BW13 field.
	VDEC_IRPLR4_IREFL_BW13_Pos = 0xf
	// Bit mask of IREFL_BW13 field.
	VDEC_IRPLR4_IREFL_BW13_Msk = 0xf8000
	// Position of IREFL_FW14 field.
	VDEC_IRPLR4_IREFL_FW14_Pos = 0x14
	// Bit mask of IREFL_FW14 field.
	VDEC_IRPLR4_IREFL_FW14_Msk = 0x1f00000
	// Position of IREFL_BW14 field.
	VDEC_IRPLR4_IREFL_BW14_Pos = 0x19
	// Bit mask of IREFL_BW14 field.
	VDEC_IRPLR4_IREFL_BW14_Msk = 0x3e000000

	// IRPLR5: H264 Initial Reference Picture List Register 5
	// Position of IREFL_FW15 field.
	VDEC_IRPLR5_IREFL_FW15_Pos = 0x0
	// Bit mask of IREFL_FW15 field.
	VDEC_IRPLR5_IREFL_FW15_Msk = 0x1f
	// Position of IREFL_BW15 field.
	VDEC_IRPLR5_IREFL_BW15_Pos = 0x5
	// Bit mask of IREFL_BW15 field.
	VDEC_IRPLR5_IREFL_BW15_Msk = 0x3e0

	// ECR: Error Concealment Register
	// Position of STARTMB_Y field.
	VDEC_ECR_STARTMB_Y_Pos = 0xf
	// Bit mask of STARTMB_Y field.
	VDEC_ECR_STARTMB_Y_Msk = 0x7f8000
	// Position of STARTMB_X field.
	VDEC_ECR_STARTMB_X_Pos = 0x17
	// Bit mask of STARTMB_X field.
	VDEC_ECR_STARTMB_X_Msk = 0xff800000
)

// Constants for UDPHS: USB High Speed Device Port
const (
	// CTRL: UDPHS Control Register
	// Position of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Pos = 0x0
	// Bit mask of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Msk = 0x7f
	// Position of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Pos = 0x7
	// Bit mask of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Msk = 0x80
	// Bit FADDR_EN.
	UDPHS_CTRL_FADDR_EN = 0x80
	// Position of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Pos = 0x8
	// Bit mask of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Msk = 0x100
	// Bit EN_UDPHS.
	UDPHS_CTRL_EN_UDPHS = 0x100
	// Position of DETACH field.
	UDPHS_CTRL_DETACH_Pos = 0x9
	// Bit mask of DETACH field.
	UDPHS_CTRL_DETACH_Msk = 0x200
	// Bit DETACH.
	UDPHS_CTRL_DETACH = 0x200
	// Position of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Pos = 0xa
	// Bit mask of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Msk = 0x400
	// Bit REWAKEUP.
	UDPHS_CTRL_REWAKEUP = 0x400
	// Position of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Pos = 0xb
	// Bit mask of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Msk = 0x800
	// Bit PULLD_DIS.
	UDPHS_CTRL_PULLD_DIS = 0x800

	// FNUM: UDPHS Frame Number Register
	// Position of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Pos = 0x0
	// Bit mask of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Msk = 0x7
	// Position of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Pos = 0x3
	// Bit mask of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Msk = 0x3ff8
	// Position of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Pos = 0x1f
	// Bit mask of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Msk = 0x80000000
	// Bit FNUM_ERR.
	UDPHS_FNUM_FNUM_ERR = 0x80000000

	// IEN: UDPHS Interrupt Enable Register
	// Position of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_IEN_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_IEN_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_IEN_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_IEN_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_IEN_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_IEN_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_IEN_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_IEN_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_IEN_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_IEN_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_IEN_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_IEN_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_IEN_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_IEN_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_IEN_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_IEN_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_IEN_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_IEN_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_IEN_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_IEN_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_IEN_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_IEN_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_IEN_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_IEN_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_IEN_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_IEN_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_IEN_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_IEN_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_IEN_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_IEN_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_IEN_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_IEN_EPT_6 = 0x4000
	// Position of DMA_1 field.
	UDPHS_IEN_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_IEN_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_IEN_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_IEN_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_IEN_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_IEN_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_IEN_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_IEN_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_IEN_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_IEN_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_IEN_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_IEN_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_IEN_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_IEN_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_IEN_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_IEN_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_IEN_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_IEN_DMA_6 = 0x40000000

	// INTSTA: UDPHS Interrupt Status Register
	// Position of SPEED field.
	UDPHS_INTSTA_SPEED_Pos = 0x0
	// Bit mask of SPEED field.
	UDPHS_INTSTA_SPEED_Msk = 0x1
	// Bit SPEED.
	UDPHS_INTSTA_SPEED = 0x1
	// Position of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_INTSTA_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_INTSTA_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_INTSTA_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_INTSTA_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_INTSTA_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_INTSTA_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_INTSTA_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_INTSTA_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_INTSTA_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_INTSTA_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_INTSTA_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_INTSTA_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_INTSTA_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_INTSTA_EPT_6 = 0x4000
	// Position of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_INTSTA_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_INTSTA_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_INTSTA_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_INTSTA_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_INTSTA_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_INTSTA_DMA_6 = 0x40000000

	// CLRINT: UDPHS Clear Interrupt Register
	// Position of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_CLRINT_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_CLRINT_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_CLRINT_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_CLRINT_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_CLRINT_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_CLRINT_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_CLRINT_UPSTR_RES = 0x80

	// EPTRST: UDPHS Endpoints Reset Register
	// Position of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Pos = 0x0
	// Bit mask of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Msk = 0x1
	// Bit EPT_0.
	UDPHS_EPTRST_EPT_0 = 0x1
	// Position of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Pos = 0x1
	// Bit mask of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Msk = 0x2
	// Bit EPT_1.
	UDPHS_EPTRST_EPT_1 = 0x2
	// Position of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Pos = 0x2
	// Bit mask of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Msk = 0x4
	// Bit EPT_2.
	UDPHS_EPTRST_EPT_2 = 0x4
	// Position of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Pos = 0x3
	// Bit mask of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Msk = 0x8
	// Bit EPT_3.
	UDPHS_EPTRST_EPT_3 = 0x8
	// Position of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Pos = 0x4
	// Bit mask of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Msk = 0x10
	// Bit EPT_4.
	UDPHS_EPTRST_EPT_4 = 0x10
	// Position of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Pos = 0x5
	// Bit mask of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Msk = 0x20
	// Bit EPT_5.
	UDPHS_EPTRST_EPT_5 = 0x20
	// Position of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Pos = 0x6
	// Bit mask of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Msk = 0x40
	// Bit EPT_6.
	UDPHS_EPTRST_EPT_6 = 0x40

	// TST: UDPHS Test Register
	// Position of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Pos = 0x0
	// Bit mask of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Msk = 0x3
	// Normal Mode: The macro is in Full Speed mode, ready to make a High Speed identification, if the host supports it and then to automatically switch to High Speed mode
	UDPHS_TST_SPEED_CFG_NORMAL = 0x0
	// Force High Speed: Set this value to force the hardware to work in High Speed mode. Only for debug or test purpose.
	UDPHS_TST_SPEED_CFG_HIGH_SPEED = 0x2
	// Force Full Speed: Set this value to force the hardware to work only in Full Speed mode. In this configuration, the macro will not respond to a High Speed reset handshake.
	UDPHS_TST_SPEED_CFG_FULL_SPEED = 0x3
	// Position of TST_J field.
	UDPHS_TST_TST_J_Pos = 0x2
	// Bit mask of TST_J field.
	UDPHS_TST_TST_J_Msk = 0x4
	// Bit TST_J.
	UDPHS_TST_TST_J = 0x4
	// Position of TST_K field.
	UDPHS_TST_TST_K_Pos = 0x3
	// Bit mask of TST_K field.
	UDPHS_TST_TST_K_Msk = 0x8
	// Bit TST_K.
	UDPHS_TST_TST_K = 0x8
	// Position of TST_PKT field.
	UDPHS_TST_TST_PKT_Pos = 0x4
	// Bit mask of TST_PKT field.
	UDPHS_TST_TST_PKT_Msk = 0x10
	// Bit TST_PKT.
	UDPHS_TST_TST_PKT = 0x10
	// Position of OPMODE2 field.
	UDPHS_TST_OPMODE2_Pos = 0x5
	// Bit mask of OPMODE2 field.
	UDPHS_TST_OPMODE2_Msk = 0x20
	// Bit OPMODE2.
	UDPHS_TST_OPMODE2 = 0x20

	// EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG0_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG0_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG0_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG0_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG0_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG0_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG0_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG0_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG0_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG0_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG0_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG0_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG0_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG0_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG0_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG0_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG0_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG0_EPT_MAPD = 0x80000000

	// EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_SHRT_PCKT = 0x80000000

	// EPTCTLENB0_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_SHRT_PCKT = 0x80000000

	// EPTCTL0_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA0_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA0_TXRDY = 0x800

	// EPTSETSTA0_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA0_NAK_OUT = 0x8000

	// EPTCLRSTA0_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA0_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_SHRT_PCKT = 0x80000000

	// EPTSTA0_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG1_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG1_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG1_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG1_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG1_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG1_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG1_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG1_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG1_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG1_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG1_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG1_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG1_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG1_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG1_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG1_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG1_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG1_EPT_MAPD = 0x80000000

	// EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_SHRT_PCKT = 0x80000000

	// EPTCTLENB1_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_SHRT_PCKT = 0x80000000

	// EPTCTL1_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA1_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA1_TXRDY = 0x800

	// EPTSETSTA1_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA1_NAK_OUT = 0x8000

	// EPTCLRSTA1_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA1_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_SHRT_PCKT = 0x80000000

	// EPTSTA1_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG2_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG2_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG2_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG2_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG2_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG2_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG2_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG2_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG2_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG2_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG2_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG2_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG2_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG2_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG2_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG2_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG2_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG2_EPT_MAPD = 0x80000000

	// EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_SHRT_PCKT = 0x80000000

	// EPTCTLENB2_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_SHRT_PCKT = 0x80000000

	// EPTCTL2_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA2_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA2_TXRDY = 0x800

	// EPTSETSTA2_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA2_NAK_OUT = 0x8000

	// EPTCLRSTA2_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA2_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_SHRT_PCKT = 0x80000000

	// EPTSTA2_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG3_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG3_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG3_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG3_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG3_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG3_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG3_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG3_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG3_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG3_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG3_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG3_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG3_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG3_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG3_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG3_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG3_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG3_EPT_MAPD = 0x80000000

	// EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_SHRT_PCKT = 0x80000000

	// EPTCTLENB3_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_SHRT_PCKT = 0x80000000

	// EPTCTL3_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA3_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA3_TXRDY = 0x800

	// EPTSETSTA3_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA3_NAK_OUT = 0x8000

	// EPTCLRSTA3_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA3_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_SHRT_PCKT = 0x80000000

	// EPTSTA3_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG4_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG4_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG4_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG4_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG4_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG4_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG4_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG4_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG4_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG4_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG4_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG4_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG4_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG4_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG4_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG4_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG4_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG4_EPT_MAPD = 0x80000000

	// EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_SHRT_PCKT = 0x80000000

	// EPTCTLENB4_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_SHRT_PCKT = 0x80000000

	// EPTCTL4_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA4_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA4_TXRDY = 0x800

	// EPTSETSTA4_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA4_NAK_OUT = 0x8000

	// EPTCLRSTA4_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA4_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_SHRT_PCKT = 0x80000000

	// EPTSTA4_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG5_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG5_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG5_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG5_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG5_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG5_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG5_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG5_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG5_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG5_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG5_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG5_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG5_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG5_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG5_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG5_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG5_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG5_EPT_MAPD = 0x80000000

	// EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_SHRT_PCKT = 0x80000000

	// EPTCTLENB5_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_SHRT_PCKT = 0x80000000

	// EPTCTL5_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA5_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA5_TXRDY = 0x800

	// EPTSETSTA5_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA5_NAK_OUT = 0x8000

	// EPTCLRSTA5_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA5_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_SHRT_PCKT = 0x80000000

	// EPTSTA5_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG6_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG6_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG6_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG6_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG6_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG6_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG6_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG6_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG6_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG6_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG6_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG6_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG6_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG6_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG6_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG6_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG6_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG6_EPT_MAPD = 0x80000000

	// EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_SHRT_PCKT = 0x80000000

	// EPTCTLENB6_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_SHRT_PCKT = 0x80000000

	// EPTCTL6_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA6_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA6_TXRDY = 0x800

	// EPTSETSTA6_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA6_NAK_OUT = 0x8000

	// EPTCLRSTA6_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA6_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_SHRT_PCKT = 0x80000000

	// EPTSTA6_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT = 0x80000000

	// DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL0_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL0_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL0_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL0_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL0_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL0_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL0_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL0_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS0_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS0_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS0_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS0_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS0_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL1_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL1_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL1_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL1_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL1_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL1_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL1_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL1_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS1_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS1_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS1_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS1_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS1_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL2_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL2_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL2_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL2_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL2_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL2_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL2_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL2_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS2_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS2_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS2_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS2_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS2_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL3_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL3_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL3_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL3_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL3_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL3_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL3_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL3_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS3_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS3_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS3_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS3_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS3_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL4_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL4_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL4_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL4_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL4_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL4_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL4_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL4_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS4_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS4_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS4_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS4_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS4_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL5_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL5_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL5_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL5_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL5_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL5_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL5_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL5_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS5_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS5_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS5_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS5_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS5_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Msk = 0xffff0000
)

// Constants for TC0: Timer Counter 0
const (
	// CCR0: Channel Control Register (channel = 0)
	// Position of CLKEN field.
	TC_CCR0_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR0_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR0_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR0_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR0_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR0_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR0_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR0_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR0_SWTRG = 0x4

	// CMR0: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR0_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR0_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR0_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR0_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR0_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR0_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR0_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR0_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR0_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR0_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR0_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR0_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR0_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR0_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR0_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR0_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR0_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR0_LDRA_Msk = 0x30000
	// None
	TC_CMR0_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR0_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR0_LDRB_Msk = 0xc0000
	// None
	TC_CMR0_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRB_EDGE = 0x3

	// CMR0_WAVE_EQ_1: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR0_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR0_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR0_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR0_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR0_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR0_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR0_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR0_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UP mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP_RC = 0x1
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR0_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR0_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR0_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR0_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR0_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR0_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// CV0: Counter Value (channel = 0)
	// Position of CV field.
	TC_CV0_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV0_CV_Msk = 0xffff

	// RA0: Register A (channel = 0)
	// Position of RA field.
	TC_RA0_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA0_RA_Msk = 0xffff

	// RB0: Register B (channel = 0)
	// Position of RB field.
	TC_RB0_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB0_RB_Msk = 0xffff

	// RC0: Register C (channel = 0)
	// Position of RC field.
	TC_RC0_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC0_RC_Msk = 0xffff

	// SR0: Status Register (channel = 0)
	// Position of COVFS field.
	TC_SR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR0_CPAS = 0x4
	// Position of CPBS field.
	TC_SR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR0_CPBS = 0x8
	// Position of CPCS field.
	TC_SR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR0_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR0_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR0_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR0_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR0_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR0_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR0_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR0_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR0_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR0_MTIOB = 0x40000

	// IER0: Interrupt Enable Register (channel = 0)
	// Position of COVFS field.
	TC_IER0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER0_CPAS = 0x4
	// Position of CPBS field.
	TC_IER0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER0_CPBS = 0x8
	// Position of CPCS field.
	TC_IER0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER0_ETRGS = 0x80

	// IDR0: Interrupt Disable Register (channel = 0)
	// Position of COVFS field.
	TC_IDR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR0_ETRGS = 0x80

	// IMR0: Interrupt Mask Register (channel = 0)
	// Position of COVFS field.
	TC_IMR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR0_ETRGS = 0x80

	// CCR1: Channel Control Register (channel = 1)
	// Position of CLKEN field.
	TC_CCR1_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR1_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR1_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR1_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR1_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR1_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR1_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR1_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR1_SWTRG = 0x4

	// CMR1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR1_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR1_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR1_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR1_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR1_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR1_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR1_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR1_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR1_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR1_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR1_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR1_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR1_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR1_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR1_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR1_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR1_LDRA_Msk = 0x30000
	// None
	TC_CMR1_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR1_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR1_LDRB_Msk = 0xc0000
	// None
	TC_CMR1_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRB_EDGE = 0x3

	// CMR1_WAVE_EQ_1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR1_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR1_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR1_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR1_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR1_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR1_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR1_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR1_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UP mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP_RC = 0x1
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR1_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR1_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR1_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR1_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR1_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR1_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// CV1: Counter Value (channel = 1)
	// Position of CV field.
	TC_CV1_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV1_CV_Msk = 0xffff

	// RA1: Register A (channel = 1)
	// Position of RA field.
	TC_RA1_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA1_RA_Msk = 0xffff

	// RB1: Register B (channel = 1)
	// Position of RB field.
	TC_RB1_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB1_RB_Msk = 0xffff

	// RC1: Register C (channel = 1)
	// Position of RC field.
	TC_RC1_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC1_RC_Msk = 0xffff

	// SR1: Status Register (channel = 1)
	// Position of COVFS field.
	TC_SR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR1_CPAS = 0x4
	// Position of CPBS field.
	TC_SR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR1_CPBS = 0x8
	// Position of CPCS field.
	TC_SR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR1_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR1_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR1_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR1_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR1_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR1_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR1_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR1_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR1_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR1_MTIOB = 0x40000

	// IER1: Interrupt Enable Register (channel = 1)
	// Position of COVFS field.
	TC_IER1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER1_CPAS = 0x4
	// Position of CPBS field.
	TC_IER1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER1_CPBS = 0x8
	// Position of CPCS field.
	TC_IER1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER1_ETRGS = 0x80

	// IDR1: Interrupt Disable Register (channel = 1)
	// Position of COVFS field.
	TC_IDR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR1_ETRGS = 0x80

	// IMR1: Interrupt Mask Register (channel = 1)
	// Position of COVFS field.
	TC_IMR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR1_ETRGS = 0x80

	// CCR2: Channel Control Register (channel = 2)
	// Position of CLKEN field.
	TC_CCR2_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR2_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR2_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR2_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR2_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR2_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR2_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR2_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR2_SWTRG = 0x4

	// CMR2: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR2_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR2_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR2_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR2_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR2_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR2_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR2_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR2_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR2_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR2_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR2_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR2_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR2_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR2_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR2_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR2_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR2_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR2_LDRA_Msk = 0x30000
	// None
	TC_CMR2_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR2_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR2_LDRB_Msk = 0xc0000
	// None
	TC_CMR2_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRB_EDGE = 0x3

	// CMR2_WAVE_EQ_1: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR2_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR2_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR2_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR2_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR2_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR2_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR2_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR2_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UP mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP_RC = 0x1
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR2_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR2_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR2_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR2_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR2_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR2_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// CV2: Counter Value (channel = 2)
	// Position of CV field.
	TC_CV2_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV2_CV_Msk = 0xffff

	// RA2: Register A (channel = 2)
	// Position of RA field.
	TC_RA2_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA2_RA_Msk = 0xffff

	// RB2: Register B (channel = 2)
	// Position of RB field.
	TC_RB2_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB2_RB_Msk = 0xffff

	// RC2: Register C (channel = 2)
	// Position of RC field.
	TC_RC2_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC2_RC_Msk = 0xffff

	// SR2: Status Register (channel = 2)
	// Position of COVFS field.
	TC_SR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR2_CPAS = 0x4
	// Position of CPBS field.
	TC_SR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR2_CPBS = 0x8
	// Position of CPCS field.
	TC_SR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR2_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR2_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR2_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR2_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR2_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR2_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR2_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR2_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR2_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR2_MTIOB = 0x40000

	// IER2: Interrupt Enable Register (channel = 2)
	// Position of COVFS field.
	TC_IER2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER2_CPAS = 0x4
	// Position of CPBS field.
	TC_IER2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER2_CPBS = 0x8
	// Position of CPCS field.
	TC_IER2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER2_ETRGS = 0x80

	// IDR2: Interrupt Disable Register (channel = 2)
	// Position of COVFS field.
	TC_IDR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR2_ETRGS = 0x80

	// IMR2: Interrupt Mask Register (channel = 2)
	// Position of COVFS field.
	TC_IMR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR2_ETRGS = 0x80

	// BCR: Block Control Register
	// Position of SYNC field.
	TC_BCR_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	TC_BCR_SYNC_Msk = 0x1
	// Bit SYNC.
	TC_BCR_SYNC = 0x1

	// BMR: Block Mode Register
	// Position of TC0XC0S field.
	TC_BMR_TC0XC0S_Pos = 0x0
	// Bit mask of TC0XC0S field.
	TC_BMR_TC0XC0S_Msk = 0x3
	// Signal connected to XC0: TCLK0
	TC_BMR_TC0XC0S_TCLK0 = 0x0
	// Signal connected to XC0: TCLK1
	TC_BMR_TC0XC0S_TCLK1 = 0x2
	// Signal connected to XC0: TCLK2
	TC_BMR_TC0XC0S_TCLK2 = 0x3
	// Position of TC1XC1S field.
	TC_BMR_TC1XC1S_Pos = 0x2
	// Bit mask of TC1XC1S field.
	TC_BMR_TC1XC1S_Msk = 0xc
	// Signal connected to XC1: TCLK0
	TC_BMR_TC1XC1S_TCLK0 = 0x0
	// Signal connected to XC1: TCLK1
	TC_BMR_TC1XC1S_TCLK1 = 0x2
	// Signal connected to XC1: TCLK2
	TC_BMR_TC1XC1S_TCLK2 = 0x3
	// Position of TC2XC2S field.
	TC_BMR_TC2XC2S_Pos = 0x4
	// Bit mask of TC2XC2S field.
	TC_BMR_TC2XC2S_Msk = 0x30
	// Signal connected to XC2: TCLK0
	TC_BMR_TC2XC2S_TCLK0 = 0x0
	// Signal connected to XC2: TCLK1
	TC_BMR_TC2XC2S_TCLK1 = 0x2
	// Signal connected to XC2: TCLK2
	TC_BMR_TC2XC2S_TCLK2 = 0x3
)

// Constants for HSMCI0: High Speed MultiMedia Card Interface 0
const (
	// CR: Control Register
	// Position of MCIEN field.
	HSMCI_CR_MCIEN_Pos = 0x0
	// Bit mask of MCIEN field.
	HSMCI_CR_MCIEN_Msk = 0x1
	// Bit MCIEN.
	HSMCI_CR_MCIEN = 0x1
	// Position of MCIDIS field.
	HSMCI_CR_MCIDIS_Pos = 0x1
	// Bit mask of MCIDIS field.
	HSMCI_CR_MCIDIS_Msk = 0x2
	// Bit MCIDIS.
	HSMCI_CR_MCIDIS = 0x2
	// Position of PWSEN field.
	HSMCI_CR_PWSEN_Pos = 0x2
	// Bit mask of PWSEN field.
	HSMCI_CR_PWSEN_Msk = 0x4
	// Bit PWSEN.
	HSMCI_CR_PWSEN = 0x4
	// Position of PWSDIS field.
	HSMCI_CR_PWSDIS_Pos = 0x3
	// Bit mask of PWSDIS field.
	HSMCI_CR_PWSDIS_Msk = 0x8
	// Bit PWSDIS.
	HSMCI_CR_PWSDIS = 0x8
	// Position of SWRST field.
	HSMCI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	HSMCI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	HSMCI_CR_SWRST = 0x80

	// MR: Mode Register
	// Position of CLKDIV field.
	HSMCI_MR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	HSMCI_MR_CLKDIV_Msk = 0xff
	// Position of PWSDIV field.
	HSMCI_MR_PWSDIV_Pos = 0x8
	// Bit mask of PWSDIV field.
	HSMCI_MR_PWSDIV_Msk = 0x700
	// Position of RDPROOF field.
	HSMCI_MR_RDPROOF_Pos = 0xb
	// Bit mask of RDPROOF field.
	HSMCI_MR_RDPROOF_Msk = 0x800
	// Bit RDPROOF.
	HSMCI_MR_RDPROOF = 0x800
	// Position of WRPROOF field.
	HSMCI_MR_WRPROOF_Pos = 0xc
	// Bit mask of WRPROOF field.
	HSMCI_MR_WRPROOF_Msk = 0x1000
	// Bit WRPROOF.
	HSMCI_MR_WRPROOF = 0x1000
	// Position of FBYTE field.
	HSMCI_MR_FBYTE_Pos = 0xd
	// Bit mask of FBYTE field.
	HSMCI_MR_FBYTE_Msk = 0x2000
	// Bit FBYTE.
	HSMCI_MR_FBYTE = 0x2000
	// Position of PADV field.
	HSMCI_MR_PADV_Pos = 0xe
	// Bit mask of PADV field.
	HSMCI_MR_PADV_Msk = 0x4000
	// Bit PADV.
	HSMCI_MR_PADV = 0x4000
	// Position of BLKLEN field.
	HSMCI_MR_BLKLEN_Pos = 0x10
	// Bit mask of BLKLEN field.
	HSMCI_MR_BLKLEN_Msk = 0xffff0000

	// DTOR: Data Timeout Register
	// Position of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Pos = 0x0
	// Bit mask of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Msk = 0xf
	// Position of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Pos = 0x4
	// Bit mask of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Msk = 0x70
	// DTOCYC
	HSMCI_DTOR_DTOMUL_1 = 0x0
	// DTOCYC x 16
	HSMCI_DTOR_DTOMUL_16 = 0x1
	// DTOCYC x 128
	HSMCI_DTOR_DTOMUL_128 = 0x2
	// DTOCYC x 256
	HSMCI_DTOR_DTOMUL_256 = 0x3
	// DTOCYC x 1024
	HSMCI_DTOR_DTOMUL_1024 = 0x4
	// DTOCYC x 4096
	HSMCI_DTOR_DTOMUL_4096 = 0x5
	// DTOCYC x 65536
	HSMCI_DTOR_DTOMUL_65536 = 0x6
	// DTOCYC x 1048576
	HSMCI_DTOR_DTOMUL_1048576 = 0x7

	// SDCR: SD/SDIO Card Register
	// Position of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Pos = 0x0
	// Bit mask of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Msk = 0x3
	// Slot A is selected.
	HSMCI_SDCR_SDCSEL_SLOTA = 0x0
	// -
	HSMCI_SDCR_SDCSEL_SLOTB = 0x1
	// -
	HSMCI_SDCR_SDCSEL_SLOTC = 0x2
	// -
	HSMCI_SDCR_SDCSEL_SLOTD = 0x3
	// Position of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Pos = 0x6
	// Bit mask of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Msk = 0xc0
	// 1 bit
	HSMCI_SDCR_SDCBUS_1 = 0x0
	// 4 bit
	HSMCI_SDCR_SDCBUS_4 = 0x1
	// 8 bit
	HSMCI_SDCR_SDCBUS_8 = 0x2

	// ARGR: Argument Register
	// Position of ARG field.
	HSMCI_ARGR_ARG_Pos = 0x0
	// Bit mask of ARG field.
	HSMCI_ARGR_ARG_Msk = 0xffffffff

	// CMDR: Command Register
	// Position of CMDNB field.
	HSMCI_CMDR_CMDNB_Pos = 0x0
	// Bit mask of CMDNB field.
	HSMCI_CMDR_CMDNB_Msk = 0x3f
	// Position of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Pos = 0x6
	// Bit mask of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Msk = 0xc0
	// No response.
	HSMCI_CMDR_RSPTYP_NORESP = 0x0
	// 48-bit response.
	HSMCI_CMDR_RSPTYP_48_BIT = 0x1
	// 136-bit response.
	HSMCI_CMDR_RSPTYP_136_BIT = 0x2
	// R1b response type
	HSMCI_CMDR_RSPTYP_R1B = 0x3
	// Position of SPCMD field.
	HSMCI_CMDR_SPCMD_Pos = 0x8
	// Bit mask of SPCMD field.
	HSMCI_CMDR_SPCMD_Msk = 0x700
	// Not a special CMD.
	HSMCI_CMDR_SPCMD_STD = 0x0
	// Initialization CMD:74 clock cycles for initialization sequence.
	HSMCI_CMDR_SPCMD_INIT = 0x1
	// Synchronized CMD:Wait for the end of the current data block transfer before sending the pending command.
	HSMCI_CMDR_SPCMD_SYNC = 0x2
	// CE-ATA Completion Signal disable Command.The host cancels the ability for the device to return a command completion signal on the command line.
	HSMCI_CMDR_SPCMD_CE_ATA = 0x3
	// Interrupt command:Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_CMD = 0x4
	// Interrupt response:Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_RESP = 0x5
	// Boot Operation Request.Start a boot operation mode, the host processor can read boot data from the MMC device directly.
	HSMCI_CMDR_SPCMD_BOR = 0x6
	// End Boot Operation.This command allows the host processor to terminate the boot operation mode.
	HSMCI_CMDR_SPCMD_EBO = 0x7
	// Position of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Pos = 0xb
	// Bit mask of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Msk = 0x800
	// Bit OPDCMD.
	HSMCI_CMDR_OPDCMD = 0x800
	// Push pull command.
	HSMCI_CMDR_OPDCMD_PUSHPULL = 0x0
	// Open drain command.
	HSMCI_CMDR_OPDCMD_OPENDRAIN = 0x1
	// Position of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Pos = 0xc
	// Bit mask of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Msk = 0x1000
	// Bit MAXLAT.
	HSMCI_CMDR_MAXLAT = 0x1000
	// 5-cycle max latency.
	HSMCI_CMDR_MAXLAT_5 = 0x0
	// 64-cycle max latency.
	HSMCI_CMDR_MAXLAT_64 = 0x1
	// Position of TRCMD field.
	HSMCI_CMDR_TRCMD_Pos = 0x10
	// Bit mask of TRCMD field.
	HSMCI_CMDR_TRCMD_Msk = 0x30000
	// No data transfer
	HSMCI_CMDR_TRCMD_NO_DATA = 0x0
	// Start data transfer
	HSMCI_CMDR_TRCMD_START_DATA = 0x1
	// Stop data transfer
	HSMCI_CMDR_TRCMD_STOP_DATA = 0x2
	// Position of TRDIR field.
	HSMCI_CMDR_TRDIR_Pos = 0x12
	// Bit mask of TRDIR field.
	HSMCI_CMDR_TRDIR_Msk = 0x40000
	// Bit TRDIR.
	HSMCI_CMDR_TRDIR = 0x40000
	// Write.
	HSMCI_CMDR_TRDIR_WRITE = 0x0
	// Read.
	HSMCI_CMDR_TRDIR_READ = 0x1
	// Position of TRTYP field.
	HSMCI_CMDR_TRTYP_Pos = 0x13
	// Bit mask of TRTYP field.
	HSMCI_CMDR_TRTYP_Msk = 0x380000
	// MMC/SDCard Single Block
	HSMCI_CMDR_TRTYP_SINGLE = 0x0
	// MMC/SDCard Multiple Block
	HSMCI_CMDR_TRTYP_MULTIPLE = 0x1
	// MMC Stream
	HSMCI_CMDR_TRTYP_STREAM = 0x2
	// SDIO Byte
	HSMCI_CMDR_TRTYP_BYTE = 0x4
	// SDIO Block
	HSMCI_CMDR_TRTYP_BLOCK = 0x5
	// Position of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Pos = 0x18
	// Bit mask of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Msk = 0x3000000
	// Not an SDIO Special Command
	HSMCI_CMDR_IOSPCMD_STD = 0x0
	// SDIO Suspend Command
	HSMCI_CMDR_IOSPCMD_SUSPEND = 0x1
	// SDIO Resume Command
	HSMCI_CMDR_IOSPCMD_RESUME = 0x2
	// Position of ATACS field.
	HSMCI_CMDR_ATACS_Pos = 0x1a
	// Bit mask of ATACS field.
	HSMCI_CMDR_ATACS_Msk = 0x4000000
	// Bit ATACS.
	HSMCI_CMDR_ATACS = 0x4000000
	// Normal operation mode.
	HSMCI_CMDR_ATACS_NORMAL = 0x0
	// This bit indicates that a completion signal is expected within a programmed amount of time (HSMCI_CSTOR).
	HSMCI_CMDR_ATACS_COMPLETION = 0x1
	// Position of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Pos = 0x1b
	// Bit mask of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Msk = 0x8000000
	// Bit BOOT_ACK.
	HSMCI_CMDR_BOOT_ACK = 0x8000000

	// BLKR: Block Register
	// Position of BCNT field.
	HSMCI_BLKR_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	HSMCI_BLKR_BCNT_Msk = 0xffff
	// MMC/SDCARD Multiple BlockFrom 1 to 65635: Value 0 corresponds to an infinite block transfer.
	HSMCI_BLKR_BCNT_MULTIPLE = 0x0
	// SDIO ByteFrom 1 to 512 bytes: Value 0 corresponds to a 512-byte transfer.Values from 0x200 to 0xFFFF are forbidden.
	HSMCI_BLKR_BCNT_BYTE = 0x4
	// SDIO BlockFrom 1 to 511 blocks: Value 0 corresponds to an infinite block transfer.Values from 0x200 to 0xFFFF are forbidden.
	HSMCI_BLKR_BCNT_BLOCK = 0x5
	// Position of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Pos = 0x10
	// Bit mask of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Msk = 0xffff0000

	// CSTOR: Completion Signal Timeout Register
	// Position of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Pos = 0x0
	// Bit mask of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Msk = 0xf
	// Position of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Pos = 0x4
	// Bit mask of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Msk = 0x70
	// CSTOCYC x 1
	HSMCI_CSTOR_CSTOMUL_1 = 0x0
	// CSTOCYC x 16
	HSMCI_CSTOR_CSTOMUL_16 = 0x1
	// CSTOCYC x 128
	HSMCI_CSTOR_CSTOMUL_128 = 0x2
	// CSTOCYC x 256
	HSMCI_CSTOR_CSTOMUL_256 = 0x3
	// CSTOCYC x 1024
	HSMCI_CSTOR_CSTOMUL_1024 = 0x4
	// CSTOCYC x 4096
	HSMCI_CSTOR_CSTOMUL_4096 = 0x5
	// CSTOCYC x 65536
	HSMCI_CSTOR_CSTOMUL_65536 = 0x6
	// CSTOCYC x 1048576
	HSMCI_CSTOR_CSTOMUL_1048576 = 0x7

	// RSPR: Response Register
	// Position of RSP field.
	HSMCI_RSPR_RSP_Pos = 0x0
	// Bit mask of RSP field.
	HSMCI_RSPR_RSP_Msk = 0xffffffff

	// RDR: Receive Data Register
	// Position of DATA field.
	HSMCI_RDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_RDR_DATA_Msk = 0xffffffff

	// TDR: Transmit Data Register
	// Position of DATA field.
	HSMCI_TDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_TDR_DATA_Msk = 0xffffffff

	// SR: Status Register
	// Position of CMDRDY field.
	HSMCI_SR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_SR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_SR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_SR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_SR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_SR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_SR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_SR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_SR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_SR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_SR_NOTBUSY = 0x20
	// Position of MCI_SDIOIRQA field.
	HSMCI_SR_MCI_SDIOIRQA_Pos = 0x8
	// Bit mask of MCI_SDIOIRQA field.
	HSMCI_SR_MCI_SDIOIRQA_Msk = 0x100
	// Bit MCI_SDIOIRQA.
	HSMCI_SR_MCI_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_SR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_SR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_SR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_SR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_SR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_SR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_SR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_SR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_SR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_SR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_SR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_SR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_SR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_SR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_SR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_SR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_SR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_SR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_SR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_SR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_SR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_SR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_SR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_SR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_SR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_SR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_SR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_SR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_SR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_SR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_SR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_SR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_SR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_SR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_SR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_SR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_SR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_SR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_SR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_SR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_SR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_SR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_SR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_SR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_SR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_SR_UNRE = 0x80000000

	// IER: Interrupt Enable Register
	// Position of CMDRDY field.
	HSMCI_IER_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IER_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IER_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IER_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IER_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IER_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IER_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IER_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IER_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IER_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IER_NOTBUSY = 0x20
	// Position of MCI_SDIOIRQA field.
	HSMCI_IER_MCI_SDIOIRQA_Pos = 0x8
	// Bit mask of MCI_SDIOIRQA field.
	HSMCI_IER_MCI_SDIOIRQA_Msk = 0x100
	// Bit MCI_SDIOIRQA.
	HSMCI_IER_MCI_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IER_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IER_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IER_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IER_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IER_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IER_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IER_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IER_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IER_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IER_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IER_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IER_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IER_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IER_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IER_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IER_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IER_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IER_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IER_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IER_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IER_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IER_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IER_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IER_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IER_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IER_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IER_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IER_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IER_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IER_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IER_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IER_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IER_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IER_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IER_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IER_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IER_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IER_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IER_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IER_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IER_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IER_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IER_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IER_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IER_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IER_UNRE = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of CMDRDY field.
	HSMCI_IDR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IDR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IDR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IDR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IDR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IDR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IDR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IDR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IDR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IDR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IDR_NOTBUSY = 0x20
	// Position of MCI_SDIOIRQA field.
	HSMCI_IDR_MCI_SDIOIRQA_Pos = 0x8
	// Bit mask of MCI_SDIOIRQA field.
	HSMCI_IDR_MCI_SDIOIRQA_Msk = 0x100
	// Bit MCI_SDIOIRQA.
	HSMCI_IDR_MCI_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IDR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IDR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IDR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IDR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IDR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IDR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IDR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IDR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IDR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IDR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IDR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IDR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IDR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IDR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IDR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IDR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IDR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IDR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IDR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IDR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IDR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IDR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IDR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IDR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IDR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IDR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IDR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IDR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IDR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IDR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IDR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IDR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IDR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IDR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IDR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IDR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IDR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IDR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IDR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IDR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IDR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IDR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IDR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IDR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IDR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IDR_UNRE = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of CMDRDY field.
	HSMCI_IMR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IMR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IMR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IMR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IMR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IMR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IMR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IMR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IMR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IMR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IMR_NOTBUSY = 0x20
	// Position of MCI_SDIOIRQA field.
	HSMCI_IMR_MCI_SDIOIRQA_Pos = 0x8
	// Bit mask of MCI_SDIOIRQA field.
	HSMCI_IMR_MCI_SDIOIRQA_Msk = 0x100
	// Bit MCI_SDIOIRQA.
	HSMCI_IMR_MCI_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IMR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IMR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IMR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IMR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IMR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IMR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IMR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IMR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IMR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IMR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IMR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IMR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IMR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IMR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IMR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IMR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IMR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IMR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IMR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IMR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IMR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IMR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IMR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IMR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IMR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IMR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IMR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IMR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IMR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IMR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IMR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IMR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IMR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IMR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IMR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IMR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IMR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IMR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IMR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IMR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IMR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IMR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IMR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IMR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IMR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IMR_UNRE = 0x80000000

	// DMA: DMA Configuration Register
	// Position of OFFSET field.
	HSMCI_DMA_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	HSMCI_DMA_OFFSET_Msk = 0x3
	// Position of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Pos = 0x4
	// Bit mask of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Msk = 0x30
	// 1 data available
	HSMCI_DMA_CHKSIZE_1 = 0x0
	// 4 data available
	HSMCI_DMA_CHKSIZE_4 = 0x1
	// 8 data available
	HSMCI_DMA_CHKSIZE_8 = 0x2
	// 16 data available
	HSMCI_DMA_CHKSIZE_16 = 0x3
	// Position of DMAEN field.
	HSMCI_DMA_DMAEN_Pos = 0x8
	// Bit mask of DMAEN field.
	HSMCI_DMA_DMAEN_Msk = 0x100
	// Bit DMAEN.
	HSMCI_DMA_DMAEN = 0x100
	// Position of ROPT field.
	HSMCI_DMA_ROPT_Pos = 0xc
	// Bit mask of ROPT field.
	HSMCI_DMA_ROPT_Msk = 0x1000
	// Bit ROPT.
	HSMCI_DMA_ROPT = 0x1000

	// CFG: Configuration Register
	// Position of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Pos = 0x0
	// Bit mask of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Msk = 0x1
	// Bit FIFOMODE.
	HSMCI_CFG_FIFOMODE = 0x1
	// Position of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Pos = 0x4
	// Bit mask of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Msk = 0x10
	// Bit FERRCTRL.
	HSMCI_CFG_FERRCTRL = 0x10
	// Position of HSMODE field.
	HSMCI_CFG_HSMODE_Pos = 0x8
	// Bit mask of HSMODE field.
	HSMCI_CFG_HSMODE_Msk = 0x100
	// Bit HSMODE.
	HSMCI_CFG_HSMODE = 0x100
	// Position of LSYNC field.
	HSMCI_CFG_LSYNC_Pos = 0xc
	// Bit mask of LSYNC field.
	HSMCI_CFG_LSYNC_Msk = 0x1000
	// Bit LSYNC.
	HSMCI_CFG_LSYNC = 0x1000

	// WPMR: Write Protection Mode Register
	// Position of WP_EN field.
	HSMCI_WPMR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	HSMCI_WPMR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	HSMCI_WPMR_WP_EN = 0x1
	// Position of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WP_VS field.
	HSMCI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	HSMCI_WPSR_WP_VS_Msk = 0xf
	// No Write Protection Violation occurred since the last read of this register (WP_SR)
	HSMCI_WPSR_WP_VS_NONE = 0x0
	// Write Protection detected unauthorized attempt to write a control register had occurred (since the last read.)
	HSMCI_WPSR_WP_VS_WRITE = 0x1
	// Software reset had been performed while Write Protection was enabled (since the last read).
	HSMCI_WPSR_WP_VS_RESET = 0x2
	// Both Write Protection violation and software reset with Write Protection enabled have occurred since the last read.
	HSMCI_WPSR_WP_VS_BOTH = 0x3
	// Position of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Msk = 0xffff00
)

// Constants for TWI0: Two-wire Interface 0
const (
	// CR: Control Register
	// Position of START field.
	TWI_CR_START_Pos = 0x0
	// Bit mask of START field.
	TWI_CR_START_Msk = 0x1
	// Bit START.
	TWI_CR_START = 0x1
	// Position of STOP field.
	TWI_CR_STOP_Pos = 0x1
	// Bit mask of STOP field.
	TWI_CR_STOP_Msk = 0x2
	// Bit STOP.
	TWI_CR_STOP = 0x2
	// Position of MSEN field.
	TWI_CR_MSEN_Pos = 0x2
	// Bit mask of MSEN field.
	TWI_CR_MSEN_Msk = 0x4
	// Bit MSEN.
	TWI_CR_MSEN = 0x4
	// Position of MSDIS field.
	TWI_CR_MSDIS_Pos = 0x3
	// Bit mask of MSDIS field.
	TWI_CR_MSDIS_Msk = 0x8
	// Bit MSDIS.
	TWI_CR_MSDIS = 0x8
	// Position of SVEN field.
	TWI_CR_SVEN_Pos = 0x4
	// Bit mask of SVEN field.
	TWI_CR_SVEN_Msk = 0x10
	// Bit SVEN.
	TWI_CR_SVEN = 0x10
	// Position of SVDIS field.
	TWI_CR_SVDIS_Pos = 0x5
	// Bit mask of SVDIS field.
	TWI_CR_SVDIS_Msk = 0x20
	// Bit SVDIS.
	TWI_CR_SVDIS = 0x20
	// Position of QUICK field.
	TWI_CR_QUICK_Pos = 0x6
	// Bit mask of QUICK field.
	TWI_CR_QUICK_Msk = 0x40
	// Bit QUICK.
	TWI_CR_QUICK = 0x40
	// Position of SWRST field.
	TWI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	TWI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	TWI_CR_SWRST = 0x80

	// MMR: Master Mode Register
	// Position of IADRSZ field.
	TWI_MMR_IADRSZ_Pos = 0x8
	// Bit mask of IADRSZ field.
	TWI_MMR_IADRSZ_Msk = 0x300
	// No internal device address
	TWI_MMR_IADRSZ_NONE = 0x0
	// One-byte internal device address
	TWI_MMR_IADRSZ_1_BYTE = 0x1
	// Two-byte internal device address
	TWI_MMR_IADRSZ_2_BYTE = 0x2
	// Three-byte internal device address
	TWI_MMR_IADRSZ_3_BYTE = 0x3
	// Position of MREAD field.
	TWI_MMR_MREAD_Pos = 0xc
	// Bit mask of MREAD field.
	TWI_MMR_MREAD_Msk = 0x1000
	// Bit MREAD.
	TWI_MMR_MREAD = 0x1000
	// Position of DADR field.
	TWI_MMR_DADR_Pos = 0x10
	// Bit mask of DADR field.
	TWI_MMR_DADR_Msk = 0x7f0000

	// SMR: Slave Mode Register
	// Position of SADR field.
	TWI_SMR_SADR_Pos = 0x10
	// Bit mask of SADR field.
	TWI_SMR_SADR_Msk = 0x7f0000

	// IADR: Internal Address Register
	// Position of IADR field.
	TWI_IADR_IADR_Pos = 0x0
	// Bit mask of IADR field.
	TWI_IADR_IADR_Msk = 0xffffff

	// CWGR: Clock Waveform Generator Register
	// Position of CLDIV field.
	TWI_CWGR_CLDIV_Pos = 0x0
	// Bit mask of CLDIV field.
	TWI_CWGR_CLDIV_Msk = 0xff
	// Position of CHDIV field.
	TWI_CWGR_CHDIV_Pos = 0x8
	// Bit mask of CHDIV field.
	TWI_CWGR_CHDIV_Msk = 0xff00
	// Position of CKDIV field.
	TWI_CWGR_CKDIV_Pos = 0x10
	// Bit mask of CKDIV field.
	TWI_CWGR_CKDIV_Msk = 0x70000

	// SR: Status Register
	// Position of TXCOMP field.
	TWI_SR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_SR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_SR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_SR_TXRDY = 0x4
	// Position of SVREAD field.
	TWI_SR_SVREAD_Pos = 0x3
	// Bit mask of SVREAD field.
	TWI_SR_SVREAD_Msk = 0x8
	// Bit SVREAD.
	TWI_SR_SVREAD = 0x8
	// Position of SVACC field.
	TWI_SR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_SR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_SR_SVACC = 0x10
	// Position of GACC field.
	TWI_SR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_SR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_SR_GACC = 0x20
	// Position of OVRE field.
	TWI_SR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_SR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_SR_OVRE = 0x40
	// Position of NACK field.
	TWI_SR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_SR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_SR_NACK = 0x100
	// Position of ARBLST field.
	TWI_SR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_SR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_SR_ARBLST = 0x200
	// Position of SCLWS field.
	TWI_SR_SCLWS_Pos = 0xa
	// Bit mask of SCLWS field.
	TWI_SR_SCLWS_Msk = 0x400
	// Bit SCLWS.
	TWI_SR_SCLWS = 0x400
	// Position of EOSACC field.
	TWI_SR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_SR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_SR_EOSACC = 0x800

	// IER: Interrupt Enable Register
	// Position of TXCOMP field.
	TWI_IER_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IER_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IER_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IER_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IER_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IER_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IER_SVACC = 0x10
	// Position of GACC field.
	TWI_IER_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IER_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IER_GACC = 0x20
	// Position of OVRE field.
	TWI_IER_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IER_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IER_OVRE = 0x40
	// Position of NACK field.
	TWI_IER_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IER_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IER_NACK = 0x100
	// Position of ARBLST field.
	TWI_IER_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IER_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IER_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IER_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IER_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IER_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IER_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IER_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IER_EOSACC = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXCOMP field.
	TWI_IDR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IDR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IDR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IDR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IDR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IDR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IDR_SVACC = 0x10
	// Position of GACC field.
	TWI_IDR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IDR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IDR_GACC = 0x20
	// Position of OVRE field.
	TWI_IDR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IDR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IDR_OVRE = 0x40
	// Position of NACK field.
	TWI_IDR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IDR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IDR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IDR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IDR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IDR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IDR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IDR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IDR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IDR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IDR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IDR_EOSACC = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXCOMP field.
	TWI_IMR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IMR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IMR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IMR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IMR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IMR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IMR_SVACC = 0x10
	// Position of GACC field.
	TWI_IMR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IMR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IMR_GACC = 0x20
	// Position of OVRE field.
	TWI_IMR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IMR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IMR_OVRE = 0x40
	// Position of NACK field.
	TWI_IMR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IMR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IMR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IMR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IMR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IMR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IMR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IMR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IMR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IMR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IMR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IMR_EOSACC = 0x800

	// RHR: Receive Holding Register
	// Position of RXDATA field.
	TWI_RHR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	TWI_RHR_RXDATA_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXDATA field.
	TWI_THR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	TWI_THR_TXDATA_Msk = 0xff
)

// Constants for USART0: Universal Synchronous Asynchronous Receiver Transmitter 0
const (
	// CR: Control Register
	// Position of RSTRX field.
	USART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_RSTSTA = 0x100
	// Position of STTBRK field.
	USART_CR_STTBRK_Pos = 0x9
	// Bit mask of STTBRK field.
	USART_CR_STTBRK_Msk = 0x200
	// Bit STTBRK.
	USART_CR_STTBRK = 0x200
	// Position of STPBRK field.
	USART_CR_STPBRK_Pos = 0xa
	// Bit mask of STPBRK field.
	USART_CR_STPBRK_Msk = 0x400
	// Bit STPBRK.
	USART_CR_STPBRK = 0x400
	// Position of STTTO field.
	USART_CR_STTTO_Pos = 0xb
	// Bit mask of STTTO field.
	USART_CR_STTTO_Msk = 0x800
	// Bit STTTO.
	USART_CR_STTTO = 0x800
	// Position of SENDA field.
	USART_CR_SENDA_Pos = 0xc
	// Bit mask of SENDA field.
	USART_CR_SENDA_Msk = 0x1000
	// Bit SENDA.
	USART_CR_SENDA = 0x1000
	// Position of RSTIT field.
	USART_CR_RSTIT_Pos = 0xd
	// Bit mask of RSTIT field.
	USART_CR_RSTIT_Msk = 0x2000
	// Bit RSTIT.
	USART_CR_RSTIT = 0x2000
	// Position of RSTNACK field.
	USART_CR_RSTNACK_Pos = 0xe
	// Bit mask of RSTNACK field.
	USART_CR_RSTNACK_Msk = 0x4000
	// Bit RSTNACK.
	USART_CR_RSTNACK = 0x4000
	// Position of RETTO field.
	USART_CR_RETTO_Pos = 0xf
	// Bit mask of RETTO field.
	USART_CR_RETTO_Msk = 0x8000
	// Bit RETTO.
	USART_CR_RETTO = 0x8000
	// Position of RTSEN field.
	USART_CR_RTSEN_Pos = 0x12
	// Bit mask of RTSEN field.
	USART_CR_RTSEN_Msk = 0x40000
	// Bit RTSEN.
	USART_CR_RTSEN = 0x40000
	// Position of RTSDIS field.
	USART_CR_RTSDIS_Pos = 0x13
	// Bit mask of RTSDIS field.
	USART_CR_RTSDIS_Msk = 0x80000
	// Bit RTSDIS.
	USART_CR_RTSDIS = 0x80000

	// CR_SPI_MODE: Control Register
	// Position of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_SPI_MODE_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_SPI_MODE_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_SPI_MODE_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_SPI_MODE_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_SPI_MODE_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_SPI_MODE_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_SPI_MODE_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_SPI_MODE_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_SPI_MODE_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_SPI_MODE_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_SPI_MODE_RSTSTA = 0x100
	// Position of FCS field.
	USART_CR_SPI_MODE_FCS_Pos = 0x12
	// Bit mask of FCS field.
	USART_CR_SPI_MODE_FCS_Msk = 0x40000
	// Bit FCS.
	USART_CR_SPI_MODE_FCS = 0x40000
	// Position of RCS field.
	USART_CR_SPI_MODE_RCS_Pos = 0x13
	// Bit mask of RCS field.
	USART_CR_SPI_MODE_RCS_Msk = 0x80000
	// Bit RCS.
	USART_CR_SPI_MODE_RCS = 0x80000

	// MR: Mode Register
	// Position of USART_MODE field.
	USART_MR_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_USART_MODE_Msk = 0xf
	// Normal mode
	USART_MR_USART_MODE_NORMAL = 0x0
	// RS485
	USART_MR_USART_MODE_RS485 = 0x1
	// Hardware Handshaking
	USART_MR_USART_MODE_HW_HANDSHAKING = 0x2
	// IS07816 Protocol: T = 0
	USART_MR_USART_MODE_IS07816_T_0 = 0x4
	// IS07816 Protocol: T = 1
	USART_MR_USART_MODE_IS07816_T_1 = 0x6
	// IrDA
	USART_MR_USART_MODE_IRDA = 0x8
	// SPI Master
	USART_MR_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=8) is selected
	USART_MR_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_CHRL_Msk = 0xc0
	// Character length is 5 bits
	USART_MR_CHRL_5_BIT = 0x0
	// Character length is 6 bits
	USART_MR_CHRL_6_BIT = 0x1
	// Character length is 7 bits
	USART_MR_CHRL_7_BIT = 0x2
	// Character length is 8 bits
	USART_MR_CHRL_8_BIT = 0x3
	// Position of SYNC field.
	USART_MR_SYNC_Pos = 0x8
	// Bit mask of SYNC field.
	USART_MR_SYNC_Msk = 0x100
	// Bit SYNC.
	USART_MR_SYNC = 0x100
	// Position of PAR field.
	USART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	USART_MR_PAR_Msk = 0xe00
	// Even parity
	USART_MR_PAR_EVEN = 0x0
	// Odd parity
	USART_MR_PAR_ODD = 0x1
	// Parity forced to 0 (Space)
	USART_MR_PAR_SPACE = 0x2
	// Parity forced to 1 (Mark)
	USART_MR_PAR_MARK = 0x3
	// No parity
	USART_MR_PAR_NO = 0x4
	// Multidrop mode
	USART_MR_PAR_MULTIDROP = 0x6
	// Position of NBSTOP field.
	USART_MR_NBSTOP_Pos = 0xc
	// Bit mask of NBSTOP field.
	USART_MR_NBSTOP_Msk = 0x3000
	// 1 stop bit
	USART_MR_NBSTOP_1_BIT = 0x0
	// 1.5 stop bit (SYNC = 0) or reserved (SYNC = 1)
	USART_MR_NBSTOP_1_5_BIT = 0x1
	// 2 stop bits
	USART_MR_NBSTOP_2_BIT = 0x2
	// Position of CHMODE field.
	USART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	USART_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	USART_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo. Receiver input is connected to the TXD pin.
	USART_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback. Transmitter output is connected to the Receiver Input.
	USART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback. RXD pin is internally connected to the TXD pin.
	USART_MR_CHMODE_REMOTE_LOOPBACK = 0x3
	// Position of MSBF field.
	USART_MR_MSBF_Pos = 0x10
	// Bit mask of MSBF field.
	USART_MR_MSBF_Msk = 0x10000
	// Bit MSBF.
	USART_MR_MSBF = 0x10000
	// Position of MODE9 field.
	USART_MR_MODE9_Pos = 0x11
	// Bit mask of MODE9 field.
	USART_MR_MODE9_Msk = 0x20000
	// Bit MODE9.
	USART_MR_MODE9 = 0x20000
	// Position of CLKO field.
	USART_MR_CLKO_Pos = 0x12
	// Bit mask of CLKO field.
	USART_MR_CLKO_Msk = 0x40000
	// Bit CLKO.
	USART_MR_CLKO = 0x40000
	// Position of OVER field.
	USART_MR_OVER_Pos = 0x13
	// Bit mask of OVER field.
	USART_MR_OVER_Msk = 0x80000
	// Bit OVER.
	USART_MR_OVER = 0x80000
	// Position of INACK field.
	USART_MR_INACK_Pos = 0x14
	// Bit mask of INACK field.
	USART_MR_INACK_Msk = 0x100000
	// Bit INACK.
	USART_MR_INACK = 0x100000
	// Position of DSNACK field.
	USART_MR_DSNACK_Pos = 0x15
	// Bit mask of DSNACK field.
	USART_MR_DSNACK_Msk = 0x200000
	// Bit DSNACK.
	USART_MR_DSNACK = 0x200000
	// Position of VAR_SYNC field.
	USART_MR_VAR_SYNC_Pos = 0x16
	// Bit mask of VAR_SYNC field.
	USART_MR_VAR_SYNC_Msk = 0x400000
	// Bit VAR_SYNC.
	USART_MR_VAR_SYNC = 0x400000
	// Position of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Pos = 0x18
	// Bit mask of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Msk = 0x7000000
	// Position of FILTER field.
	USART_MR_FILTER_Pos = 0x1c
	// Bit mask of FILTER field.
	USART_MR_FILTER_Msk = 0x10000000
	// Bit FILTER.
	USART_MR_FILTER = 0x10000000
	// Position of MAN field.
	USART_MR_MAN_Pos = 0x1d
	// Bit mask of MAN field.
	USART_MR_MAN_Msk = 0x20000000
	// Bit MAN.
	USART_MR_MAN = 0x20000000
	// Position of MODSYNC field.
	USART_MR_MODSYNC_Pos = 0x1e
	// Bit mask of MODSYNC field.
	USART_MR_MODSYNC_Msk = 0x40000000
	// Bit MODSYNC.
	USART_MR_MODSYNC = 0x40000000
	// Position of ONEBIT field.
	USART_MR_ONEBIT_Pos = 0x1f
	// Bit mask of ONEBIT field.
	USART_MR_ONEBIT_Msk = 0x80000000
	// Bit ONEBIT.
	USART_MR_ONEBIT = 0x80000000

	// MR_SPI_MODE: Mode Register
	// Position of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Msk = 0xf
	// SPI Master
	USART_MR_SPI_MODE_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_SPI_MODE_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_SPI_MODE_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=8) is selected
	USART_MR_SPI_MODE_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_SPI_MODE_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_SPI_MODE_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_SPI_MODE_CHRL_Msk = 0xc0
	// Character length is 8 bits
	USART_MR_SPI_MODE_CHRL_8_BIT = 0x3
	// Position of CPHA field.
	USART_MR_SPI_MODE_CPHA_Pos = 0x8
	// Bit mask of CPHA field.
	USART_MR_SPI_MODE_CPHA_Msk = 0x100
	// Bit CPHA.
	USART_MR_SPI_MODE_CPHA = 0x100
	// Position of CPOL field.
	USART_MR_SPI_MODE_CPOL_Pos = 0x10
	// Bit mask of CPOL field.
	USART_MR_SPI_MODE_CPOL_Msk = 0x10000
	// Bit CPOL.
	USART_MR_SPI_MODE_CPOL = 0x10000
	// Position of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Pos = 0x14
	// Bit mask of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Msk = 0x100000
	// Bit WRDBT.
	USART_MR_SPI_MODE_WRDBT = 0x100000

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IER_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IER_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IER_RXBRK = 0x4
	// Position of ENDRX field.
	USART_IER_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	USART_IER_ENDRX_Msk = 0x8
	// Bit ENDRX.
	USART_IER_ENDRX = 0x8
	// Position of ENDTX field.
	USART_IER_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	USART_IER_ENDTX_Msk = 0x10
	// Bit ENDTX.
	USART_IER_ENDTX = 0x10
	// Position of OVRE field.
	USART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_OVRE = 0x20
	// Position of FRAME field.
	USART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IER_FRAME = 0x40
	// Position of PARE field.
	USART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IER_PARE_Msk = 0x80
	// Bit PARE.
	USART_IER_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IER_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IER_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IER_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IER_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IER_ITER_Msk = 0x400
	// Bit ITER.
	USART_IER_ITER = 0x400
	// Position of TXBUFE field.
	USART_IER_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	USART_IER_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	USART_IER_TXBUFE = 0x800
	// Position of RXBUFF field.
	USART_IER_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	USART_IER_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	USART_IER_RXBUFF = 0x1000
	// Position of NACK field.
	USART_IER_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IER_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IER_NACK = 0x2000
	// Position of CTSIC field.
	USART_IER_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IER_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IER_CTSIC = 0x80000
	// Position of MANE field.
	USART_IER_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IER_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IER_MANE = 0x1000000

	// IER_SPI_MODE: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IER_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IER_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IER_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IER_SPI_MODE_UNRE = 0x400

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IDR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IDR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IDR_RXBRK = 0x4
	// Position of ENDRX field.
	USART_IDR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	USART_IDR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	USART_IDR_ENDRX = 0x8
	// Position of ENDTX field.
	USART_IDR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	USART_IDR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	USART_IDR_ENDTX = 0x10
	// Position of OVRE field.
	USART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_OVRE = 0x20
	// Position of FRAME field.
	USART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IDR_FRAME = 0x40
	// Position of PARE field.
	USART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IDR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IDR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IDR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IDR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IDR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IDR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IDR_ITER = 0x400
	// Position of TXBUFE field.
	USART_IDR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	USART_IDR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	USART_IDR_TXBUFE = 0x800
	// Position of RXBUFF field.
	USART_IDR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	USART_IDR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	USART_IDR_RXBUFF = 0x1000
	// Position of NACK field.
	USART_IDR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IDR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IDR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IDR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IDR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IDR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IDR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IDR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IDR_MANE = 0x1000000

	// IDR_SPI_MODE: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IDR_SPI_MODE_UNRE = 0x400

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IMR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IMR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IMR_RXBRK = 0x4
	// Position of ENDRX field.
	USART_IMR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	USART_IMR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	USART_IMR_ENDRX = 0x8
	// Position of ENDTX field.
	USART_IMR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	USART_IMR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	USART_IMR_ENDTX = 0x10
	// Position of OVRE field.
	USART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_OVRE = 0x20
	// Position of FRAME field.
	USART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IMR_FRAME = 0x40
	// Position of PARE field.
	USART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IMR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IMR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IMR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IMR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IMR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IMR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IMR_ITER = 0x400
	// Position of TXBUFE field.
	USART_IMR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	USART_IMR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	USART_IMR_TXBUFE = 0x800
	// Position of RXBUFF field.
	USART_IMR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	USART_IMR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	USART_IMR_RXBUFF = 0x1000
	// Position of NACK field.
	USART_IMR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IMR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IMR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IMR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IMR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IMR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IMR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IMR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IMR_MANE = 0x1000000

	// IMR_SPI_MODE: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IMR_SPI_MODE_UNRE = 0x400

	// CSR: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_CSR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_CSR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_CSR_RXBRK = 0x4
	// Position of ENDRX field.
	USART_CSR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	USART_CSR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	USART_CSR_ENDRX = 0x8
	// Position of ENDTX field.
	USART_CSR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	USART_CSR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	USART_CSR_ENDTX = 0x10
	// Position of OVRE field.
	USART_CSR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_OVRE = 0x20
	// Position of FRAME field.
	USART_CSR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_CSR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_CSR_FRAME = 0x40
	// Position of PARE field.
	USART_CSR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_CSR_PARE_Msk = 0x80
	// Bit PARE.
	USART_CSR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_CSR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_CSR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_CSR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_CSR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_CSR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_CSR_ITER_Msk = 0x400
	// Bit ITER.
	USART_CSR_ITER = 0x400
	// Position of TXBUFE field.
	USART_CSR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	USART_CSR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	USART_CSR_TXBUFE = 0x800
	// Position of RXBUFF field.
	USART_CSR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	USART_CSR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	USART_CSR_RXBUFF = 0x1000
	// Position of NACK field.
	USART_CSR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_CSR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_CSR_NACK = 0x2000
	// Position of CTSIC field.
	USART_CSR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_CSR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_CSR_CTSIC = 0x80000
	// Position of CTS field.
	USART_CSR_CTS_Pos = 0x17
	// Bit mask of CTS field.
	USART_CSR_CTS_Msk = 0x800000
	// Bit CTS.
	USART_CSR_CTS = 0x800000
	// Position of MANERR field.
	USART_CSR_MANERR_Pos = 0x18
	// Bit mask of MANERR field.
	USART_CSR_MANERR_Msk = 0x1000000
	// Bit MANERR.
	USART_CSR_MANERR = 0x1000000

	// CSR_SPI_MODE: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_CSR_SPI_MODE_UNRE = 0x400

	// RHR: Receiver Holding Register
	// Position of RXCHR field.
	USART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	USART_RHR_RXCHR_Msk = 0x1ff
	// Position of RXSYNH field.
	USART_RHR_RXSYNH_Pos = 0xf
	// Bit mask of RXSYNH field.
	USART_RHR_RXSYNH_Msk = 0x8000
	// Bit RXSYNH.
	USART_RHR_RXSYNH = 0x8000

	// THR: Transmitter Holding Register
	// Position of TXCHR field.
	USART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	USART_THR_TXCHR_Msk = 0x1ff
	// Position of TXSYNH field.
	USART_THR_TXSYNH_Pos = 0xf
	// Bit mask of TXSYNH field.
	USART_THR_TXSYNH_Msk = 0x8000
	// Bit TXSYNH.
	USART_THR_TXSYNH = 0x8000

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	USART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	USART_BRGR_CD_Msk = 0xffff
	// Position of FP field.
	USART_BRGR_FP_Pos = 0x10
	// Bit mask of FP field.
	USART_BRGR_FP_Msk = 0x70000

	// RTOR: Receiver Time-out Register
	// Position of TO field.
	USART_RTOR_TO_Pos = 0x0
	// Bit mask of TO field.
	USART_RTOR_TO_Msk = 0xffff

	// TTGR: Transmitter Timeguard Register
	// Position of TG field.
	USART_TTGR_TG_Pos = 0x0
	// Bit mask of TG field.
	USART_TTGR_TG_Msk = 0xff

	// FIDI: FI DI Ratio Register
	// Position of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Pos = 0x0
	// Bit mask of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Msk = 0x7ff

	// NER: Number of Errors Register
	// Position of NB_ERRORS field.
	USART_NER_NB_ERRORS_Pos = 0x0
	// Bit mask of NB_ERRORS field.
	USART_NER_NB_ERRORS_Msk = 0xff

	// IF: IrDA Filter Register
	// Position of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Pos = 0x0
	// Bit mask of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Msk = 0xff

	// MAN: Manchester Encoder Decoder Register
	// Position of TX_PL field.
	USART_MAN_TX_PL_Pos = 0x0
	// Bit mask of TX_PL field.
	USART_MAN_TX_PL_Msk = 0xf
	// Position of TX_PP field.
	USART_MAN_TX_PP_Pos = 0x8
	// Bit mask of TX_PP field.
	USART_MAN_TX_PP_Msk = 0x300
	// The preamble is composed of '1's
	USART_MAN_TX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_TX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_TX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_TX_PP_ONE_ZERO = 0x3
	// Position of TX_MPOL field.
	USART_MAN_TX_MPOL_Pos = 0xc
	// Bit mask of TX_MPOL field.
	USART_MAN_TX_MPOL_Msk = 0x1000
	// Bit TX_MPOL.
	USART_MAN_TX_MPOL = 0x1000
	// Position of RX_PL field.
	USART_MAN_RX_PL_Pos = 0x10
	// Bit mask of RX_PL field.
	USART_MAN_RX_PL_Msk = 0xf0000
	// Position of RX_PP field.
	USART_MAN_RX_PP_Pos = 0x18
	// Bit mask of RX_PP field.
	USART_MAN_RX_PP_Msk = 0x3000000
	// The preamble is composed of '1's
	USART_MAN_RX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_RX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_RX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_RX_PP_ONE_ZERO = 0x3
	// Position of RX_MPOL field.
	USART_MAN_RX_MPOL_Pos = 0x1c
	// Bit mask of RX_MPOL field.
	USART_MAN_RX_MPOL_Msk = 0x10000000
	// Bit RX_MPOL.
	USART_MAN_RX_MPOL = 0x10000000
	// Position of ONE field.
	USART_MAN_ONE_Pos = 0x1d
	// Bit mask of ONE field.
	USART_MAN_ONE_Msk = 0x20000000
	// Bit ONE.
	USART_MAN_ONE = 0x20000000
	// Position of DRIFT field.
	USART_MAN_DRIFT_Pos = 0x1e
	// Bit mask of DRIFT field.
	USART_MAN_DRIFT_Msk = 0x40000000
	// Bit DRIFT.
	USART_MAN_DRIFT = 0x40000000

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	USART_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	USART_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	USART_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	USART_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	USART_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	USART_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	USART_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	USART_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	USART_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	USART_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	USART_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	USART_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	USART_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	USART_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	USART_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	USART_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	USART_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	USART_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	USART_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	USART_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	USART_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	USART_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	USART_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	USART_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	USART_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	USART_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	USART_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	USART_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	USART_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	USART_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	USART_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	USART_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	USART_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	USART_PTSR_TXTEN = 0x100
)

// Constants for SSC0: Synchronous Serial Controller 0
const (
	// CR: Control Register
	// Position of RXEN field.
	SSC_CR_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	SSC_CR_RXEN_Msk = 0x1
	// Bit RXEN.
	SSC_CR_RXEN = 0x1
	// Position of RXDIS field.
	SSC_CR_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	SSC_CR_RXDIS_Msk = 0x2
	// Bit RXDIS.
	SSC_CR_RXDIS = 0x2
	// Position of TXEN field.
	SSC_CR_TXEN_Pos = 0x8
	// Bit mask of TXEN field.
	SSC_CR_TXEN_Msk = 0x100
	// Bit TXEN.
	SSC_CR_TXEN = 0x100
	// Position of TXDIS field.
	SSC_CR_TXDIS_Pos = 0x9
	// Bit mask of TXDIS field.
	SSC_CR_TXDIS_Msk = 0x200
	// Bit TXDIS.
	SSC_CR_TXDIS = 0x200
	// Position of SWRST field.
	SSC_CR_SWRST_Pos = 0xf
	// Bit mask of SWRST field.
	SSC_CR_SWRST_Msk = 0x8000
	// Bit SWRST.
	SSC_CR_SWRST = 0x8000

	// CMR: Clock Mode Register
	// Position of DIV field.
	SSC_CMR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SSC_CMR_DIV_Msk = 0xfff

	// RCMR: Receive Clock Mode Register
	// Position of CKS field.
	SSC_RCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_RCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_RCMR_CKS_MCK = 0x0
	// TK Clock signal
	SSC_RCMR_CKS_TK = 0x1
	// RK pin
	SSC_RCMR_CKS_RK = 0x2
	// Position of CKO field.
	SSC_RCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_RCMR_CKO_Msk = 0x1c
	// None
	SSC_RCMR_CKO_NONE = 0x0
	// Continuous Receive Clock
	SSC_RCMR_CKO_CONTINUOUS = 0x1
	// Receive Clock only during data transfers
	SSC_RCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_RCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_RCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_RCMR_CKI = 0x20
	// Position of CKG field.
	SSC_RCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_RCMR_CKG_Msk = 0xc0
	// None
	SSC_RCMR_CKG_NONE = 0x0
	// Continuous Receive Clock
	SSC_RCMR_CKG_CONTINUOUS = 0x1
	// Receive Clock only during data transfers
	SSC_RCMR_CKG_TRANSFER = 0x2
	// Position of START field.
	SSC_RCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_RCMR_START_Msk = 0xf00
	// Continuous, as soon as the receiver is enabled, and immediately after the end of transfer of the previous data.
	SSC_RCMR_START_CONTINUOUS = 0x0
	// Transmit start
	SSC_RCMR_START_TRANSMIT = 0x1
	// Detection of a low level on RF signal
	SSC_RCMR_START_RF_LOW = 0x2
	// Detection of a high level on RF signal
	SSC_RCMR_START_RF_HIGH = 0x3
	// Detection of a falling edge on RF signal
	SSC_RCMR_START_RF_FALLING = 0x4
	// Detection of a rising edge on RF signal
	SSC_RCMR_START_RF_RISING = 0x5
	// Detection of any level change on RF signal
	SSC_RCMR_START_RF_LEVEL = 0x6
	// Detection of any edge on RF signal
	SSC_RCMR_START_RF_EDGE = 0x7
	// Compare 0
	SSC_RCMR_START_CMP_0 = 0x8
	// Position of STOP field.
	SSC_RCMR_STOP_Pos = 0xc
	// Bit mask of STOP field.
	SSC_RCMR_STOP_Msk = 0x1000
	// Bit STOP.
	SSC_RCMR_STOP = 0x1000
	// Position of STTDLY field.
	SSC_RCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_RCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_RCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_RCMR_PERIOD_Msk = 0xff000000

	// RFMR: Receive Frame Mode Register
	// Position of DATLEN field.
	SSC_RFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_RFMR_DATLEN_Msk = 0x1f
	// Position of LOOP field.
	SSC_RFMR_LOOP_Pos = 0x5
	// Bit mask of LOOP field.
	SSC_RFMR_LOOP_Msk = 0x20
	// Bit LOOP.
	SSC_RFMR_LOOP = 0x20
	// Position of MSBF field.
	SSC_RFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_RFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_RFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_RFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_RFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_RFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_RFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_RFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_RFMR_FSOS_Msk = 0x700000
	// None
	SSC_RFMR_FSOS_NONE = 0x0
	// Negative Pulse
	SSC_RFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse
	SSC_RFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer
	SSC_RFMR_FSOS_LOW = 0x3
	// Driven High during data transfer
	SSC_RFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer
	SSC_RFMR_FSOS_TOGGLING = 0x5
	// Position of FSEDGE field.
	SSC_RFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_RFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_RFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_RFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_RFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Msk = 0xf0000000

	// TCMR: Transmit Clock Mode Register
	// Position of CKS field.
	SSC_TCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_TCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_TCMR_CKS_MCK = 0x0
	// TK Clock signal
	SSC_TCMR_CKS_TK = 0x1
	// RK pin
	SSC_TCMR_CKS_RK = 0x2
	// Position of CKO field.
	SSC_TCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_TCMR_CKO_Msk = 0x1c
	// None
	SSC_TCMR_CKO_NONE = 0x0
	// Continuous Receive Clock
	SSC_TCMR_CKO_CONTINUOUS = 0x1
	// Transmit Clock only during data transfers
	SSC_TCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_TCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_TCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_TCMR_CKI = 0x20
	// Position of CKG field.
	SSC_TCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_TCMR_CKG_Msk = 0xc0
	// None
	SSC_TCMR_CKG_NONE = 0x0
	// Transmit Clock enabled only if TF Low
	SSC_TCMR_CKG_CONTINUOUS = 0x1
	// Transmit Clock enabled only if TF High
	SSC_TCMR_CKG_TRANSFER = 0x2
	// Position of START field.
	SSC_TCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_TCMR_START_Msk = 0xf00
	// Continuous, as soon as a word is written in the SSC_THR Register (if Transmit is enabled), and immediately after the end of transfer of the previous data.
	SSC_TCMR_START_CONTINUOUS = 0x0
	// Receive start
	SSC_TCMR_START_RECEIVE = 0x1
	// Detection of a low level on TF signal
	SSC_TCMR_START_RF_LOW = 0x2
	// Detection of a high level on TF signal
	SSC_TCMR_START_RF_HIGH = 0x3
	// Detection of a falling edge on TF signal
	SSC_TCMR_START_RF_FALLING = 0x4
	// Detection of a rising edge on TF signal
	SSC_TCMR_START_RF_RISING = 0x5
	// Detection of any level change on TF signal
	SSC_TCMR_START_RF_LEVEL = 0x6
	// Detection of any edge on TF signal
	SSC_TCMR_START_RF_EDGE = 0x7
	// Compare 0
	SSC_TCMR_START_CMP_0 = 0x8
	// Position of STTDLY field.
	SSC_TCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_TCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_TCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_TCMR_PERIOD_Msk = 0xff000000

	// TFMR: Transmit Frame Mode Register
	// Position of DATLEN field.
	SSC_TFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_TFMR_DATLEN_Msk = 0x1f
	// Position of DATDEF field.
	SSC_TFMR_DATDEF_Pos = 0x5
	// Bit mask of DATDEF field.
	SSC_TFMR_DATDEF_Msk = 0x20
	// Bit DATDEF.
	SSC_TFMR_DATDEF = 0x20
	// Position of MSBF field.
	SSC_TFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_TFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_TFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_TFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_TFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_TFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_TFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_TFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_TFMR_FSOS_Msk = 0x700000
	// None
	SSC_TFMR_FSOS_NONE = 0x0
	// Negative Pulse
	SSC_TFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse
	SSC_TFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer
	SSC_TFMR_FSOS_LOW = 0x3
	// Driven High during data transfer
	SSC_TFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer
	SSC_TFMR_FSOS_TOGGLING = 0x5
	// Position of FSDEN field.
	SSC_TFMR_FSDEN_Pos = 0x17
	// Bit mask of FSDEN field.
	SSC_TFMR_FSDEN_Msk = 0x800000
	// Bit FSDEN.
	SSC_TFMR_FSDEN = 0x800000
	// Position of FSEDGE field.
	SSC_TFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_TFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_TFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_TFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_TFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Msk = 0xf0000000

	// RHR: Receive Holding Register
	// Position of RDAT field.
	SSC_RHR_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SSC_RHR_RDAT_Msk = 0xffffffff

	// THR: Transmit Holding Register
	// Position of TDAT field.
	SSC_THR_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SSC_THR_TDAT_Msk = 0xffffffff

	// RSHR: Receive Sync. Holding Register
	// Position of RSDAT field.
	SSC_RSHR_RSDAT_Pos = 0x0
	// Bit mask of RSDAT field.
	SSC_RSHR_RSDAT_Msk = 0xffff

	// TSHR: Transmit Sync. Holding Register
	// Position of TSDAT field.
	SSC_TSHR_TSDAT_Pos = 0x0
	// Bit mask of TSDAT field.
	SSC_TSHR_TSDAT_Msk = 0xffff

	// RC0R: Receive Compare 0 Register
	// Position of CP0 field.
	SSC_RC0R_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SSC_RC0R_CP0_Msk = 0xffff

	// RC1R: Receive Compare 1 Register
	// Position of CP1 field.
	SSC_RC1R_CP1_Pos = 0x0
	// Bit mask of CP1 field.
	SSC_RC1R_CP1_Msk = 0xffff

	// SR: Status Register
	// Position of TXRDY field.
	SSC_SR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_SR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_SR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_SR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_SR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_SR_TXEMPTY = 0x2
	// Position of ENDTX field.
	SSC_SR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	SSC_SR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	SSC_SR_ENDTX = 0x4
	// Position of TXBUFE field.
	SSC_SR_TXBUFE_Pos = 0x3
	// Bit mask of TXBUFE field.
	SSC_SR_TXBUFE_Msk = 0x8
	// Bit TXBUFE.
	SSC_SR_TXBUFE = 0x8
	// Position of RXRDY field.
	SSC_SR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_SR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_SR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_SR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_SR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_SR_OVRUN = 0x20
	// Position of ENDRX field.
	SSC_SR_ENDRX_Pos = 0x6
	// Bit mask of ENDRX field.
	SSC_SR_ENDRX_Msk = 0x40
	// Bit ENDRX.
	SSC_SR_ENDRX = 0x40
	// Position of RXBUFF field.
	SSC_SR_RXBUFF_Pos = 0x7
	// Bit mask of RXBUFF field.
	SSC_SR_RXBUFF_Msk = 0x80
	// Bit RXBUFF.
	SSC_SR_RXBUFF = 0x80
	// Position of CP0 field.
	SSC_SR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_SR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_SR_CP0 = 0x100
	// Position of CP1 field.
	SSC_SR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_SR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_SR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_SR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_SR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_SR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_SR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_SR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_SR_RXSYN = 0x800
	// Position of TXEN field.
	SSC_SR_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SSC_SR_TXEN_Msk = 0x10000
	// Bit TXEN.
	SSC_SR_TXEN = 0x10000
	// Position of RXEN field.
	SSC_SR_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SSC_SR_RXEN_Msk = 0x20000
	// Bit RXEN.
	SSC_SR_RXEN = 0x20000

	// IER: Interrupt Enable Register
	// Position of TXRDY field.
	SSC_IER_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IER_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IER_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IER_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IER_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IER_TXEMPTY = 0x2
	// Position of ENDTX field.
	SSC_IER_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	SSC_IER_ENDTX_Msk = 0x4
	// Bit ENDTX.
	SSC_IER_ENDTX = 0x4
	// Position of TXBUFE field.
	SSC_IER_TXBUFE_Pos = 0x3
	// Bit mask of TXBUFE field.
	SSC_IER_TXBUFE_Msk = 0x8
	// Bit TXBUFE.
	SSC_IER_TXBUFE = 0x8
	// Position of RXRDY field.
	SSC_IER_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IER_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IER_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IER_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IER_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IER_OVRUN = 0x20
	// Position of ENDRX field.
	SSC_IER_ENDRX_Pos = 0x6
	// Bit mask of ENDRX field.
	SSC_IER_ENDRX_Msk = 0x40
	// Bit ENDRX.
	SSC_IER_ENDRX = 0x40
	// Position of RXBUFF field.
	SSC_IER_RXBUFF_Pos = 0x7
	// Bit mask of RXBUFF field.
	SSC_IER_RXBUFF_Msk = 0x80
	// Bit RXBUFF.
	SSC_IER_RXBUFF = 0x80
	// Position of CP0 field.
	SSC_IER_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IER_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IER_CP0 = 0x100
	// Position of CP1 field.
	SSC_IER_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IER_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IER_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IER_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IER_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IER_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IER_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IER_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IER_RXSYN = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXRDY field.
	SSC_IDR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IDR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IDR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IDR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IDR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IDR_TXEMPTY = 0x2
	// Position of ENDTX field.
	SSC_IDR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	SSC_IDR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	SSC_IDR_ENDTX = 0x4
	// Position of TXBUFE field.
	SSC_IDR_TXBUFE_Pos = 0x3
	// Bit mask of TXBUFE field.
	SSC_IDR_TXBUFE_Msk = 0x8
	// Bit TXBUFE.
	SSC_IDR_TXBUFE = 0x8
	// Position of RXRDY field.
	SSC_IDR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IDR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IDR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IDR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IDR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IDR_OVRUN = 0x20
	// Position of ENDRX field.
	SSC_IDR_ENDRX_Pos = 0x6
	// Bit mask of ENDRX field.
	SSC_IDR_ENDRX_Msk = 0x40
	// Bit ENDRX.
	SSC_IDR_ENDRX = 0x40
	// Position of RXBUFF field.
	SSC_IDR_RXBUFF_Pos = 0x7
	// Bit mask of RXBUFF field.
	SSC_IDR_RXBUFF_Msk = 0x80
	// Bit RXBUFF.
	SSC_IDR_RXBUFF = 0x80
	// Position of CP0 field.
	SSC_IDR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IDR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IDR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IDR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IDR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IDR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IDR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IDR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IDR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IDR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IDR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IDR_RXSYN = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXRDY field.
	SSC_IMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IMR_TXEMPTY = 0x2
	// Position of ENDTX field.
	SSC_IMR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	SSC_IMR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	SSC_IMR_ENDTX = 0x4
	// Position of TXBUFE field.
	SSC_IMR_TXBUFE_Pos = 0x3
	// Bit mask of TXBUFE field.
	SSC_IMR_TXBUFE_Msk = 0x8
	// Bit TXBUFE.
	SSC_IMR_TXBUFE = 0x8
	// Position of RXRDY field.
	SSC_IMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IMR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IMR_OVRUN = 0x20
	// Position of ENDRX field.
	SSC_IMR_ENDRX_Pos = 0x6
	// Bit mask of ENDRX field.
	SSC_IMR_ENDRX_Msk = 0x40
	// Bit ENDRX.
	SSC_IMR_ENDRX = 0x40
	// Position of RXBUFF field.
	SSC_IMR_RXBUFF_Pos = 0x7
	// Bit mask of RXBUFF field.
	SSC_IMR_RXBUFF_Msk = 0x80
	// Bit RXBUFF.
	SSC_IMR_RXBUFF = 0x80
	// Position of CP0 field.
	SSC_IMR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IMR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IMR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IMR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IMR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IMR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IMR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IMR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IMR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IMR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IMR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IMR_RXSYN = 0x800

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	SSC_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	SSC_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	SSC_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	SSC_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	SSC_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	SSC_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	SSC_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	SSC_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	SSC_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	SSC_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	SSC_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	SSC_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	SSC_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	SSC_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	SSC_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	SSC_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	SSC_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SSC_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SSC_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	SSC_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	SSC_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	SSC_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	SSC_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SSC_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SSC_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	SSC_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	SSC_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	SSC_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	SSC_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SSC_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SSC_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	SSC_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SSC_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SSC_PTSR_TXTEN = 0x100
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// CR: Control Register
	// Position of SPIEN field.
	SPI_CR_SPIEN_Pos = 0x0
	// Bit mask of SPIEN field.
	SPI_CR_SPIEN_Msk = 0x1
	// Bit SPIEN.
	SPI_CR_SPIEN = 0x1
	// Position of SPIDIS field.
	SPI_CR_SPIDIS_Pos = 0x1
	// Bit mask of SPIDIS field.
	SPI_CR_SPIDIS_Msk = 0x2
	// Bit SPIDIS.
	SPI_CR_SPIDIS = 0x2
	// Position of SWRST field.
	SPI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	SPI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	SPI_CR_SWRST = 0x80
	// Position of LASTXFER field.
	SPI_CR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_CR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_CR_LASTXFER = 0x1000000

	// MR: Mode Register
	// Position of MSTR field.
	SPI_MR_MSTR_Pos = 0x0
	// Bit mask of MSTR field.
	SPI_MR_MSTR_Msk = 0x1
	// Bit MSTR.
	SPI_MR_MSTR = 0x1
	// Position of PS field.
	SPI_MR_PS_Pos = 0x1
	// Bit mask of PS field.
	SPI_MR_PS_Msk = 0x2
	// Bit PS.
	SPI_MR_PS = 0x2
	// Position of PCSDEC field.
	SPI_MR_PCSDEC_Pos = 0x2
	// Bit mask of PCSDEC field.
	SPI_MR_PCSDEC_Msk = 0x4
	// Bit PCSDEC.
	SPI_MR_PCSDEC = 0x4
	// Position of MODFDIS field.
	SPI_MR_MODFDIS_Pos = 0x4
	// Bit mask of MODFDIS field.
	SPI_MR_MODFDIS_Msk = 0x10
	// Bit MODFDIS.
	SPI_MR_MODFDIS = 0x10
	// Position of WDRBT field.
	SPI_MR_WDRBT_Pos = 0x5
	// Bit mask of WDRBT field.
	SPI_MR_WDRBT_Msk = 0x20
	// Bit WDRBT.
	SPI_MR_WDRBT = 0x20
	// Position of LLB field.
	SPI_MR_LLB_Pos = 0x7
	// Bit mask of LLB field.
	SPI_MR_LLB_Msk = 0x80
	// Bit LLB.
	SPI_MR_LLB = 0x80
	// Position of PCS field.
	SPI_MR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_MR_PCS_Msk = 0xf0000
	// Position of DLYBCS field.
	SPI_MR_DLYBCS_Pos = 0x18
	// Bit mask of DLYBCS field.
	SPI_MR_DLYBCS_Msk = 0xff000000

	// RDR: Receive Data Register
	// Position of RD field.
	SPI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	SPI_RDR_RD_Msk = 0xffff
	// Position of PCS field.
	SPI_RDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_RDR_PCS_Msk = 0xf0000

	// TDR: Transmit Data Register
	// Position of TD field.
	SPI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	SPI_TDR_TD_Msk = 0xffff
	// Position of PCS field.
	SPI_TDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_TDR_PCS_Msk = 0xf0000
	// Position of LASTXFER field.
	SPI_TDR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_TDR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_TDR_LASTXFER = 0x1000000

	// SR: Status Register
	// Position of RDRF field.
	SPI_SR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_SR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_SR_RDRF = 0x1
	// Position of TDRE field.
	SPI_SR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_SR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_SR_TDRE = 0x2
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_SR_MODF = 0x4
	// Position of OVRES field.
	SPI_SR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_SR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_SR_OVRES = 0x8
	// Position of ENDRX field.
	SPI_SR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPI_SR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPI_SR_ENDRX = 0x10
	// Position of ENDTX field.
	SPI_SR_ENDTX_Pos = 0x5
	// Bit mask of ENDTX field.
	SPI_SR_ENDTX_Msk = 0x20
	// Bit ENDTX.
	SPI_SR_ENDTX = 0x20
	// Position of RXBUFF field.
	SPI_SR_RXBUFF_Pos = 0x6
	// Bit mask of RXBUFF field.
	SPI_SR_RXBUFF_Msk = 0x40
	// Bit RXBUFF.
	SPI_SR_RXBUFF = 0x40
	// Position of TXBUFE field.
	SPI_SR_TXBUFE_Pos = 0x7
	// Bit mask of TXBUFE field.
	SPI_SR_TXBUFE_Msk = 0x80
	// Bit TXBUFE.
	SPI_SR_TXBUFE = 0x80
	// Position of NSSR field.
	SPI_SR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_SR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_SR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_SR_TXEMPTY = 0x200
	// Position of SPIENS field.
	SPI_SR_SPIENS_Pos = 0x10
	// Bit mask of SPIENS field.
	SPI_SR_SPIENS_Msk = 0x10000
	// Bit SPIENS.
	SPI_SR_SPIENS = 0x10000

	// IER: Interrupt Enable Register
	// Position of RDRF field.
	SPI_IER_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IER_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IER_RDRF = 0x1
	// Position of TDRE field.
	SPI_IER_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IER_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IER_TDRE = 0x2
	// Position of MODF field.
	SPI_IER_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IER_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IER_MODF = 0x4
	// Position of OVRES field.
	SPI_IER_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IER_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IER_OVRES = 0x8
	// Position of ENDRX field.
	SPI_IER_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPI_IER_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPI_IER_ENDRX = 0x10
	// Position of ENDTX field.
	SPI_IER_ENDTX_Pos = 0x5
	// Bit mask of ENDTX field.
	SPI_IER_ENDTX_Msk = 0x20
	// Bit ENDTX.
	SPI_IER_ENDTX = 0x20
	// Position of RXBUFF field.
	SPI_IER_RXBUFF_Pos = 0x6
	// Bit mask of RXBUFF field.
	SPI_IER_RXBUFF_Msk = 0x40
	// Bit RXBUFF.
	SPI_IER_RXBUFF = 0x40
	// Position of TXBUFE field.
	SPI_IER_TXBUFE_Pos = 0x7
	// Bit mask of TXBUFE field.
	SPI_IER_TXBUFE_Msk = 0x80
	// Bit TXBUFE.
	SPI_IER_TXBUFE = 0x80
	// Position of NSSR field.
	SPI_IER_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IER_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IER_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IER_TXEMPTY = 0x200

	// IDR: Interrupt Disable Register
	// Position of RDRF field.
	SPI_IDR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IDR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IDR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IDR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IDR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IDR_TDRE = 0x2
	// Position of MODF field.
	SPI_IDR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IDR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IDR_MODF = 0x4
	// Position of OVRES field.
	SPI_IDR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IDR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IDR_OVRES = 0x8
	// Position of ENDRX field.
	SPI_IDR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPI_IDR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPI_IDR_ENDRX = 0x10
	// Position of ENDTX field.
	SPI_IDR_ENDTX_Pos = 0x5
	// Bit mask of ENDTX field.
	SPI_IDR_ENDTX_Msk = 0x20
	// Bit ENDTX.
	SPI_IDR_ENDTX = 0x20
	// Position of RXBUFF field.
	SPI_IDR_RXBUFF_Pos = 0x6
	// Bit mask of RXBUFF field.
	SPI_IDR_RXBUFF_Msk = 0x40
	// Bit RXBUFF.
	SPI_IDR_RXBUFF = 0x40
	// Position of TXBUFE field.
	SPI_IDR_TXBUFE_Pos = 0x7
	// Bit mask of TXBUFE field.
	SPI_IDR_TXBUFE_Msk = 0x80
	// Bit TXBUFE.
	SPI_IDR_TXBUFE = 0x80
	// Position of NSSR field.
	SPI_IDR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IDR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IDR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IDR_TXEMPTY = 0x200

	// IMR: Interrupt Mask Register
	// Position of RDRF field.
	SPI_IMR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IMR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IMR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IMR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IMR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IMR_TDRE = 0x2
	// Position of MODF field.
	SPI_IMR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IMR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IMR_MODF = 0x4
	// Position of OVRES field.
	SPI_IMR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IMR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IMR_OVRES = 0x8
	// Position of ENDRX field.
	SPI_IMR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPI_IMR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPI_IMR_ENDRX = 0x10
	// Position of ENDTX field.
	SPI_IMR_ENDTX_Pos = 0x5
	// Bit mask of ENDTX field.
	SPI_IMR_ENDTX_Msk = 0x20
	// Bit ENDTX.
	SPI_IMR_ENDTX = 0x20
	// Position of RXBUFF field.
	SPI_IMR_RXBUFF_Pos = 0x6
	// Bit mask of RXBUFF field.
	SPI_IMR_RXBUFF_Msk = 0x40
	// Bit RXBUFF.
	SPI_IMR_RXBUFF = 0x40
	// Position of TXBUFE field.
	SPI_IMR_TXBUFE_Pos = 0x7
	// Bit mask of TXBUFE field.
	SPI_IMR_TXBUFE_Msk = 0x80
	// Bit TXBUFE.
	SPI_IMR_TXBUFE = 0x80
	// Position of NSSR field.
	SPI_IMR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IMR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IMR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IMR_TXEMPTY = 0x200

	// CSR: Chip Select Register
	// Position of CPOL field.
	SPI_CSR_CPOL_Pos = 0x0
	// Bit mask of CPOL field.
	SPI_CSR_CPOL_Msk = 0x1
	// Bit CPOL.
	SPI_CSR_CPOL = 0x1
	// Position of NCPHA field.
	SPI_CSR_NCPHA_Pos = 0x1
	// Bit mask of NCPHA field.
	SPI_CSR_NCPHA_Msk = 0x2
	// Bit NCPHA.
	SPI_CSR_NCPHA = 0x2
	// Position of CSAAT field.
	SPI_CSR_CSAAT_Pos = 0x3
	// Bit mask of CSAAT field.
	SPI_CSR_CSAAT_Msk = 0x8
	// Bit CSAAT.
	SPI_CSR_CSAAT = 0x8
	// Position of BITS field.
	SPI_CSR_BITS_Pos = 0x4
	// Bit mask of BITS field.
	SPI_CSR_BITS_Msk = 0xf0
	// 8 bits for transfer
	SPI_CSR_BITS_8_BIT = 0x0
	// 9 bits for transfer
	SPI_CSR_BITS_9_BIT = 0x1
	// 10 bits for transfer
	SPI_CSR_BITS_10_BIT = 0x2
	// 11 bits for transfer
	SPI_CSR_BITS_11_BIT = 0x3
	// 12 bits for transfer
	SPI_CSR_BITS_12_BIT = 0x4
	// 13 bits for transfer
	SPI_CSR_BITS_13_BIT = 0x5
	// 14 bits for transfer
	SPI_CSR_BITS_14_BIT = 0x6
	// 15 bits for transfer
	SPI_CSR_BITS_15_BIT = 0x7
	// 16 bits for transfer
	SPI_CSR_BITS_16_BIT = 0x8
	// Position of SCBR field.
	SPI_CSR_SCBR_Pos = 0x8
	// Bit mask of SCBR field.
	SPI_CSR_SCBR_Msk = 0xff00
	// Position of DLYBS field.
	SPI_CSR_DLYBS_Pos = 0x10
	// Bit mask of DLYBS field.
	SPI_CSR_DLYBS_Msk = 0xff0000
	// Position of DLYBCT field.
	SPI_CSR_DLYBCT_Pos = 0x18
	// Bit mask of DLYBCT field.
	SPI_CSR_DLYBCT_Msk = 0xff000000

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	SPI_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	SPI_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	SPI_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	SPI_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	SPI_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	SPI_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	SPI_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	SPI_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	SPI_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	SPI_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	SPI_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	SPI_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	SPI_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	SPI_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	SPI_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	SPI_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	SPI_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SPI_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SPI_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	SPI_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	SPI_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	SPI_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	SPI_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SPI_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SPI_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	SPI_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	SPI_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	SPI_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	SPI_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SPI_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SPI_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	SPI_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SPI_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SPI_PTSR_TXTEN = 0x100
)

// Constants for AC97C: AC97 Controller
const (
	// MR: Mode Register
	// Position of ENA field.
	AC97C_MR_ENA_Pos = 0x0
	// Bit mask of ENA field.
	AC97C_MR_ENA_Msk = 0x1
	// Bit ENA.
	AC97C_MR_ENA = 0x1
	// Position of WRST field.
	AC97C_MR_WRST_Pos = 0x1
	// Bit mask of WRST field.
	AC97C_MR_WRST_Msk = 0x2
	// Bit WRST.
	AC97C_MR_WRST = 0x2
	// Position of VRA field.
	AC97C_MR_VRA_Pos = 0x2
	// Bit mask of VRA field.
	AC97C_MR_VRA_Msk = 0x4
	// Bit VRA.
	AC97C_MR_VRA = 0x4

	// ICA: Input Channel Assignment Register
	// Position of CHID3 field.
	AC97C_ICA_CHID3_Pos = 0x0
	// Bit mask of CHID3 field.
	AC97C_ICA_CHID3_Msk = 0x7
	// Position of CHID4 field.
	AC97C_ICA_CHID4_Pos = 0x3
	// Bit mask of CHID4 field.
	AC97C_ICA_CHID4_Msk = 0x38
	// Position of CHID5 field.
	AC97C_ICA_CHID5_Pos = 0x6
	// Bit mask of CHID5 field.
	AC97C_ICA_CHID5_Msk = 0x1c0
	// Position of CHID6 field.
	AC97C_ICA_CHID6_Pos = 0x9
	// Bit mask of CHID6 field.
	AC97C_ICA_CHID6_Msk = 0xe00
	// Position of CHID7 field.
	AC97C_ICA_CHID7_Pos = 0xc
	// Bit mask of CHID7 field.
	AC97C_ICA_CHID7_Msk = 0x7000
	// Position of CHID8 field.
	AC97C_ICA_CHID8_Pos = 0xf
	// Bit mask of CHID8 field.
	AC97C_ICA_CHID8_Msk = 0x38000
	// Position of CHID9 field.
	AC97C_ICA_CHID9_Pos = 0x12
	// Bit mask of CHID9 field.
	AC97C_ICA_CHID9_Msk = 0x1c0000
	// Position of CHID10 field.
	AC97C_ICA_CHID10_Pos = 0x15
	// Bit mask of CHID10 field.
	AC97C_ICA_CHID10_Msk = 0xe00000
	// Position of CHID11 field.
	AC97C_ICA_CHID11_Pos = 0x18
	// Bit mask of CHID11 field.
	AC97C_ICA_CHID11_Msk = 0x7000000
	// Position of CHID12 field.
	AC97C_ICA_CHID12_Pos = 0x1b
	// Bit mask of CHID12 field.
	AC97C_ICA_CHID12_Msk = 0x38000000

	// OCA: Output Channel Assignment Register
	// Position of CHID3 field.
	AC97C_OCA_CHID3_Pos = 0x0
	// Bit mask of CHID3 field.
	AC97C_OCA_CHID3_Msk = 0x7
	// Position of CHID4 field.
	AC97C_OCA_CHID4_Pos = 0x3
	// Bit mask of CHID4 field.
	AC97C_OCA_CHID4_Msk = 0x38
	// Position of CHID5 field.
	AC97C_OCA_CHID5_Pos = 0x6
	// Bit mask of CHID5 field.
	AC97C_OCA_CHID5_Msk = 0x1c0
	// Position of CHID6 field.
	AC97C_OCA_CHID6_Pos = 0x9
	// Bit mask of CHID6 field.
	AC97C_OCA_CHID6_Msk = 0xe00
	// Position of CHID7 field.
	AC97C_OCA_CHID7_Pos = 0xc
	// Bit mask of CHID7 field.
	AC97C_OCA_CHID7_Msk = 0x7000
	// Position of CHID8 field.
	AC97C_OCA_CHID8_Pos = 0xf
	// Bit mask of CHID8 field.
	AC97C_OCA_CHID8_Msk = 0x38000
	// Position of CHID9 field.
	AC97C_OCA_CHID9_Pos = 0x12
	// Bit mask of CHID9 field.
	AC97C_OCA_CHID9_Msk = 0x1c0000
	// Position of CHID10 field.
	AC97C_OCA_CHID10_Pos = 0x15
	// Bit mask of CHID10 field.
	AC97C_OCA_CHID10_Msk = 0xe00000
	// Position of CHID11 field.
	AC97C_OCA_CHID11_Pos = 0x18
	// Bit mask of CHID11 field.
	AC97C_OCA_CHID11_Msk = 0x7000000
	// Position of CHID12 field.
	AC97C_OCA_CHID12_Pos = 0x1b
	// Bit mask of CHID12 field.
	AC97C_OCA_CHID12_Msk = 0x38000000

	// CARHR: Channel A Receive Holding Register
	// Position of RDATA field.
	AC97C_CARHR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	AC97C_CARHR_RDATA_Msk = 0xfffff

	// CATHR: Channel A Transmit Holding Register
	// Position of TDATA field.
	AC97C_CATHR_TDATA_Pos = 0x0
	// Bit mask of TDATA field.
	AC97C_CATHR_TDATA_Msk = 0xfffff

	// CASR: Channel A Status Register
	// Position of TXRDY field.
	AC97C_CASR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_CASR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_CASR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_CASR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_CASR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_CASR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_CASR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_CASR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_CASR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_CASR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_CASR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_CASR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_CASR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_CASR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_CASR_OVRUN = 0x20
	// Position of ENDTX field.
	AC97C_CASR_ENDTX_Pos = 0xa
	// Bit mask of ENDTX field.
	AC97C_CASR_ENDTX_Msk = 0x400
	// Bit ENDTX.
	AC97C_CASR_ENDTX = 0x400
	// Position of TXBUFE field.
	AC97C_CASR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	AC97C_CASR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	AC97C_CASR_TXBUFE = 0x800
	// Position of ENDRX field.
	AC97C_CASR_ENDRX_Pos = 0xe
	// Bit mask of ENDRX field.
	AC97C_CASR_ENDRX_Msk = 0x4000
	// Bit ENDRX.
	AC97C_CASR_ENDRX = 0x4000
	// Position of RXBUFF field.
	AC97C_CASR_RXBUFF_Pos = 0xf
	// Bit mask of RXBUFF field.
	AC97C_CASR_RXBUFF_Msk = 0x8000
	// Bit RXBUFF.
	AC97C_CASR_RXBUFF = 0x8000

	// CAMR: Channel A Mode Register
	// Position of TXRDY field.
	AC97C_CAMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_CAMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_CAMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_CAMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_CAMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_CAMR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_CAMR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_CAMR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_CAMR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_CAMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_CAMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_CAMR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_CAMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_CAMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_CAMR_OVRUN = 0x20
	// Position of ENDTX field.
	AC97C_CAMR_ENDTX_Pos = 0xa
	// Bit mask of ENDTX field.
	AC97C_CAMR_ENDTX_Msk = 0x400
	// Bit ENDTX.
	AC97C_CAMR_ENDTX = 0x400
	// Position of TXBUFE field.
	AC97C_CAMR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	AC97C_CAMR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	AC97C_CAMR_TXBUFE = 0x800
	// Position of ENDRX field.
	AC97C_CAMR_ENDRX_Pos = 0xe
	// Bit mask of ENDRX field.
	AC97C_CAMR_ENDRX_Msk = 0x4000
	// Bit ENDRX.
	AC97C_CAMR_ENDRX = 0x4000
	// Position of RXBUFF field.
	AC97C_CAMR_RXBUFF_Pos = 0xf
	// Bit mask of RXBUFF field.
	AC97C_CAMR_RXBUFF_Msk = 0x8000
	// Bit RXBUFF.
	AC97C_CAMR_RXBUFF = 0x8000
	// Position of SIZE field.
	AC97C_CAMR_SIZE_Pos = 0x10
	// Bit mask of SIZE field.
	AC97C_CAMR_SIZE_Msk = 0x30000
	// Position of CEM field.
	AC97C_CAMR_CEM_Pos = 0x12
	// Bit mask of CEM field.
	AC97C_CAMR_CEM_Msk = 0x40000
	// Bit CEM.
	AC97C_CAMR_CEM = 0x40000
	// Position of CEN field.
	AC97C_CAMR_CEN_Pos = 0x15
	// Bit mask of CEN field.
	AC97C_CAMR_CEN_Msk = 0x200000
	// Bit CEN.
	AC97C_CAMR_CEN = 0x200000
	// Position of PDCEN field.
	AC97C_CAMR_PDCEN_Pos = 0x16
	// Bit mask of PDCEN field.
	AC97C_CAMR_PDCEN_Msk = 0x400000
	// Bit PDCEN.
	AC97C_CAMR_PDCEN = 0x400000

	// CBRHR: Channel B Receive Holding Register
	// Position of RDATA field.
	AC97C_CBRHR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	AC97C_CBRHR_RDATA_Msk = 0xfffff

	// CBTHR: Channel B Transmit Holding Register
	// Position of TDATA field.
	AC97C_CBTHR_TDATA_Pos = 0x0
	// Bit mask of TDATA field.
	AC97C_CBTHR_TDATA_Msk = 0xfffff

	// CBSR: Channel B Status Register
	// Position of TXRDY field.
	AC97C_CBSR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_CBSR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_CBSR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_CBSR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_CBSR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_CBSR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_CBSR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_CBSR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_CBSR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_CBSR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_CBSR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_CBSR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_CBSR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_CBSR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_CBSR_OVRUN = 0x20
	// Position of ENDTX field.
	AC97C_CBSR_ENDTX_Pos = 0x9
	// Bit mask of ENDTX field.
	AC97C_CBSR_ENDTX_Msk = 0x200
	// Bit ENDTX.
	AC97C_CBSR_ENDTX = 0x200
	// Position of TXBUFE field.
	AC97C_CBSR_TXBUFE_Pos = 0xa
	// Bit mask of TXBUFE field.
	AC97C_CBSR_TXBUFE_Msk = 0x400
	// Bit TXBUFE.
	AC97C_CBSR_TXBUFE = 0x400
	// Position of ENDRX field.
	AC97C_CBSR_ENDRX_Pos = 0xe
	// Bit mask of ENDRX field.
	AC97C_CBSR_ENDRX_Msk = 0x4000
	// Bit ENDRX.
	AC97C_CBSR_ENDRX = 0x4000
	// Position of RXBUFF field.
	AC97C_CBSR_RXBUFF_Pos = 0xf
	// Bit mask of RXBUFF field.
	AC97C_CBSR_RXBUFF_Msk = 0x8000
	// Bit RXBUFF.
	AC97C_CBSR_RXBUFF = 0x8000

	// CBMR: Channel B Mode Register
	// Position of TXRDY field.
	AC97C_CBMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_CBMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_CBMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_CBMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_CBMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_CBMR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_CBMR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_CBMR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_CBMR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_CBMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_CBMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_CBMR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_CBMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_CBMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_CBMR_OVRUN = 0x20
	// Position of ENDTX field.
	AC97C_CBMR_ENDTX_Pos = 0xa
	// Bit mask of ENDTX field.
	AC97C_CBMR_ENDTX_Msk = 0x400
	// Bit ENDTX.
	AC97C_CBMR_ENDTX = 0x400
	// Position of TXBUFE field.
	AC97C_CBMR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	AC97C_CBMR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	AC97C_CBMR_TXBUFE = 0x800
	// Position of ENDRX field.
	AC97C_CBMR_ENDRX_Pos = 0xe
	// Bit mask of ENDRX field.
	AC97C_CBMR_ENDRX_Msk = 0x4000
	// Bit ENDRX.
	AC97C_CBMR_ENDRX = 0x4000
	// Position of RXBUFF field.
	AC97C_CBMR_RXBUFF_Pos = 0xf
	// Bit mask of RXBUFF field.
	AC97C_CBMR_RXBUFF_Msk = 0x8000
	// Bit RXBUFF.
	AC97C_CBMR_RXBUFF = 0x8000
	// Position of SIZE field.
	AC97C_CBMR_SIZE_Pos = 0x10
	// Bit mask of SIZE field.
	AC97C_CBMR_SIZE_Msk = 0x30000
	// Position of CEM field.
	AC97C_CBMR_CEM_Pos = 0x12
	// Bit mask of CEM field.
	AC97C_CBMR_CEM_Msk = 0x40000
	// Bit CEM.
	AC97C_CBMR_CEM = 0x40000
	// Position of CEN field.
	AC97C_CBMR_CEN_Pos = 0x15
	// Bit mask of CEN field.
	AC97C_CBMR_CEN_Msk = 0x200000
	// Bit CEN.
	AC97C_CBMR_CEN = 0x200000
	// Position of PDCEN field.
	AC97C_CBMR_PDCEN_Pos = 0x16
	// Bit mask of PDCEN field.
	AC97C_CBMR_PDCEN_Msk = 0x400000
	// Bit PDCEN.
	AC97C_CBMR_PDCEN = 0x400000

	// CORHR: Codec Channel Receive Holding Register
	// Position of SDATA field.
	AC97C_CORHR_SDATA_Pos = 0x0
	// Bit mask of SDATA field.
	AC97C_CORHR_SDATA_Msk = 0xffff

	// COTHR: Codec Channel Transmit Holding Register
	// Position of CDATA field.
	AC97C_COTHR_CDATA_Pos = 0x0
	// Bit mask of CDATA field.
	AC97C_COTHR_CDATA_Msk = 0xffff
	// Position of CADDR field.
	AC97C_COTHR_CADDR_Pos = 0x10
	// Bit mask of CADDR field.
	AC97C_COTHR_CADDR_Msk = 0x7f0000
	// Position of READ field.
	AC97C_COTHR_READ_Pos = 0x17
	// Bit mask of READ field.
	AC97C_COTHR_READ_Msk = 0x800000
	// Bit READ.
	AC97C_COTHR_READ = 0x800000

	// COSR: Codec Status Register
	// Position of TXRDY field.
	AC97C_COSR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_COSR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_COSR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_COSR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_COSR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_COSR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_COSR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_COSR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_COSR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_COSR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_COSR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_COSR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_COSR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_COSR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_COSR_OVRUN = 0x20

	// COMR: Codec Mode Register
	// Position of TXRDY field.
	AC97C_COMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	AC97C_COMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	AC97C_COMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	AC97C_COMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	AC97C_COMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	AC97C_COMR_TXEMPTY = 0x2
	// Position of UNRUN field.
	AC97C_COMR_UNRUN_Pos = 0x2
	// Bit mask of UNRUN field.
	AC97C_COMR_UNRUN_Msk = 0x4
	// Bit UNRUN.
	AC97C_COMR_UNRUN = 0x4
	// Position of RXRDY field.
	AC97C_COMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	AC97C_COMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	AC97C_COMR_RXRDY = 0x10
	// Position of OVRUN field.
	AC97C_COMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	AC97C_COMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	AC97C_COMR_OVRUN = 0x20

	// SR: Status Register
	// Position of SOF field.
	AC97C_SR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	AC97C_SR_SOF_Msk = 0x1
	// Bit SOF.
	AC97C_SR_SOF = 0x1
	// Position of WKUP field.
	AC97C_SR_WKUP_Pos = 0x1
	// Bit mask of WKUP field.
	AC97C_SR_WKUP_Msk = 0x2
	// Bit WKUP.
	AC97C_SR_WKUP = 0x2
	// Position of COEVT field.
	AC97C_SR_COEVT_Pos = 0x2
	// Bit mask of COEVT field.
	AC97C_SR_COEVT_Msk = 0x4
	// Bit COEVT.
	AC97C_SR_COEVT = 0x4
	// Position of CAEVT field.
	AC97C_SR_CAEVT_Pos = 0x3
	// Bit mask of CAEVT field.
	AC97C_SR_CAEVT_Msk = 0x8
	// Bit CAEVT.
	AC97C_SR_CAEVT = 0x8
	// Position of CBEVT field.
	AC97C_SR_CBEVT_Pos = 0x4
	// Bit mask of CBEVT field.
	AC97C_SR_CBEVT_Msk = 0x10
	// Bit CBEVT.
	AC97C_SR_CBEVT = 0x10

	// IER: Interrupt Enable Register
	// Position of SOF field.
	AC97C_IER_SOF_Pos = 0x0
	// Bit mask of SOF field.
	AC97C_IER_SOF_Msk = 0x1
	// Bit SOF.
	AC97C_IER_SOF = 0x1
	// Position of WKUP field.
	AC97C_IER_WKUP_Pos = 0x1
	// Bit mask of WKUP field.
	AC97C_IER_WKUP_Msk = 0x2
	// Bit WKUP.
	AC97C_IER_WKUP = 0x2
	// Position of COEVT field.
	AC97C_IER_COEVT_Pos = 0x2
	// Bit mask of COEVT field.
	AC97C_IER_COEVT_Msk = 0x4
	// Bit COEVT.
	AC97C_IER_COEVT = 0x4
	// Position of CAEVT field.
	AC97C_IER_CAEVT_Pos = 0x3
	// Bit mask of CAEVT field.
	AC97C_IER_CAEVT_Msk = 0x8
	// Bit CAEVT.
	AC97C_IER_CAEVT = 0x8
	// Position of CBEVT field.
	AC97C_IER_CBEVT_Pos = 0x4
	// Bit mask of CBEVT field.
	AC97C_IER_CBEVT_Msk = 0x10
	// Bit CBEVT.
	AC97C_IER_CBEVT = 0x10

	// IDR: Interrupt Disable Register
	// Position of SOF field.
	AC97C_IDR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	AC97C_IDR_SOF_Msk = 0x1
	// Bit SOF.
	AC97C_IDR_SOF = 0x1
	// Position of WKUP field.
	AC97C_IDR_WKUP_Pos = 0x1
	// Bit mask of WKUP field.
	AC97C_IDR_WKUP_Msk = 0x2
	// Bit WKUP.
	AC97C_IDR_WKUP = 0x2
	// Position of COEVT field.
	AC97C_IDR_COEVT_Pos = 0x2
	// Bit mask of COEVT field.
	AC97C_IDR_COEVT_Msk = 0x4
	// Bit COEVT.
	AC97C_IDR_COEVT = 0x4
	// Position of CAEVT field.
	AC97C_IDR_CAEVT_Pos = 0x3
	// Bit mask of CAEVT field.
	AC97C_IDR_CAEVT_Msk = 0x8
	// Bit CAEVT.
	AC97C_IDR_CAEVT = 0x8
	// Position of CBEVT field.
	AC97C_IDR_CBEVT_Pos = 0x4
	// Bit mask of CBEVT field.
	AC97C_IDR_CBEVT_Msk = 0x10
	// Bit CBEVT.
	AC97C_IDR_CBEVT = 0x10

	// IMR: Interrupt Mask Register
	// Position of SOF field.
	AC97C_IMR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	AC97C_IMR_SOF_Msk = 0x1
	// Bit SOF.
	AC97C_IMR_SOF = 0x1
	// Position of WKUP field.
	AC97C_IMR_WKUP_Pos = 0x1
	// Bit mask of WKUP field.
	AC97C_IMR_WKUP_Msk = 0x2
	// Bit WKUP.
	AC97C_IMR_WKUP = 0x2
	// Position of COEVT field.
	AC97C_IMR_COEVT_Pos = 0x2
	// Bit mask of COEVT field.
	AC97C_IMR_COEVT_Msk = 0x4
	// Bit COEVT.
	AC97C_IMR_COEVT = 0x4
	// Position of CAEVT field.
	AC97C_IMR_CAEVT_Pos = 0x3
	// Bit mask of CAEVT field.
	AC97C_IMR_CAEVT_Msk = 0x8
	// Bit CAEVT.
	AC97C_IMR_CAEVT = 0x8
	// Position of CBEVT field.
	AC97C_IMR_CBEVT_Pos = 0x4
	// Bit mask of CBEVT field.
	AC97C_IMR_CBEVT_Msk = 0x10
	// Bit CBEVT.
	AC97C_IMR_CBEVT = 0x10

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	AC97C_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	AC97C_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	AC97C_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	AC97C_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	AC97C_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	AC97C_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	AC97C_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	AC97C_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	AC97C_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	AC97C_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	AC97C_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	AC97C_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	AC97C_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	AC97C_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	AC97C_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	AC97C_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	AC97C_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	AC97C_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	AC97C_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	AC97C_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	AC97C_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	AC97C_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	AC97C_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	AC97C_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	AC97C_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	AC97C_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	AC97C_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	AC97C_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	AC97C_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	AC97C_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	AC97C_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	AC97C_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	AC97C_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	AC97C_PTSR_TXTEN = 0x100
)

// Constants for TSADCC: Touch Screen ADC Controller
const (
	// CR: Control Register
	// Position of SWRST field.
	TSADCC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TSADCC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	TSADCC_CR_SWRST = 0x1
	// Position of START field.
	TSADCC_CR_START_Pos = 0x1
	// Bit mask of START field.
	TSADCC_CR_START_Msk = 0x2
	// Bit START.
	TSADCC_CR_START = 0x2

	// MR: Mode Register
	// Position of TSAMOD field.
	TSADCC_MR_TSAMOD_Pos = 0x0
	// Bit mask of TSAMOD field.
	TSADCC_MR_TSAMOD_Msk = 0x3
	// Position of PDCEN field.
	TSADCC_MR_PDCEN_Pos = 0x3
	// Bit mask of PDCEN field.
	TSADCC_MR_PDCEN_Msk = 0x8
	// Bit PDCEN.
	TSADCC_MR_PDCEN = 0x8
	// Position of LOWRES field.
	TSADCC_MR_LOWRES_Pos = 0x4
	// Bit mask of LOWRES field.
	TSADCC_MR_LOWRES_Msk = 0x10
	// Bit LOWRES.
	TSADCC_MR_LOWRES = 0x10
	// Position of SLEEP field.
	TSADCC_MR_SLEEP_Pos = 0x5
	// Bit mask of SLEEP field.
	TSADCC_MR_SLEEP_Msk = 0x20
	// Bit SLEEP.
	TSADCC_MR_SLEEP = 0x20
	// Position of PENDET field.
	TSADCC_MR_PENDET_Pos = 0x6
	// Bit mask of PENDET field.
	TSADCC_MR_PENDET_Msk = 0x40
	// Bit PENDET.
	TSADCC_MR_PENDET = 0x40
	// Position of PRES field.
	TSADCC_MR_PRES_Pos = 0x7
	// Bit mask of PRES field.
	TSADCC_MR_PRES_Msk = 0x80
	// Bit PRES.
	TSADCC_MR_PRES = 0x80
	// Position of PRESCAL field.
	TSADCC_MR_PRESCAL_Pos = 0x8
	// Bit mask of PRESCAL field.
	TSADCC_MR_PRESCAL_Msk = 0xff00
	// Position of STARTUP field.
	TSADCC_MR_STARTUP_Pos = 0x10
	// Bit mask of STARTUP field.
	TSADCC_MR_STARTUP_Msk = 0x7f0000
	// Position of SHTIM field.
	TSADCC_MR_SHTIM_Pos = 0x18
	// Bit mask of SHTIM field.
	TSADCC_MR_SHTIM_Msk = 0xf000000
	// Position of PENDBC field.
	TSADCC_MR_PENDBC_Pos = 0x1c
	// Bit mask of PENDBC field.
	TSADCC_MR_PENDBC_Msk = 0xf0000000

	// TRGR: Trigger Register
	// Position of TRGMOD field.
	TSADCC_TRGR_TRGMOD_Pos = 0x0
	// Bit mask of TRGMOD field.
	TSADCC_TRGR_TRGMOD_Msk = 0x7
	// Position of TRGPER field.
	TSADCC_TRGR_TRGPER_Pos = 0x10
	// Bit mask of TRGPER field.
	TSADCC_TRGR_TRGPER_Msk = 0xffff0000

	// TSR: Touch Screen Register
	// Position of TSFREQ field.
	TSADCC_TSR_TSFREQ_Pos = 0x0
	// Bit mask of TSFREQ field.
	TSADCC_TSR_TSFREQ_Msk = 0xf
	// Position of TSSHTIM field.
	TSADCC_TSR_TSSHTIM_Pos = 0x18
	// Bit mask of TSSHTIM field.
	TSADCC_TSR_TSSHTIM_Msk = 0xf000000

	// CHER: Channel Enable Register
	// Position of CH0 field.
	TSADCC_CHER_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	TSADCC_CHER_CH0_Msk = 0x1
	// Bit CH0.
	TSADCC_CHER_CH0 = 0x1
	// Position of CH1 field.
	TSADCC_CHER_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	TSADCC_CHER_CH1_Msk = 0x2
	// Bit CH1.
	TSADCC_CHER_CH1 = 0x2
	// Position of CH2 field.
	TSADCC_CHER_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	TSADCC_CHER_CH2_Msk = 0x4
	// Bit CH2.
	TSADCC_CHER_CH2 = 0x4
	// Position of CH3 field.
	TSADCC_CHER_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	TSADCC_CHER_CH3_Msk = 0x8
	// Bit CH3.
	TSADCC_CHER_CH3 = 0x8
	// Position of CH4 field.
	TSADCC_CHER_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	TSADCC_CHER_CH4_Msk = 0x10
	// Bit CH4.
	TSADCC_CHER_CH4 = 0x10
	// Position of CH5 field.
	TSADCC_CHER_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	TSADCC_CHER_CH5_Msk = 0x20
	// Bit CH5.
	TSADCC_CHER_CH5 = 0x20
	// Position of CH6 field.
	TSADCC_CHER_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	TSADCC_CHER_CH6_Msk = 0x40
	// Bit CH6.
	TSADCC_CHER_CH6 = 0x40
	// Position of CH7 field.
	TSADCC_CHER_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	TSADCC_CHER_CH7_Msk = 0x80
	// Bit CH7.
	TSADCC_CHER_CH7 = 0x80

	// CHDR: Channel Disable Register
	// Position of CH0 field.
	TSADCC_CHDR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	TSADCC_CHDR_CH0_Msk = 0x1
	// Bit CH0.
	TSADCC_CHDR_CH0 = 0x1
	// Position of CH1 field.
	TSADCC_CHDR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	TSADCC_CHDR_CH1_Msk = 0x2
	// Bit CH1.
	TSADCC_CHDR_CH1 = 0x2
	// Position of CH2 field.
	TSADCC_CHDR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	TSADCC_CHDR_CH2_Msk = 0x4
	// Bit CH2.
	TSADCC_CHDR_CH2 = 0x4
	// Position of CH3 field.
	TSADCC_CHDR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	TSADCC_CHDR_CH3_Msk = 0x8
	// Bit CH3.
	TSADCC_CHDR_CH3 = 0x8
	// Position of CH4 field.
	TSADCC_CHDR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	TSADCC_CHDR_CH4_Msk = 0x10
	// Bit CH4.
	TSADCC_CHDR_CH4 = 0x10
	// Position of CH5 field.
	TSADCC_CHDR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	TSADCC_CHDR_CH5_Msk = 0x20
	// Bit CH5.
	TSADCC_CHDR_CH5 = 0x20
	// Position of CH6 field.
	TSADCC_CHDR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	TSADCC_CHDR_CH6_Msk = 0x40
	// Bit CH6.
	TSADCC_CHDR_CH6 = 0x40
	// Position of CH7 field.
	TSADCC_CHDR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	TSADCC_CHDR_CH7_Msk = 0x80
	// Bit CH7.
	TSADCC_CHDR_CH7 = 0x80

	// CHSR: Channel Status Register
	// Position of CH0 field.
	TSADCC_CHSR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	TSADCC_CHSR_CH0_Msk = 0x1
	// Bit CH0.
	TSADCC_CHSR_CH0 = 0x1
	// Position of CH1 field.
	TSADCC_CHSR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	TSADCC_CHSR_CH1_Msk = 0x2
	// Bit CH1.
	TSADCC_CHSR_CH1 = 0x2
	// Position of CH2 field.
	TSADCC_CHSR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	TSADCC_CHSR_CH2_Msk = 0x4
	// Bit CH2.
	TSADCC_CHSR_CH2 = 0x4
	// Position of CH3 field.
	TSADCC_CHSR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	TSADCC_CHSR_CH3_Msk = 0x8
	// Bit CH3.
	TSADCC_CHSR_CH3 = 0x8
	// Position of CH4 field.
	TSADCC_CHSR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	TSADCC_CHSR_CH4_Msk = 0x10
	// Bit CH4.
	TSADCC_CHSR_CH4 = 0x10
	// Position of CH5 field.
	TSADCC_CHSR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	TSADCC_CHSR_CH5_Msk = 0x20
	// Bit CH5.
	TSADCC_CHSR_CH5 = 0x20
	// Position of CH6 field.
	TSADCC_CHSR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	TSADCC_CHSR_CH6_Msk = 0x40
	// Bit CH6.
	TSADCC_CHSR_CH6 = 0x40
	// Position of CH7 field.
	TSADCC_CHSR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	TSADCC_CHSR_CH7_Msk = 0x80
	// Bit CH7.
	TSADCC_CHSR_CH7 = 0x80

	// SR: Status Register
	// Position of EOC0 field.
	TSADCC_SR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	TSADCC_SR_EOC0_Msk = 0x1
	// Bit EOC0.
	TSADCC_SR_EOC0 = 0x1
	// Position of EOC1 field.
	TSADCC_SR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	TSADCC_SR_EOC1_Msk = 0x2
	// Bit EOC1.
	TSADCC_SR_EOC1 = 0x2
	// Position of EOC2 field.
	TSADCC_SR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	TSADCC_SR_EOC2_Msk = 0x4
	// Bit EOC2.
	TSADCC_SR_EOC2 = 0x4
	// Position of EOC3 field.
	TSADCC_SR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	TSADCC_SR_EOC3_Msk = 0x8
	// Bit EOC3.
	TSADCC_SR_EOC3 = 0x8
	// Position of EOC4 field.
	TSADCC_SR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	TSADCC_SR_EOC4_Msk = 0x10
	// Bit EOC4.
	TSADCC_SR_EOC4 = 0x10
	// Position of EOC5 field.
	TSADCC_SR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	TSADCC_SR_EOC5_Msk = 0x20
	// Bit EOC5.
	TSADCC_SR_EOC5 = 0x20
	// Position of EOC6 field.
	TSADCC_SR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	TSADCC_SR_EOC6_Msk = 0x40
	// Bit EOC6.
	TSADCC_SR_EOC6 = 0x40
	// Position of EOC7 field.
	TSADCC_SR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	TSADCC_SR_EOC7_Msk = 0x80
	// Bit EOC7.
	TSADCC_SR_EOC7 = 0x80
	// Position of OVRE0 field.
	TSADCC_SR_OVRE0_Pos = 0x8
	// Bit mask of OVRE0 field.
	TSADCC_SR_OVRE0_Msk = 0x100
	// Bit OVRE0.
	TSADCC_SR_OVRE0 = 0x100
	// Position of OVRE1 field.
	TSADCC_SR_OVRE1_Pos = 0x9
	// Bit mask of OVRE1 field.
	TSADCC_SR_OVRE1_Msk = 0x200
	// Bit OVRE1.
	TSADCC_SR_OVRE1 = 0x200
	// Position of OVRE2 field.
	TSADCC_SR_OVRE2_Pos = 0xa
	// Bit mask of OVRE2 field.
	TSADCC_SR_OVRE2_Msk = 0x400
	// Bit OVRE2.
	TSADCC_SR_OVRE2 = 0x400
	// Position of OVRE3 field.
	TSADCC_SR_OVRE3_Pos = 0xb
	// Bit mask of OVRE3 field.
	TSADCC_SR_OVRE3_Msk = 0x800
	// Bit OVRE3.
	TSADCC_SR_OVRE3 = 0x800
	// Position of OVRE4 field.
	TSADCC_SR_OVRE4_Pos = 0xc
	// Bit mask of OVRE4 field.
	TSADCC_SR_OVRE4_Msk = 0x1000
	// Bit OVRE4.
	TSADCC_SR_OVRE4 = 0x1000
	// Position of OVRE5 field.
	TSADCC_SR_OVRE5_Pos = 0xd
	// Bit mask of OVRE5 field.
	TSADCC_SR_OVRE5_Msk = 0x2000
	// Bit OVRE5.
	TSADCC_SR_OVRE5 = 0x2000
	// Position of OVRE6 field.
	TSADCC_SR_OVRE6_Pos = 0xe
	// Bit mask of OVRE6 field.
	TSADCC_SR_OVRE6_Msk = 0x4000
	// Bit OVRE6.
	TSADCC_SR_OVRE6 = 0x4000
	// Position of OVRE7 field.
	TSADCC_SR_OVRE7_Pos = 0xf
	// Bit mask of OVRE7 field.
	TSADCC_SR_OVRE7_Msk = 0x8000
	// Bit OVRE7.
	TSADCC_SR_OVRE7 = 0x8000
	// Position of DRDY field.
	TSADCC_SR_DRDY_Pos = 0x10
	// Bit mask of DRDY field.
	TSADCC_SR_DRDY_Msk = 0x10000
	// Bit DRDY.
	TSADCC_SR_DRDY = 0x10000
	// Position of GOVRE field.
	TSADCC_SR_GOVRE_Pos = 0x11
	// Bit mask of GOVRE field.
	TSADCC_SR_GOVRE_Msk = 0x20000
	// Bit GOVRE.
	TSADCC_SR_GOVRE = 0x20000
	// Position of ENDRX field.
	TSADCC_SR_ENDRX_Pos = 0x12
	// Bit mask of ENDRX field.
	TSADCC_SR_ENDRX_Msk = 0x40000
	// Bit ENDRX.
	TSADCC_SR_ENDRX = 0x40000
	// Position of RXBUFF field.
	TSADCC_SR_RXBUFF_Pos = 0x13
	// Bit mask of RXBUFF field.
	TSADCC_SR_RXBUFF_Msk = 0x80000
	// Bit RXBUFF.
	TSADCC_SR_RXBUFF = 0x80000
	// Position of PENCNT field.
	TSADCC_SR_PENCNT_Pos = 0x14
	// Bit mask of PENCNT field.
	TSADCC_SR_PENCNT_Msk = 0x100000
	// Bit PENCNT.
	TSADCC_SR_PENCNT = 0x100000
	// Position of NOCNT field.
	TSADCC_SR_NOCNT_Pos = 0x15
	// Bit mask of NOCNT field.
	TSADCC_SR_NOCNT_Msk = 0x200000
	// Bit NOCNT.
	TSADCC_SR_NOCNT = 0x200000
	// Position of EOCXP field.
	TSADCC_SR_EOCXP_Pos = 0x18
	// Bit mask of EOCXP field.
	TSADCC_SR_EOCXP_Msk = 0x1000000
	// Bit EOCXP.
	TSADCC_SR_EOCXP = 0x1000000
	// Position of EOCZ1 field.
	TSADCC_SR_EOCZ1_Pos = 0x19
	// Bit mask of EOCZ1 field.
	TSADCC_SR_EOCZ1_Msk = 0x2000000
	// Bit EOCZ1.
	TSADCC_SR_EOCZ1 = 0x2000000
	// Position of EOCZ2 field.
	TSADCC_SR_EOCZ2_Pos = 0x1a
	// Bit mask of EOCZ2 field.
	TSADCC_SR_EOCZ2_Msk = 0x4000000
	// Bit EOCZ2.
	TSADCC_SR_EOCZ2 = 0x4000000
	// Position of OVREXP field.
	TSADCC_SR_OVREXP_Pos = 0x1c
	// Bit mask of OVREXP field.
	TSADCC_SR_OVREXP_Msk = 0x10000000
	// Bit OVREXP.
	TSADCC_SR_OVREXP = 0x10000000
	// Position of OVREZ1 field.
	TSADCC_SR_OVREZ1_Pos = 0x1d
	// Bit mask of OVREZ1 field.
	TSADCC_SR_OVREZ1_Msk = 0x20000000
	// Bit OVREZ1.
	TSADCC_SR_OVREZ1 = 0x20000000
	// Position of OVREZ2 field.
	TSADCC_SR_OVREZ2_Pos = 0x1e
	// Bit mask of OVREZ2 field.
	TSADCC_SR_OVREZ2_Msk = 0x40000000
	// Bit OVREZ2.
	TSADCC_SR_OVREZ2 = 0x40000000

	// LCDR: Last Converted Data Register
	// Position of LDATA field.
	TSADCC_LCDR_LDATA_Pos = 0x0
	// Bit mask of LDATA field.
	TSADCC_LCDR_LDATA_Msk = 0x3ff

	// IER: Interrupt Enable Register
	// Position of EOC0 field.
	TSADCC_IER_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	TSADCC_IER_EOC0_Msk = 0x1
	// Bit EOC0.
	TSADCC_IER_EOC0 = 0x1
	// Position of EOC1 field.
	TSADCC_IER_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	TSADCC_IER_EOC1_Msk = 0x2
	// Bit EOC1.
	TSADCC_IER_EOC1 = 0x2
	// Position of EOC2 field.
	TSADCC_IER_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	TSADCC_IER_EOC2_Msk = 0x4
	// Bit EOC2.
	TSADCC_IER_EOC2 = 0x4
	// Position of EOC3 field.
	TSADCC_IER_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	TSADCC_IER_EOC3_Msk = 0x8
	// Bit EOC3.
	TSADCC_IER_EOC3 = 0x8
	// Position of EOC4 field.
	TSADCC_IER_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	TSADCC_IER_EOC4_Msk = 0x10
	// Bit EOC4.
	TSADCC_IER_EOC4 = 0x10
	// Position of EOC5 field.
	TSADCC_IER_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	TSADCC_IER_EOC5_Msk = 0x20
	// Bit EOC5.
	TSADCC_IER_EOC5 = 0x20
	// Position of EOC6 field.
	TSADCC_IER_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	TSADCC_IER_EOC6_Msk = 0x40
	// Bit EOC6.
	TSADCC_IER_EOC6 = 0x40
	// Position of EOC7 field.
	TSADCC_IER_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	TSADCC_IER_EOC7_Msk = 0x80
	// Bit EOC7.
	TSADCC_IER_EOC7 = 0x80
	// Position of OVRE0 field.
	TSADCC_IER_OVRE0_Pos = 0x8
	// Bit mask of OVRE0 field.
	TSADCC_IER_OVRE0_Msk = 0x100
	// Bit OVRE0.
	TSADCC_IER_OVRE0 = 0x100
	// Position of OVRE1 field.
	TSADCC_IER_OVRE1_Pos = 0x9
	// Bit mask of OVRE1 field.
	TSADCC_IER_OVRE1_Msk = 0x200
	// Bit OVRE1.
	TSADCC_IER_OVRE1 = 0x200
	// Position of OVRE2 field.
	TSADCC_IER_OVRE2_Pos = 0xa
	// Bit mask of OVRE2 field.
	TSADCC_IER_OVRE2_Msk = 0x400
	// Bit OVRE2.
	TSADCC_IER_OVRE2 = 0x400
	// Position of OVRE3 field.
	TSADCC_IER_OVRE3_Pos = 0xb
	// Bit mask of OVRE3 field.
	TSADCC_IER_OVRE3_Msk = 0x800
	// Bit OVRE3.
	TSADCC_IER_OVRE3 = 0x800
	// Position of OVRE4 field.
	TSADCC_IER_OVRE4_Pos = 0xc
	// Bit mask of OVRE4 field.
	TSADCC_IER_OVRE4_Msk = 0x1000
	// Bit OVRE4.
	TSADCC_IER_OVRE4 = 0x1000
	// Position of OVRE5 field.
	TSADCC_IER_OVRE5_Pos = 0xd
	// Bit mask of OVRE5 field.
	TSADCC_IER_OVRE5_Msk = 0x2000
	// Bit OVRE5.
	TSADCC_IER_OVRE5 = 0x2000
	// Position of OVRE6 field.
	TSADCC_IER_OVRE6_Pos = 0xe
	// Bit mask of OVRE6 field.
	TSADCC_IER_OVRE6_Msk = 0x4000
	// Bit OVRE6.
	TSADCC_IER_OVRE6 = 0x4000
	// Position of OVRE7 field.
	TSADCC_IER_OVRE7_Pos = 0xf
	// Bit mask of OVRE7 field.
	TSADCC_IER_OVRE7_Msk = 0x8000
	// Bit OVRE7.
	TSADCC_IER_OVRE7 = 0x8000
	// Position of DRDY field.
	TSADCC_IER_DRDY_Pos = 0x10
	// Bit mask of DRDY field.
	TSADCC_IER_DRDY_Msk = 0x10000
	// Bit DRDY.
	TSADCC_IER_DRDY = 0x10000
	// Position of GOVRE field.
	TSADCC_IER_GOVRE_Pos = 0x11
	// Bit mask of GOVRE field.
	TSADCC_IER_GOVRE_Msk = 0x20000
	// Bit GOVRE.
	TSADCC_IER_GOVRE = 0x20000
	// Position of ENDRX field.
	TSADCC_IER_ENDRX_Pos = 0x12
	// Bit mask of ENDRX field.
	TSADCC_IER_ENDRX_Msk = 0x40000
	// Bit ENDRX.
	TSADCC_IER_ENDRX = 0x40000
	// Position of RXBUFF field.
	TSADCC_IER_RXBUFF_Pos = 0x13
	// Bit mask of RXBUFF field.
	TSADCC_IER_RXBUFF_Msk = 0x80000
	// Bit RXBUFF.
	TSADCC_IER_RXBUFF = 0x80000
	// Position of PENCNT field.
	TSADCC_IER_PENCNT_Pos = 0x14
	// Bit mask of PENCNT field.
	TSADCC_IER_PENCNT_Msk = 0x100000
	// Bit PENCNT.
	TSADCC_IER_PENCNT = 0x100000
	// Position of NOCNT field.
	TSADCC_IER_NOCNT_Pos = 0x15
	// Bit mask of NOCNT field.
	TSADCC_IER_NOCNT_Msk = 0x200000
	// Bit NOCNT.
	TSADCC_IER_NOCNT = 0x200000
	// Position of EOCXP field.
	TSADCC_IER_EOCXP_Pos = 0x18
	// Bit mask of EOCXP field.
	TSADCC_IER_EOCXP_Msk = 0x1000000
	// Bit EOCXP.
	TSADCC_IER_EOCXP = 0x1000000
	// Position of EOCZ1 field.
	TSADCC_IER_EOCZ1_Pos = 0x19
	// Bit mask of EOCZ1 field.
	TSADCC_IER_EOCZ1_Msk = 0x2000000
	// Bit EOCZ1.
	TSADCC_IER_EOCZ1 = 0x2000000
	// Position of EOCZ2 field.
	TSADCC_IER_EOCZ2_Pos = 0x1a
	// Bit mask of EOCZ2 field.
	TSADCC_IER_EOCZ2_Msk = 0x4000000
	// Bit EOCZ2.
	TSADCC_IER_EOCZ2 = 0x4000000
	// Position of OVREXP field.
	TSADCC_IER_OVREXP_Pos = 0x1c
	// Bit mask of OVREXP field.
	TSADCC_IER_OVREXP_Msk = 0x10000000
	// Bit OVREXP.
	TSADCC_IER_OVREXP = 0x10000000
	// Position of OVREZ1 field.
	TSADCC_IER_OVREZ1_Pos = 0x1d
	// Bit mask of OVREZ1 field.
	TSADCC_IER_OVREZ1_Msk = 0x20000000
	// Bit OVREZ1.
	TSADCC_IER_OVREZ1 = 0x20000000
	// Position of OVREZ2 field.
	TSADCC_IER_OVREZ2_Pos = 0x1e
	// Bit mask of OVREZ2 field.
	TSADCC_IER_OVREZ2_Msk = 0x40000000
	// Bit OVREZ2.
	TSADCC_IER_OVREZ2 = 0x40000000

	// IDR: Interrupt Disable Register
	// Position of EOC0 field.
	TSADCC_IDR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	TSADCC_IDR_EOC0_Msk = 0x1
	// Bit EOC0.
	TSADCC_IDR_EOC0 = 0x1
	// Position of EOC1 field.
	TSADCC_IDR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	TSADCC_IDR_EOC1_Msk = 0x2
	// Bit EOC1.
	TSADCC_IDR_EOC1 = 0x2
	// Position of EOC2 field.
	TSADCC_IDR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	TSADCC_IDR_EOC2_Msk = 0x4
	// Bit EOC2.
	TSADCC_IDR_EOC2 = 0x4
	// Position of EOC3 field.
	TSADCC_IDR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	TSADCC_IDR_EOC3_Msk = 0x8
	// Bit EOC3.
	TSADCC_IDR_EOC3 = 0x8
	// Position of EOC4 field.
	TSADCC_IDR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	TSADCC_IDR_EOC4_Msk = 0x10
	// Bit EOC4.
	TSADCC_IDR_EOC4 = 0x10
	// Position of EOC5 field.
	TSADCC_IDR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	TSADCC_IDR_EOC5_Msk = 0x20
	// Bit EOC5.
	TSADCC_IDR_EOC5 = 0x20
	// Position of EOC6 field.
	TSADCC_IDR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	TSADCC_IDR_EOC6_Msk = 0x40
	// Bit EOC6.
	TSADCC_IDR_EOC6 = 0x40
	// Position of EOC7 field.
	TSADCC_IDR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	TSADCC_IDR_EOC7_Msk = 0x80
	// Bit EOC7.
	TSADCC_IDR_EOC7 = 0x80
	// Position of OVRE0 field.
	TSADCC_IDR_OVRE0_Pos = 0x8
	// Bit mask of OVRE0 field.
	TSADCC_IDR_OVRE0_Msk = 0x100
	// Bit OVRE0.
	TSADCC_IDR_OVRE0 = 0x100
	// Position of OVRE1 field.
	TSADCC_IDR_OVRE1_Pos = 0x9
	// Bit mask of OVRE1 field.
	TSADCC_IDR_OVRE1_Msk = 0x200
	// Bit OVRE1.
	TSADCC_IDR_OVRE1 = 0x200
	// Position of OVRE2 field.
	TSADCC_IDR_OVRE2_Pos = 0xa
	// Bit mask of OVRE2 field.
	TSADCC_IDR_OVRE2_Msk = 0x400
	// Bit OVRE2.
	TSADCC_IDR_OVRE2 = 0x400
	// Position of OVRE3 field.
	TSADCC_IDR_OVRE3_Pos = 0xb
	// Bit mask of OVRE3 field.
	TSADCC_IDR_OVRE3_Msk = 0x800
	// Bit OVRE3.
	TSADCC_IDR_OVRE3 = 0x800
	// Position of OVRE4 field.
	TSADCC_IDR_OVRE4_Pos = 0xc
	// Bit mask of OVRE4 field.
	TSADCC_IDR_OVRE4_Msk = 0x1000
	// Bit OVRE4.
	TSADCC_IDR_OVRE4 = 0x1000
	// Position of OVRE5 field.
	TSADCC_IDR_OVRE5_Pos = 0xd
	// Bit mask of OVRE5 field.
	TSADCC_IDR_OVRE5_Msk = 0x2000
	// Bit OVRE5.
	TSADCC_IDR_OVRE5 = 0x2000
	// Position of OVRE6 field.
	TSADCC_IDR_OVRE6_Pos = 0xe
	// Bit mask of OVRE6 field.
	TSADCC_IDR_OVRE6_Msk = 0x4000
	// Bit OVRE6.
	TSADCC_IDR_OVRE6 = 0x4000
	// Position of OVRE7 field.
	TSADCC_IDR_OVRE7_Pos = 0xf
	// Bit mask of OVRE7 field.
	TSADCC_IDR_OVRE7_Msk = 0x8000
	// Bit OVRE7.
	TSADCC_IDR_OVRE7 = 0x8000
	// Position of DRDY field.
	TSADCC_IDR_DRDY_Pos = 0x10
	// Bit mask of DRDY field.
	TSADCC_IDR_DRDY_Msk = 0x10000
	// Bit DRDY.
	TSADCC_IDR_DRDY = 0x10000
	// Position of GOVRE field.
	TSADCC_IDR_GOVRE_Pos = 0x11
	// Bit mask of GOVRE field.
	TSADCC_IDR_GOVRE_Msk = 0x20000
	// Bit GOVRE.
	TSADCC_IDR_GOVRE = 0x20000
	// Position of ENDRX field.
	TSADCC_IDR_ENDRX_Pos = 0x12
	// Bit mask of ENDRX field.
	TSADCC_IDR_ENDRX_Msk = 0x40000
	// Bit ENDRX.
	TSADCC_IDR_ENDRX = 0x40000
	// Position of RXBUFF field.
	TSADCC_IDR_RXBUFF_Pos = 0x13
	// Bit mask of RXBUFF field.
	TSADCC_IDR_RXBUFF_Msk = 0x80000
	// Bit RXBUFF.
	TSADCC_IDR_RXBUFF = 0x80000
	// Position of PENCNT field.
	TSADCC_IDR_PENCNT_Pos = 0x14
	// Bit mask of PENCNT field.
	TSADCC_IDR_PENCNT_Msk = 0x100000
	// Bit PENCNT.
	TSADCC_IDR_PENCNT = 0x100000
	// Position of NOCNT field.
	TSADCC_IDR_NOCNT_Pos = 0x15
	// Bit mask of NOCNT field.
	TSADCC_IDR_NOCNT_Msk = 0x200000
	// Bit NOCNT.
	TSADCC_IDR_NOCNT = 0x200000
	// Position of EOCXP field.
	TSADCC_IDR_EOCXP_Pos = 0x18
	// Bit mask of EOCXP field.
	TSADCC_IDR_EOCXP_Msk = 0x1000000
	// Bit EOCXP.
	TSADCC_IDR_EOCXP = 0x1000000
	// Position of EOCZ1 field.
	TSADCC_IDR_EOCZ1_Pos = 0x19
	// Bit mask of EOCZ1 field.
	TSADCC_IDR_EOCZ1_Msk = 0x2000000
	// Bit EOCZ1.
	TSADCC_IDR_EOCZ1 = 0x2000000
	// Position of EOCZ2 field.
	TSADCC_IDR_EOCZ2_Pos = 0x1a
	// Bit mask of EOCZ2 field.
	TSADCC_IDR_EOCZ2_Msk = 0x4000000
	// Bit EOCZ2.
	TSADCC_IDR_EOCZ2 = 0x4000000
	// Position of OVREXP field.
	TSADCC_IDR_OVREXP_Pos = 0x1c
	// Bit mask of OVREXP field.
	TSADCC_IDR_OVREXP_Msk = 0x10000000
	// Bit OVREXP.
	TSADCC_IDR_OVREXP = 0x10000000
	// Position of OVREZ1 field.
	TSADCC_IDR_OVREZ1_Pos = 0x1d
	// Bit mask of OVREZ1 field.
	TSADCC_IDR_OVREZ1_Msk = 0x20000000
	// Bit OVREZ1.
	TSADCC_IDR_OVREZ1 = 0x20000000
	// Position of OVREZ2 field.
	TSADCC_IDR_OVREZ2_Pos = 0x1e
	// Bit mask of OVREZ2 field.
	TSADCC_IDR_OVREZ2_Msk = 0x40000000
	// Bit OVREZ2.
	TSADCC_IDR_OVREZ2 = 0x40000000

	// IMR: Interrupt Mask Register
	// Position of EOC0 field.
	TSADCC_IMR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	TSADCC_IMR_EOC0_Msk = 0x1
	// Bit EOC0.
	TSADCC_IMR_EOC0 = 0x1
	// Position of EOC1 field.
	TSADCC_IMR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	TSADCC_IMR_EOC1_Msk = 0x2
	// Bit EOC1.
	TSADCC_IMR_EOC1 = 0x2
	// Position of EOC2 field.
	TSADCC_IMR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	TSADCC_IMR_EOC2_Msk = 0x4
	// Bit EOC2.
	TSADCC_IMR_EOC2 = 0x4
	// Position of EOC3 field.
	TSADCC_IMR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	TSADCC_IMR_EOC3_Msk = 0x8
	// Bit EOC3.
	TSADCC_IMR_EOC3 = 0x8
	// Position of EOC4 field.
	TSADCC_IMR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	TSADCC_IMR_EOC4_Msk = 0x10
	// Bit EOC4.
	TSADCC_IMR_EOC4 = 0x10
	// Position of EOC5 field.
	TSADCC_IMR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	TSADCC_IMR_EOC5_Msk = 0x20
	// Bit EOC5.
	TSADCC_IMR_EOC5 = 0x20
	// Position of EOC6 field.
	TSADCC_IMR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	TSADCC_IMR_EOC6_Msk = 0x40
	// Bit EOC6.
	TSADCC_IMR_EOC6 = 0x40
	// Position of EOC7 field.
	TSADCC_IMR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	TSADCC_IMR_EOC7_Msk = 0x80
	// Bit EOC7.
	TSADCC_IMR_EOC7 = 0x80
	// Position of OVRE0 field.
	TSADCC_IMR_OVRE0_Pos = 0x8
	// Bit mask of OVRE0 field.
	TSADCC_IMR_OVRE0_Msk = 0x100
	// Bit OVRE0.
	TSADCC_IMR_OVRE0 = 0x100
	// Position of OVRE1 field.
	TSADCC_IMR_OVRE1_Pos = 0x9
	// Bit mask of OVRE1 field.
	TSADCC_IMR_OVRE1_Msk = 0x200
	// Bit OVRE1.
	TSADCC_IMR_OVRE1 = 0x200
	// Position of OVRE2 field.
	TSADCC_IMR_OVRE2_Pos = 0xa
	// Bit mask of OVRE2 field.
	TSADCC_IMR_OVRE2_Msk = 0x400
	// Bit OVRE2.
	TSADCC_IMR_OVRE2 = 0x400
	// Position of OVRE3 field.
	TSADCC_IMR_OVRE3_Pos = 0xb
	// Bit mask of OVRE3 field.
	TSADCC_IMR_OVRE3_Msk = 0x800
	// Bit OVRE3.
	TSADCC_IMR_OVRE3 = 0x800
	// Position of OVRE4 field.
	TSADCC_IMR_OVRE4_Pos = 0xc
	// Bit mask of OVRE4 field.
	TSADCC_IMR_OVRE4_Msk = 0x1000
	// Bit OVRE4.
	TSADCC_IMR_OVRE4 = 0x1000
	// Position of OVRE5 field.
	TSADCC_IMR_OVRE5_Pos = 0xd
	// Bit mask of OVRE5 field.
	TSADCC_IMR_OVRE5_Msk = 0x2000
	// Bit OVRE5.
	TSADCC_IMR_OVRE5 = 0x2000
	// Position of OVRE6 field.
	TSADCC_IMR_OVRE6_Pos = 0xe
	// Bit mask of OVRE6 field.
	TSADCC_IMR_OVRE6_Msk = 0x4000
	// Bit OVRE6.
	TSADCC_IMR_OVRE6 = 0x4000
	// Position of OVRE7 field.
	TSADCC_IMR_OVRE7_Pos = 0xf
	// Bit mask of OVRE7 field.
	TSADCC_IMR_OVRE7_Msk = 0x8000
	// Bit OVRE7.
	TSADCC_IMR_OVRE7 = 0x8000
	// Position of DRDY field.
	TSADCC_IMR_DRDY_Pos = 0x10
	// Bit mask of DRDY field.
	TSADCC_IMR_DRDY_Msk = 0x10000
	// Bit DRDY.
	TSADCC_IMR_DRDY = 0x10000
	// Position of GOVRE field.
	TSADCC_IMR_GOVRE_Pos = 0x11
	// Bit mask of GOVRE field.
	TSADCC_IMR_GOVRE_Msk = 0x20000
	// Bit GOVRE.
	TSADCC_IMR_GOVRE = 0x20000
	// Position of ENDRX field.
	TSADCC_IMR_ENDRX_Pos = 0x12
	// Bit mask of ENDRX field.
	TSADCC_IMR_ENDRX_Msk = 0x40000
	// Bit ENDRX.
	TSADCC_IMR_ENDRX = 0x40000
	// Position of RXBUFF field.
	TSADCC_IMR_RXBUFF_Pos = 0x13
	// Bit mask of RXBUFF field.
	TSADCC_IMR_RXBUFF_Msk = 0x80000
	// Bit RXBUFF.
	TSADCC_IMR_RXBUFF = 0x80000
	// Position of PENCNT field.
	TSADCC_IMR_PENCNT_Pos = 0x14
	// Bit mask of PENCNT field.
	TSADCC_IMR_PENCNT_Msk = 0x100000
	// Bit PENCNT.
	TSADCC_IMR_PENCNT = 0x100000
	// Position of NOCNT field.
	TSADCC_IMR_NOCNT_Pos = 0x15
	// Bit mask of NOCNT field.
	TSADCC_IMR_NOCNT_Msk = 0x200000
	// Bit NOCNT.
	TSADCC_IMR_NOCNT = 0x200000
	// Position of EOCXP field.
	TSADCC_IMR_EOCXP_Pos = 0x18
	// Bit mask of EOCXP field.
	TSADCC_IMR_EOCXP_Msk = 0x1000000
	// Bit EOCXP.
	TSADCC_IMR_EOCXP = 0x1000000
	// Position of EOCZ1 field.
	TSADCC_IMR_EOCZ1_Pos = 0x19
	// Bit mask of EOCZ1 field.
	TSADCC_IMR_EOCZ1_Msk = 0x2000000
	// Bit EOCZ1.
	TSADCC_IMR_EOCZ1 = 0x2000000
	// Position of EOCZ2 field.
	TSADCC_IMR_EOCZ2_Pos = 0x1a
	// Bit mask of EOCZ2 field.
	TSADCC_IMR_EOCZ2_Msk = 0x4000000
	// Bit EOCZ2.
	TSADCC_IMR_EOCZ2 = 0x4000000
	// Position of OVREXP field.
	TSADCC_IMR_OVREXP_Pos = 0x1c
	// Bit mask of OVREXP field.
	TSADCC_IMR_OVREXP_Msk = 0x10000000
	// Bit OVREXP.
	TSADCC_IMR_OVREXP = 0x10000000
	// Position of OVREZ1 field.
	TSADCC_IMR_OVREZ1_Pos = 0x1d
	// Bit mask of OVREZ1 field.
	TSADCC_IMR_OVREZ1_Msk = 0x20000000
	// Bit OVREZ1.
	TSADCC_IMR_OVREZ1 = 0x20000000
	// Position of OVREZ2 field.
	TSADCC_IMR_OVREZ2_Pos = 0x1e
	// Bit mask of OVREZ2 field.
	TSADCC_IMR_OVREZ2_Msk = 0x40000000
	// Bit OVREZ2.
	TSADCC_IMR_OVREZ2 = 0x40000000

	// CDR: Channel Data Register
	// Position of DATA field.
	TSADCC_CDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	TSADCC_CDR_DATA_Msk = 0x3ff

	// XPDR: X Position Data Register
	// Position of DATA field.
	TSADCC_XPDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	TSADCC_XPDR_DATA_Msk = 0x3ff

	// Z1DR: Z1 Data Register
	// Position of DATA field.
	TSADCC_Z1DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	TSADCC_Z1DR_DATA_Msk = 0x3ff

	// Z2DR: Z2 Data Register
	// Position of Z2 field.
	TSADCC_Z2DR_Z2_Pos = 0x0
	// Bit mask of Z2 field.
	TSADCC_Z2DR_Z2_Msk = 0x3ff

	// MSCR: Manual Switch Command Register
	// Position of XP field.
	TSADCC_MSCR_XP_Pos = 0x0
	// Bit mask of XP field.
	TSADCC_MSCR_XP_Msk = 0x1
	// Bit XP.
	TSADCC_MSCR_XP = 0x1
	// Position of XM field.
	TSADCC_MSCR_XM_Pos = 0x1
	// Bit mask of XM field.
	TSADCC_MSCR_XM_Msk = 0x2
	// Bit XM.
	TSADCC_MSCR_XM = 0x2
	// Position of YP field.
	TSADCC_MSCR_YP_Pos = 0x2
	// Bit mask of YP field.
	TSADCC_MSCR_YP_Msk = 0x4
	// Bit YP.
	TSADCC_MSCR_YP = 0x4
	// Position of YM field.
	TSADCC_MSCR_YM_Pos = 0x3
	// Bit mask of YM field.
	TSADCC_MSCR_YM_Msk = 0x8
	// Bit YM.
	TSADCC_MSCR_YM = 0x8

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	TSADCC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	TSADCC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	TSADCC_WPMR_WPEN = 0x1
	// Position of KEY field.
	TSADCC_WPMR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TSADCC_WPMR_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WPS field.
	TSADCC_WPSR_WPS_Pos = 0x0
	// Bit mask of WPS field.
	TSADCC_WPSR_WPS_Msk = 0x1
	// Bit WPS.
	TSADCC_WPSR_WPS = 0x1
	// Position of OFFSET_ERR field.
	TSADCC_WPSR_OFFSET_ERR_Pos = 0x8
	// Bit mask of OFFSET_ERR field.
	TSADCC_WPSR_OFFSET_ERR_Msk = 0xffffff00

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	TSADCC_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	TSADCC_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	TSADCC_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	TSADCC_RCR_RXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	TSADCC_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	TSADCC_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	TSADCC_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	TSADCC_RNCR_RXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	TSADCC_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	TSADCC_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	TSADCC_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	TSADCC_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	TSADCC_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	TSADCC_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	TSADCC_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	TSADCC_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	TSADCC_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	TSADCC_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	TSADCC_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	TSADCC_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	TSADCC_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	TSADCC_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	TSADCC_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	TSADCC_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	TSADCC_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	TSADCC_PTSR_TXTEN = 0x100
)

// Constants for ISI: Image Sensor Interface
const (
	// ISI_CFG1: ISI Configuration 1 Register
	// Position of HSYNC_POL field.
	ISI_ISI_CFG1_HSYNC_POL_Pos = 0x2
	// Bit mask of HSYNC_POL field.
	ISI_ISI_CFG1_HSYNC_POL_Msk = 0x4
	// Bit HSYNC_POL.
	ISI_ISI_CFG1_HSYNC_POL = 0x4
	// Position of VSYNC_POL field.
	ISI_ISI_CFG1_VSYNC_POL_Pos = 0x3
	// Bit mask of VSYNC_POL field.
	ISI_ISI_CFG1_VSYNC_POL_Msk = 0x8
	// Bit VSYNC_POL.
	ISI_ISI_CFG1_VSYNC_POL = 0x8
	// Position of PIXCLK_POL field.
	ISI_ISI_CFG1_PIXCLK_POL_Pos = 0x4
	// Bit mask of PIXCLK_POL field.
	ISI_ISI_CFG1_PIXCLK_POL_Msk = 0x10
	// Bit PIXCLK_POL.
	ISI_ISI_CFG1_PIXCLK_POL = 0x10
	// Position of EMB_SYNC field.
	ISI_ISI_CFG1_EMB_SYNC_Pos = 0x6
	// Bit mask of EMB_SYNC field.
	ISI_ISI_CFG1_EMB_SYNC_Msk = 0x40
	// Bit EMB_SYNC.
	ISI_ISI_CFG1_EMB_SYNC = 0x40
	// Position of CRC_SYNC field.
	ISI_ISI_CFG1_CRC_SYNC_Pos = 0x7
	// Bit mask of CRC_SYNC field.
	ISI_ISI_CFG1_CRC_SYNC_Msk = 0x80
	// Bit CRC_SYNC.
	ISI_ISI_CFG1_CRC_SYNC = 0x80
	// Position of FRATE field.
	ISI_ISI_CFG1_FRATE_Pos = 0x8
	// Bit mask of FRATE field.
	ISI_ISI_CFG1_FRATE_Msk = 0x700
	// Position of DISCR field.
	ISI_ISI_CFG1_DISCR_Pos = 0xb
	// Bit mask of DISCR field.
	ISI_ISI_CFG1_DISCR_Msk = 0x800
	// Bit DISCR.
	ISI_ISI_CFG1_DISCR = 0x800
	// Position of FULL field.
	ISI_ISI_CFG1_FULL_Pos = 0xc
	// Bit mask of FULL field.
	ISI_ISI_CFG1_FULL_Msk = 0x1000
	// Bit FULL.
	ISI_ISI_CFG1_FULL = 0x1000
	// Position of THMASK field.
	ISI_ISI_CFG1_THMASK_Pos = 0xd
	// Bit mask of THMASK field.
	ISI_ISI_CFG1_THMASK_Msk = 0x6000
	// Position of SLD field.
	ISI_ISI_CFG1_SLD_Pos = 0x10
	// Bit mask of SLD field.
	ISI_ISI_CFG1_SLD_Msk = 0xff0000
	// Position of SFD field.
	ISI_ISI_CFG1_SFD_Pos = 0x18
	// Bit mask of SFD field.
	ISI_ISI_CFG1_SFD_Msk = 0xff000000

	// ISI_CFG2: ISI Configuration 2 Register
	// Position of IM_VSIZE field.
	ISI_ISI_CFG2_IM_VSIZE_Pos = 0x0
	// Bit mask of IM_VSIZE field.
	ISI_ISI_CFG2_IM_VSIZE_Msk = 0x7ff
	// Position of GS_MODE field.
	ISI_ISI_CFG2_GS_MODE_Pos = 0xb
	// Bit mask of GS_MODE field.
	ISI_ISI_CFG2_GS_MODE_Msk = 0x800
	// Bit GS_MODE.
	ISI_ISI_CFG2_GS_MODE = 0x800
	// Position of RGB_MODE field.
	ISI_ISI_CFG2_RGB_MODE_Pos = 0xc
	// Bit mask of RGB_MODE field.
	ISI_ISI_CFG2_RGB_MODE_Msk = 0x1000
	// Bit RGB_MODE.
	ISI_ISI_CFG2_RGB_MODE = 0x1000
	// Position of GRAYSCALE field.
	ISI_ISI_CFG2_GRAYSCALE_Pos = 0xd
	// Bit mask of GRAYSCALE field.
	ISI_ISI_CFG2_GRAYSCALE_Msk = 0x2000
	// Bit GRAYSCALE.
	ISI_ISI_CFG2_GRAYSCALE = 0x2000
	// Position of RGB_SWAP field.
	ISI_ISI_CFG2_RGB_SWAP_Pos = 0xe
	// Bit mask of RGB_SWAP field.
	ISI_ISI_CFG2_RGB_SWAP_Msk = 0x4000
	// Bit RGB_SWAP.
	ISI_ISI_CFG2_RGB_SWAP = 0x4000
	// Position of COL_SPACE field.
	ISI_ISI_CFG2_COL_SPACE_Pos = 0xf
	// Bit mask of COL_SPACE field.
	ISI_ISI_CFG2_COL_SPACE_Msk = 0x8000
	// Bit COL_SPACE.
	ISI_ISI_CFG2_COL_SPACE = 0x8000
	// Position of IM_HSIZE field.
	ISI_ISI_CFG2_IM_HSIZE_Pos = 0x10
	// Bit mask of IM_HSIZE field.
	ISI_ISI_CFG2_IM_HSIZE_Msk = 0x7ff0000
	// Position of YCC_SWAP field.
	ISI_ISI_CFG2_YCC_SWAP_Pos = 0x1c
	// Bit mask of YCC_SWAP field.
	ISI_ISI_CFG2_YCC_SWAP_Msk = 0x30000000
	// Position of RGB_CFG field.
	ISI_ISI_CFG2_RGB_CFG_Pos = 0x1e
	// Bit mask of RGB_CFG field.
	ISI_ISI_CFG2_RGB_CFG_Msk = 0xc0000000

	// ISI_PSIZE: ISI Preview Size Register
	// Position of PREV_VSIZE field.
	ISI_ISI_PSIZE_PREV_VSIZE_Pos = 0x0
	// Bit mask of PREV_VSIZE field.
	ISI_ISI_PSIZE_PREV_VSIZE_Msk = 0x3ff
	// Position of PREV_HSIZE field.
	ISI_ISI_PSIZE_PREV_HSIZE_Pos = 0x10
	// Bit mask of PREV_HSIZE field.
	ISI_ISI_PSIZE_PREV_HSIZE_Msk = 0x3ff0000

	// ISI_PDECF: ISI Preview Decimation Factor Register
	// Position of DEC_FACTOR field.
	ISI_ISI_PDECF_DEC_FACTOR_Pos = 0x0
	// Bit mask of DEC_FACTOR field.
	ISI_ISI_PDECF_DEC_FACTOR_Msk = 0xff

	// ISI_Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
	// Position of C0 field.
	ISI_ISI_Y2R_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_ISI_Y2R_SET0_C0_Msk = 0xff
	// Position of C1 field.
	ISI_ISI_Y2R_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_ISI_Y2R_SET0_C1_Msk = 0xff00
	// Position of C2 field.
	ISI_ISI_Y2R_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_ISI_Y2R_SET0_C2_Msk = 0xff0000
	// Position of C3 field.
	ISI_ISI_Y2R_SET0_C3_Pos = 0x18
	// Bit mask of C3 field.
	ISI_ISI_Y2R_SET0_C3_Msk = 0xff000000

	// ISI_Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
	// Position of C4 field.
	ISI_ISI_Y2R_SET1_C4_Pos = 0x0
	// Bit mask of C4 field.
	ISI_ISI_Y2R_SET1_C4_Msk = 0x1ff
	// Position of Yoff field.
	ISI_ISI_Y2R_SET1_Yoff_Pos = 0xc
	// Bit mask of Yoff field.
	ISI_ISI_Y2R_SET1_Yoff_Msk = 0x1000
	// Bit Yoff.
	ISI_ISI_Y2R_SET1_Yoff = 0x1000
	// Position of Croff field.
	ISI_ISI_Y2R_SET1_Croff_Pos = 0xd
	// Bit mask of Croff field.
	ISI_ISI_Y2R_SET1_Croff_Msk = 0x2000
	// Bit Croff.
	ISI_ISI_Y2R_SET1_Croff = 0x2000
	// Position of Cboff field.
	ISI_ISI_Y2R_SET1_Cboff_Pos = 0xe
	// Bit mask of Cboff field.
	ISI_ISI_Y2R_SET1_Cboff_Msk = 0x4000
	// Bit Cboff.
	ISI_ISI_Y2R_SET1_Cboff = 0x4000

	// ISI_R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
	// Position of C0 field.
	ISI_ISI_R2Y_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_ISI_R2Y_SET0_C0_Msk = 0xff
	// Position of C1 field.
	ISI_ISI_R2Y_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_ISI_R2Y_SET0_C1_Msk = 0xff00
	// Position of C2 field.
	ISI_ISI_R2Y_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_ISI_R2Y_SET0_C2_Msk = 0xff0000
	// Position of Roff field.
	ISI_ISI_R2Y_SET0_Roff_Pos = 0x18
	// Bit mask of Roff field.
	ISI_ISI_R2Y_SET0_Roff_Msk = 0x1000000
	// Bit Roff.
	ISI_ISI_R2Y_SET0_Roff = 0x1000000

	// ISI_R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
	// Position of C3 field.
	ISI_ISI_R2Y_SET1_C3_Pos = 0x0
	// Bit mask of C3 field.
	ISI_ISI_R2Y_SET1_C3_Msk = 0xff
	// Position of C4 field.
	ISI_ISI_R2Y_SET1_C4_Pos = 0x8
	// Bit mask of C4 field.
	ISI_ISI_R2Y_SET1_C4_Msk = 0xff00
	// Position of C5 field.
	ISI_ISI_R2Y_SET1_C5_Pos = 0x10
	// Bit mask of C5 field.
	ISI_ISI_R2Y_SET1_C5_Msk = 0xff0000
	// Position of Goff field.
	ISI_ISI_R2Y_SET1_Goff_Pos = 0x18
	// Bit mask of Goff field.
	ISI_ISI_R2Y_SET1_Goff_Msk = 0x1000000
	// Bit Goff.
	ISI_ISI_R2Y_SET1_Goff = 0x1000000

	// ISI_R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
	// Position of C6 field.
	ISI_ISI_R2Y_SET2_C6_Pos = 0x0
	// Bit mask of C6 field.
	ISI_ISI_R2Y_SET2_C6_Msk = 0xff
	// Position of C7 field.
	ISI_ISI_R2Y_SET2_C7_Pos = 0x8
	// Bit mask of C7 field.
	ISI_ISI_R2Y_SET2_C7_Msk = 0xff00
	// Position of C8 field.
	ISI_ISI_R2Y_SET2_C8_Pos = 0x10
	// Bit mask of C8 field.
	ISI_ISI_R2Y_SET2_C8_Msk = 0xff0000
	// Position of Boff field.
	ISI_ISI_R2Y_SET2_Boff_Pos = 0x18
	// Bit mask of Boff field.
	ISI_ISI_R2Y_SET2_Boff_Msk = 0x1000000
	// Bit Boff.
	ISI_ISI_R2Y_SET2_Boff = 0x1000000

	// ISI_CR: ISI Control Register
	// Position of ISI_EN field.
	ISI_ISI_CR_ISI_EN_Pos = 0x0
	// Bit mask of ISI_EN field.
	ISI_ISI_CR_ISI_EN_Msk = 0x1
	// Bit ISI_EN.
	ISI_ISI_CR_ISI_EN = 0x1
	// Position of ISI_DIS field.
	ISI_ISI_CR_ISI_DIS_Pos = 0x1
	// Bit mask of ISI_DIS field.
	ISI_ISI_CR_ISI_DIS_Msk = 0x2
	// Bit ISI_DIS.
	ISI_ISI_CR_ISI_DIS = 0x2
	// Position of ISI_SRST field.
	ISI_ISI_CR_ISI_SRST_Pos = 0x2
	// Bit mask of ISI_SRST field.
	ISI_ISI_CR_ISI_SRST_Msk = 0x4
	// Bit ISI_SRST.
	ISI_ISI_CR_ISI_SRST = 0x4
	// Position of ISI_CDC field.
	ISI_ISI_CR_ISI_CDC_Pos = 0x8
	// Bit mask of ISI_CDC field.
	ISI_ISI_CR_ISI_CDC_Msk = 0x100
	// Bit ISI_CDC.
	ISI_ISI_CR_ISI_CDC = 0x100

	// ISI_SR: ISI Status Register
	// Position of ENABLE field.
	ISI_ISI_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ISI_ISI_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ISI_ISI_SR_ENABLE = 0x1
	// Position of DIS_DONE field.
	ISI_ISI_SR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_ISI_SR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_ISI_SR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_ISI_SR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_ISI_SR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_ISI_SR_SRST = 0x4
	// Position of CDC_PND field.
	ISI_ISI_SR_CDC_PND_Pos = 0x8
	// Bit mask of CDC_PND field.
	ISI_ISI_SR_CDC_PND_Msk = 0x100
	// Bit CDC_PND.
	ISI_ISI_SR_CDC_PND = 0x100
	// Position of VSYNC field.
	ISI_ISI_SR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_ISI_SR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_ISI_SR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_ISI_SR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_ISI_SR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_ISI_SR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_ISI_SR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_ISI_SR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_ISI_SR_CXFR_DONE = 0x20000
	// Position of SIP field.
	ISI_ISI_SR_SIP_Pos = 0x13
	// Bit mask of SIP field.
	ISI_ISI_SR_SIP_Msk = 0x80000
	// Bit SIP.
	ISI_ISI_SR_SIP = 0x80000
	// Position of P_OVR field.
	ISI_ISI_SR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_ISI_SR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_ISI_SR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_ISI_SR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_ISI_SR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_ISI_SR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_ISI_SR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_ISI_SR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_ISI_SR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_ISI_SR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_ISI_SR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_ISI_SR_FR_OVR = 0x8000000

	// ISI_IER: ISI Interrupt Enable Register
	// Position of DIS_DONE field.
	ISI_ISI_IER_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_ISI_IER_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_ISI_IER_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_ISI_IER_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_ISI_IER_SRST_Msk = 0x4
	// Bit SRST.
	ISI_ISI_IER_SRST = 0x4
	// Position of VSYNC field.
	ISI_ISI_IER_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_ISI_IER_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_ISI_IER_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_ISI_IER_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_ISI_IER_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_ISI_IER_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_ISI_IER_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_ISI_IER_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_ISI_IER_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_ISI_IER_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_ISI_IER_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_ISI_IER_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_ISI_IER_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_ISI_IER_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_ISI_IER_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_ISI_IER_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_ISI_IER_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_ISI_IER_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_ISI_IER_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_ISI_IER_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_ISI_IER_FR_OVR = 0x8000000

	// ISI_IDR: ISI Interrupt Disable Register
	// Position of DIS_DONE field.
	ISI_ISI_IDR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_ISI_IDR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_ISI_IDR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_ISI_IDR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_ISI_IDR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_ISI_IDR_SRST = 0x4
	// Position of VSYNC field.
	ISI_ISI_IDR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_ISI_IDR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_ISI_IDR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_ISI_IDR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_ISI_IDR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_ISI_IDR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_ISI_IDR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_ISI_IDR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_ISI_IDR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_ISI_IDR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_ISI_IDR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_ISI_IDR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_ISI_IDR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_ISI_IDR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_ISI_IDR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_ISI_IDR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_ISI_IDR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_ISI_IDR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_ISI_IDR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_ISI_IDR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_ISI_IDR_FR_OVR = 0x8000000

	// ISI_IMR: ISI Interrupt Mask Register
	// Position of DIS_DONE field.
	ISI_ISI_IMR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_ISI_IMR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_ISI_IMR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_ISI_IMR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_ISI_IMR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_ISI_IMR_SRST = 0x4
	// Position of VSYNC field.
	ISI_ISI_IMR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_ISI_IMR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_ISI_IMR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_ISI_IMR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_ISI_IMR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_ISI_IMR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_ISI_IMR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_ISI_IMR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_ISI_IMR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_ISI_IMR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_ISI_IMR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_ISI_IMR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_ISI_IMR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_ISI_IMR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_ISI_IMR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_ISI_IMR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_ISI_IMR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_ISI_IMR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_ISI_IMR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_ISI_IMR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_ISI_IMR_FR_OVR = 0x8000000

	// DMA_CHER: DMA Channel Enable Register
	// Position of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Pos = 0x0
	// Bit mask of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Msk = 0x1
	// Bit P_CH_EN.
	ISI_DMA_CHER_P_CH_EN = 0x1
	// Position of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Pos = 0x1
	// Bit mask of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Msk = 0x2
	// Bit C_CH_EN.
	ISI_DMA_CHER_C_CH_EN = 0x2

	// DMA_CHDR: DMA Channel Disable Register
	// Position of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Pos = 0x0
	// Bit mask of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Msk = 0x1
	// Bit P_CH_DIS.
	ISI_DMA_CHDR_P_CH_DIS = 0x1
	// Position of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Pos = 0x1
	// Bit mask of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Msk = 0x2
	// Bit C_CH_DIS.
	ISI_DMA_CHDR_C_CH_DIS = 0x2

	// DMA_CHSR: DMA Channel Status Register
	// Position of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Pos = 0x0
	// Bit mask of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Msk = 0x1
	// Bit P_CH_S.
	ISI_DMA_CHSR_P_CH_S = 0x1
	// Position of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Pos = 0x1
	// Bit mask of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Msk = 0x2
	// Bit C_CH_S.
	ISI_DMA_CHSR_C_CH_S = 0x2

	// DMA_P_ADDR: DMA Preview Base Address Register
	// Position of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Pos = 0x2
	// Bit mask of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Msk = 0xfffffffc

	// DMA_P_CTRL: DMA Preview Control Register
	// Position of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Pos = 0x0
	// Bit mask of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Msk = 0x1
	// Bit P_FETCH.
	ISI_DMA_P_CTRL_P_FETCH = 0x1
	// Position of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Pos = 0x1
	// Bit mask of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Msk = 0x2
	// Bit P_WB.
	ISI_DMA_P_CTRL_P_WB = 0x2
	// Position of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Pos = 0x2
	// Bit mask of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Msk = 0x4
	// Bit P_IEN.
	ISI_DMA_P_CTRL_P_IEN = 0x4
	// Position of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Pos = 0x3
	// Bit mask of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Msk = 0x8
	// Bit P_DONE.
	ISI_DMA_P_CTRL_P_DONE = 0x8

	// DMA_P_DSCR: DMA Preview Descriptor Address Register
	// Position of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Pos = 0x2
	// Bit mask of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Msk = 0xfffffffc

	// DMA_C_ADDR: DMA Codec Base Address Register
	// Position of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Pos = 0x2
	// Bit mask of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Msk = 0xfffffffc

	// DMA_C_CTRL: DMA Codec Control Register
	// Position of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Pos = 0x0
	// Bit mask of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Msk = 0x1
	// Bit C_FETCH.
	ISI_DMA_C_CTRL_C_FETCH = 0x1
	// Position of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Pos = 0x1
	// Bit mask of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Msk = 0x2
	// Bit C_WB.
	ISI_DMA_C_CTRL_C_WB = 0x2
	// Position of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Pos = 0x2
	// Bit mask of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Msk = 0x4
	// Bit C_IEN.
	ISI_DMA_C_CTRL_C_IEN = 0x4
	// Position of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Pos = 0x3
	// Bit mask of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Msk = 0x8
	// Bit C_DONE.
	ISI_DMA_C_CTRL_C_DONE = 0x8

	// DMA_C_DSCR: DMA Codec Descriptor Address Register
	// Position of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Pos = 0x2
	// Bit mask of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Msk = 0xfffffffc

	// ISI_WPCR: Write Protection Control Register
	// Position of WP_EN field.
	ISI_ISI_WPCR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	ISI_ISI_WPCR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	ISI_ISI_WPCR_WP_EN = 0x1
	// Position of WP_KEY field.
	ISI_ISI_WPCR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	ISI_ISI_WPCR_WP_KEY_Msk = 0xffffff00

	// ISI_WPSR: Write Protection Status Register
	// Position of WP_VS field.
	ISI_ISI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	ISI_ISI_WPSR_WP_VS_Msk = 0xf
	// Position of WP_VSRC field.
	ISI_ISI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	ISI_ISI_WPSR_WP_VSRC_Msk = 0xffff00
)

// Constants for PWM: Pulse Width Modulation Controller
const (
	// MR: PWM Mode Register
	// Position of DIVA field.
	PWM_MR_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PWM_MR_DIVA_Msk = 0xff
	// CLKA, CLKB clock is turned off
	PWM_MR_DIVA_CLK_OFF = 0x0
	// CLKA, CLKB clock is clock selected by PREA, PREB
	PWM_MR_DIVA_CLK_DIV1 = 0x1
	// Position of PREA field.
	PWM_MR_PREA_Pos = 0x8
	// Bit mask of PREA field.
	PWM_MR_PREA_Msk = 0xf00
	// Master Clock
	PWM_MR_PREA_MCK = 0x0
	// Master Clock divided by 2
	PWM_MR_PREA_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_MR_PREA_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_MR_PREA_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_MR_PREA_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_MR_PREA_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_MR_PREA_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_MR_PREA_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_MR_PREA_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_MR_PREA_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_MR_PREA_MCKDIV1024 = 0xa
	// Position of DIVB field.
	PWM_MR_DIVB_Pos = 0x10
	// Bit mask of DIVB field.
	PWM_MR_DIVB_Msk = 0xff0000
	// CLKA, CLKB clock is turned off
	PWM_MR_DIVB_CLK_OFF = 0x0
	// CLKA, CLKB clock is clock selected by PREA, PREB
	PWM_MR_DIVB_CLK_DIV1 = 0x1
	// Position of PREB field.
	PWM_MR_PREB_Pos = 0x18
	// Bit mask of PREB field.
	PWM_MR_PREB_Msk = 0xf000000
	// Master Clock
	PWM_MR_PREB_MCK = 0x0
	// Master Clock divided by 2
	PWM_MR_PREB_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_MR_PREB_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_MR_PREB_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_MR_PREB_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_MR_PREB_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_MR_PREB_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_MR_PREB_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_MR_PREB_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_MR_PREB_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_MR_PREB_MCKDIV1024 = 0xa

	// ENA: PWM Enable Register
	// Position of CHID0 field.
	PWM_ENA_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ENA_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ENA_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ENA_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ENA_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ENA_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ENA_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ENA_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ENA_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ENA_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ENA_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ENA_CHID3 = 0x8

	// DIS: PWM Disable Register
	// Position of CHID0 field.
	PWM_DIS_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_DIS_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_DIS_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_DIS_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_DIS_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_DIS_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_DIS_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_DIS_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_DIS_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_DIS_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_DIS_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_DIS_CHID3 = 0x8

	// SR: PWM Status Register
	// Position of CHID0 field.
	PWM_SR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_SR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_SR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_SR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_SR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_SR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_SR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_SR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_SR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_SR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_SR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_SR_CHID3 = 0x8

	// IER: PWM Interrupt Enable Register
	// Position of CHID0 field.
	PWM_IER_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IER_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IER_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IER_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IER_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IER_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IER_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IER_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IER_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IER_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IER_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IER_CHID3 = 0x8

	// IDR: PWM Interrupt Disable Register
	// Position of CHID0 field.
	PWM_IDR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IDR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IDR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IDR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IDR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IDR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IDR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IDR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IDR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IDR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IDR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IDR_CHID3 = 0x8

	// IMR: PWM Interrupt Mask Register
	// Position of CHID0 field.
	PWM_IMR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IMR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IMR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IMR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IMR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IMR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IMR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IMR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IMR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IMR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IMR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IMR_CHID3 = 0x8

	// ISR: PWM Interrupt Status Register
	// Position of CHID0 field.
	PWM_ISR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ISR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ISR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ISR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ISR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ISR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ISR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ISR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ISR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ISR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ISR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ISR_CHID3 = 0x8

	// CMR0: PWM Channel Mode Register (ch_num = 0)
	// Position of CPRE field.
	PWM_CMR0_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR0_CPRE_Msk = 0xf
	// Master Clock
	PWM_CMR0_CPRE_MCK = 0x0
	// Master Clock divided by 2
	PWM_CMR0_CPRE_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_CMR0_CPRE_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_CMR0_CPRE_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_CMR0_CPRE_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_CMR0_CPRE_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_CMR0_CPRE_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_CMR0_CPRE_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_CMR0_CPRE_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_CMR0_CPRE_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_CMR0_CPRE_MCKDIV1024 = 0xa
	// Clock A
	PWM_CMR0_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR0_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR0_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR0_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR0_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR0_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR0_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR0_CPOL = 0x200
	// Position of CPD field.
	PWM_CMR0_CPD_Pos = 0xa
	// Bit mask of CPD field.
	PWM_CMR0_CPD_Msk = 0x400
	// Bit CPD.
	PWM_CMR0_CPD = 0x400

	// CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
	// Position of CDTY field.
	PWM_CDTY0_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY0_CDTY_Msk = 0xffffffff

	// CPRD0: PWM Channel Period Register (ch_num = 0)
	// Position of CPRD field.
	PWM_CPRD0_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD0_CPRD_Msk = 0xffffffff

	// CCNT0: PWM Channel Counter Register (ch_num = 0)
	// Position of CNT field.
	PWM_CCNT0_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT0_CNT_Msk = 0xffffffff

	// CUPD0: PWM Channel Update Register (ch_num = 0)
	// Position of CUPD field.
	PWM_CUPD0_CUPD_Pos = 0x0
	// Bit mask of CUPD field.
	PWM_CUPD0_CUPD_Msk = 0xffffffff

	// CMR1: PWM Channel Mode Register (ch_num = 1)
	// Position of CPRE field.
	PWM_CMR1_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR1_CPRE_Msk = 0xf
	// Master Clock
	PWM_CMR1_CPRE_MCK = 0x0
	// Master Clock divided by 2
	PWM_CMR1_CPRE_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_CMR1_CPRE_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_CMR1_CPRE_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_CMR1_CPRE_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_CMR1_CPRE_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_CMR1_CPRE_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_CMR1_CPRE_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_CMR1_CPRE_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_CMR1_CPRE_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_CMR1_CPRE_MCKDIV1024 = 0xa
	// Clock A
	PWM_CMR1_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR1_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR1_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR1_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR1_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR1_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR1_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR1_CPOL = 0x200
	// Position of CPD field.
	PWM_CMR1_CPD_Pos = 0xa
	// Bit mask of CPD field.
	PWM_CMR1_CPD_Msk = 0x400
	// Bit CPD.
	PWM_CMR1_CPD = 0x400

	// CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
	// Position of CDTY field.
	PWM_CDTY1_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY1_CDTY_Msk = 0xffffffff

	// CPRD1: PWM Channel Period Register (ch_num = 1)
	// Position of CPRD field.
	PWM_CPRD1_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD1_CPRD_Msk = 0xffffffff

	// CCNT1: PWM Channel Counter Register (ch_num = 1)
	// Position of CNT field.
	PWM_CCNT1_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT1_CNT_Msk = 0xffffffff

	// CUPD1: PWM Channel Update Register (ch_num = 1)
	// Position of CUPD field.
	PWM_CUPD1_CUPD_Pos = 0x0
	// Bit mask of CUPD field.
	PWM_CUPD1_CUPD_Msk = 0xffffffff

	// CMR2: PWM Channel Mode Register (ch_num = 2)
	// Position of CPRE field.
	PWM_CMR2_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR2_CPRE_Msk = 0xf
	// Master Clock
	PWM_CMR2_CPRE_MCK = 0x0
	// Master Clock divided by 2
	PWM_CMR2_CPRE_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_CMR2_CPRE_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_CMR2_CPRE_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_CMR2_CPRE_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_CMR2_CPRE_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_CMR2_CPRE_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_CMR2_CPRE_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_CMR2_CPRE_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_CMR2_CPRE_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_CMR2_CPRE_MCKDIV1024 = 0xa
	// Clock A
	PWM_CMR2_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR2_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR2_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR2_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR2_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR2_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR2_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR2_CPOL = 0x200
	// Position of CPD field.
	PWM_CMR2_CPD_Pos = 0xa
	// Bit mask of CPD field.
	PWM_CMR2_CPD_Msk = 0x400
	// Bit CPD.
	PWM_CMR2_CPD = 0x400

	// CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
	// Position of CDTY field.
	PWM_CDTY2_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY2_CDTY_Msk = 0xffffffff

	// CPRD2: PWM Channel Period Register (ch_num = 2)
	// Position of CPRD field.
	PWM_CPRD2_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD2_CPRD_Msk = 0xffffffff

	// CCNT2: PWM Channel Counter Register (ch_num = 2)
	// Position of CNT field.
	PWM_CCNT2_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT2_CNT_Msk = 0xffffffff

	// CUPD2: PWM Channel Update Register (ch_num = 2)
	// Position of CUPD field.
	PWM_CUPD2_CUPD_Pos = 0x0
	// Bit mask of CUPD field.
	PWM_CUPD2_CUPD_Msk = 0xffffffff

	// CMR3: PWM Channel Mode Register (ch_num = 3)
	// Position of CPRE field.
	PWM_CMR3_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR3_CPRE_Msk = 0xf
	// Master Clock
	PWM_CMR3_CPRE_MCK = 0x0
	// Master Clock divided by 2
	PWM_CMR3_CPRE_MCKDIV2 = 0x1
	// Master Clock divided by 4
	PWM_CMR3_CPRE_MCKDIV4 = 0x2
	// Master Clock divided by 8
	PWM_CMR3_CPRE_MCKDIV8 = 0x3
	// Master Clock divided by 16
	PWM_CMR3_CPRE_MCKDIV16 = 0x4
	// Master Clock divided by 32
	PWM_CMR3_CPRE_MCKDIV32 = 0x5
	// Master Clock divided by 64
	PWM_CMR3_CPRE_MCKDIV64 = 0x6
	// Master Clock divided by 128
	PWM_CMR3_CPRE_MCKDIV128 = 0x7
	// Master Clock divided by 256
	PWM_CMR3_CPRE_MCKDIV256 = 0x8
	// Master Clock divided by 512
	PWM_CMR3_CPRE_MCKDIV512 = 0x9
	// Master Clock divided by 1024
	PWM_CMR3_CPRE_MCKDIV1024 = 0xa
	// Clock A
	PWM_CMR3_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR3_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR3_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR3_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR3_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR3_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR3_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR3_CPOL = 0x200
	// Position of CPD field.
	PWM_CMR3_CPD_Pos = 0xa
	// Bit mask of CPD field.
	PWM_CMR3_CPD_Msk = 0x400
	// Bit CPD.
	PWM_CMR3_CPD = 0x400

	// CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
	// Position of CDTY field.
	PWM_CDTY3_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY3_CDTY_Msk = 0xffffffff

	// CPRD3: PWM Channel Period Register (ch_num = 3)
	// Position of CPRD field.
	PWM_CPRD3_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD3_CPRD_Msk = 0xffffffff

	// CCNT3: PWM Channel Counter Register (ch_num = 3)
	// Position of CNT field.
	PWM_CCNT3_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT3_CNT_Msk = 0xffffffff

	// CUPD3: PWM Channel Update Register (ch_num = 3)
	// Position of CUPD field.
	PWM_CUPD3_CUPD_Pos = 0x0
	// Bit mask of CUPD field.
	PWM_CUPD3_CUPD_Msk = 0xffffffff
)

// Constants for EMAC: Ethernet MAC 10/100
const (
	// NCR: Network Control Register
	// Position of LB field.
	EMAC_NCR_LB_Pos = 0x0
	// Bit mask of LB field.
	EMAC_NCR_LB_Msk = 0x1
	// Bit LB.
	EMAC_NCR_LB = 0x1
	// Position of LLB field.
	EMAC_NCR_LLB_Pos = 0x1
	// Bit mask of LLB field.
	EMAC_NCR_LLB_Msk = 0x2
	// Bit LLB.
	EMAC_NCR_LLB = 0x2
	// Position of RE field.
	EMAC_NCR_RE_Pos = 0x2
	// Bit mask of RE field.
	EMAC_NCR_RE_Msk = 0x4
	// Bit RE.
	EMAC_NCR_RE = 0x4
	// Position of TE field.
	EMAC_NCR_TE_Pos = 0x3
	// Bit mask of TE field.
	EMAC_NCR_TE_Msk = 0x8
	// Bit TE.
	EMAC_NCR_TE = 0x8
	// Position of MPE field.
	EMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	EMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	EMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	EMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	EMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	EMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	EMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	EMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	EMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	EMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	EMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	EMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	EMAC_NCR_BP = 0x100
	// Position of TSTART field.
	EMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	EMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	EMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	EMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	EMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	EMAC_NCR_THALT = 0x400

	// NCFG: Network Configuration Register
	// Position of SPD field.
	EMAC_NCFG_SPD_Pos = 0x0
	// Bit mask of SPD field.
	EMAC_NCFG_SPD_Msk = 0x1
	// Bit SPD.
	EMAC_NCFG_SPD = 0x1
	// Position of FD field.
	EMAC_NCFG_FD_Pos = 0x1
	// Bit mask of FD field.
	EMAC_NCFG_FD_Msk = 0x2
	// Bit FD.
	EMAC_NCFG_FD = 0x2
	// Position of JFRAME field.
	EMAC_NCFG_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	EMAC_NCFG_JFRAME_Msk = 0x8
	// Bit JFRAME.
	EMAC_NCFG_JFRAME = 0x8
	// Position of CAF field.
	EMAC_NCFG_CAF_Pos = 0x4
	// Bit mask of CAF field.
	EMAC_NCFG_CAF_Msk = 0x10
	// Bit CAF.
	EMAC_NCFG_CAF = 0x10
	// Position of NBC field.
	EMAC_NCFG_NBC_Pos = 0x5
	// Bit mask of NBC field.
	EMAC_NCFG_NBC_Msk = 0x20
	// Bit NBC.
	EMAC_NCFG_NBC = 0x20
	// Position of MTI field.
	EMAC_NCFG_MTI_Pos = 0x6
	// Bit mask of MTI field.
	EMAC_NCFG_MTI_Msk = 0x40
	// Bit MTI.
	EMAC_NCFG_MTI = 0x40
	// Position of UNI field.
	EMAC_NCFG_UNI_Pos = 0x7
	// Bit mask of UNI field.
	EMAC_NCFG_UNI_Msk = 0x80
	// Bit UNI.
	EMAC_NCFG_UNI = 0x80
	// Position of BIG field.
	EMAC_NCFG_BIG_Pos = 0x8
	// Bit mask of BIG field.
	EMAC_NCFG_BIG_Msk = 0x100
	// Bit BIG.
	EMAC_NCFG_BIG = 0x100
	// Position of CLK field.
	EMAC_NCFG_CLK_Pos = 0xa
	// Bit mask of CLK field.
	EMAC_NCFG_CLK_Msk = 0xc00
	// Position of RTY field.
	EMAC_NCFG_RTY_Pos = 0xc
	// Bit mask of RTY field.
	EMAC_NCFG_RTY_Msk = 0x1000
	// Bit RTY.
	EMAC_NCFG_RTY = 0x1000
	// Position of PAE field.
	EMAC_NCFG_PAE_Pos = 0xd
	// Bit mask of PAE field.
	EMAC_NCFG_PAE_Msk = 0x2000
	// Bit PAE.
	EMAC_NCFG_PAE = 0x2000
	// Position of RBOF field.
	EMAC_NCFG_RBOF_Pos = 0xe
	// Bit mask of RBOF field.
	EMAC_NCFG_RBOF_Msk = 0xc000
	// Position of RLCE field.
	EMAC_NCFG_RLCE_Pos = 0x10
	// Bit mask of RLCE field.
	EMAC_NCFG_RLCE_Msk = 0x10000
	// Bit RLCE.
	EMAC_NCFG_RLCE = 0x10000
	// Position of DRFCS field.
	EMAC_NCFG_DRFCS_Pos = 0x11
	// Bit mask of DRFCS field.
	EMAC_NCFG_DRFCS_Msk = 0x20000
	// Bit DRFCS.
	EMAC_NCFG_DRFCS = 0x20000
	// Position of EFRHD field.
	EMAC_NCFG_EFRHD_Pos = 0x12
	// Bit mask of EFRHD field.
	EMAC_NCFG_EFRHD_Msk = 0x40000
	// Bit EFRHD.
	EMAC_NCFG_EFRHD = 0x40000
	// Position of IRXFCS field.
	EMAC_NCFG_IRXFCS_Pos = 0x13
	// Bit mask of IRXFCS field.
	EMAC_NCFG_IRXFCS_Msk = 0x80000
	// Bit IRXFCS.
	EMAC_NCFG_IRXFCS = 0x80000

	// NSR: Network Status Register
	// Position of MDIO field.
	EMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	EMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	EMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	EMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	EMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	EMAC_NSR_IDLE = 0x4

	// TSR: Transmit Status Register
	// Position of UBR field.
	EMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	EMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	EMAC_TSR_UBR = 0x1
	// Position of COL field.
	EMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	EMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	EMAC_TSR_COL = 0x2
	// Position of RLE field.
	EMAC_TSR_RLE_Pos = 0x2
	// Bit mask of RLE field.
	EMAC_TSR_RLE_Msk = 0x4
	// Bit RLE.
	EMAC_TSR_RLE = 0x4
	// Position of TGO field.
	EMAC_TSR_TGO_Pos = 0x3
	// Bit mask of TGO field.
	EMAC_TSR_TGO_Msk = 0x8
	// Bit TGO.
	EMAC_TSR_TGO = 0x8
	// Position of BEX field.
	EMAC_TSR_BEX_Pos = 0x4
	// Bit mask of BEX field.
	EMAC_TSR_BEX_Msk = 0x10
	// Bit BEX.
	EMAC_TSR_BEX = 0x10
	// Position of COMP field.
	EMAC_TSR_COMP_Pos = 0x5
	// Bit mask of COMP field.
	EMAC_TSR_COMP_Msk = 0x20
	// Bit COMP.
	EMAC_TSR_COMP = 0x20
	// Position of UND field.
	EMAC_TSR_UND_Pos = 0x6
	// Bit mask of UND field.
	EMAC_TSR_UND_Msk = 0x40
	// Bit UND.
	EMAC_TSR_UND = 0x40

	// RBQP: Receive Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_RBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_RBQP_ADDR_Msk = 0xfffffffc

	// TBQP: Transmit Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_TBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_TBQP_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	EMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	EMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	EMAC_RSR_BNA = 0x1
	// Position of REC field.
	EMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	EMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	EMAC_RSR_REC = 0x2
	// Position of OVR field.
	EMAC_RSR_OVR_Pos = 0x2
	// Bit mask of OVR field.
	EMAC_RSR_OVR_Msk = 0x4
	// Bit OVR.
	EMAC_RSR_OVR = 0x4

	// ISR: Interrupt Status Register
	// Position of MFD field.
	EMAC_ISR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_ISR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_ISR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_ISR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_ISR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_ISR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_ISR_TUND = 0x10
	// Position of RLE field.
	EMAC_ISR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_ISR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_ISR_RLE = 0x20
	// Position of TXERR field.
	EMAC_ISR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_ISR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_ISR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_ISR_HRESP = 0x800
	// Position of PFR field.
	EMAC_ISR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_ISR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_ISR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_ISR_PTZ = 0x2000

	// IER: Interrupt Enable Register
	// Position of MFD field.
	EMAC_IER_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IER_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IER_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IER_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IER_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IER_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IER_TUND = 0x10
	// Position of RLE field.
	EMAC_IER_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IER_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IER_RLE = 0x20
	// Position of TXERR field.
	EMAC_IER_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IER_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IER_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IER_HRESP = 0x800
	// Position of PFR field.
	EMAC_IER_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IER_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IER_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IER_PTZ = 0x2000

	// IDR: Interrupt Disable Register
	// Position of MFD field.
	EMAC_IDR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IDR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IDR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IDR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IDR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IDR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IDR_TUND = 0x10
	// Position of RLE field.
	EMAC_IDR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IDR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IDR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IDR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IDR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IDR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IDR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IDR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IDR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IDR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IDR_PTZ = 0x2000

	// IMR: Interrupt Mask Register
	// Position of MFD field.
	EMAC_IMR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IMR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IMR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IMR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IMR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IMR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IMR_TUND = 0x10
	// Position of RLE field.
	EMAC_IMR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IMR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IMR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IMR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IMR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IMR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IMR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IMR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IMR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IMR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IMR_PTZ = 0x2000

	// MAN: Phy Maintenance Register
	// Position of DATA field.
	EMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	EMAC_MAN_DATA_Msk = 0xffff
	// Position of CODE field.
	EMAC_MAN_CODE_Pos = 0x10
	// Bit mask of CODE field.
	EMAC_MAN_CODE_Msk = 0x30000
	// Position of REGA field.
	EMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	EMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	EMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	EMAC_MAN_PHYA_Msk = 0xf800000
	// Position of RW field.
	EMAC_MAN_RW_Pos = 0x1c
	// Bit mask of RW field.
	EMAC_MAN_RW_Msk = 0x30000000
	// Position of SOF field.
	EMAC_MAN_SOF_Pos = 0x1e
	// Bit mask of SOF field.
	EMAC_MAN_SOF_Msk = 0xc0000000

	// PTR: Pause Time Register
	// Position of PTIME field.
	EMAC_PTR_PTIME_Pos = 0x0
	// Bit mask of PTIME field.
	EMAC_PTR_PTIME_Msk = 0xffff

	// PFR: Pause Frames Received Register
	// Position of FROK field.
	EMAC_PFR_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_PFR_FROK_Msk = 0xffff

	// FTO: Frames Transmitted Ok Register
	// Position of FTOK field.
	EMAC_FTO_FTOK_Pos = 0x0
	// Bit mask of FTOK field.
	EMAC_FTO_FTOK_Msk = 0xffffff

	// SCF: Single Collision Frames Register
	// Position of SCF field.
	EMAC_SCF_SCF_Pos = 0x0
	// Bit mask of SCF field.
	EMAC_SCF_SCF_Msk = 0xffff

	// MCF: Multiple Collision Frames Register
	// Position of MCF field.
	EMAC_MCF_MCF_Pos = 0x0
	// Bit mask of MCF field.
	EMAC_MCF_MCF_Msk = 0xffff

	// FRO: Frames Received Ok Register
	// Position of FROK field.
	EMAC_FRO_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_FRO_FROK_Msk = 0xffffff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCSE field.
	EMAC_FCSE_FCSE_Pos = 0x0
	// Bit mask of FCSE field.
	EMAC_FCSE_FCSE_Msk = 0xff

	// ALE: Alignment Errors Register
	// Position of ALE field.
	EMAC_ALE_ALE_Pos = 0x0
	// Bit mask of ALE field.
	EMAC_ALE_ALE_Msk = 0xff

	// DTF: Deferred Transmission Frames Register
	// Position of DTF field.
	EMAC_DTF_DTF_Pos = 0x0
	// Bit mask of DTF field.
	EMAC_DTF_DTF_Msk = 0xffff

	// LCOL: Late Collisions Register
	// Position of LCOL field.
	EMAC_LCOL_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	EMAC_LCOL_LCOL_Msk = 0xff

	// ECOL: Excessive Collisions Register
	// Position of EXCOL field.
	EMAC_ECOL_EXCOL_Pos = 0x0
	// Bit mask of EXCOL field.
	EMAC_ECOL_EXCOL_Msk = 0xff

	// TUND: Transmit Underrun Errors Register
	// Position of TUND field.
	EMAC_TUND_TUND_Pos = 0x0
	// Bit mask of TUND field.
	EMAC_TUND_TUND_Msk = 0xff

	// CSE: Carrier Sense Errors Register
	// Position of CSE field.
	EMAC_CSE_CSE_Pos = 0x0
	// Bit mask of CSE field.
	EMAC_CSE_CSE_Msk = 0xff

	// RRE: Receive Resource Errors Register
	// Position of RRE field.
	EMAC_RRE_RRE_Pos = 0x0
	// Bit mask of RRE field.
	EMAC_RRE_RRE_Msk = 0xffff

	// ROV: Receive Overrun Errors Register
	// Position of ROVR field.
	EMAC_ROV_ROVR_Pos = 0x0
	// Bit mask of ROVR field.
	EMAC_ROV_ROVR_Msk = 0xff

	// RSE: Receive Symbol Errors Register
	// Position of RSE field.
	EMAC_RSE_RSE_Pos = 0x0
	// Bit mask of RSE field.
	EMAC_RSE_RSE_Msk = 0xff

	// ELE: Excessive Length Errors Register
	// Position of EXL field.
	EMAC_ELE_EXL_Pos = 0x0
	// Bit mask of EXL field.
	EMAC_ELE_EXL_Msk = 0xff

	// RJA: Receive Jabbers Register
	// Position of RJB field.
	EMAC_RJA_RJB_Pos = 0x0
	// Bit mask of RJB field.
	EMAC_RJA_RJB_Msk = 0xff

	// USF: Undersize Frames Register
	// Position of USF field.
	EMAC_USF_USF_Pos = 0x0
	// Bit mask of USF field.
	EMAC_USF_USF_Msk = 0xff

	// STE: SQE Test Errors Register
	// Position of SQER field.
	EMAC_STE_SQER_Pos = 0x0
	// Bit mask of SQER field.
	EMAC_STE_SQER_Msk = 0xff

	// RLE: Received Length Field Mismatch Register
	// Position of RLFM field.
	EMAC_RLE_RLFM_Pos = 0x0
	// Bit mask of RLFM field.
	EMAC_RLE_RLFM_Msk = 0xff

	// HRB: Hash Register Bottom [31:0] Register
	// Position of ADDR field.
	EMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top [63:32] Register
	// Position of ADDR field.
	EMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRT_ADDR_Msk = 0xffffffff

	// SA1B: Specific Address 1 Bottom Register
	// Position of ADDR field.
	EMAC_SA1B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1B_ADDR_Msk = 0xffffffff

	// SA1T: Specific Address 1 Top Register
	// Position of ADDR field.
	EMAC_SA1T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1T_ADDR_Msk = 0xffff

	// SA2B: Specific Address 2 Bottom Register
	// Position of ADDR field.
	EMAC_SA2B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2B_ADDR_Msk = 0xffffffff

	// SA2T: Specific Address 2 Top Register
	// Position of ADDR field.
	EMAC_SA2T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2T_ADDR_Msk = 0xffff

	// SA3B: Specific Address 3 Bottom Register
	// Position of ADDR field.
	EMAC_SA3B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3B_ADDR_Msk = 0xffffffff

	// SA3T: Specific Address 3 Top Register
	// Position of ADDR field.
	EMAC_SA3T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3T_ADDR_Msk = 0xffff

	// SA4B: Specific Address 4 Bottom Register
	// Position of ADDR field.
	EMAC_SA4B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4B_ADDR_Msk = 0xffffffff

	// SA4T: Specific Address 4 Top Register
	// Position of ADDR field.
	EMAC_SA4T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4T_ADDR_Msk = 0xffff

	// TID: Type ID Checking Register
	// Position of TID field.
	EMAC_TID_TID_Pos = 0x0
	// Bit mask of TID field.
	EMAC_TID_TID_Msk = 0xffff

	// USRIO: User Input/Output Register
	// Position of RMII field.
	EMAC_USRIO_RMII_Pos = 0x0
	// Bit mask of RMII field.
	EMAC_USRIO_RMII_Msk = 0x1
	// Bit RMII.
	EMAC_USRIO_RMII = 0x1
	// Position of CLKEN field.
	EMAC_USRIO_CLKEN_Pos = 0x1
	// Bit mask of CLKEN field.
	EMAC_USRIO_CLKEN_Msk = 0x2
	// Bit CLKEN.
	EMAC_USRIO_CLKEN = 0x2
)

// Constants for AES: Advanced Encryption Standard
const (
	// CR: Control Register
	// Position of START field.
	AES_CR_START_Pos = 0x0
	// Bit mask of START field.
	AES_CR_START_Msk = 0x1
	// Bit START.
	AES_CR_START = 0x1
	// Position of SWRST field.
	AES_CR_SWRST_Pos = 0x8
	// Bit mask of SWRST field.
	AES_CR_SWRST_Msk = 0x100
	// Bit SWRST.
	AES_CR_SWRST = 0x100
	// Position of LOADSEED field.
	AES_CR_LOADSEED_Pos = 0x10
	// Bit mask of LOADSEED field.
	AES_CR_LOADSEED_Msk = 0x10000
	// Bit LOADSEED.
	AES_CR_LOADSEED = 0x10000

	// MR: Mode Register
	// Position of CIPHER field.
	AES_MR_CIPHER_Pos = 0x0
	// Bit mask of CIPHER field.
	AES_MR_CIPHER_Msk = 0x1
	// Bit CIPHER.
	AES_MR_CIPHER = 0x1
	// Position of PROCDLY field.
	AES_MR_PROCDLY_Pos = 0x4
	// Bit mask of PROCDLY field.
	AES_MR_PROCDLY_Msk = 0xf0
	// Position of SMOD field.
	AES_MR_SMOD_Pos = 0x8
	// Bit mask of SMOD field.
	AES_MR_SMOD_Msk = 0x300
	// Manual Mode
	AES_MR_SMOD_MANUAL_START = 0x0
	// Auto Mode
	AES_MR_SMOD_AUTO_START = 0x1
	// AES_IDATAR0 access only Auto Mode
	AES_MR_SMOD_IDATAR0_START = 0x2
	// Position of KEYSIZE field.
	AES_MR_KEYSIZE_Pos = 0xa
	// Bit mask of KEYSIZE field.
	AES_MR_KEYSIZE_Msk = 0xc00
	// AES Key Size is 128 bits
	AES_MR_KEYSIZE_AES128 = 0x0
	// AES Key Size is 192 bits
	AES_MR_KEYSIZE_AES192 = 0x1
	// AES Key Size is 256 bits
	AES_MR_KEYSIZE_AES256 = 0x2
	// Position of OPMOD field.
	AES_MR_OPMOD_Pos = 0xc
	// Bit mask of OPMOD field.
	AES_MR_OPMOD_Msk = 0x7000
	// ECB: Electronic Code Book mode
	AES_MR_OPMOD_ECB = 0x0
	// CBC: Cipher Block Chaining mode
	AES_MR_OPMOD_CBC = 0x1
	// OFB: Output Feedback mode
	AES_MR_OPMOD_OFB = 0x2
	// CFB: Cipher Feedback mode
	AES_MR_OPMOD_CFB = 0x3
	// CTR: Counter mode (16-bit internal counter)
	AES_MR_OPMOD_CTR = 0x4
	// Position of LOD field.
	AES_MR_LOD_Pos = 0xf
	// Bit mask of LOD field.
	AES_MR_LOD_Msk = 0x8000
	// Bit LOD.
	AES_MR_LOD = 0x8000
	// Position of CFBS field.
	AES_MR_CFBS_Pos = 0x10
	// Bit mask of CFBS field.
	AES_MR_CFBS_Msk = 0x70000
	// 128-bit
	AES_MR_CFBS_SIZE_128BIT = 0x0
	// 64-bit
	AES_MR_CFBS_SIZE_64BIT = 0x1
	// 32-bit
	AES_MR_CFBS_SIZE_32BIT = 0x2
	// 16-bit
	AES_MR_CFBS_SIZE_16BIT = 0x3
	// 8-bit
	AES_MR_CFBS_SIZE_8BIT = 0x4
	// Position of CKEY field.
	AES_MR_CKEY_Pos = 0x14
	// Bit mask of CKEY field.
	AES_MR_CKEY_Msk = 0xf00000
	// Position of CMTYP1 field.
	AES_MR_CMTYP1_Pos = 0x18
	// Bit mask of CMTYP1 field.
	AES_MR_CMTYP1_Msk = 0x1000000
	// Bit CMTYP1.
	AES_MR_CMTYP1 = 0x1000000
	// Counter-Measure type 1 is disabled
	AES_MR_CMTYP1_NOPROT_EXTXKEY = 0x0
	// Counter-Measure type 1 is enabled
	AES_MR_CMTYP1_PROT_EXTKEY = 0x1
	// Position of CMTYP2 field.
	AES_MR_CMTYP2_Pos = 0x19
	// Bit mask of CMTYP2 field.
	AES_MR_CMTYP2_Msk = 0x2000000
	// Bit CMTYP2.
	AES_MR_CMTYP2 = 0x2000000
	// Counter-Measure type 2 is disabled
	AES_MR_CMTYP2_NO_PAUSE = 0x0
	// Counter-Measure type 2 is enabled
	AES_MR_CMTYP2_PAUSE = 0x1
	// Position of CMTYP3 field.
	AES_MR_CMTYP3_Pos = 0x1a
	// Bit mask of CMTYP3 field.
	AES_MR_CMTYP3_Msk = 0x4000000
	// Bit CMTYP3.
	AES_MR_CMTYP3 = 0x4000000
	// Counter-Measure type 3 is disabled
	AES_MR_CMTYP3_NO_DUMMY = 0x0
	// Counter-Measure type 3 is enabled
	AES_MR_CMTYP3_DUMMY = 0x1
	// Position of CMTYP4 field.
	AES_MR_CMTYP4_Pos = 0x1b
	// Bit mask of CMTYP4 field.
	AES_MR_CMTYP4_Msk = 0x8000000
	// Bit CMTYP4.
	AES_MR_CMTYP4 = 0x8000000
	// Counter-Measure type 4 is disabled
	AES_MR_CMTYP4_NO_RESTART = 0x0
	// Counter-Measure type 4 is enabled
	AES_MR_CMTYP4_RESTART = 0x1
	// Position of CMTYP5 field.
	AES_MR_CMTYP5_Pos = 0x1c
	// Bit mask of CMTYP5 field.
	AES_MR_CMTYP5_Msk = 0x10000000
	// Bit CMTYP5.
	AES_MR_CMTYP5 = 0x10000000
	// Counter-Measure type 5 is disabled
	AES_MR_CMTYP5_NO_ADDACCESS = 0x0
	// Counter-Measure type 5 is enabled
	AES_MR_CMTYP5_ADDACCESS = 0x1

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	AES_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IER_DATRDY = 0x1
	// Position of URAD field.
	AES_IER_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IER_URAD_Msk = 0x100
	// Bit URAD.
	AES_IER_URAD = 0x100

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	AES_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IDR_DATRDY = 0x1
	// Position of URAD field.
	AES_IDR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IDR_URAD_Msk = 0x100
	// Bit URAD.
	AES_IDR_URAD = 0x100

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	AES_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_IMR_DATRDY = 0x1
	// Position of URAD field.
	AES_IMR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_IMR_URAD_Msk = 0x100
	// Bit URAD.
	AES_IMR_URAD = 0x100

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	AES_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	AES_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	AES_ISR_DATRDY = 0x1
	// Position of URAD field.
	AES_ISR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	AES_ISR_URAD_Msk = 0x100
	// Bit URAD.
	AES_ISR_URAD = 0x100
	// Position of URAT field.
	AES_ISR_URAT_Pos = 0xc
	// Bit mask of URAT field.
	AES_ISR_URAT_Msk = 0xf000
	// Input Data Register written during the data processing when SMOD=0x2 mode.
	AES_ISR_URAT_IDR_WR_PROCESSING = 0x0
	// Output Data Register read during the data processing.
	AES_ISR_URAT_ODR_RD_PROCESSING = 0x1
	// Mode Register written during the data processing.
	AES_ISR_URAT_MR_WR_PROCESSING = 0x2
	// Output Data Register read during the sub-keys generation.
	AES_ISR_URAT_ODR_RD_SUBKGEN = 0x3
	// Mode Register written during the sub-keys generation.
	AES_ISR_URAT_MR_WR_SUBKGEN = 0x4
	// Write-only register read access.
	AES_ISR_URAT_WOR_RD_ACCESS = 0x5

	// KEYWR: Key Word Register
	// Position of KEYW field.
	AES_KEYWR_KEYW_Pos = 0x0
	// Bit mask of KEYW field.
	AES_KEYWR_KEYW_Msk = 0xffffffff

	// IDATAR: Input Data Register
	// Position of IDATA field.
	AES_IDATAR_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	AES_IDATAR_IDATA_Msk = 0xffffffff

	// ODATAR: Output Data Register
	// Position of ODATA field.
	AES_ODATAR_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	AES_ODATAR_ODATA_Msk = 0xffffffff

	// IVR: Initialization Vector Register
	// Position of IV field.
	AES_IVR_IV_Pos = 0x0
	// Bit mask of IV field.
	AES_IVR_IV_Msk = 0xffffffff
)

// Constants for TDES: Triple Data Encryption Standard
const (
	// CR: Control Register
	// Position of START field.
	TDES_CR_START_Pos = 0x0
	// Bit mask of START field.
	TDES_CR_START_Msk = 0x1
	// Bit START.
	TDES_CR_START = 0x1
	// Position of SWRST field.
	TDES_CR_SWRST_Pos = 0x8
	// Bit mask of SWRST field.
	TDES_CR_SWRST_Msk = 0x100
	// Bit SWRST.
	TDES_CR_SWRST = 0x100
	// Position of LOADSEED field.
	TDES_CR_LOADSEED_Pos = 0x10
	// Bit mask of LOADSEED field.
	TDES_CR_LOADSEED_Msk = 0x10000
	// Bit LOADSEED.
	TDES_CR_LOADSEED = 0x10000

	// MR: Mode Register
	// Position of CIPHER field.
	TDES_MR_CIPHER_Pos = 0x0
	// Bit mask of CIPHER field.
	TDES_MR_CIPHER_Msk = 0x1
	// Bit CIPHER.
	TDES_MR_CIPHER = 0x1
	// Position of TDESMOD field.
	TDES_MR_TDESMOD_Pos = 0x1
	// Bit mask of TDESMOD field.
	TDES_MR_TDESMOD_Msk = 0x2
	// Bit TDESMOD.
	TDES_MR_TDESMOD = 0x2
	// Position of KEYMOD field.
	TDES_MR_KEYMOD_Pos = 0x4
	// Bit mask of KEYMOD field.
	TDES_MR_KEYMOD_Msk = 0x10
	// Bit KEYMOD.
	TDES_MR_KEYMOD = 0x10
	// Position of SMOD field.
	TDES_MR_SMOD_Pos = 0x8
	// Bit mask of SMOD field.
	TDES_MR_SMOD_Msk = 0x300
	// Position of OPMOD field.
	TDES_MR_OPMOD_Pos = 0xc
	// Bit mask of OPMOD field.
	TDES_MR_OPMOD_Msk = 0x3000
	// Position of LOD field.
	TDES_MR_LOD_Pos = 0xf
	// Bit mask of LOD field.
	TDES_MR_LOD_Msk = 0x8000
	// Bit LOD.
	TDES_MR_LOD = 0x8000
	// Position of CFBS field.
	TDES_MR_CFBS_Pos = 0x10
	// Bit mask of CFBS field.
	TDES_MR_CFBS_Msk = 0x30000
	// Position of CKEY field.
	TDES_MR_CKEY_Pos = 0x14
	// Bit mask of CKEY field.
	TDES_MR_CKEY_Msk = 0xf00000
	// Position of CTYPE field.
	TDES_MR_CTYPE_Pos = 0x18
	// Bit mask of CTYPE field.
	TDES_MR_CTYPE_Msk = 0x3f000000

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	TDES_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TDES_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TDES_IER_DATRDY = 0x1
	// Position of ENDRX field.
	TDES_IER_ENDRX_Pos = 0x1
	// Bit mask of ENDRX field.
	TDES_IER_ENDRX_Msk = 0x2
	// Bit ENDRX.
	TDES_IER_ENDRX = 0x2
	// Position of ENDTX field.
	TDES_IER_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	TDES_IER_ENDTX_Msk = 0x4
	// Bit ENDTX.
	TDES_IER_ENDTX = 0x4
	// Position of RXBUFF field.
	TDES_IER_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	TDES_IER_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	TDES_IER_RXBUFF = 0x8
	// Position of TXBUFE field.
	TDES_IER_TXBUFE_Pos = 0x4
	// Bit mask of TXBUFE field.
	TDES_IER_TXBUFE_Msk = 0x10
	// Bit TXBUFE.
	TDES_IER_TXBUFE = 0x10
	// Position of URAD field.
	TDES_IER_URAD_Pos = 0x8
	// Bit mask of URAD field.
	TDES_IER_URAD_Msk = 0x100
	// Bit URAD.
	TDES_IER_URAD = 0x100

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	TDES_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TDES_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TDES_IDR_DATRDY = 0x1
	// Position of ENDRX field.
	TDES_IDR_ENDRX_Pos = 0x1
	// Bit mask of ENDRX field.
	TDES_IDR_ENDRX_Msk = 0x2
	// Bit ENDRX.
	TDES_IDR_ENDRX = 0x2
	// Position of ENDTX field.
	TDES_IDR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	TDES_IDR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	TDES_IDR_ENDTX = 0x4
	// Position of RXBUFF field.
	TDES_IDR_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	TDES_IDR_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	TDES_IDR_RXBUFF = 0x8
	// Position of TXBUFE field.
	TDES_IDR_TXBUFE_Pos = 0x4
	// Bit mask of TXBUFE field.
	TDES_IDR_TXBUFE_Msk = 0x10
	// Bit TXBUFE.
	TDES_IDR_TXBUFE = 0x10
	// Position of URAD field.
	TDES_IDR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	TDES_IDR_URAD_Msk = 0x100
	// Bit URAD.
	TDES_IDR_URAD = 0x100

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	TDES_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TDES_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TDES_IMR_DATRDY = 0x1
	// Position of ENDRX field.
	TDES_IMR_ENDRX_Pos = 0x1
	// Bit mask of ENDRX field.
	TDES_IMR_ENDRX_Msk = 0x2
	// Bit ENDRX.
	TDES_IMR_ENDRX = 0x2
	// Position of ENDTX field.
	TDES_IMR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	TDES_IMR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	TDES_IMR_ENDTX = 0x4
	// Position of RXBUFF field.
	TDES_IMR_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	TDES_IMR_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	TDES_IMR_RXBUFF = 0x8
	// Position of TXBUFE field.
	TDES_IMR_TXBUFE_Pos = 0x4
	// Bit mask of TXBUFE field.
	TDES_IMR_TXBUFE_Msk = 0x10
	// Bit TXBUFE.
	TDES_IMR_TXBUFE = 0x10
	// Position of URAD field.
	TDES_IMR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	TDES_IMR_URAD_Msk = 0x100
	// Bit URAD.
	TDES_IMR_URAD = 0x100

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	TDES_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TDES_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TDES_ISR_DATRDY = 0x1
	// Position of ENDRX field.
	TDES_ISR_ENDRX_Pos = 0x1
	// Bit mask of ENDRX field.
	TDES_ISR_ENDRX_Msk = 0x2
	// Bit ENDRX.
	TDES_ISR_ENDRX = 0x2
	// Position of ENDTX field.
	TDES_ISR_ENDTX_Pos = 0x2
	// Bit mask of ENDTX field.
	TDES_ISR_ENDTX_Msk = 0x4
	// Bit ENDTX.
	TDES_ISR_ENDTX = 0x4
	// Position of RXBUFF field.
	TDES_ISR_RXBUFF_Pos = 0x3
	// Bit mask of RXBUFF field.
	TDES_ISR_RXBUFF_Msk = 0x8
	// Bit RXBUFF.
	TDES_ISR_RXBUFF = 0x8
	// Position of TXBUFE field.
	TDES_ISR_TXBUFE_Pos = 0x4
	// Bit mask of TXBUFE field.
	TDES_ISR_TXBUFE_Msk = 0x10
	// Bit TXBUFE.
	TDES_ISR_TXBUFE = 0x10
	// Position of URAD field.
	TDES_ISR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	TDES_ISR_URAD_Msk = 0x100
	// Bit URAD.
	TDES_ISR_URAD = 0x100
	// Position of URAT field.
	TDES_ISR_URAT_Pos = 0xc
	// Bit mask of URAT field.
	TDES_ISR_URAT_Msk = 0x3000

	// KEY1WxR: Key 1 Word Register
	// Position of KEY1Wx field.
	TDES_KEY1WxR_KEY1Wx_Pos = 0x0
	// Bit mask of KEY1Wx field.
	TDES_KEY1WxR_KEY1Wx_Msk = 0xffffffff

	// KEY2WxR: Key 2 Word Register
	// Position of KEY2Wx field.
	TDES_KEY2WxR_KEY2Wx_Pos = 0x0
	// Bit mask of KEY2Wx field.
	TDES_KEY2WxR_KEY2Wx_Msk = 0xffffffff

	// KEY3WxR: Key 3 Word Register
	// Position of KEY3Wx field.
	TDES_KEY3WxR_KEY3Wx_Pos = 0x0
	// Bit mask of KEY3Wx field.
	TDES_KEY3WxR_KEY3Wx_Msk = 0xffffffff

	// IDATAxR: Input Data Register
	// Position of IDATAx field.
	TDES_IDATAxR_IDATAx_Pos = 0x0
	// Bit mask of IDATAx field.
	TDES_IDATAxR_IDATAx_Msk = 0xffffffff

	// ODATAxR: Output Data Register
	// Position of ODATAx field.
	TDES_ODATAxR_ODATAx_Pos = 0x0
	// Bit mask of ODATAx field.
	TDES_ODATAxR_ODATAx_Msk = 0xffffffff

	// IVxR: Initialization Vector Register
	// Position of IVx field.
	TDES_IVxR_IVx_Pos = 0x0
	// Bit mask of IVx field.
	TDES_IVxR_IVx_Msk = 0xffffffff

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	TDES_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	TDES_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	TDES_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	TDES_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	TDES_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	TDES_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	TDES_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	TDES_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	TDES_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	TDES_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	TDES_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	TDES_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	TDES_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	TDES_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	TDES_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	TDES_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	TDES_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	TDES_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	TDES_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	TDES_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	TDES_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	TDES_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	TDES_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	TDES_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	TDES_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	TDES_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	TDES_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	TDES_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	TDES_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	TDES_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	TDES_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	TDES_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	TDES_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	TDES_PTSR_TXTEN = 0x100
)

// Constants for SHA: Secure Hash Algorithm
const (
	// CR: Control Register
	// Position of START field.
	SHA_CR_START_Pos = 0x0
	// Bit mask of START field.
	SHA_CR_START_Msk = 0x1
	// Bit START.
	SHA_CR_START = 0x1
	// Position of FIRST field.
	SHA_CR_FIRST_Pos = 0x4
	// Bit mask of FIRST field.
	SHA_CR_FIRST_Msk = 0x10
	// Bit FIRST.
	SHA_CR_FIRST = 0x10
	// Position of SWRST field.
	SHA_CR_SWRST_Pos = 0x8
	// Bit mask of SWRST field.
	SHA_CR_SWRST_Msk = 0x100
	// Bit SWRST.
	SHA_CR_SWRST = 0x100

	// MR: Mode Register
	// Position of SMOD field.
	SHA_MR_SMOD_Pos = 0x0
	// Bit mask of SMOD field.
	SHA_MR_SMOD_Msk = 0x3
	// Position of PROCDLY field.
	SHA_MR_PROCDLY_Pos = 0x4
	// Bit mask of PROCDLY field.
	SHA_MR_PROCDLY_Msk = 0x10
	// Bit PROCDLY.
	SHA_MR_PROCDLY = 0x10
	// Position of ALGO field.
	SHA_MR_ALGO_Pos = 0x8
	// Bit mask of ALGO field.
	SHA_MR_ALGO_Msk = 0x100
	// Bit ALGO.
	SHA_MR_ALGO = 0x100

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	SHA_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	SHA_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	SHA_IER_DATRDY = 0x1
	// Position of ENDTX field.
	SHA_IER_ENDTX_Pos = 0x1
	// Bit mask of ENDTX field.
	SHA_IER_ENDTX_Msk = 0x2
	// Bit ENDTX.
	SHA_IER_ENDTX = 0x2
	// Position of TXBUFE field.
	SHA_IER_TXBUFE_Pos = 0x2
	// Bit mask of TXBUFE field.
	SHA_IER_TXBUFE_Msk = 0x4
	// Bit TXBUFE.
	SHA_IER_TXBUFE = 0x4
	// Position of URAD field.
	SHA_IER_URAD_Pos = 0x8
	// Bit mask of URAD field.
	SHA_IER_URAD_Msk = 0x100
	// Bit URAD.
	SHA_IER_URAD = 0x100

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	SHA_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	SHA_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	SHA_IDR_DATRDY = 0x1
	// Position of ENDTX field.
	SHA_IDR_ENDTX_Pos = 0x1
	// Bit mask of ENDTX field.
	SHA_IDR_ENDTX_Msk = 0x2
	// Bit ENDTX.
	SHA_IDR_ENDTX = 0x2
	// Position of TXBUFE field.
	SHA_IDR_TXBUFE_Pos = 0x2
	// Bit mask of TXBUFE field.
	SHA_IDR_TXBUFE_Msk = 0x4
	// Bit TXBUFE.
	SHA_IDR_TXBUFE = 0x4
	// Position of URAD field.
	SHA_IDR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	SHA_IDR_URAD_Msk = 0x100
	// Bit URAD.
	SHA_IDR_URAD = 0x100

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	SHA_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	SHA_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	SHA_IMR_DATRDY = 0x1
	// Position of ENDTX field.
	SHA_IMR_ENDTX_Pos = 0x1
	// Bit mask of ENDTX field.
	SHA_IMR_ENDTX_Msk = 0x2
	// Bit ENDTX.
	SHA_IMR_ENDTX = 0x2
	// Position of TXBUFE field.
	SHA_IMR_TXBUFE_Pos = 0x2
	// Bit mask of TXBUFE field.
	SHA_IMR_TXBUFE_Msk = 0x4
	// Bit TXBUFE.
	SHA_IMR_TXBUFE = 0x4
	// Position of URAD field.
	SHA_IMR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	SHA_IMR_URAD_Msk = 0x100
	// Bit URAD.
	SHA_IMR_URAD = 0x100

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	SHA_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	SHA_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	SHA_ISR_DATRDY = 0x1
	// Position of ENDTX field.
	SHA_ISR_ENDTX_Pos = 0x1
	// Bit mask of ENDTX field.
	SHA_ISR_ENDTX_Msk = 0x2
	// Bit ENDTX.
	SHA_ISR_ENDTX = 0x2
	// Position of TXBUFE field.
	SHA_ISR_TXBUFE_Pos = 0x2
	// Bit mask of TXBUFE field.
	SHA_ISR_TXBUFE_Msk = 0x4
	// Bit TXBUFE.
	SHA_ISR_TXBUFE = 0x4
	// Position of URAD field.
	SHA_ISR_URAD_Pos = 0x8
	// Bit mask of URAD field.
	SHA_ISR_URAD_Msk = 0x100
	// Bit URAD.
	SHA_ISR_URAD = 0x100
	// Position of URAT field.
	SHA_ISR_URAT_Pos = 0xc
	// Bit mask of URAT field.
	SHA_ISR_URAT_Msk = 0x7000

	// IDATAxR: Input Data Register
	// Position of IDATAx field.
	SHA_IDATAxR_IDATAx_Pos = 0x0
	// Bit mask of IDATAx field.
	SHA_IDATAxR_IDATAx_Msk = 0xffffffff

	// ODATAxR: Output Data Register
	// Position of ODATAx field.
	SHA_ODATAxR_ODATAx_Pos = 0x0
	// Bit mask of ODATAx field.
	SHA_ODATAxR_ODATAx_Msk = 0xffffffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	SHA_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	SHA_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	SHA_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	SHA_TCR_TXCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	SHA_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	SHA_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	SHA_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	SHA_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	SHA_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SHA_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SHA_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	SHA_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	SHA_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	SHA_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	SHA_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SHA_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SHA_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	SHA_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	SHA_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	SHA_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	SHA_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	SHA_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	SHA_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	SHA_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	SHA_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	SHA_PTSR_TXTEN = 0x100
)

// Constants for TRNG: True Random Number Generator
const (
	// CR: Control Register
	// Position of ENABLE field.
	TRNG_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TRNG_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	TRNG_CR_ENABLE = 0x1

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	TRNG_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IER_DATRDY = 0x1

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	TRNG_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IDR_DATRDY = 0x1

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	TRNG_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IMR_DATRDY = 0x1

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	TRNG_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_ISR_DATRDY = 0x1

	// ODATA: Output Data Register
	// Position of ODATA field.
	TRNG_ODATA_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	TRNG_ODATA_ODATA_Msk = 0xffffffff
)

// Constants for DDRSDRC1: DDR_SDR SDRAM Controller 1
const (
	// MR: DDRSDRC Mode Register
	// Position of MODE field.
	EBI_MR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	EBI_MR_MODE_Msk = 0x7

	// RTR: DDRSDRC Refresh Timer Register
	// Position of COUNT field.
	EBI_RTR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	EBI_RTR_COUNT_Msk = 0xfff

	// CR: DDRSDRC Configuration Register
	// Position of NC field.
	EBI_CR_NC_Pos = 0x0
	// Bit mask of NC field.
	EBI_CR_NC_Msk = 0x3
	// Position of NR field.
	EBI_CR_NR_Pos = 0x2
	// Bit mask of NR field.
	EBI_CR_NR_Msk = 0xc
	// Position of CAS field.
	EBI_CR_CAS_Pos = 0x4
	// Bit mask of CAS field.
	EBI_CR_CAS_Msk = 0x70
	// Position of DLL field.
	EBI_CR_DLL_Pos = 0x7
	// Bit mask of DLL field.
	EBI_CR_DLL_Msk = 0x80
	// Bit DLL.
	EBI_CR_DLL = 0x80
	// Position of DIC field.
	EBI_CR_DIC_Pos = 0x8
	// Bit mask of DIC field.
	EBI_CR_DIC_Msk = 0x100
	// Bit DIC.
	EBI_CR_DIC = 0x100
	// Position of DIS_DLL field.
	EBI_CR_DIS_DLL_Pos = 0x9
	// Bit mask of DIS_DLL field.
	EBI_CR_DIS_DLL_Msk = 0x200
	// Bit DIS_DLL.
	EBI_CR_DIS_DLL = 0x200
	// Position of OCD field.
	EBI_CR_OCD_Pos = 0xc
	// Bit mask of OCD field.
	EBI_CR_OCD_Msk = 0x7000
	// Position of EBISHARE field.
	EBI_CR_EBISHARE_Pos = 0x10
	// Bit mask of EBISHARE field.
	EBI_CR_EBISHARE_Msk = 0x10000
	// Bit EBISHARE.
	EBI_CR_EBISHARE = 0x10000
	// Position of ACTBST field.
	EBI_CR_ACTBST_Pos = 0x12
	// Bit mask of ACTBST field.
	EBI_CR_ACTBST_Msk = 0x40000
	// Bit ACTBST.
	EBI_CR_ACTBST = 0x40000

	// TPR0: DDRSDRC Timing Parameter 0 Register
	// Position of TRAS field.
	EBI_TPR0_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	EBI_TPR0_TRAS_Msk = 0xf
	// Position of TRCD field.
	EBI_TPR0_TRCD_Pos = 0x4
	// Bit mask of TRCD field.
	EBI_TPR0_TRCD_Msk = 0xf0
	// Position of TWR field.
	EBI_TPR0_TWR_Pos = 0x8
	// Bit mask of TWR field.
	EBI_TPR0_TWR_Msk = 0xf00
	// Position of TRC field.
	EBI_TPR0_TRC_Pos = 0xc
	// Bit mask of TRC field.
	EBI_TPR0_TRC_Msk = 0xf000
	// Position of TRP field.
	EBI_TPR0_TRP_Pos = 0x10
	// Bit mask of TRP field.
	EBI_TPR0_TRP_Msk = 0xf0000
	// Position of TRRD field.
	EBI_TPR0_TRRD_Pos = 0x14
	// Bit mask of TRRD field.
	EBI_TPR0_TRRD_Msk = 0xf00000
	// Position of TWTR field.
	EBI_TPR0_TWTR_Pos = 0x18
	// Bit mask of TWTR field.
	EBI_TPR0_TWTR_Msk = 0x7000000
	// Position of REDUCE_WRRD field.
	EBI_TPR0_REDUCE_WRRD_Pos = 0x1b
	// Bit mask of REDUCE_WRRD field.
	EBI_TPR0_REDUCE_WRRD_Msk = 0x8000000
	// Bit REDUCE_WRRD.
	EBI_TPR0_REDUCE_WRRD = 0x8000000
	// Position of TMRD field.
	EBI_TPR0_TMRD_Pos = 0x1c
	// Bit mask of TMRD field.
	EBI_TPR0_TMRD_Msk = 0xf0000000

	// TPR1: DDRSDRC Timing Parameter 1 Register
	// Position of TRFC field.
	EBI_TPR1_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	EBI_TPR1_TRFC_Msk = 0x1f
	// Position of TXSNR field.
	EBI_TPR1_TXSNR_Pos = 0x8
	// Bit mask of TXSNR field.
	EBI_TPR1_TXSNR_Msk = 0xff00
	// Position of TXSRD field.
	EBI_TPR1_TXSRD_Pos = 0x10
	// Bit mask of TXSRD field.
	EBI_TPR1_TXSRD_Msk = 0xff0000
	// Position of TXP field.
	EBI_TPR1_TXP_Pos = 0x18
	// Bit mask of TXP field.
	EBI_TPR1_TXP_Msk = 0xf000000

	// TPR2: DDRSDRC Timing Parameter 2 Register
	// Position of TXARD field.
	EBI_TPR2_TXARD_Pos = 0x0
	// Bit mask of TXARD field.
	EBI_TPR2_TXARD_Msk = 0xf
	// Position of TXARDS field.
	EBI_TPR2_TXARDS_Pos = 0x4
	// Bit mask of TXARDS field.
	EBI_TPR2_TXARDS_Msk = 0xf0
	// Position of TRPA field.
	EBI_TPR2_TRPA_Pos = 0x8
	// Bit mask of TRPA field.
	EBI_TPR2_TRPA_Msk = 0xf00
	// Position of TRTP field.
	EBI_TPR2_TRTP_Pos = 0xc
	// Bit mask of TRTP field.
	EBI_TPR2_TRTP_Msk = 0x7000

	// LPR: DDRSDRC Low-power Register
	// Position of LPCB field.
	EBI_LPR_LPCB_Pos = 0x0
	// Bit mask of LPCB field.
	EBI_LPR_LPCB_Msk = 0x3
	// Position of CLK_FR field.
	EBI_LPR_CLK_FR_Pos = 0x2
	// Bit mask of CLK_FR field.
	EBI_LPR_CLK_FR_Msk = 0x4
	// Bit CLK_FR.
	EBI_LPR_CLK_FR = 0x4
	// Position of PASR field.
	EBI_LPR_PASR_Pos = 0x4
	// Bit mask of PASR field.
	EBI_LPR_PASR_Msk = 0x70
	// Position of TCR field.
	EBI_LPR_TCR_Pos = 0x8
	// Bit mask of TCR field.
	EBI_LPR_TCR_Msk = 0x300
	// Position of DS field.
	EBI_LPR_DS_Pos = 0xa
	// Bit mask of DS field.
	EBI_LPR_DS_Msk = 0xc00
	// Position of TIMEOUT field.
	EBI_LPR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	EBI_LPR_TIMEOUT_Msk = 0x3000
	// Position of APDE field.
	EBI_LPR_APDE_Pos = 0x10
	// Bit mask of APDE field.
	EBI_LPR_APDE_Msk = 0x10000
	// Bit APDE.
	EBI_LPR_APDE = 0x10000
	// Position of UPD_MR field.
	EBI_LPR_UPD_MR_Pos = 0x14
	// Bit mask of UPD_MR field.
	EBI_LPR_UPD_MR_Msk = 0x300000

	// MD: DDRSDRC Memory Device Register
	// Position of MD field.
	EBI_MD_MD_Pos = 0x0
	// Bit mask of MD field.
	EBI_MD_MD_Msk = 0x7
	// Position of DBW field.
	EBI_MD_DBW_Pos = 0x4
	// Bit mask of DBW field.
	EBI_MD_DBW_Msk = 0x10
	// Bit DBW.
	EBI_MD_DBW = 0x10

	// DLL: DDRSDRC DLL Information Register
	// Position of MDINC field.
	EBI_DLL_MDINC_Pos = 0x0
	// Bit mask of MDINC field.
	EBI_DLL_MDINC_Msk = 0x1
	// Bit MDINC.
	EBI_DLL_MDINC = 0x1
	// Position of MDDEC field.
	EBI_DLL_MDDEC_Pos = 0x1
	// Bit mask of MDDEC field.
	EBI_DLL_MDDEC_Msk = 0x2
	// Bit MDDEC.
	EBI_DLL_MDDEC = 0x2
	// Position of MDOVF field.
	EBI_DLL_MDOVF_Pos = 0x2
	// Bit mask of MDOVF field.
	EBI_DLL_MDOVF_Msk = 0x4
	// Bit MDOVF.
	EBI_DLL_MDOVF = 0x4
	// Position of MDVAL field.
	EBI_DLL_MDVAL_Pos = 0x8
	// Bit mask of MDVAL field.
	EBI_DLL_MDVAL_Msk = 0xff00

	// HS: DDRSDRC High Speed Register
	// Position of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Pos = 0x2
	// Bit mask of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Msk = 0x4
	// Bit DIS_ANTICIP_READ.
	EBI_HS_DIS_ANTICIP_READ = 0x4

	// DELAY: DDRSDRC Delay I/O Register
	// Position of DELAY1 field.
	EBI_DELAY_DELAY1_Pos = 0x0
	// Bit mask of DELAY1 field.
	EBI_DELAY_DELAY1_Msk = 0xf
	// Position of DELAY2 field.
	EBI_DELAY_DELAY2_Pos = 0x4
	// Bit mask of DELAY2 field.
	EBI_DELAY_DELAY2_Msk = 0xf0
	// Position of DELAY3 field.
	EBI_DELAY_DELAY3_Pos = 0x8
	// Bit mask of DELAY3 field.
	EBI_DELAY_DELAY3_Msk = 0xf00
	// Position of DELAY4 field.
	EBI_DELAY_DELAY4_Pos = 0xc
	// Bit mask of DELAY4 field.
	EBI_DELAY_DELAY4_Msk = 0xf000
	// Position of DELAY5 field.
	EBI_DELAY_DELAY5_Pos = 0x10
	// Bit mask of DELAY5 field.
	EBI_DELAY_DELAY5_Msk = 0xf0000
	// Position of DELAY6 field.
	EBI_DELAY_DELAY6_Pos = 0x14
	// Bit mask of DELAY6 field.
	EBI_DELAY_DELAY6_Msk = 0xf00000
	// Position of DELAY7 field.
	EBI_DELAY_DELAY7_Pos = 0x18
	// Bit mask of DELAY7 field.
	EBI_DELAY_DELAY7_Msk = 0xf000000
	// Position of DELAY8 field.
	EBI_DELAY_DELAY8_Pos = 0x1c
	// Bit mask of DELAY8 field.
	EBI_DELAY_DELAY8_Msk = 0xf0000000

	// WPMR: DDRSDRC Write Protect Mode Register
	// Position of WPEN field.
	EBI_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	EBI_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	EBI_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	EBI_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	EBI_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: DDRSDRC Write Protect Status Register
	// Position of WPVS field.
	EBI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	EBI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	EBI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	EBI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	EBI_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for DDRSDRC0: DDR_SDR SDRAM Controller 0
const (
	// MR: DDRSDRC Mode Register
	// Position of MODE field.
	DDRSDRC_MR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	DDRSDRC_MR_MODE_Msk = 0x7

	// RTR: DDRSDRC Refresh Timer Register
	// Position of COUNT field.
	DDRSDRC_RTR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	DDRSDRC_RTR_COUNT_Msk = 0xfff

	// CR: DDRSDRC Configuration Register
	// Position of NC field.
	DDRSDRC_CR_NC_Pos = 0x0
	// Bit mask of NC field.
	DDRSDRC_CR_NC_Msk = 0x3
	// Position of NR field.
	DDRSDRC_CR_NR_Pos = 0x2
	// Bit mask of NR field.
	DDRSDRC_CR_NR_Msk = 0xc
	// Position of CAS field.
	DDRSDRC_CR_CAS_Pos = 0x4
	// Bit mask of CAS field.
	DDRSDRC_CR_CAS_Msk = 0x70
	// Position of DLL field.
	DDRSDRC_CR_DLL_Pos = 0x7
	// Bit mask of DLL field.
	DDRSDRC_CR_DLL_Msk = 0x80
	// Bit DLL.
	DDRSDRC_CR_DLL = 0x80
	// Position of DIC field.
	DDRSDRC_CR_DIC_Pos = 0x8
	// Bit mask of DIC field.
	DDRSDRC_CR_DIC_Msk = 0x100
	// Bit DIC.
	DDRSDRC_CR_DIC = 0x100
	// Position of DIS_DLL field.
	DDRSDRC_CR_DIS_DLL_Pos = 0x9
	// Bit mask of DIS_DLL field.
	DDRSDRC_CR_DIS_DLL_Msk = 0x200
	// Bit DIS_DLL.
	DDRSDRC_CR_DIS_DLL = 0x200
	// Position of OCD field.
	DDRSDRC_CR_OCD_Pos = 0xc
	// Bit mask of OCD field.
	DDRSDRC_CR_OCD_Msk = 0x7000
	// Position of EBISHARE field.
	DDRSDRC_CR_EBISHARE_Pos = 0x10
	// Bit mask of EBISHARE field.
	DDRSDRC_CR_EBISHARE_Msk = 0x10000
	// Bit EBISHARE.
	DDRSDRC_CR_EBISHARE = 0x10000
	// Position of ACTBST field.
	DDRSDRC_CR_ACTBST_Pos = 0x12
	// Bit mask of ACTBST field.
	DDRSDRC_CR_ACTBST_Msk = 0x40000
	// Bit ACTBST.
	DDRSDRC_CR_ACTBST = 0x40000

	// TPR0: DDRSDRC Timing Parameter 0 Register
	// Position of TRAS field.
	DDRSDRC_TPR0_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	DDRSDRC_TPR0_TRAS_Msk = 0xf
	// Position of TRCD field.
	DDRSDRC_TPR0_TRCD_Pos = 0x4
	// Bit mask of TRCD field.
	DDRSDRC_TPR0_TRCD_Msk = 0xf0
	// Position of TWR field.
	DDRSDRC_TPR0_TWR_Pos = 0x8
	// Bit mask of TWR field.
	DDRSDRC_TPR0_TWR_Msk = 0xf00
	// Position of TRC field.
	DDRSDRC_TPR0_TRC_Pos = 0xc
	// Bit mask of TRC field.
	DDRSDRC_TPR0_TRC_Msk = 0xf000
	// Position of TRP field.
	DDRSDRC_TPR0_TRP_Pos = 0x10
	// Bit mask of TRP field.
	DDRSDRC_TPR0_TRP_Msk = 0xf0000
	// Position of TRRD field.
	DDRSDRC_TPR0_TRRD_Pos = 0x14
	// Bit mask of TRRD field.
	DDRSDRC_TPR0_TRRD_Msk = 0xf00000
	// Position of TWTR field.
	DDRSDRC_TPR0_TWTR_Pos = 0x18
	// Bit mask of TWTR field.
	DDRSDRC_TPR0_TWTR_Msk = 0x7000000
	// Position of REDUCE_WRRD field.
	DDRSDRC_TPR0_REDUCE_WRRD_Pos = 0x1b
	// Bit mask of REDUCE_WRRD field.
	DDRSDRC_TPR0_REDUCE_WRRD_Msk = 0x8000000
	// Bit REDUCE_WRRD.
	DDRSDRC_TPR0_REDUCE_WRRD = 0x8000000
	// Position of TMRD field.
	DDRSDRC_TPR0_TMRD_Pos = 0x1c
	// Bit mask of TMRD field.
	DDRSDRC_TPR0_TMRD_Msk = 0xf0000000

	// TPR1: DDRSDRC Timing Parameter 1 Register
	// Position of TRFC field.
	DDRSDRC_TPR1_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	DDRSDRC_TPR1_TRFC_Msk = 0x1f
	// Position of TXSNR field.
	DDRSDRC_TPR1_TXSNR_Pos = 0x8
	// Bit mask of TXSNR field.
	DDRSDRC_TPR1_TXSNR_Msk = 0xff00
	// Position of TXSRD field.
	DDRSDRC_TPR1_TXSRD_Pos = 0x10
	// Bit mask of TXSRD field.
	DDRSDRC_TPR1_TXSRD_Msk = 0xff0000
	// Position of TXP field.
	DDRSDRC_TPR1_TXP_Pos = 0x18
	// Bit mask of TXP field.
	DDRSDRC_TPR1_TXP_Msk = 0xf000000

	// TPR2: DDRSDRC Timing Parameter 2 Register
	// Position of TXARD field.
	DDRSDRC_TPR2_TXARD_Pos = 0x0
	// Bit mask of TXARD field.
	DDRSDRC_TPR2_TXARD_Msk = 0xf
	// Position of TXARDS field.
	DDRSDRC_TPR2_TXARDS_Pos = 0x4
	// Bit mask of TXARDS field.
	DDRSDRC_TPR2_TXARDS_Msk = 0xf0
	// Position of TRPA field.
	DDRSDRC_TPR2_TRPA_Pos = 0x8
	// Bit mask of TRPA field.
	DDRSDRC_TPR2_TRPA_Msk = 0xf00
	// Position of TRTP field.
	DDRSDRC_TPR2_TRTP_Pos = 0xc
	// Bit mask of TRTP field.
	DDRSDRC_TPR2_TRTP_Msk = 0x7000

	// LPR: DDRSDRC Low-power Register
	// Position of LPCB field.
	DDRSDRC_LPR_LPCB_Pos = 0x0
	// Bit mask of LPCB field.
	DDRSDRC_LPR_LPCB_Msk = 0x3
	// Position of CLK_FR field.
	DDRSDRC_LPR_CLK_FR_Pos = 0x2
	// Bit mask of CLK_FR field.
	DDRSDRC_LPR_CLK_FR_Msk = 0x4
	// Bit CLK_FR.
	DDRSDRC_LPR_CLK_FR = 0x4
	// Position of PASR field.
	DDRSDRC_LPR_PASR_Pos = 0x4
	// Bit mask of PASR field.
	DDRSDRC_LPR_PASR_Msk = 0x70
	// Position of TCR field.
	DDRSDRC_LPR_TCR_Pos = 0x8
	// Bit mask of TCR field.
	DDRSDRC_LPR_TCR_Msk = 0x300
	// Position of DS field.
	DDRSDRC_LPR_DS_Pos = 0xa
	// Bit mask of DS field.
	DDRSDRC_LPR_DS_Msk = 0xc00
	// Position of TIMEOUT field.
	DDRSDRC_LPR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	DDRSDRC_LPR_TIMEOUT_Msk = 0x3000
	// Position of APDE field.
	DDRSDRC_LPR_APDE_Pos = 0x10
	// Bit mask of APDE field.
	DDRSDRC_LPR_APDE_Msk = 0x10000
	// Bit APDE.
	DDRSDRC_LPR_APDE = 0x10000
	// Position of UPD_MR field.
	DDRSDRC_LPR_UPD_MR_Pos = 0x14
	// Bit mask of UPD_MR field.
	DDRSDRC_LPR_UPD_MR_Msk = 0x300000

	// MD: DDRSDRC Memory Device Register
	// Position of MD field.
	DDRSDRC_MD_MD_Pos = 0x0
	// Bit mask of MD field.
	DDRSDRC_MD_MD_Msk = 0x7
	// Position of DBW field.
	DDRSDRC_MD_DBW_Pos = 0x4
	// Bit mask of DBW field.
	DDRSDRC_MD_DBW_Msk = 0x10
	// Bit DBW.
	DDRSDRC_MD_DBW = 0x10

	// DLL: DDRSDRC DLL Information Register
	// Position of MDINC field.
	DDRSDRC_DLL_MDINC_Pos = 0x0
	// Bit mask of MDINC field.
	DDRSDRC_DLL_MDINC_Msk = 0x1
	// Bit MDINC.
	DDRSDRC_DLL_MDINC = 0x1
	// Position of MDDEC field.
	DDRSDRC_DLL_MDDEC_Pos = 0x1
	// Bit mask of MDDEC field.
	DDRSDRC_DLL_MDDEC_Msk = 0x2
	// Bit MDDEC.
	DDRSDRC_DLL_MDDEC = 0x2
	// Position of MDOVF field.
	DDRSDRC_DLL_MDOVF_Pos = 0x2
	// Bit mask of MDOVF field.
	DDRSDRC_DLL_MDOVF_Msk = 0x4
	// Bit MDOVF.
	DDRSDRC_DLL_MDOVF = 0x4
	// Position of MDVAL field.
	DDRSDRC_DLL_MDVAL_Pos = 0x8
	// Bit mask of MDVAL field.
	DDRSDRC_DLL_MDVAL_Msk = 0xff00

	// HS: DDRSDRC High Speed Register
	// Position of DIS_ANTICIP_READ field.
	DDRSDRC_HS_DIS_ANTICIP_READ_Pos = 0x2
	// Bit mask of DIS_ANTICIP_READ field.
	DDRSDRC_HS_DIS_ANTICIP_READ_Msk = 0x4
	// Bit DIS_ANTICIP_READ.
	DDRSDRC_HS_DIS_ANTICIP_READ = 0x4

	// DELAY: DDRSDRC Delay I/O Register
	// Position of DELAY1 field.
	DDRSDRC_DELAY_DELAY1_Pos = 0x0
	// Bit mask of DELAY1 field.
	DDRSDRC_DELAY_DELAY1_Msk = 0xf
	// Position of DELAY2 field.
	DDRSDRC_DELAY_DELAY2_Pos = 0x4
	// Bit mask of DELAY2 field.
	DDRSDRC_DELAY_DELAY2_Msk = 0xf0
	// Position of DELAY3 field.
	DDRSDRC_DELAY_DELAY3_Pos = 0x8
	// Bit mask of DELAY3 field.
	DDRSDRC_DELAY_DELAY3_Msk = 0xf00
	// Position of DELAY4 field.
	DDRSDRC_DELAY_DELAY4_Pos = 0xc
	// Bit mask of DELAY4 field.
	DDRSDRC_DELAY_DELAY4_Msk = 0xf000
	// Position of DELAY5 field.
	DDRSDRC_DELAY_DELAY5_Pos = 0x10
	// Bit mask of DELAY5 field.
	DDRSDRC_DELAY_DELAY5_Msk = 0xf0000
	// Position of DELAY6 field.
	DDRSDRC_DELAY_DELAY6_Pos = 0x14
	// Bit mask of DELAY6 field.
	DDRSDRC_DELAY_DELAY6_Msk = 0xf00000
	// Position of DELAY7 field.
	DDRSDRC_DELAY_DELAY7_Pos = 0x18
	// Bit mask of DELAY7 field.
	DDRSDRC_DELAY_DELAY7_Msk = 0xf000000
	// Position of DELAY8 field.
	DDRSDRC_DELAY_DELAY8_Pos = 0x1c
	// Bit mask of DELAY8 field.
	DDRSDRC_DELAY_DELAY8_Msk = 0xf0000000

	// WPMR: DDRSDRC Write Protect Mode Register
	// Position of WPEN field.
	DDRSDRC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	DDRSDRC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	DDRSDRC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	DDRSDRC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	DDRSDRC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: DDRSDRC Write Protect Status Register
	// Position of WPVS field.
	DDRSDRC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	DDRSDRC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	DDRSDRC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	DDRSDRC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	DDRSDRC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MATRIX: AHB Bus Matrix
const (
	// MCFG: Master Configuration Register
	// Position of ULBT field.
	MATRIX_MCFG_ULBT_Pos = 0x0
	// Bit mask of ULBT field.
	MATRIX_MCFG_ULBT_Msk = 0x7

	// SCFG: Slave Configuration Register
	// Position of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Pos = 0x0
	// Bit mask of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Msk = 0x1ff
	// Position of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Pos = 0x10
	// Bit mask of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Msk = 0x30000
	// Position of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Pos = 0x12
	// Bit mask of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Msk = 0x3c0000

	// PRAS0: Priority Register A for Slave 0
	// Position of M0PR field.
	MATRIX_PRAS0_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS0_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS0_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS0_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS0_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS0_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS0_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS0_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS0_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS0_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS0_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS0_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS0_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS0_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS0_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS0_M7PR_Msk = 0x30000000

	// PRBS0: Priority Register B for Slave 0
	// Position of M8PR field.
	MATRIX_PRBS0_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS0_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS0_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS0_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS0_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS0_M10PR_Msk = 0x300

	// PRAS1: Priority Register A for Slave 1
	// Position of M0PR field.
	MATRIX_PRAS1_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS1_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS1_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS1_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS1_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS1_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS1_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS1_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS1_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS1_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS1_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS1_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS1_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS1_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS1_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS1_M7PR_Msk = 0x30000000

	// PRBS1: Priority Register B for Slave 1
	// Position of M8PR field.
	MATRIX_PRBS1_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS1_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS1_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS1_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS1_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS1_M10PR_Msk = 0x300

	// PRAS2: Priority Register A for Slave 2
	// Position of M0PR field.
	MATRIX_PRAS2_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS2_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS2_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS2_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS2_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS2_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS2_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS2_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS2_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS2_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS2_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS2_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS2_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS2_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS2_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS2_M7PR_Msk = 0x30000000

	// PRBS2: Priority Register B for Slave 2
	// Position of M8PR field.
	MATRIX_PRBS2_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS2_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS2_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS2_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS2_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS2_M10PR_Msk = 0x300

	// PRAS3: Priority Register A for Slave 3
	// Position of M0PR field.
	MATRIX_PRAS3_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS3_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS3_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS3_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS3_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS3_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS3_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS3_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS3_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS3_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS3_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS3_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS3_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS3_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS3_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS3_M7PR_Msk = 0x30000000

	// PRBS3: Priority Register B for Slave 3
	// Position of M8PR field.
	MATRIX_PRBS3_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS3_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS3_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS3_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS3_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS3_M10PR_Msk = 0x300

	// PRAS4: Priority Register A for Slave 4
	// Position of M0PR field.
	MATRIX_PRAS4_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS4_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS4_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS4_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS4_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS4_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS4_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS4_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS4_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS4_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS4_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS4_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS4_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS4_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS4_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS4_M7PR_Msk = 0x30000000

	// PRBS4: Priority Register B for Slave 4
	// Position of M8PR field.
	MATRIX_PRBS4_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS4_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS4_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS4_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS4_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS4_M10PR_Msk = 0x300

	// PRAS5: Priority Register A for Slave 5
	// Position of M0PR field.
	MATRIX_PRAS5_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS5_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS5_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS5_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS5_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS5_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS5_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS5_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS5_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS5_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS5_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS5_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS5_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS5_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS5_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS5_M7PR_Msk = 0x30000000

	// PRBS5: Priority Register B for Slave 5
	// Position of M8PR field.
	MATRIX_PRBS5_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS5_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS5_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS5_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS5_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS5_M10PR_Msk = 0x300

	// PRAS6: Priority Register A for Slave 6
	// Position of M0PR field.
	MATRIX_PRAS6_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS6_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS6_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS6_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS6_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS6_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS6_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS6_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS6_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS6_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS6_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS6_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS6_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS6_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS6_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS6_M7PR_Msk = 0x30000000

	// PRBS6: Priority Register B for Slave 6
	// Position of M8PR field.
	MATRIX_PRBS6_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS6_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS6_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS6_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS6_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS6_M10PR_Msk = 0x300

	// PRAS7: Priority Register A for Slave 7
	// Position of M0PR field.
	MATRIX_PRAS7_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS7_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS7_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS7_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS7_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS7_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS7_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS7_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS7_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS7_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS7_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS7_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS7_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS7_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS7_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS7_M7PR_Msk = 0x30000000

	// PRBS7: Priority Register B for Slave 7
	// Position of M8PR field.
	MATRIX_PRBS7_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS7_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS7_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS7_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS7_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS7_M10PR_Msk = 0x300

	// MRCR: Master Remap Control Register
	// Position of RCB0 field.
	MATRIX_MRCR_RCB0_Pos = 0x0
	// Bit mask of RCB0 field.
	MATRIX_MRCR_RCB0_Msk = 0x1
	// Bit RCB0.
	MATRIX_MRCR_RCB0 = 0x1
	// Position of RCB1 field.
	MATRIX_MRCR_RCB1_Pos = 0x1
	// Bit mask of RCB1 field.
	MATRIX_MRCR_RCB1_Msk = 0x2
	// Bit RCB1.
	MATRIX_MRCR_RCB1 = 0x2
	// Position of RCB2 field.
	MATRIX_MRCR_RCB2_Pos = 0x2
	// Bit mask of RCB2 field.
	MATRIX_MRCR_RCB2_Msk = 0x4
	// Bit RCB2.
	MATRIX_MRCR_RCB2 = 0x4
	// Position of RCB3 field.
	MATRIX_MRCR_RCB3_Pos = 0x3
	// Bit mask of RCB3 field.
	MATRIX_MRCR_RCB3_Msk = 0x8
	// Bit RCB3.
	MATRIX_MRCR_RCB3 = 0x8
	// Position of RCB4 field.
	MATRIX_MRCR_RCB4_Pos = 0x4
	// Bit mask of RCB4 field.
	MATRIX_MRCR_RCB4_Msk = 0x10
	// Bit RCB4.
	MATRIX_MRCR_RCB4 = 0x10
	// Position of RCB5 field.
	MATRIX_MRCR_RCB5_Pos = 0x5
	// Bit mask of RCB5 field.
	MATRIX_MRCR_RCB5_Msk = 0x20
	// Bit RCB5.
	MATRIX_MRCR_RCB5 = 0x20
	// Position of RCB6 field.
	MATRIX_MRCR_RCB6_Pos = 0x6
	// Bit mask of RCB6 field.
	MATRIX_MRCR_RCB6_Msk = 0x40
	// Bit RCB6.
	MATRIX_MRCR_RCB6 = 0x40
	// Position of RCB7 field.
	MATRIX_MRCR_RCB7_Pos = 0x7
	// Bit mask of RCB7 field.
	MATRIX_MRCR_RCB7_Msk = 0x80
	// Bit RCB7.
	MATRIX_MRCR_RCB7 = 0x80
	// Position of RCB8 field.
	MATRIX_MRCR_RCB8_Pos = 0x8
	// Bit mask of RCB8 field.
	MATRIX_MRCR_RCB8_Msk = 0x100
	// Bit RCB8.
	MATRIX_MRCR_RCB8 = 0x100
	// Position of RCB9 field.
	MATRIX_MRCR_RCB9_Pos = 0x9
	// Bit mask of RCB9 field.
	MATRIX_MRCR_RCB9_Msk = 0x200
	// Bit RCB9.
	MATRIX_MRCR_RCB9 = 0x200
	// Position of RCB10 field.
	MATRIX_MRCR_RCB10_Pos = 0xa
	// Bit mask of RCB10 field.
	MATRIX_MRCR_RCB10_Msk = 0x400
	// Bit RCB10.
	MATRIX_MRCR_RCB10 = 0x400

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	MATRIX_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	MATRIX_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	MATRIX_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	MATRIX_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	MATRIX_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	MATRIX_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	MATRIX_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	MATRIX_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for DMAC: DMA Controller
const (
	// GCFG: DMAC Global Configuration Register
	// Position of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Pos = 0x4
	// Bit mask of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Msk = 0x10
	// Bit ARB_CFG.
	DMAC_GCFG_ARB_CFG = 0x10

	// EN: DMAC Enable Register
	// Position of ENABLE field.
	DMAC_EN_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DMAC_EN_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DMAC_EN_ENABLE = 0x1

	// SREQ: DMAC Software Single Request Register
	// Position of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Pos = 0x0
	// Bit mask of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Msk = 0x1
	// Bit SSREQ0.
	DMAC_SREQ_SSREQ0 = 0x1
	// Position of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Pos = 0x1
	// Bit mask of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Msk = 0x2
	// Bit DSREQ0.
	DMAC_SREQ_DSREQ0 = 0x2
	// Position of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Pos = 0x2
	// Bit mask of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Msk = 0x4
	// Bit SSREQ1.
	DMAC_SREQ_SSREQ1 = 0x4
	// Position of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Pos = 0x3
	// Bit mask of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Msk = 0x8
	// Bit DSREQ1.
	DMAC_SREQ_DSREQ1 = 0x8
	// Position of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Pos = 0x4
	// Bit mask of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Msk = 0x10
	// Bit SSREQ2.
	DMAC_SREQ_SSREQ2 = 0x10
	// Position of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Pos = 0x5
	// Bit mask of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Msk = 0x20
	// Bit DSREQ2.
	DMAC_SREQ_DSREQ2 = 0x20
	// Position of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Pos = 0x6
	// Bit mask of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Msk = 0x40
	// Bit SSREQ3.
	DMAC_SREQ_SSREQ3 = 0x40
	// Position of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Pos = 0x7
	// Bit mask of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Msk = 0x80
	// Bit DSREQ3.
	DMAC_SREQ_DSREQ3 = 0x80
	// Position of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Pos = 0x8
	// Bit mask of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Msk = 0x100
	// Bit SSREQ4.
	DMAC_SREQ_SSREQ4 = 0x100
	// Position of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Pos = 0x9
	// Bit mask of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Msk = 0x200
	// Bit DSREQ4.
	DMAC_SREQ_DSREQ4 = 0x200
	// Position of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Pos = 0xa
	// Bit mask of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Msk = 0x400
	// Bit SSREQ5.
	DMAC_SREQ_SSREQ5 = 0x400
	// Position of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Pos = 0xb
	// Bit mask of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Msk = 0x800
	// Bit DSREQ5.
	DMAC_SREQ_DSREQ5 = 0x800
	// Position of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Pos = 0xc
	// Bit mask of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Msk = 0x1000
	// Bit SSREQ6.
	DMAC_SREQ_SSREQ6 = 0x1000
	// Position of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Pos = 0xd
	// Bit mask of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Msk = 0x2000
	// Bit DSREQ6.
	DMAC_SREQ_DSREQ6 = 0x2000
	// Position of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Pos = 0xe
	// Bit mask of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Msk = 0x4000
	// Bit SSREQ7.
	DMAC_SREQ_SSREQ7 = 0x4000
	// Position of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Pos = 0xf
	// Bit mask of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Msk = 0x8000
	// Bit DSREQ7.
	DMAC_SREQ_DSREQ7 = 0x8000

	// CREQ: DMAC Software Chunk Transfer Request Register
	// Position of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Pos = 0x0
	// Bit mask of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Msk = 0x1
	// Bit SCREQ0.
	DMAC_CREQ_SCREQ0 = 0x1
	// Position of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Pos = 0x1
	// Bit mask of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Msk = 0x2
	// Bit DCREQ0.
	DMAC_CREQ_DCREQ0 = 0x2
	// Position of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Pos = 0x2
	// Bit mask of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Msk = 0x4
	// Bit SCREQ1.
	DMAC_CREQ_SCREQ1 = 0x4
	// Position of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Pos = 0x3
	// Bit mask of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Msk = 0x8
	// Bit DCREQ1.
	DMAC_CREQ_DCREQ1 = 0x8
	// Position of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Pos = 0x4
	// Bit mask of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Msk = 0x10
	// Bit SCREQ2.
	DMAC_CREQ_SCREQ2 = 0x10
	// Position of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Pos = 0x5
	// Bit mask of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Msk = 0x20
	// Bit DCREQ2.
	DMAC_CREQ_DCREQ2 = 0x20
	// Position of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Pos = 0x6
	// Bit mask of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Msk = 0x40
	// Bit SCREQ3.
	DMAC_CREQ_SCREQ3 = 0x40
	// Position of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Pos = 0x7
	// Bit mask of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Msk = 0x80
	// Bit DCREQ3.
	DMAC_CREQ_DCREQ3 = 0x80
	// Position of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Pos = 0x8
	// Bit mask of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Msk = 0x100
	// Bit SCREQ4.
	DMAC_CREQ_SCREQ4 = 0x100
	// Position of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Pos = 0x9
	// Bit mask of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Msk = 0x200
	// Bit DCREQ4.
	DMAC_CREQ_DCREQ4 = 0x200
	// Position of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Pos = 0xa
	// Bit mask of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Msk = 0x400
	// Bit SCREQ5.
	DMAC_CREQ_SCREQ5 = 0x400
	// Position of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Pos = 0xb
	// Bit mask of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Msk = 0x800
	// Bit DCREQ5.
	DMAC_CREQ_DCREQ5 = 0x800
	// Position of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Pos = 0xc
	// Bit mask of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Msk = 0x1000
	// Bit SCREQ6.
	DMAC_CREQ_SCREQ6 = 0x1000
	// Position of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Pos = 0xd
	// Bit mask of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Msk = 0x2000
	// Bit DCREQ6.
	DMAC_CREQ_DCREQ6 = 0x2000
	// Position of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Pos = 0xe
	// Bit mask of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Msk = 0x4000
	// Bit SCREQ7.
	DMAC_CREQ_SCREQ7 = 0x4000
	// Position of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Pos = 0xf
	// Bit mask of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Msk = 0x8000
	// Bit DCREQ7.
	DMAC_CREQ_DCREQ7 = 0x8000

	// LAST: DMAC Software Last Transfer Flag Register
	// Position of SLAST0 field.
	DMAC_LAST_SLAST0_Pos = 0x0
	// Bit mask of SLAST0 field.
	DMAC_LAST_SLAST0_Msk = 0x1
	// Bit SLAST0.
	DMAC_LAST_SLAST0 = 0x1
	// Position of DLAST0 field.
	DMAC_LAST_DLAST0_Pos = 0x1
	// Bit mask of DLAST0 field.
	DMAC_LAST_DLAST0_Msk = 0x2
	// Bit DLAST0.
	DMAC_LAST_DLAST0 = 0x2
	// Position of SLAST1 field.
	DMAC_LAST_SLAST1_Pos = 0x2
	// Bit mask of SLAST1 field.
	DMAC_LAST_SLAST1_Msk = 0x4
	// Bit SLAST1.
	DMAC_LAST_SLAST1 = 0x4
	// Position of DLAST1 field.
	DMAC_LAST_DLAST1_Pos = 0x3
	// Bit mask of DLAST1 field.
	DMAC_LAST_DLAST1_Msk = 0x8
	// Bit DLAST1.
	DMAC_LAST_DLAST1 = 0x8
	// Position of SLAST2 field.
	DMAC_LAST_SLAST2_Pos = 0x4
	// Bit mask of SLAST2 field.
	DMAC_LAST_SLAST2_Msk = 0x10
	// Bit SLAST2.
	DMAC_LAST_SLAST2 = 0x10
	// Position of DLAST2 field.
	DMAC_LAST_DLAST2_Pos = 0x5
	// Bit mask of DLAST2 field.
	DMAC_LAST_DLAST2_Msk = 0x20
	// Bit DLAST2.
	DMAC_LAST_DLAST2 = 0x20
	// Position of SLAST3 field.
	DMAC_LAST_SLAST3_Pos = 0x6
	// Bit mask of SLAST3 field.
	DMAC_LAST_SLAST3_Msk = 0x40
	// Bit SLAST3.
	DMAC_LAST_SLAST3 = 0x40
	// Position of DLAST3 field.
	DMAC_LAST_DLAST3_Pos = 0x7
	// Bit mask of DLAST3 field.
	DMAC_LAST_DLAST3_Msk = 0x80
	// Bit DLAST3.
	DMAC_LAST_DLAST3 = 0x80
	// Position of SLAST4 field.
	DMAC_LAST_SLAST4_Pos = 0x8
	// Bit mask of SLAST4 field.
	DMAC_LAST_SLAST4_Msk = 0x100
	// Bit SLAST4.
	DMAC_LAST_SLAST4 = 0x100
	// Position of DLAST4 field.
	DMAC_LAST_DLAST4_Pos = 0x9
	// Bit mask of DLAST4 field.
	DMAC_LAST_DLAST4_Msk = 0x200
	// Bit DLAST4.
	DMAC_LAST_DLAST4 = 0x200
	// Position of SLAST5 field.
	DMAC_LAST_SLAST5_Pos = 0xa
	// Bit mask of SLAST5 field.
	DMAC_LAST_SLAST5_Msk = 0x400
	// Bit SLAST5.
	DMAC_LAST_SLAST5 = 0x400
	// Position of DLAST5 field.
	DMAC_LAST_DLAST5_Pos = 0xb
	// Bit mask of DLAST5 field.
	DMAC_LAST_DLAST5_Msk = 0x800
	// Bit DLAST5.
	DMAC_LAST_DLAST5 = 0x800
	// Position of SLAST6 field.
	DMAC_LAST_SLAST6_Pos = 0xc
	// Bit mask of SLAST6 field.
	DMAC_LAST_SLAST6_Msk = 0x1000
	// Bit SLAST6.
	DMAC_LAST_SLAST6 = 0x1000
	// Position of DLAST6 field.
	DMAC_LAST_DLAST6_Pos = 0xd
	// Bit mask of DLAST6 field.
	DMAC_LAST_DLAST6_Msk = 0x2000
	// Bit DLAST6.
	DMAC_LAST_DLAST6 = 0x2000
	// Position of SLAST7 field.
	DMAC_LAST_SLAST7_Pos = 0xe
	// Bit mask of SLAST7 field.
	DMAC_LAST_SLAST7_Msk = 0x4000
	// Bit SLAST7.
	DMAC_LAST_SLAST7 = 0x4000
	// Position of DLAST7 field.
	DMAC_LAST_DLAST7_Pos = 0xf
	// Bit mask of DLAST7 field.
	DMAC_LAST_DLAST7_Msk = 0x8000
	// Bit DLAST7.
	DMAC_LAST_DLAST7 = 0x8000

	// EBCIER: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Enable register.
	// Position of BTC0 field.
	DMAC_EBCIER_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIER_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIER_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIER_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIER_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIER_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIER_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIER_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIER_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIER_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIER_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIER_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIER_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIER_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIER_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIER_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIER_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIER_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIER_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIER_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIER_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIER_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIER_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIER_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIER_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIER_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIER_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIER_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIER_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIER_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIER_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIER_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIER_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIER_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIER_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIER_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIER_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIER_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIER_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIER_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIER_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIER_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIER_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIER_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIER_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIER_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIER_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIER_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIER_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIER_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIER_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIER_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIER_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIER_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIER_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIER_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIER_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIER_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIER_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIER_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIER_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIER_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIER_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIER_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIER_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIER_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIER_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIER_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIER_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIER_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIER_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIER_ERR7 = 0x800000

	// EBCIDR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Disable register.
	// Position of BTC0 field.
	DMAC_EBCIDR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIDR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIDR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIDR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIDR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIDR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIDR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIDR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIDR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIDR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIDR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIDR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIDR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIDR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIDR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIDR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIDR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIDR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIDR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIDR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIDR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIDR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIDR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIDR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIDR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIDR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIDR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIDR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIDR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIDR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIDR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIDR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIDR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIDR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIDR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIDR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIDR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIDR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIDR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIDR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIDR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIDR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIDR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIDR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIDR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIDR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIDR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIDR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIDR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIDR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIDR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIDR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIDR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIDR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIDR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIDR_ERR7 = 0x800000

	// EBCIMR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Mask Register.
	// Position of BTC0 field.
	DMAC_EBCIMR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIMR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIMR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIMR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIMR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIMR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIMR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIMR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIMR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIMR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIMR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIMR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIMR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIMR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIMR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIMR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIMR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIMR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIMR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIMR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIMR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIMR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIMR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIMR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIMR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIMR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIMR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIMR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIMR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIMR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIMR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIMR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIMR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIMR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIMR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIMR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIMR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIMR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIMR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIMR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIMR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIMR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIMR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIMR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIMR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIMR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIMR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIMR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIMR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIMR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIMR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIMR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIMR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIMR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIMR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIMR_ERR7 = 0x800000

	// EBCISR: DMAC Error, Chained Buffer transfer completed and Buffer transfer completed Status Register.
	// Position of BTC0 field.
	DMAC_EBCISR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCISR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCISR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCISR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCISR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCISR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCISR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCISR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCISR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCISR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCISR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCISR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCISR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCISR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCISR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCISR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCISR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCISR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCISR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCISR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCISR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCISR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCISR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCISR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCISR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCISR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCISR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCISR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCISR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCISR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCISR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCISR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCISR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCISR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCISR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCISR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCISR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCISR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCISR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCISR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCISR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCISR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCISR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCISR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCISR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCISR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCISR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCISR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCISR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCISR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCISR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCISR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCISR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCISR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCISR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCISR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCISR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCISR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCISR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCISR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCISR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCISR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCISR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCISR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCISR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCISR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCISR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCISR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCISR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCISR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCISR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCISR_ERR7 = 0x800000

	// CHER: DMAC Channel Handler Enable Register
	// Position of ENA0 field.
	DMAC_CHER_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHER_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHER_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHER_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHER_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHER_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHER_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHER_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHER_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHER_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHER_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHER_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHER_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHER_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHER_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHER_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHER_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHER_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHER_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHER_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHER_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHER_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHER_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHER_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHER_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHER_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHER_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHER_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHER_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHER_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHER_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHER_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHER_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHER_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHER_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHER_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHER_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHER_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHER_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHER_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHER_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHER_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHER_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHER_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHER_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHER_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHER_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHER_SUSP7 = 0x8000
	// Position of KEEP0 field.
	DMAC_CHER_KEEP0_Pos = 0x18
	// Bit mask of KEEP0 field.
	DMAC_CHER_KEEP0_Msk = 0x1000000
	// Bit KEEP0.
	DMAC_CHER_KEEP0 = 0x1000000
	// Position of KEEP1 field.
	DMAC_CHER_KEEP1_Pos = 0x19
	// Bit mask of KEEP1 field.
	DMAC_CHER_KEEP1_Msk = 0x2000000
	// Bit KEEP1.
	DMAC_CHER_KEEP1 = 0x2000000
	// Position of KEEP2 field.
	DMAC_CHER_KEEP2_Pos = 0x1a
	// Bit mask of KEEP2 field.
	DMAC_CHER_KEEP2_Msk = 0x4000000
	// Bit KEEP2.
	DMAC_CHER_KEEP2 = 0x4000000
	// Position of KEEP3 field.
	DMAC_CHER_KEEP3_Pos = 0x1b
	// Bit mask of KEEP3 field.
	DMAC_CHER_KEEP3_Msk = 0x8000000
	// Bit KEEP3.
	DMAC_CHER_KEEP3 = 0x8000000
	// Position of KEEP4 field.
	DMAC_CHER_KEEP4_Pos = 0x1c
	// Bit mask of KEEP4 field.
	DMAC_CHER_KEEP4_Msk = 0x10000000
	// Bit KEEP4.
	DMAC_CHER_KEEP4 = 0x10000000
	// Position of KEEP5 field.
	DMAC_CHER_KEEP5_Pos = 0x1d
	// Bit mask of KEEP5 field.
	DMAC_CHER_KEEP5_Msk = 0x20000000
	// Bit KEEP5.
	DMAC_CHER_KEEP5 = 0x20000000
	// Position of KEEP6 field.
	DMAC_CHER_KEEP6_Pos = 0x1e
	// Bit mask of KEEP6 field.
	DMAC_CHER_KEEP6_Msk = 0x40000000
	// Bit KEEP6.
	DMAC_CHER_KEEP6 = 0x40000000
	// Position of KEEP7 field.
	DMAC_CHER_KEEP7_Pos = 0x1f
	// Bit mask of KEEP7 field.
	DMAC_CHER_KEEP7_Msk = 0x80000000
	// Bit KEEP7.
	DMAC_CHER_KEEP7 = 0x80000000

	// CHDR: DMAC Channel Handler Disable Register
	// Position of DIS0 field.
	DMAC_CHDR_DIS0_Pos = 0x0
	// Bit mask of DIS0 field.
	DMAC_CHDR_DIS0_Msk = 0x1
	// Bit DIS0.
	DMAC_CHDR_DIS0 = 0x1
	// Position of DIS1 field.
	DMAC_CHDR_DIS1_Pos = 0x1
	// Bit mask of DIS1 field.
	DMAC_CHDR_DIS1_Msk = 0x2
	// Bit DIS1.
	DMAC_CHDR_DIS1 = 0x2
	// Position of DIS2 field.
	DMAC_CHDR_DIS2_Pos = 0x2
	// Bit mask of DIS2 field.
	DMAC_CHDR_DIS2_Msk = 0x4
	// Bit DIS2.
	DMAC_CHDR_DIS2 = 0x4
	// Position of DIS3 field.
	DMAC_CHDR_DIS3_Pos = 0x3
	// Bit mask of DIS3 field.
	DMAC_CHDR_DIS3_Msk = 0x8
	// Bit DIS3.
	DMAC_CHDR_DIS3 = 0x8
	// Position of DIS4 field.
	DMAC_CHDR_DIS4_Pos = 0x4
	// Bit mask of DIS4 field.
	DMAC_CHDR_DIS4_Msk = 0x10
	// Bit DIS4.
	DMAC_CHDR_DIS4 = 0x10
	// Position of DIS5 field.
	DMAC_CHDR_DIS5_Pos = 0x5
	// Bit mask of DIS5 field.
	DMAC_CHDR_DIS5_Msk = 0x20
	// Bit DIS5.
	DMAC_CHDR_DIS5 = 0x20
	// Position of DIS6 field.
	DMAC_CHDR_DIS6_Pos = 0x6
	// Bit mask of DIS6 field.
	DMAC_CHDR_DIS6_Msk = 0x40
	// Bit DIS6.
	DMAC_CHDR_DIS6 = 0x40
	// Position of DIS7 field.
	DMAC_CHDR_DIS7_Pos = 0x7
	// Bit mask of DIS7 field.
	DMAC_CHDR_DIS7_Msk = 0x80
	// Bit DIS7.
	DMAC_CHDR_DIS7 = 0x80
	// Position of RES0 field.
	DMAC_CHDR_RES0_Pos = 0x8
	// Bit mask of RES0 field.
	DMAC_CHDR_RES0_Msk = 0x100
	// Bit RES0.
	DMAC_CHDR_RES0 = 0x100
	// Position of RES1 field.
	DMAC_CHDR_RES1_Pos = 0x9
	// Bit mask of RES1 field.
	DMAC_CHDR_RES1_Msk = 0x200
	// Bit RES1.
	DMAC_CHDR_RES1 = 0x200
	// Position of RES2 field.
	DMAC_CHDR_RES2_Pos = 0xa
	// Bit mask of RES2 field.
	DMAC_CHDR_RES2_Msk = 0x400
	// Bit RES2.
	DMAC_CHDR_RES2 = 0x400
	// Position of RES3 field.
	DMAC_CHDR_RES3_Pos = 0xb
	// Bit mask of RES3 field.
	DMAC_CHDR_RES3_Msk = 0x800
	// Bit RES3.
	DMAC_CHDR_RES3 = 0x800
	// Position of RES4 field.
	DMAC_CHDR_RES4_Pos = 0xc
	// Bit mask of RES4 field.
	DMAC_CHDR_RES4_Msk = 0x1000
	// Bit RES4.
	DMAC_CHDR_RES4 = 0x1000
	// Position of RES5 field.
	DMAC_CHDR_RES5_Pos = 0xd
	// Bit mask of RES5 field.
	DMAC_CHDR_RES5_Msk = 0x2000
	// Bit RES5.
	DMAC_CHDR_RES5 = 0x2000
	// Position of RES6 field.
	DMAC_CHDR_RES6_Pos = 0xe
	// Bit mask of RES6 field.
	DMAC_CHDR_RES6_Msk = 0x4000
	// Bit RES6.
	DMAC_CHDR_RES6 = 0x4000
	// Position of RES7 field.
	DMAC_CHDR_RES7_Pos = 0xf
	// Bit mask of RES7 field.
	DMAC_CHDR_RES7_Msk = 0x8000
	// Bit RES7.
	DMAC_CHDR_RES7 = 0x8000

	// CHSR: DMAC Channel Handler Status Register
	// Position of ENA0 field.
	DMAC_CHSR_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHSR_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHSR_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHSR_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHSR_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHSR_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHSR_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHSR_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHSR_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHSR_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHSR_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHSR_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHSR_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHSR_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHSR_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHSR_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHSR_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHSR_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHSR_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHSR_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHSR_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHSR_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHSR_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHSR_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHSR_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHSR_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHSR_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHSR_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHSR_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHSR_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHSR_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHSR_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHSR_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHSR_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHSR_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHSR_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHSR_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHSR_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHSR_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHSR_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHSR_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHSR_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHSR_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHSR_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHSR_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHSR_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHSR_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHSR_SUSP7 = 0x8000
	// Position of EMPT0 field.
	DMAC_CHSR_EMPT0_Pos = 0x10
	// Bit mask of EMPT0 field.
	DMAC_CHSR_EMPT0_Msk = 0x10000
	// Bit EMPT0.
	DMAC_CHSR_EMPT0 = 0x10000
	// Position of EMPT1 field.
	DMAC_CHSR_EMPT1_Pos = 0x11
	// Bit mask of EMPT1 field.
	DMAC_CHSR_EMPT1_Msk = 0x20000
	// Bit EMPT1.
	DMAC_CHSR_EMPT1 = 0x20000
	// Position of EMPT2 field.
	DMAC_CHSR_EMPT2_Pos = 0x12
	// Bit mask of EMPT2 field.
	DMAC_CHSR_EMPT2_Msk = 0x40000
	// Bit EMPT2.
	DMAC_CHSR_EMPT2 = 0x40000
	// Position of EMPT3 field.
	DMAC_CHSR_EMPT3_Pos = 0x13
	// Bit mask of EMPT3 field.
	DMAC_CHSR_EMPT3_Msk = 0x80000
	// Bit EMPT3.
	DMAC_CHSR_EMPT3 = 0x80000
	// Position of EMPT4 field.
	DMAC_CHSR_EMPT4_Pos = 0x14
	// Bit mask of EMPT4 field.
	DMAC_CHSR_EMPT4_Msk = 0x100000
	// Bit EMPT4.
	DMAC_CHSR_EMPT4 = 0x100000
	// Position of EMPT5 field.
	DMAC_CHSR_EMPT5_Pos = 0x15
	// Bit mask of EMPT5 field.
	DMAC_CHSR_EMPT5_Msk = 0x200000
	// Bit EMPT5.
	DMAC_CHSR_EMPT5 = 0x200000
	// Position of EMPT6 field.
	DMAC_CHSR_EMPT6_Pos = 0x16
	// Bit mask of EMPT6 field.
	DMAC_CHSR_EMPT6_Msk = 0x400000
	// Bit EMPT6.
	DMAC_CHSR_EMPT6 = 0x400000
	// Position of EMPT7 field.
	DMAC_CHSR_EMPT7_Pos = 0x17
	// Bit mask of EMPT7 field.
	DMAC_CHSR_EMPT7_Msk = 0x800000
	// Bit EMPT7.
	DMAC_CHSR_EMPT7 = 0x800000
	// Position of STAL0 field.
	DMAC_CHSR_STAL0_Pos = 0x18
	// Bit mask of STAL0 field.
	DMAC_CHSR_STAL0_Msk = 0x1000000
	// Bit STAL0.
	DMAC_CHSR_STAL0 = 0x1000000
	// Position of STAL1 field.
	DMAC_CHSR_STAL1_Pos = 0x19
	// Bit mask of STAL1 field.
	DMAC_CHSR_STAL1_Msk = 0x2000000
	// Bit STAL1.
	DMAC_CHSR_STAL1 = 0x2000000
	// Position of STAL2 field.
	DMAC_CHSR_STAL2_Pos = 0x1a
	// Bit mask of STAL2 field.
	DMAC_CHSR_STAL2_Msk = 0x4000000
	// Bit STAL2.
	DMAC_CHSR_STAL2 = 0x4000000
	// Position of STAL3 field.
	DMAC_CHSR_STAL3_Pos = 0x1b
	// Bit mask of STAL3 field.
	DMAC_CHSR_STAL3_Msk = 0x8000000
	// Bit STAL3.
	DMAC_CHSR_STAL3 = 0x8000000
	// Position of STAL4 field.
	DMAC_CHSR_STAL4_Pos = 0x1c
	// Bit mask of STAL4 field.
	DMAC_CHSR_STAL4_Msk = 0x10000000
	// Bit STAL4.
	DMAC_CHSR_STAL4 = 0x10000000
	// Position of STAL5 field.
	DMAC_CHSR_STAL5_Pos = 0x1d
	// Bit mask of STAL5 field.
	DMAC_CHSR_STAL5_Msk = 0x20000000
	// Bit STAL5.
	DMAC_CHSR_STAL5 = 0x20000000
	// Position of STAL6 field.
	DMAC_CHSR_STAL6_Pos = 0x1e
	// Bit mask of STAL6 field.
	DMAC_CHSR_STAL6_Msk = 0x40000000
	// Bit STAL6.
	DMAC_CHSR_STAL6 = 0x40000000
	// Position of STAL7 field.
	DMAC_CHSR_STAL7_Pos = 0x1f
	// Bit mask of STAL7 field.
	DMAC_CHSR_STAL7_Msk = 0x80000000
	// Bit STAL7.
	DMAC_CHSR_STAL7 = 0x80000000

	// SADDR0: DMAC Channel Source Address Register (ch_num = 0)
	// Position of SADDR field.
	DMAC_SADDR0_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR0_SADDR_Msk = 0xffffffff

	// DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
	// Position of DADDR field.
	DMAC_DADDR0_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR0_DADDR_Msk = 0xffffffff

	// DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
	// Position of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR0_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR0_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR0_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR0_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR0_DSCR_Msk = 0xfffffffc

	// CTRLA0: DMAC Channel Control A Register (ch_num = 0)
	// Position of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA0_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA0_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA0_DONE = 0x80000000

	// CTRLB0: DMAC Channel Control B Register (ch_num = 0)
	// Position of SIF field.
	DMAC_CTRLB0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB0_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB0_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB0_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB0_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB0_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB0_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB0_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB0_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB0_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB0_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB0_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB0_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB0_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB0_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB0_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB0_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB0_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB0_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB0_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB0_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB0_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB0_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB0_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB0_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB0_AUTO = 0x80000000

	// CFG0: DMAC Channel Configuration Register (ch_num = 0)
	// Position of SRC_PER field.
	DMAC_CFG0_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG0_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG0_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG0_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG0_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG0_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG0_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG0_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG0_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG0_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG0_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG0_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG0_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG0_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG0_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG0_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG0_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG0_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG0_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG0_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG0_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG0_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG0_FIFOCFG_ASAP_CFG = 0x2

	// SADDR1: DMAC Channel Source Address Register (ch_num = 1)
	// Position of SADDR field.
	DMAC_SADDR1_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR1_SADDR_Msk = 0xffffffff

	// DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
	// Position of DADDR field.
	DMAC_DADDR1_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR1_DADDR_Msk = 0xffffffff

	// DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
	// Position of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR1_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR1_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR1_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR1_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR1_DSCR_Msk = 0xfffffffc

	// CTRLA1: DMAC Channel Control A Register (ch_num = 1)
	// Position of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA1_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA1_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA1_DONE = 0x80000000

	// CTRLB1: DMAC Channel Control B Register (ch_num = 1)
	// Position of SIF field.
	DMAC_CTRLB1_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB1_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB1_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB1_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB1_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB1_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB1_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB1_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB1_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB1_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB1_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB1_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB1_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB1_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB1_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB1_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB1_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB1_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB1_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB1_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB1_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB1_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB1_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB1_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB1_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB1_AUTO = 0x80000000

	// CFG1: DMAC Channel Configuration Register (ch_num = 1)
	// Position of SRC_PER field.
	DMAC_CFG1_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG1_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG1_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG1_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG1_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG1_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG1_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG1_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG1_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG1_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG1_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG1_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG1_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG1_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG1_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG1_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG1_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG1_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG1_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG1_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG1_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG1_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG1_FIFOCFG_ASAP_CFG = 0x2

	// SADDR2: DMAC Channel Source Address Register (ch_num = 2)
	// Position of SADDR field.
	DMAC_SADDR2_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR2_SADDR_Msk = 0xffffffff

	// DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
	// Position of DADDR field.
	DMAC_DADDR2_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR2_DADDR_Msk = 0xffffffff

	// DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
	// Position of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR2_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR2_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR2_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR2_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR2_DSCR_Msk = 0xfffffffc

	// CTRLA2: DMAC Channel Control A Register (ch_num = 2)
	// Position of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA2_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA2_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA2_DONE = 0x80000000

	// CTRLB2: DMAC Channel Control B Register (ch_num = 2)
	// Position of SIF field.
	DMAC_CTRLB2_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB2_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB2_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB2_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB2_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB2_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB2_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB2_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB2_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB2_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB2_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB2_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB2_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB2_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB2_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB2_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB2_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB2_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB2_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB2_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB2_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB2_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB2_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB2_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB2_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB2_AUTO = 0x80000000

	// CFG2: DMAC Channel Configuration Register (ch_num = 2)
	// Position of SRC_PER field.
	DMAC_CFG2_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG2_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG2_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG2_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG2_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG2_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG2_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG2_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG2_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG2_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG2_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG2_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG2_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG2_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG2_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG2_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG2_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG2_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG2_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG2_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG2_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG2_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG2_FIFOCFG_ASAP_CFG = 0x2

	// SADDR3: DMAC Channel Source Address Register (ch_num = 3)
	// Position of SADDR field.
	DMAC_SADDR3_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR3_SADDR_Msk = 0xffffffff

	// DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
	// Position of DADDR field.
	DMAC_DADDR3_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR3_DADDR_Msk = 0xffffffff

	// DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
	// Position of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR3_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR3_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR3_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR3_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR3_DSCR_Msk = 0xfffffffc

	// CTRLA3: DMAC Channel Control A Register (ch_num = 3)
	// Position of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA3_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA3_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA3_DONE = 0x80000000

	// CTRLB3: DMAC Channel Control B Register (ch_num = 3)
	// Position of SIF field.
	DMAC_CTRLB3_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB3_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB3_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB3_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB3_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB3_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB3_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB3_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB3_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB3_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB3_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB3_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB3_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB3_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB3_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB3_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB3_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB3_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB3_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB3_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB3_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB3_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB3_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB3_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB3_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB3_AUTO = 0x80000000

	// CFG3: DMAC Channel Configuration Register (ch_num = 3)
	// Position of SRC_PER field.
	DMAC_CFG3_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG3_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG3_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG3_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG3_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG3_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG3_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG3_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG3_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG3_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG3_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG3_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG3_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG3_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG3_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG3_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG3_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG3_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG3_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG3_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG3_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG3_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG3_FIFOCFG_ASAP_CFG = 0x2

	// SADDR4: DMAC Channel Source Address Register (ch_num = 4)
	// Position of SADDR field.
	DMAC_SADDR4_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR4_SADDR_Msk = 0xffffffff

	// DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
	// Position of DADDR field.
	DMAC_DADDR4_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR4_DADDR_Msk = 0xffffffff

	// DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
	// Position of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR4_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR4_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR4_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR4_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR4_DSCR_Msk = 0xfffffffc

	// CTRLA4: DMAC Channel Control A Register (ch_num = 4)
	// Position of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA4_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA4_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA4_DONE = 0x80000000

	// CTRLB4: DMAC Channel Control B Register (ch_num = 4)
	// Position of SIF field.
	DMAC_CTRLB4_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB4_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB4_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB4_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB4_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB4_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB4_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB4_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB4_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB4_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB4_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB4_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB4_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB4_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB4_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB4_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB4_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB4_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB4_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB4_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB4_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB4_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB4_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB4_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB4_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB4_AUTO = 0x80000000

	// CFG4: DMAC Channel Configuration Register (ch_num = 4)
	// Position of SRC_PER field.
	DMAC_CFG4_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG4_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG4_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG4_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG4_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG4_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG4_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG4_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG4_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG4_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG4_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG4_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG4_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG4_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG4_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG4_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG4_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG4_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG4_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG4_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG4_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG4_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG4_FIFOCFG_ASAP_CFG = 0x2

	// SADDR5: DMAC Channel Source Address Register (ch_num = 5)
	// Position of SADDR field.
	DMAC_SADDR5_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR5_SADDR_Msk = 0xffffffff

	// DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
	// Position of DADDR field.
	DMAC_DADDR5_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR5_DADDR_Msk = 0xffffffff

	// DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
	// Position of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR5_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR5_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR5_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR5_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR5_DSCR_Msk = 0xfffffffc

	// CTRLA5: DMAC Channel Control A Register (ch_num = 5)
	// Position of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA5_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA5_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA5_DONE = 0x80000000

	// CTRLB5: DMAC Channel Control B Register (ch_num = 5)
	// Position of SIF field.
	DMAC_CTRLB5_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB5_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB5_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB5_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB5_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB5_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB5_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB5_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB5_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB5_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB5_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB5_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB5_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB5_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB5_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB5_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB5_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB5_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB5_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB5_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB5_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB5_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB5_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB5_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB5_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB5_AUTO = 0x80000000

	// CFG5: DMAC Channel Configuration Register (ch_num = 5)
	// Position of SRC_PER field.
	DMAC_CFG5_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG5_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG5_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG5_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG5_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG5_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG5_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG5_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG5_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG5_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG5_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG5_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG5_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG5_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG5_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG5_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG5_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG5_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG5_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG5_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG5_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG5_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG5_FIFOCFG_ASAP_CFG = 0x2

	// SADDR6: DMAC Channel Source Address Register (ch_num = 6)
	// Position of SADDR field.
	DMAC_SADDR6_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR6_SADDR_Msk = 0xffffffff

	// DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
	// Position of DADDR field.
	DMAC_DADDR6_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR6_DADDR_Msk = 0xffffffff

	// DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
	// Position of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR6_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR6_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR6_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR6_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR6_DSCR_Msk = 0xfffffffc

	// CTRLA6: DMAC Channel Control A Register (ch_num = 6)
	// Position of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA6_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA6_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA6_DONE = 0x80000000

	// CTRLB6: DMAC Channel Control B Register (ch_num = 6)
	// Position of SIF field.
	DMAC_CTRLB6_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB6_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB6_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB6_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB6_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB6_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB6_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB6_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB6_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB6_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB6_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB6_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB6_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB6_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB6_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB6_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB6_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB6_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB6_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB6_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB6_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB6_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB6_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB6_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB6_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB6_AUTO = 0x80000000

	// CFG6: DMAC Channel Configuration Register (ch_num = 6)
	// Position of SRC_PER field.
	DMAC_CFG6_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG6_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG6_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG6_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG6_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG6_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG6_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG6_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG6_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG6_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG6_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG6_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG6_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG6_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG6_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG6_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG6_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG6_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG6_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG6_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG6_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG6_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG6_FIFOCFG_ASAP_CFG = 0x2

	// SADDR7: DMAC Channel Source Address Register (ch_num = 7)
	// Position of SADDR field.
	DMAC_SADDR7_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR7_SADDR_Msk = 0xffffffff

	// DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
	// Position of DADDR field.
	DMAC_DADDR7_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR7_DADDR_Msk = 0xffffffff

	// DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
	// Position of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR7_DSCR_IF_AHB_IFO = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR7_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR7_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR7_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR7_DSCR_Msk = 0xfffffffc

	// CTRLA7: DMAC Channel Control A Register (ch_num = 7)
	// Position of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_256 = 0x7
	// Position of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_16 = 0x3
	// 32 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_32 = 0x4
	// 64 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_64 = 0x5
	// 128 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_128 = 0x6
	// 256 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_256 = 0x7
	// Position of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_SRC_WIDTH_WORD = 0x2
	// Position of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_DST_WIDTH_WORD = 0x2
	// Position of DONE field.
	DMAC_CTRLA7_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA7_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA7_DONE = 0x80000000

	// CTRLB7: DMAC Channel Control B Register (ch_num = 7)
	// Position of SIF field.
	DMAC_CTRLB7_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB7_SIF_Msk = 0x3
	// The source transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB7_SIF_AHB_IFO = 0x0
	// The source transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB7_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB7_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB7_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB7_DIF_Msk = 0x30
	// The destination transfer is done via AHB-Lite Interface 0
	DMAC_CTRLB7_DIF_AHB_IFO = 0x0
	// The destination transfer is done via AHB-Lite Interface 1
	DMAC_CTRLB7_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB-Lite Interface 2
	DMAC_CTRLB7_DIF_AHB_IF2 = 0x2
	// Position of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB7_SRC_DSCR = 0x10000
	// Position of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB7_DST_DSCR = 0x100000
	// Position of FC field.
	DMAC_CTRLB7_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB7_FC_Msk = 0xe00000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2PER_DMA_FC = 0x3
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2MEM_PER_FC = 0x4
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2PER_PER_FC = 0x5
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2PER_SPER_FC = 0x6
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2PER_DPER_FC = 0x7
	// Position of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB7_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB7_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB7_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB7_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB7_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB7_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB7_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB7_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB7_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB7_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB7_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB7_AUTO = 0x80000000

	// CFG7: DMAC Channel Configuration Register (ch_num = 7)
	// Position of SRC_PER field.
	DMAC_CFG7_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG7_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG7_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG7_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG7_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG7_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG7_SRC_REP = 0x100
	// Position of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG7_SRC_H2SEL = 0x200
	// Position of DST_REP field.
	DMAC_CFG7_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG7_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG7_DST_REP = 0x1000
	// Position of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG7_DST_H2SEL = 0x2000
	// Position of SOD field.
	DMAC_CFG7_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG7_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG7_SOD = 0x10000
	// Position of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG7_LOCK_IF = 0x100000
	// Position of LOCK_B field.
	DMAC_CFG7_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG7_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG7_LOCK_B = 0x200000
	// Position of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG7_LOCK_IF_L = 0x400000
	// Position of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG7_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG7_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG7_FIFOCFG_ASAP_CFG = 0x2

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	DMAC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	DMAC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	DMAC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	DMAC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	DMAC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	DMAC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	DMAC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	DMAC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	DMAC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	DMAC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for DBGU: Debug Unit
const (
	// CR: Control Register
	// Position of RSTRX field.
	DBGU_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	DBGU_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	DBGU_CR_RSTRX = 0x4
	// Position of RSTTX field.
	DBGU_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	DBGU_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	DBGU_CR_RSTTX = 0x8
	// Position of RXEN field.
	DBGU_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	DBGU_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	DBGU_CR_RXEN = 0x10
	// Position of RXDIS field.
	DBGU_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	DBGU_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	DBGU_CR_RXDIS = 0x20
	// Position of TXEN field.
	DBGU_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	DBGU_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	DBGU_CR_TXEN = 0x40
	// Position of TXDIS field.
	DBGU_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	DBGU_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	DBGU_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	DBGU_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	DBGU_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	DBGU_CR_RSTSTA = 0x100

	// MR: Mode Register
	// Position of PAR field.
	DBGU_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	DBGU_MR_PAR_Msk = 0xe00
	// Position of CHMODE field.
	DBGU_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	DBGU_MR_CHMODE_Msk = 0xc000

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	DBGU_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IER_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IER_TXRDY = 0x2
	// Position of ENDRX field.
	DBGU_IER_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	DBGU_IER_ENDRX_Msk = 0x8
	// Bit ENDRX.
	DBGU_IER_ENDRX = 0x8
	// Position of ENDTX field.
	DBGU_IER_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	DBGU_IER_ENDTX_Msk = 0x10
	// Bit ENDTX.
	DBGU_IER_ENDTX = 0x10
	// Position of OVRE field.
	DBGU_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IER_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IER_FRAME = 0x40
	// Position of PARE field.
	DBGU_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IER_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IER_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IER_TXEMPTY = 0x200
	// Position of TXBUFE field.
	DBGU_IER_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	DBGU_IER_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	DBGU_IER_TXBUFE = 0x800
	// Position of RXBUFF field.
	DBGU_IER_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	DBGU_IER_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	DBGU_IER_RXBUFF = 0x1000
	// Position of COMMTX field.
	DBGU_IER_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IER_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IER_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IER_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IER_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IER_COMMRX = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	DBGU_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IDR_TXRDY = 0x2
	// Position of ENDRX field.
	DBGU_IDR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	DBGU_IDR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	DBGU_IDR_ENDRX = 0x8
	// Position of ENDTX field.
	DBGU_IDR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	DBGU_IDR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	DBGU_IDR_ENDTX = 0x10
	// Position of OVRE field.
	DBGU_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IDR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IDR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IDR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IDR_TXEMPTY = 0x200
	// Position of TXBUFE field.
	DBGU_IDR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	DBGU_IDR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	DBGU_IDR_TXBUFE = 0x800
	// Position of RXBUFF field.
	DBGU_IDR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	DBGU_IDR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	DBGU_IDR_RXBUFF = 0x1000
	// Position of COMMTX field.
	DBGU_IDR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IDR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IDR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IDR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IDR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IDR_COMMRX = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	DBGU_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IMR_TXRDY = 0x2
	// Position of ENDRX field.
	DBGU_IMR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	DBGU_IMR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	DBGU_IMR_ENDRX = 0x8
	// Position of ENDTX field.
	DBGU_IMR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	DBGU_IMR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	DBGU_IMR_ENDTX = 0x10
	// Position of OVRE field.
	DBGU_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IMR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IMR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IMR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IMR_TXEMPTY = 0x200
	// Position of TXBUFE field.
	DBGU_IMR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	DBGU_IMR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	DBGU_IMR_TXBUFE = 0x800
	// Position of RXBUFF field.
	DBGU_IMR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	DBGU_IMR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	DBGU_IMR_RXBUFF = 0x1000
	// Position of COMMTX field.
	DBGU_IMR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IMR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IMR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IMR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IMR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IMR_COMMRX = 0x80000000

	// SR: Status Register
	// Position of RXRDY field.
	DBGU_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_SR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_SR_TXRDY = 0x2
	// Position of ENDRX field.
	DBGU_SR_ENDRX_Pos = 0x3
	// Bit mask of ENDRX field.
	DBGU_SR_ENDRX_Msk = 0x8
	// Bit ENDRX.
	DBGU_SR_ENDRX = 0x8
	// Position of ENDTX field.
	DBGU_SR_ENDTX_Pos = 0x4
	// Bit mask of ENDTX field.
	DBGU_SR_ENDTX_Msk = 0x10
	// Bit ENDTX.
	DBGU_SR_ENDTX = 0x10
	// Position of OVRE field.
	DBGU_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_SR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_SR_FRAME = 0x40
	// Position of PARE field.
	DBGU_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_SR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_SR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_SR_TXEMPTY = 0x200
	// Position of TXBUFE field.
	DBGU_SR_TXBUFE_Pos = 0xb
	// Bit mask of TXBUFE field.
	DBGU_SR_TXBUFE_Msk = 0x800
	// Bit TXBUFE.
	DBGU_SR_TXBUFE = 0x800
	// Position of RXBUFF field.
	DBGU_SR_RXBUFF_Pos = 0xc
	// Bit mask of RXBUFF field.
	DBGU_SR_RXBUFF_Msk = 0x1000
	// Bit RXBUFF.
	DBGU_SR_RXBUFF = 0x1000
	// Position of COMMTX field.
	DBGU_SR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_SR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_SR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_SR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_SR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_SR_COMMRX = 0x80000000

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	DBGU_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	DBGU_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	DBGU_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	DBGU_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	DBGU_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	DBGU_BRGR_CD_Msk = 0xffff

	// CIDR: Chip ID Register
	// Position of VERSION field.
	DBGU_CIDR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	DBGU_CIDR_VERSION_Msk = 0x1f
	// Position of EPROC field.
	DBGU_CIDR_EPROC_Pos = 0x5
	// Bit mask of EPROC field.
	DBGU_CIDR_EPROC_Msk = 0xe0
	// Position of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Pos = 0x8
	// Bit mask of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Msk = 0xf00
	// Position of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Pos = 0xc
	// Bit mask of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Msk = 0xf000
	// Position of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Pos = 0x10
	// Bit mask of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Msk = 0xf0000
	// Position of ARCH field.
	DBGU_CIDR_ARCH_Pos = 0x14
	// Bit mask of ARCH field.
	DBGU_CIDR_ARCH_Msk = 0xff00000
	// Position of NVPTYP field.
	DBGU_CIDR_NVPTYP_Pos = 0x1c
	// Bit mask of NVPTYP field.
	DBGU_CIDR_NVPTYP_Msk = 0x70000000
	// Position of EXT field.
	DBGU_CIDR_EXT_Pos = 0x1f
	// Bit mask of EXT field.
	DBGU_CIDR_EXT_Msk = 0x80000000
	// Bit EXT.
	DBGU_CIDR_EXT = 0x80000000

	// EXID: Chip ID Extension Register
	// Position of EXID field.
	DBGU_EXID_EXID_Pos = 0x0
	// Bit mask of EXID field.
	DBGU_EXID_EXID_Msk = 0xffffffff

	// FNR: Force NTRST Register
	// Position of FNTRST field.
	DBGU_FNR_FNTRST_Pos = 0x0
	// Bit mask of FNTRST field.
	DBGU_FNR_FNTRST_Msk = 0x1
	// Bit FNTRST.
	DBGU_FNR_FNTRST = 0x1

	// RPR: Receive Pointer Register
	// Position of RXPTR field.
	DBGU_RPR_RXPTR_Pos = 0x0
	// Bit mask of RXPTR field.
	DBGU_RPR_RXPTR_Msk = 0xffffffff

	// RCR: Receive Counter Register
	// Position of RXCTR field.
	DBGU_RCR_RXCTR_Pos = 0x0
	// Bit mask of RXCTR field.
	DBGU_RCR_RXCTR_Msk = 0xffff

	// TPR: Transmit Pointer Register
	// Position of TXPTR field.
	DBGU_TPR_TXPTR_Pos = 0x0
	// Bit mask of TXPTR field.
	DBGU_TPR_TXPTR_Msk = 0xffffffff

	// TCR: Transmit Counter Register
	// Position of TXCTR field.
	DBGU_TCR_TXCTR_Pos = 0x0
	// Bit mask of TXCTR field.
	DBGU_TCR_TXCTR_Msk = 0xffff

	// RNPR: Receive Next Pointer Register
	// Position of RXNPTR field.
	DBGU_RNPR_RXNPTR_Pos = 0x0
	// Bit mask of RXNPTR field.
	DBGU_RNPR_RXNPTR_Msk = 0xffffffff

	// RNCR: Receive Next Counter Register
	// Position of RXNCTR field.
	DBGU_RNCR_RXNCTR_Pos = 0x0
	// Bit mask of RXNCTR field.
	DBGU_RNCR_RXNCTR_Msk = 0xffff

	// TNPR: Transmit Next Pointer Register
	// Position of TXNPTR field.
	DBGU_TNPR_TXNPTR_Pos = 0x0
	// Bit mask of TXNPTR field.
	DBGU_TNPR_TXNPTR_Msk = 0xffffffff

	// TNCR: Transmit Next Counter Register
	// Position of TXNCTR field.
	DBGU_TNCR_TXNCTR_Pos = 0x0
	// Bit mask of TXNCTR field.
	DBGU_TNCR_TXNCTR_Msk = 0xffff

	// PTCR: Transfer Control Register
	// Position of RXTEN field.
	DBGU_PTCR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	DBGU_PTCR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	DBGU_PTCR_RXTEN = 0x1
	// Position of RXTDIS field.
	DBGU_PTCR_RXTDIS_Pos = 0x1
	// Bit mask of RXTDIS field.
	DBGU_PTCR_RXTDIS_Msk = 0x2
	// Bit RXTDIS.
	DBGU_PTCR_RXTDIS = 0x2
	// Position of TXTEN field.
	DBGU_PTCR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	DBGU_PTCR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	DBGU_PTCR_TXTEN = 0x100
	// Position of TXTDIS field.
	DBGU_PTCR_TXTDIS_Pos = 0x9
	// Bit mask of TXTDIS field.
	DBGU_PTCR_TXTDIS_Msk = 0x200
	// Bit TXTDIS.
	DBGU_PTCR_TXTDIS = 0x200

	// PTSR: Transfer Status Register
	// Position of RXTEN field.
	DBGU_PTSR_RXTEN_Pos = 0x0
	// Bit mask of RXTEN field.
	DBGU_PTSR_RXTEN_Msk = 0x1
	// Bit RXTEN.
	DBGU_PTSR_RXTEN = 0x1
	// Position of TXTEN field.
	DBGU_PTSR_TXTEN_Pos = 0x8
	// Bit mask of TXTEN field.
	DBGU_PTSR_TXTEN_Msk = 0x100
	// Bit TXTEN.
	DBGU_PTSR_TXTEN = 0x100
)

// Constants for AIC: Advanced Interrupt Controller
const (
	// SMR: Source Mode Register
	// Position of PRIOR field.
	AIC_SMR_PRIOR_Pos = 0x0
	// Bit mask of PRIOR field.
	AIC_SMR_PRIOR_Msk = 0x7
	// Position of SRCTYPE field.
	AIC_SMR_SRCTYPE_Pos = 0x5
	// Bit mask of SRCTYPE field.
	AIC_SMR_SRCTYPE_Msk = 0x60

	// SVR: Source Vector Register
	// Position of VECTOR field.
	AIC_SVR_VECTOR_Pos = 0x0
	// Bit mask of VECTOR field.
	AIC_SVR_VECTOR_Msk = 0xffffffff

	// IVR: Interrupt Vector Register
	// Position of IRQV field.
	AIC_IVR_IRQV_Pos = 0x0
	// Bit mask of IRQV field.
	AIC_IVR_IRQV_Msk = 0xffffffff

	// FVR: FIQ Interrupt Vector Register
	// Position of FIQV field.
	AIC_FVR_FIQV_Pos = 0x0
	// Bit mask of FIQV field.
	AIC_FVR_FIQV_Msk = 0xffffffff

	// ISR: Interrupt Status Register
	// Position of IRQID field.
	AIC_ISR_IRQID_Pos = 0x0
	// Bit mask of IRQID field.
	AIC_ISR_IRQID_Msk = 0x1f

	// IPR: Interrupt Pending Register
	// Position of FIQ field.
	AIC_IPR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IPR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IPR_FIQ = 0x1
	// Position of SYS field.
	AIC_IPR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IPR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IPR_SYS = 0x2
	// Position of PID2 field.
	AIC_IPR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IPR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IPR_PID2 = 0x4
	// Position of PID3 field.
	AIC_IPR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IPR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IPR_PID3 = 0x8
	// Position of PID4 field.
	AIC_IPR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IPR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IPR_PID4 = 0x10
	// Position of PID5 field.
	AIC_IPR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IPR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IPR_PID5 = 0x20
	// Position of PID6 field.
	AIC_IPR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IPR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IPR_PID6 = 0x40
	// Position of PID7 field.
	AIC_IPR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IPR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IPR_PID7 = 0x80
	// Position of PID8 field.
	AIC_IPR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IPR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IPR_PID8 = 0x100
	// Position of PID9 field.
	AIC_IPR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IPR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IPR_PID9 = 0x200
	// Position of PID10 field.
	AIC_IPR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IPR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IPR_PID10 = 0x400
	// Position of PID11 field.
	AIC_IPR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IPR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IPR_PID11 = 0x800
	// Position of PID12 field.
	AIC_IPR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IPR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IPR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IPR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IPR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IPR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IPR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IPR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IPR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IPR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IPR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IPR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IPR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IPR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IPR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IPR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IPR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IPR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IPR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IPR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IPR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IPR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IPR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IPR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IPR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IPR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IPR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IPR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IPR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IPR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IPR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IPR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IPR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IPR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IPR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IPR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IPR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IPR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IPR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IPR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IPR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IPR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IPR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IPR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IPR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IPR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IPR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IPR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IPR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IPR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IPR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IPR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IPR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IPR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IPR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IPR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IPR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IPR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IPR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IPR_PID31 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of FIQ field.
	AIC_IMR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IMR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IMR_FIQ = 0x1
	// Position of SYS field.
	AIC_IMR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IMR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IMR_SYS = 0x2
	// Position of PID2 field.
	AIC_IMR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IMR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IMR_PID2 = 0x4
	// Position of PID3 field.
	AIC_IMR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IMR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IMR_PID3 = 0x8
	// Position of PID4 field.
	AIC_IMR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IMR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IMR_PID4 = 0x10
	// Position of PID5 field.
	AIC_IMR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IMR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IMR_PID5 = 0x20
	// Position of PID6 field.
	AIC_IMR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IMR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IMR_PID6 = 0x40
	// Position of PID7 field.
	AIC_IMR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IMR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IMR_PID7 = 0x80
	// Position of PID8 field.
	AIC_IMR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IMR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IMR_PID8 = 0x100
	// Position of PID9 field.
	AIC_IMR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IMR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IMR_PID9 = 0x200
	// Position of PID10 field.
	AIC_IMR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IMR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IMR_PID10 = 0x400
	// Position of PID11 field.
	AIC_IMR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IMR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IMR_PID11 = 0x800
	// Position of PID12 field.
	AIC_IMR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IMR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IMR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IMR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IMR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IMR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IMR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IMR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IMR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IMR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IMR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IMR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IMR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IMR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IMR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IMR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IMR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IMR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IMR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IMR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IMR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IMR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IMR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IMR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IMR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IMR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IMR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IMR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IMR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IMR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IMR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IMR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IMR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IMR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IMR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IMR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IMR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IMR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IMR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IMR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IMR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IMR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IMR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IMR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IMR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IMR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IMR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IMR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IMR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IMR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IMR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IMR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IMR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IMR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IMR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IMR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IMR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IMR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IMR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IMR_PID31 = 0x80000000

	// CISR: Core Interrupt Status Register
	// Position of NFIQ field.
	AIC_CISR_NFIQ_Pos = 0x0
	// Bit mask of NFIQ field.
	AIC_CISR_NFIQ_Msk = 0x1
	// Bit NFIQ.
	AIC_CISR_NFIQ = 0x1
	// Position of NIRQ field.
	AIC_CISR_NIRQ_Pos = 0x1
	// Bit mask of NIRQ field.
	AIC_CISR_NIRQ_Msk = 0x2
	// Bit NIRQ.
	AIC_CISR_NIRQ = 0x2

	// IECR: Interrupt Enable Command Register
	// Position of FIQ field.
	AIC_IECR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IECR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IECR_FIQ = 0x1
	// Position of SYS field.
	AIC_IECR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IECR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IECR_SYS = 0x2
	// Position of PID2 field.
	AIC_IECR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IECR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IECR_PID2 = 0x4
	// Position of PID3 field.
	AIC_IECR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IECR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IECR_PID3 = 0x8
	// Position of PID4 field.
	AIC_IECR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IECR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IECR_PID4 = 0x10
	// Position of PID5 field.
	AIC_IECR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IECR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IECR_PID5 = 0x20
	// Position of PID6 field.
	AIC_IECR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IECR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IECR_PID6 = 0x40
	// Position of PID7 field.
	AIC_IECR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IECR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IECR_PID7 = 0x80
	// Position of PID8 field.
	AIC_IECR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IECR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IECR_PID8 = 0x100
	// Position of PID9 field.
	AIC_IECR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IECR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IECR_PID9 = 0x200
	// Position of PID10 field.
	AIC_IECR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IECR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IECR_PID10 = 0x400
	// Position of PID11 field.
	AIC_IECR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IECR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IECR_PID11 = 0x800
	// Position of PID12 field.
	AIC_IECR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IECR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IECR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IECR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IECR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IECR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IECR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IECR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IECR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IECR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IECR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IECR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IECR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IECR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IECR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IECR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IECR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IECR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IECR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IECR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IECR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IECR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IECR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IECR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IECR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IECR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IECR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IECR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IECR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IECR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IECR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IECR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IECR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IECR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IECR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IECR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IECR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IECR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IECR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IECR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IECR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IECR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IECR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IECR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IECR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IECR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IECR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IECR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IECR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IECR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IECR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IECR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IECR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IECR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IECR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IECR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IECR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IECR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IECR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IECR_PID31 = 0x80000000

	// IDCR: Interrupt Disable Command Register
	// Position of FIQ field.
	AIC_IDCR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IDCR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IDCR_FIQ = 0x1
	// Position of SYS field.
	AIC_IDCR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IDCR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IDCR_SYS = 0x2
	// Position of PID2 field.
	AIC_IDCR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IDCR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IDCR_PID2 = 0x4
	// Position of PID3 field.
	AIC_IDCR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IDCR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IDCR_PID3 = 0x8
	// Position of PID4 field.
	AIC_IDCR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IDCR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IDCR_PID4 = 0x10
	// Position of PID5 field.
	AIC_IDCR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IDCR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IDCR_PID5 = 0x20
	// Position of PID6 field.
	AIC_IDCR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IDCR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IDCR_PID6 = 0x40
	// Position of PID7 field.
	AIC_IDCR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IDCR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IDCR_PID7 = 0x80
	// Position of PID8 field.
	AIC_IDCR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IDCR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IDCR_PID8 = 0x100
	// Position of PID9 field.
	AIC_IDCR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IDCR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IDCR_PID9 = 0x200
	// Position of PID10 field.
	AIC_IDCR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IDCR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IDCR_PID10 = 0x400
	// Position of PID11 field.
	AIC_IDCR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IDCR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IDCR_PID11 = 0x800
	// Position of PID12 field.
	AIC_IDCR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IDCR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IDCR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IDCR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IDCR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IDCR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IDCR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IDCR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IDCR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IDCR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IDCR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IDCR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IDCR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IDCR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IDCR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IDCR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IDCR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IDCR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IDCR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IDCR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IDCR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IDCR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IDCR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IDCR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IDCR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IDCR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IDCR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IDCR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IDCR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IDCR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IDCR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IDCR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IDCR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IDCR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IDCR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IDCR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IDCR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IDCR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IDCR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IDCR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IDCR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IDCR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IDCR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IDCR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IDCR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IDCR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IDCR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IDCR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IDCR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IDCR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IDCR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IDCR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IDCR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IDCR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IDCR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IDCR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IDCR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IDCR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IDCR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IDCR_PID31 = 0x80000000

	// ICCR: Interrupt Clear Command Register
	// Position of FIQ field.
	AIC_ICCR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_ICCR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_ICCR_FIQ = 0x1
	// Position of SYS field.
	AIC_ICCR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_ICCR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_ICCR_SYS = 0x2
	// Position of PID2 field.
	AIC_ICCR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_ICCR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_ICCR_PID2 = 0x4
	// Position of PID3 field.
	AIC_ICCR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_ICCR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_ICCR_PID3 = 0x8
	// Position of PID4 field.
	AIC_ICCR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_ICCR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_ICCR_PID4 = 0x10
	// Position of PID5 field.
	AIC_ICCR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_ICCR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_ICCR_PID5 = 0x20
	// Position of PID6 field.
	AIC_ICCR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_ICCR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_ICCR_PID6 = 0x40
	// Position of PID7 field.
	AIC_ICCR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_ICCR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_ICCR_PID7 = 0x80
	// Position of PID8 field.
	AIC_ICCR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_ICCR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_ICCR_PID8 = 0x100
	// Position of PID9 field.
	AIC_ICCR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_ICCR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_ICCR_PID9 = 0x200
	// Position of PID10 field.
	AIC_ICCR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_ICCR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_ICCR_PID10 = 0x400
	// Position of PID11 field.
	AIC_ICCR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_ICCR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_ICCR_PID11 = 0x800
	// Position of PID12 field.
	AIC_ICCR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_ICCR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_ICCR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_ICCR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_ICCR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_ICCR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_ICCR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_ICCR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_ICCR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_ICCR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_ICCR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_ICCR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_ICCR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_ICCR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_ICCR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_ICCR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_ICCR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_ICCR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_ICCR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_ICCR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_ICCR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_ICCR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_ICCR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_ICCR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_ICCR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_ICCR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_ICCR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_ICCR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_ICCR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_ICCR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_ICCR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_ICCR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_ICCR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_ICCR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_ICCR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_ICCR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_ICCR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_ICCR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_ICCR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_ICCR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_ICCR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_ICCR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_ICCR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_ICCR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_ICCR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_ICCR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_ICCR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_ICCR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_ICCR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_ICCR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_ICCR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_ICCR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_ICCR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_ICCR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_ICCR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_ICCR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_ICCR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_ICCR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_ICCR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_ICCR_PID31 = 0x80000000

	// ISCR: Interrupt Set Command Register
	// Position of FIQ field.
	AIC_ISCR_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_ISCR_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_ISCR_FIQ = 0x1
	// Position of SYS field.
	AIC_ISCR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_ISCR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_ISCR_SYS = 0x2
	// Position of PID2 field.
	AIC_ISCR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_ISCR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_ISCR_PID2 = 0x4
	// Position of PID3 field.
	AIC_ISCR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_ISCR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_ISCR_PID3 = 0x8
	// Position of PID4 field.
	AIC_ISCR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_ISCR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_ISCR_PID4 = 0x10
	// Position of PID5 field.
	AIC_ISCR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_ISCR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_ISCR_PID5 = 0x20
	// Position of PID6 field.
	AIC_ISCR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_ISCR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_ISCR_PID6 = 0x40
	// Position of PID7 field.
	AIC_ISCR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_ISCR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_ISCR_PID7 = 0x80
	// Position of PID8 field.
	AIC_ISCR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_ISCR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_ISCR_PID8 = 0x100
	// Position of PID9 field.
	AIC_ISCR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_ISCR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_ISCR_PID9 = 0x200
	// Position of PID10 field.
	AIC_ISCR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_ISCR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_ISCR_PID10 = 0x400
	// Position of PID11 field.
	AIC_ISCR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_ISCR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_ISCR_PID11 = 0x800
	// Position of PID12 field.
	AIC_ISCR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_ISCR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_ISCR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_ISCR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_ISCR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_ISCR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_ISCR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_ISCR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_ISCR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_ISCR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_ISCR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_ISCR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_ISCR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_ISCR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_ISCR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_ISCR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_ISCR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_ISCR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_ISCR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_ISCR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_ISCR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_ISCR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_ISCR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_ISCR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_ISCR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_ISCR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_ISCR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_ISCR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_ISCR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_ISCR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_ISCR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_ISCR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_ISCR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_ISCR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_ISCR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_ISCR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_ISCR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_ISCR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_ISCR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_ISCR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_ISCR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_ISCR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_ISCR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_ISCR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_ISCR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_ISCR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_ISCR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_ISCR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_ISCR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_ISCR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_ISCR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_ISCR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_ISCR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_ISCR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_ISCR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_ISCR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_ISCR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_ISCR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_ISCR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_ISCR_PID31 = 0x80000000

	// SPU: Spurious Interrupt Vector Register
	// Position of SIVR field.
	AIC_SPU_SIVR_Pos = 0x0
	// Bit mask of SIVR field.
	AIC_SPU_SIVR_Msk = 0xffffffff

	// DCR: Debug Control Register
	// Position of PROT field.
	AIC_DCR_PROT_Pos = 0x0
	// Bit mask of PROT field.
	AIC_DCR_PROT_Msk = 0x1
	// Bit PROT.
	AIC_DCR_PROT = 0x1
	// Position of GMSK field.
	AIC_DCR_GMSK_Pos = 0x1
	// Bit mask of GMSK field.
	AIC_DCR_GMSK_Msk = 0x2
	// Bit GMSK.
	AIC_DCR_GMSK = 0x2

	// FFER: Fast Forcing Enable Register
	// Position of SYS field.
	AIC_FFER_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_FFER_SYS_Msk = 0x2
	// Bit SYS.
	AIC_FFER_SYS = 0x2
	// Position of PID2 field.
	AIC_FFER_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_FFER_PID2_Msk = 0x4
	// Bit PID2.
	AIC_FFER_PID2 = 0x4
	// Position of PID3 field.
	AIC_FFER_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_FFER_PID3_Msk = 0x8
	// Bit PID3.
	AIC_FFER_PID3 = 0x8
	// Position of PID4 field.
	AIC_FFER_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_FFER_PID4_Msk = 0x10
	// Bit PID4.
	AIC_FFER_PID4 = 0x10
	// Position of PID5 field.
	AIC_FFER_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_FFER_PID5_Msk = 0x20
	// Bit PID5.
	AIC_FFER_PID5 = 0x20
	// Position of PID6 field.
	AIC_FFER_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_FFER_PID6_Msk = 0x40
	// Bit PID6.
	AIC_FFER_PID6 = 0x40
	// Position of PID7 field.
	AIC_FFER_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_FFER_PID7_Msk = 0x80
	// Bit PID7.
	AIC_FFER_PID7 = 0x80
	// Position of PID8 field.
	AIC_FFER_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_FFER_PID8_Msk = 0x100
	// Bit PID8.
	AIC_FFER_PID8 = 0x100
	// Position of PID9 field.
	AIC_FFER_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_FFER_PID9_Msk = 0x200
	// Bit PID9.
	AIC_FFER_PID9 = 0x200
	// Position of PID10 field.
	AIC_FFER_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_FFER_PID10_Msk = 0x400
	// Bit PID10.
	AIC_FFER_PID10 = 0x400
	// Position of PID11 field.
	AIC_FFER_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_FFER_PID11_Msk = 0x800
	// Bit PID11.
	AIC_FFER_PID11 = 0x800
	// Position of PID12 field.
	AIC_FFER_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_FFER_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_FFER_PID12 = 0x1000
	// Position of PID13 field.
	AIC_FFER_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_FFER_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_FFER_PID13 = 0x2000
	// Position of PID14 field.
	AIC_FFER_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_FFER_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_FFER_PID14 = 0x4000
	// Position of PID15 field.
	AIC_FFER_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_FFER_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_FFER_PID15 = 0x8000
	// Position of PID16 field.
	AIC_FFER_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_FFER_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_FFER_PID16 = 0x10000
	// Position of PID17 field.
	AIC_FFER_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_FFER_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_FFER_PID17 = 0x20000
	// Position of PID18 field.
	AIC_FFER_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_FFER_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_FFER_PID18 = 0x40000
	// Position of PID19 field.
	AIC_FFER_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_FFER_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_FFER_PID19 = 0x80000
	// Position of PID20 field.
	AIC_FFER_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_FFER_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_FFER_PID20 = 0x100000
	// Position of PID21 field.
	AIC_FFER_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_FFER_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_FFER_PID21 = 0x200000
	// Position of PID22 field.
	AIC_FFER_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_FFER_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_FFER_PID22 = 0x400000
	// Position of PID23 field.
	AIC_FFER_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_FFER_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_FFER_PID23 = 0x800000
	// Position of PID24 field.
	AIC_FFER_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_FFER_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_FFER_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_FFER_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_FFER_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_FFER_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_FFER_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_FFER_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_FFER_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_FFER_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_FFER_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_FFER_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_FFER_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_FFER_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_FFER_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_FFER_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_FFER_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_FFER_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_FFER_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_FFER_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_FFER_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_FFER_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_FFER_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_FFER_PID31 = 0x80000000

	// FFDR: Fast Forcing Disable Register
	// Position of SYS field.
	AIC_FFDR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_FFDR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_FFDR_SYS = 0x2
	// Position of PID2 field.
	AIC_FFDR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_FFDR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_FFDR_PID2 = 0x4
	// Position of PID3 field.
	AIC_FFDR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_FFDR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_FFDR_PID3 = 0x8
	// Position of PID4 field.
	AIC_FFDR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_FFDR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_FFDR_PID4 = 0x10
	// Position of PID5 field.
	AIC_FFDR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_FFDR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_FFDR_PID5 = 0x20
	// Position of PID6 field.
	AIC_FFDR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_FFDR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_FFDR_PID6 = 0x40
	// Position of PID7 field.
	AIC_FFDR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_FFDR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_FFDR_PID7 = 0x80
	// Position of PID8 field.
	AIC_FFDR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_FFDR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_FFDR_PID8 = 0x100
	// Position of PID9 field.
	AIC_FFDR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_FFDR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_FFDR_PID9 = 0x200
	// Position of PID10 field.
	AIC_FFDR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_FFDR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_FFDR_PID10 = 0x400
	// Position of PID11 field.
	AIC_FFDR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_FFDR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_FFDR_PID11 = 0x800
	// Position of PID12 field.
	AIC_FFDR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_FFDR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_FFDR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_FFDR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_FFDR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_FFDR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_FFDR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_FFDR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_FFDR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_FFDR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_FFDR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_FFDR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_FFDR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_FFDR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_FFDR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_FFDR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_FFDR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_FFDR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_FFDR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_FFDR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_FFDR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_FFDR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_FFDR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_FFDR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_FFDR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_FFDR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_FFDR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_FFDR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_FFDR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_FFDR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_FFDR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_FFDR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_FFDR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_FFDR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_FFDR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_FFDR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_FFDR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_FFDR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_FFDR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_FFDR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_FFDR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_FFDR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_FFDR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_FFDR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_FFDR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_FFDR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_FFDR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_FFDR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_FFDR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_FFDR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_FFDR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_FFDR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_FFDR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_FFDR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_FFDR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_FFDR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_FFDR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_FFDR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_FFDR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_FFDR_PID31 = 0x80000000

	// FFSR: Fast Forcing Status Register
	// Position of SYS field.
	AIC_FFSR_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_FFSR_SYS_Msk = 0x2
	// Bit SYS.
	AIC_FFSR_SYS = 0x2
	// Position of PID2 field.
	AIC_FFSR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_FFSR_PID2_Msk = 0x4
	// Bit PID2.
	AIC_FFSR_PID2 = 0x4
	// Position of PID3 field.
	AIC_FFSR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_FFSR_PID3_Msk = 0x8
	// Bit PID3.
	AIC_FFSR_PID3 = 0x8
	// Position of PID4 field.
	AIC_FFSR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_FFSR_PID4_Msk = 0x10
	// Bit PID4.
	AIC_FFSR_PID4 = 0x10
	// Position of PID5 field.
	AIC_FFSR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_FFSR_PID5_Msk = 0x20
	// Bit PID5.
	AIC_FFSR_PID5 = 0x20
	// Position of PID6 field.
	AIC_FFSR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_FFSR_PID6_Msk = 0x40
	// Bit PID6.
	AIC_FFSR_PID6 = 0x40
	// Position of PID7 field.
	AIC_FFSR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_FFSR_PID7_Msk = 0x80
	// Bit PID7.
	AIC_FFSR_PID7 = 0x80
	// Position of PID8 field.
	AIC_FFSR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_FFSR_PID8_Msk = 0x100
	// Bit PID8.
	AIC_FFSR_PID8 = 0x100
	// Position of PID9 field.
	AIC_FFSR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_FFSR_PID9_Msk = 0x200
	// Bit PID9.
	AIC_FFSR_PID9 = 0x200
	// Position of PID10 field.
	AIC_FFSR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_FFSR_PID10_Msk = 0x400
	// Bit PID10.
	AIC_FFSR_PID10 = 0x400
	// Position of PID11 field.
	AIC_FFSR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_FFSR_PID11_Msk = 0x800
	// Bit PID11.
	AIC_FFSR_PID11 = 0x800
	// Position of PID12 field.
	AIC_FFSR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_FFSR_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_FFSR_PID12 = 0x1000
	// Position of PID13 field.
	AIC_FFSR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_FFSR_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_FFSR_PID13 = 0x2000
	// Position of PID14 field.
	AIC_FFSR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_FFSR_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_FFSR_PID14 = 0x4000
	// Position of PID15 field.
	AIC_FFSR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_FFSR_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_FFSR_PID15 = 0x8000
	// Position of PID16 field.
	AIC_FFSR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_FFSR_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_FFSR_PID16 = 0x10000
	// Position of PID17 field.
	AIC_FFSR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_FFSR_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_FFSR_PID17 = 0x20000
	// Position of PID18 field.
	AIC_FFSR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_FFSR_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_FFSR_PID18 = 0x40000
	// Position of PID19 field.
	AIC_FFSR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_FFSR_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_FFSR_PID19 = 0x80000
	// Position of PID20 field.
	AIC_FFSR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_FFSR_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_FFSR_PID20 = 0x100000
	// Position of PID21 field.
	AIC_FFSR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_FFSR_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_FFSR_PID21 = 0x200000
	// Position of PID22 field.
	AIC_FFSR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_FFSR_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_FFSR_PID22 = 0x400000
	// Position of PID23 field.
	AIC_FFSR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_FFSR_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_FFSR_PID23 = 0x800000
	// Position of PID24 field.
	AIC_FFSR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_FFSR_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_FFSR_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_FFSR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_FFSR_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_FFSR_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_FFSR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_FFSR_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_FFSR_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_FFSR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_FFSR_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_FFSR_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_FFSR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_FFSR_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_FFSR_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_FFSR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_FFSR_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_FFSR_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_FFSR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_FFSR_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_FFSR_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_FFSR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_FFSR_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_FFSR_PID31 = 0x80000000
)

// Constants for PIOA: Parallel Input/Output Controller A
const (
	// PER: PIO Enable Register
	// Position of P0 field.
	PIO_PER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PER_P0_Msk = 0x1
	// Bit P0.
	PIO_PER_P0 = 0x1
	// Position of P1 field.
	PIO_PER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PER_P1_Msk = 0x2
	// Bit P1.
	PIO_PER_P1 = 0x2
	// Position of P2 field.
	PIO_PER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PER_P2_Msk = 0x4
	// Bit P2.
	PIO_PER_P2 = 0x4
	// Position of P3 field.
	PIO_PER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PER_P3_Msk = 0x8
	// Bit P3.
	PIO_PER_P3 = 0x8
	// Position of P4 field.
	PIO_PER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PER_P4_Msk = 0x10
	// Bit P4.
	PIO_PER_P4 = 0x10
	// Position of P5 field.
	PIO_PER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PER_P5_Msk = 0x20
	// Bit P5.
	PIO_PER_P5 = 0x20
	// Position of P6 field.
	PIO_PER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PER_P6_Msk = 0x40
	// Bit P6.
	PIO_PER_P6 = 0x40
	// Position of P7 field.
	PIO_PER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PER_P7_Msk = 0x80
	// Bit P7.
	PIO_PER_P7 = 0x80
	// Position of P8 field.
	PIO_PER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PER_P8_Msk = 0x100
	// Bit P8.
	PIO_PER_P8 = 0x100
	// Position of P9 field.
	PIO_PER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PER_P9_Msk = 0x200
	// Bit P9.
	PIO_PER_P9 = 0x200
	// Position of P10 field.
	PIO_PER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PER_P10_Msk = 0x400
	// Bit P10.
	PIO_PER_P10 = 0x400
	// Position of P11 field.
	PIO_PER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PER_P11_Msk = 0x800
	// Bit P11.
	PIO_PER_P11 = 0x800
	// Position of P12 field.
	PIO_PER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PER_P12 = 0x1000
	// Position of P13 field.
	PIO_PER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PER_P13 = 0x2000
	// Position of P14 field.
	PIO_PER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PER_P14 = 0x4000
	// Position of P15 field.
	PIO_PER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PER_P15 = 0x8000
	// Position of P16 field.
	PIO_PER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PER_P16 = 0x10000
	// Position of P17 field.
	PIO_PER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PER_P17 = 0x20000
	// Position of P18 field.
	PIO_PER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PER_P18 = 0x40000
	// Position of P19 field.
	PIO_PER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PER_P19 = 0x80000
	// Position of P20 field.
	PIO_PER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PER_P20 = 0x100000
	// Position of P21 field.
	PIO_PER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PER_P21 = 0x200000
	// Position of P22 field.
	PIO_PER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PER_P22 = 0x400000
	// Position of P23 field.
	PIO_PER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PER_P23 = 0x800000
	// Position of P24 field.
	PIO_PER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PER_P31 = 0x80000000

	// PDR: PIO Disable Register
	// Position of P0 field.
	PIO_PDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDR_P0 = 0x1
	// Position of P1 field.
	PIO_PDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDR_P1 = 0x2
	// Position of P2 field.
	PIO_PDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDR_P2 = 0x4
	// Position of P3 field.
	PIO_PDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDR_P3 = 0x8
	// Position of P4 field.
	PIO_PDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDR_P4 = 0x10
	// Position of P5 field.
	PIO_PDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDR_P5 = 0x20
	// Position of P6 field.
	PIO_PDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDR_P6 = 0x40
	// Position of P7 field.
	PIO_PDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDR_P7 = 0x80
	// Position of P8 field.
	PIO_PDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDR_P8 = 0x100
	// Position of P9 field.
	PIO_PDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDR_P9 = 0x200
	// Position of P10 field.
	PIO_PDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDR_P10 = 0x400
	// Position of P11 field.
	PIO_PDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDR_P11 = 0x800
	// Position of P12 field.
	PIO_PDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDR_P31 = 0x80000000

	// PSR: PIO Status Register
	// Position of P0 field.
	PIO_PSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PSR_P0 = 0x1
	// Position of P1 field.
	PIO_PSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PSR_P1 = 0x2
	// Position of P2 field.
	PIO_PSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PSR_P2 = 0x4
	// Position of P3 field.
	PIO_PSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PSR_P3 = 0x8
	// Position of P4 field.
	PIO_PSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PSR_P4 = 0x10
	// Position of P5 field.
	PIO_PSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PSR_P5 = 0x20
	// Position of P6 field.
	PIO_PSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PSR_P6 = 0x40
	// Position of P7 field.
	PIO_PSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PSR_P7 = 0x80
	// Position of P8 field.
	PIO_PSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PSR_P8 = 0x100
	// Position of P9 field.
	PIO_PSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PSR_P9 = 0x200
	// Position of P10 field.
	PIO_PSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PSR_P10 = 0x400
	// Position of P11 field.
	PIO_PSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PSR_P11 = 0x800
	// Position of P12 field.
	PIO_PSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PSR_P31 = 0x80000000

	// OER: Output Enable Register
	// Position of P0 field.
	PIO_OER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OER_P0_Msk = 0x1
	// Bit P0.
	PIO_OER_P0 = 0x1
	// Position of P1 field.
	PIO_OER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OER_P1_Msk = 0x2
	// Bit P1.
	PIO_OER_P1 = 0x2
	// Position of P2 field.
	PIO_OER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OER_P2_Msk = 0x4
	// Bit P2.
	PIO_OER_P2 = 0x4
	// Position of P3 field.
	PIO_OER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OER_P3_Msk = 0x8
	// Bit P3.
	PIO_OER_P3 = 0x8
	// Position of P4 field.
	PIO_OER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OER_P4_Msk = 0x10
	// Bit P4.
	PIO_OER_P4 = 0x10
	// Position of P5 field.
	PIO_OER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OER_P5_Msk = 0x20
	// Bit P5.
	PIO_OER_P5 = 0x20
	// Position of P6 field.
	PIO_OER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OER_P6_Msk = 0x40
	// Bit P6.
	PIO_OER_P6 = 0x40
	// Position of P7 field.
	PIO_OER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OER_P7_Msk = 0x80
	// Bit P7.
	PIO_OER_P7 = 0x80
	// Position of P8 field.
	PIO_OER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OER_P8_Msk = 0x100
	// Bit P8.
	PIO_OER_P8 = 0x100
	// Position of P9 field.
	PIO_OER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OER_P9_Msk = 0x200
	// Bit P9.
	PIO_OER_P9 = 0x200
	// Position of P10 field.
	PIO_OER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OER_P10_Msk = 0x400
	// Bit P10.
	PIO_OER_P10 = 0x400
	// Position of P11 field.
	PIO_OER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OER_P11_Msk = 0x800
	// Bit P11.
	PIO_OER_P11 = 0x800
	// Position of P12 field.
	PIO_OER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OER_P12 = 0x1000
	// Position of P13 field.
	PIO_OER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OER_P13 = 0x2000
	// Position of P14 field.
	PIO_OER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OER_P14 = 0x4000
	// Position of P15 field.
	PIO_OER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OER_P15 = 0x8000
	// Position of P16 field.
	PIO_OER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OER_P16 = 0x10000
	// Position of P17 field.
	PIO_OER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OER_P17 = 0x20000
	// Position of P18 field.
	PIO_OER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OER_P18 = 0x40000
	// Position of P19 field.
	PIO_OER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OER_P19 = 0x80000
	// Position of P20 field.
	PIO_OER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OER_P20 = 0x100000
	// Position of P21 field.
	PIO_OER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OER_P21 = 0x200000
	// Position of P22 field.
	PIO_OER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OER_P22 = 0x400000
	// Position of P23 field.
	PIO_OER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OER_P23 = 0x800000
	// Position of P24 field.
	PIO_OER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OER_P31 = 0x80000000

	// ODR: Output Disable Register
	// Position of P0 field.
	PIO_ODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODR_P0 = 0x1
	// Position of P1 field.
	PIO_ODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODR_P1 = 0x2
	// Position of P2 field.
	PIO_ODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODR_P2 = 0x4
	// Position of P3 field.
	PIO_ODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODR_P3 = 0x8
	// Position of P4 field.
	PIO_ODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODR_P4 = 0x10
	// Position of P5 field.
	PIO_ODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODR_P5 = 0x20
	// Position of P6 field.
	PIO_ODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODR_P6 = 0x40
	// Position of P7 field.
	PIO_ODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODR_P7 = 0x80
	// Position of P8 field.
	PIO_ODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODR_P8 = 0x100
	// Position of P9 field.
	PIO_ODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODR_P9 = 0x200
	// Position of P10 field.
	PIO_ODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODR_P10 = 0x400
	// Position of P11 field.
	PIO_ODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODR_P11 = 0x800
	// Position of P12 field.
	PIO_ODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODR_P31 = 0x80000000

	// OSR: Output Status Register
	// Position of P0 field.
	PIO_OSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OSR_P0 = 0x1
	// Position of P1 field.
	PIO_OSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OSR_P1 = 0x2
	// Position of P2 field.
	PIO_OSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OSR_P2 = 0x4
	// Position of P3 field.
	PIO_OSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OSR_P3 = 0x8
	// Position of P4 field.
	PIO_OSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OSR_P4 = 0x10
	// Position of P5 field.
	PIO_OSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OSR_P5 = 0x20
	// Position of P6 field.
	PIO_OSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OSR_P6 = 0x40
	// Position of P7 field.
	PIO_OSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OSR_P7 = 0x80
	// Position of P8 field.
	PIO_OSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OSR_P8 = 0x100
	// Position of P9 field.
	PIO_OSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OSR_P9 = 0x200
	// Position of P10 field.
	PIO_OSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OSR_P10 = 0x400
	// Position of P11 field.
	PIO_OSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OSR_P11 = 0x800
	// Position of P12 field.
	PIO_OSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OSR_P31 = 0x80000000

	// IFER: Glitch Input Filter Enable Register
	// Position of P0 field.
	PIO_IFER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFER_P0 = 0x1
	// Position of P1 field.
	PIO_IFER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFER_P1 = 0x2
	// Position of P2 field.
	PIO_IFER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFER_P2 = 0x4
	// Position of P3 field.
	PIO_IFER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFER_P3 = 0x8
	// Position of P4 field.
	PIO_IFER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFER_P4 = 0x10
	// Position of P5 field.
	PIO_IFER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFER_P5 = 0x20
	// Position of P6 field.
	PIO_IFER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFER_P6 = 0x40
	// Position of P7 field.
	PIO_IFER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFER_P7 = 0x80
	// Position of P8 field.
	PIO_IFER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFER_P8 = 0x100
	// Position of P9 field.
	PIO_IFER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFER_P9 = 0x200
	// Position of P10 field.
	PIO_IFER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFER_P10 = 0x400
	// Position of P11 field.
	PIO_IFER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFER_P11 = 0x800
	// Position of P12 field.
	PIO_IFER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFER_P31 = 0x80000000

	// IFDR: Glitch Input Filter Disable Register
	// Position of P0 field.
	PIO_IFDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFDR_P31 = 0x80000000

	// IFSR: Glitch Input Filter Status Register
	// Position of P0 field.
	PIO_IFSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSR_P31 = 0x80000000

	// SODR: Set Output Data Register
	// Position of P0 field.
	PIO_SODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_SODR_P0_Msk = 0x1
	// Bit P0.
	PIO_SODR_P0 = 0x1
	// Position of P1 field.
	PIO_SODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_SODR_P1_Msk = 0x2
	// Bit P1.
	PIO_SODR_P1 = 0x2
	// Position of P2 field.
	PIO_SODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_SODR_P2_Msk = 0x4
	// Bit P2.
	PIO_SODR_P2 = 0x4
	// Position of P3 field.
	PIO_SODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_SODR_P3_Msk = 0x8
	// Bit P3.
	PIO_SODR_P3 = 0x8
	// Position of P4 field.
	PIO_SODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_SODR_P4_Msk = 0x10
	// Bit P4.
	PIO_SODR_P4 = 0x10
	// Position of P5 field.
	PIO_SODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_SODR_P5_Msk = 0x20
	// Bit P5.
	PIO_SODR_P5 = 0x20
	// Position of P6 field.
	PIO_SODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_SODR_P6_Msk = 0x40
	// Bit P6.
	PIO_SODR_P6 = 0x40
	// Position of P7 field.
	PIO_SODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_SODR_P7_Msk = 0x80
	// Bit P7.
	PIO_SODR_P7 = 0x80
	// Position of P8 field.
	PIO_SODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_SODR_P8_Msk = 0x100
	// Bit P8.
	PIO_SODR_P8 = 0x100
	// Position of P9 field.
	PIO_SODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_SODR_P9_Msk = 0x200
	// Bit P9.
	PIO_SODR_P9 = 0x200
	// Position of P10 field.
	PIO_SODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_SODR_P10_Msk = 0x400
	// Bit P10.
	PIO_SODR_P10 = 0x400
	// Position of P11 field.
	PIO_SODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_SODR_P11_Msk = 0x800
	// Bit P11.
	PIO_SODR_P11 = 0x800
	// Position of P12 field.
	PIO_SODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_SODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_SODR_P12 = 0x1000
	// Position of P13 field.
	PIO_SODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_SODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_SODR_P13 = 0x2000
	// Position of P14 field.
	PIO_SODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_SODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_SODR_P14 = 0x4000
	// Position of P15 field.
	PIO_SODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_SODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_SODR_P15 = 0x8000
	// Position of P16 field.
	PIO_SODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_SODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_SODR_P16 = 0x10000
	// Position of P17 field.
	PIO_SODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_SODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_SODR_P17 = 0x20000
	// Position of P18 field.
	PIO_SODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_SODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_SODR_P18 = 0x40000
	// Position of P19 field.
	PIO_SODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_SODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_SODR_P19 = 0x80000
	// Position of P20 field.
	PIO_SODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_SODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_SODR_P20 = 0x100000
	// Position of P21 field.
	PIO_SODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_SODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_SODR_P21 = 0x200000
	// Position of P22 field.
	PIO_SODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_SODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_SODR_P22 = 0x400000
	// Position of P23 field.
	PIO_SODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_SODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_SODR_P23 = 0x800000
	// Position of P24 field.
	PIO_SODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_SODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_SODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_SODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_SODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_SODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_SODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_SODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_SODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_SODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_SODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_SODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_SODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_SODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_SODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_SODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_SODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_SODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_SODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_SODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_SODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_SODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_SODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_SODR_P31 = 0x80000000

	// CODR: Clear Output Data Register
	// Position of P0 field.
	PIO_CODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_CODR_P0_Msk = 0x1
	// Bit P0.
	PIO_CODR_P0 = 0x1
	// Position of P1 field.
	PIO_CODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_CODR_P1_Msk = 0x2
	// Bit P1.
	PIO_CODR_P1 = 0x2
	// Position of P2 field.
	PIO_CODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_CODR_P2_Msk = 0x4
	// Bit P2.
	PIO_CODR_P2 = 0x4
	// Position of P3 field.
	PIO_CODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_CODR_P3_Msk = 0x8
	// Bit P3.
	PIO_CODR_P3 = 0x8
	// Position of P4 field.
	PIO_CODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_CODR_P4_Msk = 0x10
	// Bit P4.
	PIO_CODR_P4 = 0x10
	// Position of P5 field.
	PIO_CODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_CODR_P5_Msk = 0x20
	// Bit P5.
	PIO_CODR_P5 = 0x20
	// Position of P6 field.
	PIO_CODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_CODR_P6_Msk = 0x40
	// Bit P6.
	PIO_CODR_P6 = 0x40
	// Position of P7 field.
	PIO_CODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_CODR_P7_Msk = 0x80
	// Bit P7.
	PIO_CODR_P7 = 0x80
	// Position of P8 field.
	PIO_CODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_CODR_P8_Msk = 0x100
	// Bit P8.
	PIO_CODR_P8 = 0x100
	// Position of P9 field.
	PIO_CODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_CODR_P9_Msk = 0x200
	// Bit P9.
	PIO_CODR_P9 = 0x200
	// Position of P10 field.
	PIO_CODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_CODR_P10_Msk = 0x400
	// Bit P10.
	PIO_CODR_P10 = 0x400
	// Position of P11 field.
	PIO_CODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_CODR_P11_Msk = 0x800
	// Bit P11.
	PIO_CODR_P11 = 0x800
	// Position of P12 field.
	PIO_CODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_CODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_CODR_P12 = 0x1000
	// Position of P13 field.
	PIO_CODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_CODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_CODR_P13 = 0x2000
	// Position of P14 field.
	PIO_CODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_CODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_CODR_P14 = 0x4000
	// Position of P15 field.
	PIO_CODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_CODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_CODR_P15 = 0x8000
	// Position of P16 field.
	PIO_CODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_CODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_CODR_P16 = 0x10000
	// Position of P17 field.
	PIO_CODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_CODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_CODR_P17 = 0x20000
	// Position of P18 field.
	PIO_CODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_CODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_CODR_P18 = 0x40000
	// Position of P19 field.
	PIO_CODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_CODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_CODR_P19 = 0x80000
	// Position of P20 field.
	PIO_CODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_CODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_CODR_P20 = 0x100000
	// Position of P21 field.
	PIO_CODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_CODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_CODR_P21 = 0x200000
	// Position of P22 field.
	PIO_CODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_CODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_CODR_P22 = 0x400000
	// Position of P23 field.
	PIO_CODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_CODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_CODR_P23 = 0x800000
	// Position of P24 field.
	PIO_CODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_CODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_CODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_CODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_CODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_CODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_CODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_CODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_CODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_CODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_CODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_CODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_CODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_CODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_CODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_CODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_CODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_CODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_CODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_CODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_CODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_CODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_CODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_CODR_P31 = 0x80000000

	// ODSR: Output Data Status Register
	// Position of P0 field.
	PIO_ODSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODSR_P0 = 0x1
	// Position of P1 field.
	PIO_ODSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODSR_P1 = 0x2
	// Position of P2 field.
	PIO_ODSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODSR_P2 = 0x4
	// Position of P3 field.
	PIO_ODSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODSR_P3 = 0x8
	// Position of P4 field.
	PIO_ODSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODSR_P4 = 0x10
	// Position of P5 field.
	PIO_ODSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODSR_P5 = 0x20
	// Position of P6 field.
	PIO_ODSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODSR_P6 = 0x40
	// Position of P7 field.
	PIO_ODSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODSR_P7 = 0x80
	// Position of P8 field.
	PIO_ODSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODSR_P8 = 0x100
	// Position of P9 field.
	PIO_ODSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODSR_P9 = 0x200
	// Position of P10 field.
	PIO_ODSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODSR_P10 = 0x400
	// Position of P11 field.
	PIO_ODSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODSR_P11 = 0x800
	// Position of P12 field.
	PIO_ODSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODSR_P31 = 0x80000000

	// PDSR: Pin Data Status Register
	// Position of P0 field.
	PIO_PDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDSR_P31 = 0x80000000

	// IER: Interrupt Enable Register
	// Position of P0 field.
	PIO_IER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IER_P0_Msk = 0x1
	// Bit P0.
	PIO_IER_P0 = 0x1
	// Position of P1 field.
	PIO_IER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IER_P1_Msk = 0x2
	// Bit P1.
	PIO_IER_P1 = 0x2
	// Position of P2 field.
	PIO_IER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IER_P2_Msk = 0x4
	// Bit P2.
	PIO_IER_P2 = 0x4
	// Position of P3 field.
	PIO_IER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IER_P3_Msk = 0x8
	// Bit P3.
	PIO_IER_P3 = 0x8
	// Position of P4 field.
	PIO_IER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IER_P4_Msk = 0x10
	// Bit P4.
	PIO_IER_P4 = 0x10
	// Position of P5 field.
	PIO_IER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IER_P5_Msk = 0x20
	// Bit P5.
	PIO_IER_P5 = 0x20
	// Position of P6 field.
	PIO_IER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IER_P6_Msk = 0x40
	// Bit P6.
	PIO_IER_P6 = 0x40
	// Position of P7 field.
	PIO_IER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IER_P7_Msk = 0x80
	// Bit P7.
	PIO_IER_P7 = 0x80
	// Position of P8 field.
	PIO_IER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IER_P8_Msk = 0x100
	// Bit P8.
	PIO_IER_P8 = 0x100
	// Position of P9 field.
	PIO_IER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IER_P9_Msk = 0x200
	// Bit P9.
	PIO_IER_P9 = 0x200
	// Position of P10 field.
	PIO_IER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IER_P10_Msk = 0x400
	// Bit P10.
	PIO_IER_P10 = 0x400
	// Position of P11 field.
	PIO_IER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IER_P11_Msk = 0x800
	// Bit P11.
	PIO_IER_P11 = 0x800
	// Position of P12 field.
	PIO_IER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IER_P12 = 0x1000
	// Position of P13 field.
	PIO_IER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IER_P13 = 0x2000
	// Position of P14 field.
	PIO_IER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IER_P14 = 0x4000
	// Position of P15 field.
	PIO_IER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IER_P15 = 0x8000
	// Position of P16 field.
	PIO_IER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IER_P16 = 0x10000
	// Position of P17 field.
	PIO_IER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IER_P17 = 0x20000
	// Position of P18 field.
	PIO_IER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IER_P18 = 0x40000
	// Position of P19 field.
	PIO_IER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IER_P19 = 0x80000
	// Position of P20 field.
	PIO_IER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IER_P20 = 0x100000
	// Position of P21 field.
	PIO_IER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IER_P21 = 0x200000
	// Position of P22 field.
	PIO_IER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IER_P22 = 0x400000
	// Position of P23 field.
	PIO_IER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IER_P23 = 0x800000
	// Position of P24 field.
	PIO_IER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IER_P31 = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of P0 field.
	PIO_IDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IDR_P0 = 0x1
	// Position of P1 field.
	PIO_IDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IDR_P1 = 0x2
	// Position of P2 field.
	PIO_IDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IDR_P2 = 0x4
	// Position of P3 field.
	PIO_IDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IDR_P3 = 0x8
	// Position of P4 field.
	PIO_IDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IDR_P4 = 0x10
	// Position of P5 field.
	PIO_IDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IDR_P5 = 0x20
	// Position of P6 field.
	PIO_IDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IDR_P6 = 0x40
	// Position of P7 field.
	PIO_IDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IDR_P7 = 0x80
	// Position of P8 field.
	PIO_IDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IDR_P8 = 0x100
	// Position of P9 field.
	PIO_IDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IDR_P9 = 0x200
	// Position of P10 field.
	PIO_IDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IDR_P10 = 0x400
	// Position of P11 field.
	PIO_IDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IDR_P11 = 0x800
	// Position of P12 field.
	PIO_IDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IDR_P31 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of P0 field.
	PIO_IMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IMR_P0_Msk = 0x1
	// Bit P0.
	PIO_IMR_P0 = 0x1
	// Position of P1 field.
	PIO_IMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IMR_P1_Msk = 0x2
	// Bit P1.
	PIO_IMR_P1 = 0x2
	// Position of P2 field.
	PIO_IMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IMR_P2_Msk = 0x4
	// Bit P2.
	PIO_IMR_P2 = 0x4
	// Position of P3 field.
	PIO_IMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IMR_P3_Msk = 0x8
	// Bit P3.
	PIO_IMR_P3 = 0x8
	// Position of P4 field.
	PIO_IMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IMR_P4_Msk = 0x10
	// Bit P4.
	PIO_IMR_P4 = 0x10
	// Position of P5 field.
	PIO_IMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IMR_P5_Msk = 0x20
	// Bit P5.
	PIO_IMR_P5 = 0x20
	// Position of P6 field.
	PIO_IMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IMR_P6_Msk = 0x40
	// Bit P6.
	PIO_IMR_P6 = 0x40
	// Position of P7 field.
	PIO_IMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IMR_P7_Msk = 0x80
	// Bit P7.
	PIO_IMR_P7 = 0x80
	// Position of P8 field.
	PIO_IMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IMR_P8_Msk = 0x100
	// Bit P8.
	PIO_IMR_P8 = 0x100
	// Position of P9 field.
	PIO_IMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IMR_P9_Msk = 0x200
	// Bit P9.
	PIO_IMR_P9 = 0x200
	// Position of P10 field.
	PIO_IMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IMR_P10_Msk = 0x400
	// Bit P10.
	PIO_IMR_P10 = 0x400
	// Position of P11 field.
	PIO_IMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IMR_P11_Msk = 0x800
	// Bit P11.
	PIO_IMR_P11 = 0x800
	// Position of P12 field.
	PIO_IMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IMR_P12 = 0x1000
	// Position of P13 field.
	PIO_IMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IMR_P13 = 0x2000
	// Position of P14 field.
	PIO_IMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IMR_P14 = 0x4000
	// Position of P15 field.
	PIO_IMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IMR_P15 = 0x8000
	// Position of P16 field.
	PIO_IMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IMR_P16 = 0x10000
	// Position of P17 field.
	PIO_IMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IMR_P17 = 0x20000
	// Position of P18 field.
	PIO_IMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IMR_P18 = 0x40000
	// Position of P19 field.
	PIO_IMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IMR_P19 = 0x80000
	// Position of P20 field.
	PIO_IMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IMR_P20 = 0x100000
	// Position of P21 field.
	PIO_IMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IMR_P21 = 0x200000
	// Position of P22 field.
	PIO_IMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IMR_P22 = 0x400000
	// Position of P23 field.
	PIO_IMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IMR_P23 = 0x800000
	// Position of P24 field.
	PIO_IMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IMR_P31 = 0x80000000

	// ISR: Interrupt Status Register
	// Position of P0 field.
	PIO_ISR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ISR_P0_Msk = 0x1
	// Bit P0.
	PIO_ISR_P0 = 0x1
	// Position of P1 field.
	PIO_ISR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ISR_P1_Msk = 0x2
	// Bit P1.
	PIO_ISR_P1 = 0x2
	// Position of P2 field.
	PIO_ISR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ISR_P2_Msk = 0x4
	// Bit P2.
	PIO_ISR_P2 = 0x4
	// Position of P3 field.
	PIO_ISR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ISR_P3_Msk = 0x8
	// Bit P3.
	PIO_ISR_P3 = 0x8
	// Position of P4 field.
	PIO_ISR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ISR_P4_Msk = 0x10
	// Bit P4.
	PIO_ISR_P4 = 0x10
	// Position of P5 field.
	PIO_ISR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ISR_P5_Msk = 0x20
	// Bit P5.
	PIO_ISR_P5 = 0x20
	// Position of P6 field.
	PIO_ISR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ISR_P6_Msk = 0x40
	// Bit P6.
	PIO_ISR_P6 = 0x40
	// Position of P7 field.
	PIO_ISR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ISR_P7_Msk = 0x80
	// Bit P7.
	PIO_ISR_P7 = 0x80
	// Position of P8 field.
	PIO_ISR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ISR_P8_Msk = 0x100
	// Bit P8.
	PIO_ISR_P8 = 0x100
	// Position of P9 field.
	PIO_ISR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ISR_P9_Msk = 0x200
	// Bit P9.
	PIO_ISR_P9 = 0x200
	// Position of P10 field.
	PIO_ISR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ISR_P10_Msk = 0x400
	// Bit P10.
	PIO_ISR_P10 = 0x400
	// Position of P11 field.
	PIO_ISR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ISR_P11_Msk = 0x800
	// Bit P11.
	PIO_ISR_P11 = 0x800
	// Position of P12 field.
	PIO_ISR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ISR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ISR_P12 = 0x1000
	// Position of P13 field.
	PIO_ISR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ISR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ISR_P13 = 0x2000
	// Position of P14 field.
	PIO_ISR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ISR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ISR_P14 = 0x4000
	// Position of P15 field.
	PIO_ISR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ISR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ISR_P15 = 0x8000
	// Position of P16 field.
	PIO_ISR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ISR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ISR_P16 = 0x10000
	// Position of P17 field.
	PIO_ISR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ISR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ISR_P17 = 0x20000
	// Position of P18 field.
	PIO_ISR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ISR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ISR_P18 = 0x40000
	// Position of P19 field.
	PIO_ISR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ISR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ISR_P19 = 0x80000
	// Position of P20 field.
	PIO_ISR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ISR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ISR_P20 = 0x100000
	// Position of P21 field.
	PIO_ISR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ISR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ISR_P21 = 0x200000
	// Position of P22 field.
	PIO_ISR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ISR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ISR_P22 = 0x400000
	// Position of P23 field.
	PIO_ISR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ISR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ISR_P23 = 0x800000
	// Position of P24 field.
	PIO_ISR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ISR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ISR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ISR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ISR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ISR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ISR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ISR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ISR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ISR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ISR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ISR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ISR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ISR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ISR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ISR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ISR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ISR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ISR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ISR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ISR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ISR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ISR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ISR_P31 = 0x80000000

	// MDER: Multi-driver Enable Register
	// Position of P0 field.
	PIO_MDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDER_P0_Msk = 0x1
	// Bit P0.
	PIO_MDER_P0 = 0x1
	// Position of P1 field.
	PIO_MDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDER_P1_Msk = 0x2
	// Bit P1.
	PIO_MDER_P1 = 0x2
	// Position of P2 field.
	PIO_MDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDER_P2_Msk = 0x4
	// Bit P2.
	PIO_MDER_P2 = 0x4
	// Position of P3 field.
	PIO_MDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDER_P3_Msk = 0x8
	// Bit P3.
	PIO_MDER_P3 = 0x8
	// Position of P4 field.
	PIO_MDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDER_P4_Msk = 0x10
	// Bit P4.
	PIO_MDER_P4 = 0x10
	// Position of P5 field.
	PIO_MDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDER_P5_Msk = 0x20
	// Bit P5.
	PIO_MDER_P5 = 0x20
	// Position of P6 field.
	PIO_MDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDER_P6_Msk = 0x40
	// Bit P6.
	PIO_MDER_P6 = 0x40
	// Position of P7 field.
	PIO_MDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDER_P7_Msk = 0x80
	// Bit P7.
	PIO_MDER_P7 = 0x80
	// Position of P8 field.
	PIO_MDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDER_P8_Msk = 0x100
	// Bit P8.
	PIO_MDER_P8 = 0x100
	// Position of P9 field.
	PIO_MDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDER_P9_Msk = 0x200
	// Bit P9.
	PIO_MDER_P9 = 0x200
	// Position of P10 field.
	PIO_MDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDER_P10_Msk = 0x400
	// Bit P10.
	PIO_MDER_P10 = 0x400
	// Position of P11 field.
	PIO_MDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDER_P11_Msk = 0x800
	// Bit P11.
	PIO_MDER_P11 = 0x800
	// Position of P12 field.
	PIO_MDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDER_P12 = 0x1000
	// Position of P13 field.
	PIO_MDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDER_P13 = 0x2000
	// Position of P14 field.
	PIO_MDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDER_P14 = 0x4000
	// Position of P15 field.
	PIO_MDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDER_P15 = 0x8000
	// Position of P16 field.
	PIO_MDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDER_P16 = 0x10000
	// Position of P17 field.
	PIO_MDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDER_P17 = 0x20000
	// Position of P18 field.
	PIO_MDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDER_P18 = 0x40000
	// Position of P19 field.
	PIO_MDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDER_P19 = 0x80000
	// Position of P20 field.
	PIO_MDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDER_P20 = 0x100000
	// Position of P21 field.
	PIO_MDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDER_P21 = 0x200000
	// Position of P22 field.
	PIO_MDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDER_P22 = 0x400000
	// Position of P23 field.
	PIO_MDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDER_P23 = 0x800000
	// Position of P24 field.
	PIO_MDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDER_P31 = 0x80000000

	// MDDR: Multi-driver Disable Register
	// Position of P0 field.
	PIO_MDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDDR_P0 = 0x1
	// Position of P1 field.
	PIO_MDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDDR_P1 = 0x2
	// Position of P2 field.
	PIO_MDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDDR_P2 = 0x4
	// Position of P3 field.
	PIO_MDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDDR_P3 = 0x8
	// Position of P4 field.
	PIO_MDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDDR_P4 = 0x10
	// Position of P5 field.
	PIO_MDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDDR_P5 = 0x20
	// Position of P6 field.
	PIO_MDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDDR_P6 = 0x40
	// Position of P7 field.
	PIO_MDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDDR_P7 = 0x80
	// Position of P8 field.
	PIO_MDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDDR_P8 = 0x100
	// Position of P9 field.
	PIO_MDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDDR_P9 = 0x200
	// Position of P10 field.
	PIO_MDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDDR_P10 = 0x400
	// Position of P11 field.
	PIO_MDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDDR_P11 = 0x800
	// Position of P12 field.
	PIO_MDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDDR_P31 = 0x80000000

	// MDSR: Multi-driver Status Register
	// Position of P0 field.
	PIO_MDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDSR_P0 = 0x1
	// Position of P1 field.
	PIO_MDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDSR_P1 = 0x2
	// Position of P2 field.
	PIO_MDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDSR_P2 = 0x4
	// Position of P3 field.
	PIO_MDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDSR_P3 = 0x8
	// Position of P4 field.
	PIO_MDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDSR_P4 = 0x10
	// Position of P5 field.
	PIO_MDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDSR_P5 = 0x20
	// Position of P6 field.
	PIO_MDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDSR_P6 = 0x40
	// Position of P7 field.
	PIO_MDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDSR_P7 = 0x80
	// Position of P8 field.
	PIO_MDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDSR_P8 = 0x100
	// Position of P9 field.
	PIO_MDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDSR_P9 = 0x200
	// Position of P10 field.
	PIO_MDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDSR_P10 = 0x400
	// Position of P11 field.
	PIO_MDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDSR_P11 = 0x800
	// Position of P12 field.
	PIO_MDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDSR_P31 = 0x80000000

	// PUDR: Pull-up Disable Register
	// Position of P0 field.
	PIO_PUDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUDR_P0 = 0x1
	// Position of P1 field.
	PIO_PUDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUDR_P1 = 0x2
	// Position of P2 field.
	PIO_PUDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUDR_P2 = 0x4
	// Position of P3 field.
	PIO_PUDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUDR_P3 = 0x8
	// Position of P4 field.
	PIO_PUDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUDR_P4 = 0x10
	// Position of P5 field.
	PIO_PUDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUDR_P5 = 0x20
	// Position of P6 field.
	PIO_PUDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUDR_P6 = 0x40
	// Position of P7 field.
	PIO_PUDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUDR_P7 = 0x80
	// Position of P8 field.
	PIO_PUDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUDR_P8 = 0x100
	// Position of P9 field.
	PIO_PUDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUDR_P9 = 0x200
	// Position of P10 field.
	PIO_PUDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUDR_P10 = 0x400
	// Position of P11 field.
	PIO_PUDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUDR_P11 = 0x800
	// Position of P12 field.
	PIO_PUDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUDR_P31 = 0x80000000

	// PUER: Pull-up Enable Register
	// Position of P0 field.
	PIO_PUER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUER_P0_Msk = 0x1
	// Bit P0.
	PIO_PUER_P0 = 0x1
	// Position of P1 field.
	PIO_PUER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUER_P1_Msk = 0x2
	// Bit P1.
	PIO_PUER_P1 = 0x2
	// Position of P2 field.
	PIO_PUER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUER_P2_Msk = 0x4
	// Bit P2.
	PIO_PUER_P2 = 0x4
	// Position of P3 field.
	PIO_PUER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUER_P3_Msk = 0x8
	// Bit P3.
	PIO_PUER_P3 = 0x8
	// Position of P4 field.
	PIO_PUER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUER_P4_Msk = 0x10
	// Bit P4.
	PIO_PUER_P4 = 0x10
	// Position of P5 field.
	PIO_PUER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUER_P5_Msk = 0x20
	// Bit P5.
	PIO_PUER_P5 = 0x20
	// Position of P6 field.
	PIO_PUER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUER_P6_Msk = 0x40
	// Bit P6.
	PIO_PUER_P6 = 0x40
	// Position of P7 field.
	PIO_PUER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUER_P7_Msk = 0x80
	// Bit P7.
	PIO_PUER_P7 = 0x80
	// Position of P8 field.
	PIO_PUER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUER_P8_Msk = 0x100
	// Bit P8.
	PIO_PUER_P8 = 0x100
	// Position of P9 field.
	PIO_PUER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUER_P9_Msk = 0x200
	// Bit P9.
	PIO_PUER_P9 = 0x200
	// Position of P10 field.
	PIO_PUER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUER_P10_Msk = 0x400
	// Bit P10.
	PIO_PUER_P10 = 0x400
	// Position of P11 field.
	PIO_PUER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUER_P11_Msk = 0x800
	// Bit P11.
	PIO_PUER_P11 = 0x800
	// Position of P12 field.
	PIO_PUER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUER_P12 = 0x1000
	// Position of P13 field.
	PIO_PUER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUER_P13 = 0x2000
	// Position of P14 field.
	PIO_PUER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUER_P14 = 0x4000
	// Position of P15 field.
	PIO_PUER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUER_P15 = 0x8000
	// Position of P16 field.
	PIO_PUER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUER_P16 = 0x10000
	// Position of P17 field.
	PIO_PUER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUER_P17 = 0x20000
	// Position of P18 field.
	PIO_PUER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUER_P18 = 0x40000
	// Position of P19 field.
	PIO_PUER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUER_P19 = 0x80000
	// Position of P20 field.
	PIO_PUER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUER_P20 = 0x100000
	// Position of P21 field.
	PIO_PUER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUER_P21 = 0x200000
	// Position of P22 field.
	PIO_PUER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUER_P22 = 0x400000
	// Position of P23 field.
	PIO_PUER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUER_P23 = 0x800000
	// Position of P24 field.
	PIO_PUER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUER_P31 = 0x80000000

	// PUSR: Pad Pull-up Status Register
	// Position of P0 field.
	PIO_PUSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUSR_P0 = 0x1
	// Position of P1 field.
	PIO_PUSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUSR_P1 = 0x2
	// Position of P2 field.
	PIO_PUSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUSR_P2 = 0x4
	// Position of P3 field.
	PIO_PUSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUSR_P3 = 0x8
	// Position of P4 field.
	PIO_PUSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUSR_P4 = 0x10
	// Position of P5 field.
	PIO_PUSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUSR_P5 = 0x20
	// Position of P6 field.
	PIO_PUSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUSR_P6 = 0x40
	// Position of P7 field.
	PIO_PUSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUSR_P7 = 0x80
	// Position of P8 field.
	PIO_PUSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUSR_P8 = 0x100
	// Position of P9 field.
	PIO_PUSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUSR_P9 = 0x200
	// Position of P10 field.
	PIO_PUSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUSR_P10 = 0x400
	// Position of P11 field.
	PIO_PUSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUSR_P11 = 0x800
	// Position of P12 field.
	PIO_PUSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUSR_P31 = 0x80000000

	// ASR: Peripheral A Select Register
	// Position of P0 field.
	PIO_ASR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ASR_P0_Msk = 0x1
	// Bit P0.
	PIO_ASR_P0 = 0x1
	// Position of P1 field.
	PIO_ASR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ASR_P1_Msk = 0x2
	// Bit P1.
	PIO_ASR_P1 = 0x2
	// Position of P2 field.
	PIO_ASR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ASR_P2_Msk = 0x4
	// Bit P2.
	PIO_ASR_P2 = 0x4
	// Position of P3 field.
	PIO_ASR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ASR_P3_Msk = 0x8
	// Bit P3.
	PIO_ASR_P3 = 0x8
	// Position of P4 field.
	PIO_ASR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ASR_P4_Msk = 0x10
	// Bit P4.
	PIO_ASR_P4 = 0x10
	// Position of P5 field.
	PIO_ASR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ASR_P5_Msk = 0x20
	// Bit P5.
	PIO_ASR_P5 = 0x20
	// Position of P6 field.
	PIO_ASR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ASR_P6_Msk = 0x40
	// Bit P6.
	PIO_ASR_P6 = 0x40
	// Position of P7 field.
	PIO_ASR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ASR_P7_Msk = 0x80
	// Bit P7.
	PIO_ASR_P7 = 0x80
	// Position of P8 field.
	PIO_ASR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ASR_P8_Msk = 0x100
	// Bit P8.
	PIO_ASR_P8 = 0x100
	// Position of P9 field.
	PIO_ASR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ASR_P9_Msk = 0x200
	// Bit P9.
	PIO_ASR_P9 = 0x200
	// Position of P10 field.
	PIO_ASR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ASR_P10_Msk = 0x400
	// Bit P10.
	PIO_ASR_P10 = 0x400
	// Position of P11 field.
	PIO_ASR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ASR_P11_Msk = 0x800
	// Bit P11.
	PIO_ASR_P11 = 0x800
	// Position of P12 field.
	PIO_ASR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ASR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ASR_P12 = 0x1000
	// Position of P13 field.
	PIO_ASR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ASR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ASR_P13 = 0x2000
	// Position of P14 field.
	PIO_ASR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ASR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ASR_P14 = 0x4000
	// Position of P15 field.
	PIO_ASR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ASR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ASR_P15 = 0x8000
	// Position of P16 field.
	PIO_ASR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ASR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ASR_P16 = 0x10000
	// Position of P17 field.
	PIO_ASR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ASR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ASR_P17 = 0x20000
	// Position of P18 field.
	PIO_ASR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ASR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ASR_P18 = 0x40000
	// Position of P19 field.
	PIO_ASR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ASR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ASR_P19 = 0x80000
	// Position of P20 field.
	PIO_ASR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ASR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ASR_P20 = 0x100000
	// Position of P21 field.
	PIO_ASR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ASR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ASR_P21 = 0x200000
	// Position of P22 field.
	PIO_ASR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ASR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ASR_P22 = 0x400000
	// Position of P23 field.
	PIO_ASR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ASR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ASR_P23 = 0x800000
	// Position of P24 field.
	PIO_ASR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ASR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ASR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ASR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ASR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ASR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ASR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ASR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ASR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ASR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ASR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ASR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ASR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ASR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ASR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ASR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ASR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ASR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ASR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ASR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ASR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ASR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ASR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ASR_P31 = 0x80000000

	// BSR: Peripheral B Select Register
	// Position of P0 field.
	PIO_BSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_BSR_P0_Msk = 0x1
	// Bit P0.
	PIO_BSR_P0 = 0x1
	// Position of P1 field.
	PIO_BSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_BSR_P1_Msk = 0x2
	// Bit P1.
	PIO_BSR_P1 = 0x2
	// Position of P2 field.
	PIO_BSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_BSR_P2_Msk = 0x4
	// Bit P2.
	PIO_BSR_P2 = 0x4
	// Position of P3 field.
	PIO_BSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_BSR_P3_Msk = 0x8
	// Bit P3.
	PIO_BSR_P3 = 0x8
	// Position of P4 field.
	PIO_BSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_BSR_P4_Msk = 0x10
	// Bit P4.
	PIO_BSR_P4 = 0x10
	// Position of P5 field.
	PIO_BSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_BSR_P5_Msk = 0x20
	// Bit P5.
	PIO_BSR_P5 = 0x20
	// Position of P6 field.
	PIO_BSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_BSR_P6_Msk = 0x40
	// Bit P6.
	PIO_BSR_P6 = 0x40
	// Position of P7 field.
	PIO_BSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_BSR_P7_Msk = 0x80
	// Bit P7.
	PIO_BSR_P7 = 0x80
	// Position of P8 field.
	PIO_BSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_BSR_P8_Msk = 0x100
	// Bit P8.
	PIO_BSR_P8 = 0x100
	// Position of P9 field.
	PIO_BSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_BSR_P9_Msk = 0x200
	// Bit P9.
	PIO_BSR_P9 = 0x200
	// Position of P10 field.
	PIO_BSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_BSR_P10_Msk = 0x400
	// Bit P10.
	PIO_BSR_P10 = 0x400
	// Position of P11 field.
	PIO_BSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_BSR_P11_Msk = 0x800
	// Bit P11.
	PIO_BSR_P11 = 0x800
	// Position of P12 field.
	PIO_BSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_BSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_BSR_P12 = 0x1000
	// Position of P13 field.
	PIO_BSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_BSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_BSR_P13 = 0x2000
	// Position of P14 field.
	PIO_BSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_BSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_BSR_P14 = 0x4000
	// Position of P15 field.
	PIO_BSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_BSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_BSR_P15 = 0x8000
	// Position of P16 field.
	PIO_BSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_BSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_BSR_P16 = 0x10000
	// Position of P17 field.
	PIO_BSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_BSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_BSR_P17 = 0x20000
	// Position of P18 field.
	PIO_BSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_BSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_BSR_P18 = 0x40000
	// Position of P19 field.
	PIO_BSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_BSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_BSR_P19 = 0x80000
	// Position of P20 field.
	PIO_BSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_BSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_BSR_P20 = 0x100000
	// Position of P21 field.
	PIO_BSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_BSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_BSR_P21 = 0x200000
	// Position of P22 field.
	PIO_BSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_BSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_BSR_P22 = 0x400000
	// Position of P23 field.
	PIO_BSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_BSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_BSR_P23 = 0x800000
	// Position of P24 field.
	PIO_BSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_BSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_BSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_BSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_BSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_BSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_BSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_BSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_BSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_BSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_BSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_BSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_BSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_BSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_BSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_BSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_BSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_BSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_BSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_BSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_BSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_BSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_BSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_BSR_P31 = 0x80000000

	// ABSR: AB Status Register
	// Position of P0 field.
	PIO_ABSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ABSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ABSR_P0 = 0x1
	// Position of P1 field.
	PIO_ABSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ABSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ABSR_P1 = 0x2
	// Position of P2 field.
	PIO_ABSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ABSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ABSR_P2 = 0x4
	// Position of P3 field.
	PIO_ABSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ABSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ABSR_P3 = 0x8
	// Position of P4 field.
	PIO_ABSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ABSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ABSR_P4 = 0x10
	// Position of P5 field.
	PIO_ABSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ABSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ABSR_P5 = 0x20
	// Position of P6 field.
	PIO_ABSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ABSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ABSR_P6 = 0x40
	// Position of P7 field.
	PIO_ABSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ABSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ABSR_P7 = 0x80
	// Position of P8 field.
	PIO_ABSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ABSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ABSR_P8 = 0x100
	// Position of P9 field.
	PIO_ABSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ABSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ABSR_P9 = 0x200
	// Position of P10 field.
	PIO_ABSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ABSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ABSR_P10 = 0x400
	// Position of P11 field.
	PIO_ABSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ABSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ABSR_P11 = 0x800
	// Position of P12 field.
	PIO_ABSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ABSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ABSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ABSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ABSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ABSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ABSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ABSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ABSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ABSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ABSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ABSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ABSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ABSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ABSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ABSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ABSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ABSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ABSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ABSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ABSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ABSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ABSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ABSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ABSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ABSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ABSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ABSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ABSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ABSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ABSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ABSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ABSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ABSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ABSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ABSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ABSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ABSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ABSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ABSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ABSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ABSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ABSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ABSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ABSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ABSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ABSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ABSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ABSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ABSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ABSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ABSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ABSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ABSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ABSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ABSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ABSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ABSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ABSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ABSR_P31 = 0x80000000

	// OWER: Output Write Enable
	// Position of P0 field.
	PIO_OWER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWER_P0_Msk = 0x1
	// Bit P0.
	PIO_OWER_P0 = 0x1
	// Position of P1 field.
	PIO_OWER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWER_P1_Msk = 0x2
	// Bit P1.
	PIO_OWER_P1 = 0x2
	// Position of P2 field.
	PIO_OWER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWER_P2_Msk = 0x4
	// Bit P2.
	PIO_OWER_P2 = 0x4
	// Position of P3 field.
	PIO_OWER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWER_P3_Msk = 0x8
	// Bit P3.
	PIO_OWER_P3 = 0x8
	// Position of P4 field.
	PIO_OWER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWER_P4_Msk = 0x10
	// Bit P4.
	PIO_OWER_P4 = 0x10
	// Position of P5 field.
	PIO_OWER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWER_P5_Msk = 0x20
	// Bit P5.
	PIO_OWER_P5 = 0x20
	// Position of P6 field.
	PIO_OWER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWER_P6_Msk = 0x40
	// Bit P6.
	PIO_OWER_P6 = 0x40
	// Position of P7 field.
	PIO_OWER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWER_P7_Msk = 0x80
	// Bit P7.
	PIO_OWER_P7 = 0x80
	// Position of P8 field.
	PIO_OWER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWER_P8_Msk = 0x100
	// Bit P8.
	PIO_OWER_P8 = 0x100
	// Position of P9 field.
	PIO_OWER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWER_P9_Msk = 0x200
	// Bit P9.
	PIO_OWER_P9 = 0x200
	// Position of P10 field.
	PIO_OWER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWER_P10_Msk = 0x400
	// Bit P10.
	PIO_OWER_P10 = 0x400
	// Position of P11 field.
	PIO_OWER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWER_P11_Msk = 0x800
	// Bit P11.
	PIO_OWER_P11 = 0x800
	// Position of P12 field.
	PIO_OWER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWER_P12 = 0x1000
	// Position of P13 field.
	PIO_OWER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWER_P13 = 0x2000
	// Position of P14 field.
	PIO_OWER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWER_P14 = 0x4000
	// Position of P15 field.
	PIO_OWER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWER_P15 = 0x8000
	// Position of P16 field.
	PIO_OWER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWER_P16 = 0x10000
	// Position of P17 field.
	PIO_OWER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWER_P17 = 0x20000
	// Position of P18 field.
	PIO_OWER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWER_P18 = 0x40000
	// Position of P19 field.
	PIO_OWER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWER_P19 = 0x80000
	// Position of P20 field.
	PIO_OWER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWER_P20 = 0x100000
	// Position of P21 field.
	PIO_OWER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWER_P21 = 0x200000
	// Position of P22 field.
	PIO_OWER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWER_P22 = 0x400000
	// Position of P23 field.
	PIO_OWER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWER_P23 = 0x800000
	// Position of P24 field.
	PIO_OWER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWER_P31 = 0x80000000

	// OWDR: Output Write Disable
	// Position of P0 field.
	PIO_OWDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWDR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWDR_P0 = 0x1
	// Position of P1 field.
	PIO_OWDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWDR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWDR_P1 = 0x2
	// Position of P2 field.
	PIO_OWDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWDR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWDR_P2 = 0x4
	// Position of P3 field.
	PIO_OWDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWDR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWDR_P3 = 0x8
	// Position of P4 field.
	PIO_OWDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWDR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWDR_P4 = 0x10
	// Position of P5 field.
	PIO_OWDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWDR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWDR_P5 = 0x20
	// Position of P6 field.
	PIO_OWDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWDR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWDR_P6 = 0x40
	// Position of P7 field.
	PIO_OWDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWDR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWDR_P7 = 0x80
	// Position of P8 field.
	PIO_OWDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWDR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWDR_P8 = 0x100
	// Position of P9 field.
	PIO_OWDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWDR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWDR_P9 = 0x200
	// Position of P10 field.
	PIO_OWDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWDR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWDR_P10 = 0x400
	// Position of P11 field.
	PIO_OWDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWDR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWDR_P11 = 0x800
	// Position of P12 field.
	PIO_OWDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWDR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWDR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWDR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWDR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWDR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWDR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWDR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWDR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWDR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWDR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWDR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWDR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWDR_P31 = 0x80000000

	// OWSR: Output Write Status Register
	// Position of P0 field.
	PIO_OWSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWSR_P0 = 0x1
	// Position of P1 field.
	PIO_OWSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWSR_P1 = 0x2
	// Position of P2 field.
	PIO_OWSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWSR_P2 = 0x4
	// Position of P3 field.
	PIO_OWSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWSR_P3 = 0x8
	// Position of P4 field.
	PIO_OWSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWSR_P4 = 0x10
	// Position of P5 field.
	PIO_OWSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWSR_P5 = 0x20
	// Position of P6 field.
	PIO_OWSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWSR_P6 = 0x40
	// Position of P7 field.
	PIO_OWSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWSR_P7 = 0x80
	// Position of P8 field.
	PIO_OWSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWSR_P8 = 0x100
	// Position of P9 field.
	PIO_OWSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWSR_P9 = 0x200
	// Position of P10 field.
	PIO_OWSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWSR_P10 = 0x400
	// Position of P11 field.
	PIO_OWSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWSR_P11 = 0x800
	// Position of P12 field.
	PIO_OWSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWSR_P31 = 0x80000000

	// DELAYR: I/O Delay Register
	// Position of Delay0 field.
	PIO_DELAYR_Delay0_Pos = 0x0
	// Bit mask of Delay0 field.
	PIO_DELAYR_Delay0_Msk = 0xf
	// Position of Delay1 field.
	PIO_DELAYR_Delay1_Pos = 0x4
	// Bit mask of Delay1 field.
	PIO_DELAYR_Delay1_Msk = 0xf0
	// Position of Delay2 field.
	PIO_DELAYR_Delay2_Pos = 0x8
	// Bit mask of Delay2 field.
	PIO_DELAYR_Delay2_Msk = 0xf00
	// Position of Delay3 field.
	PIO_DELAYR_Delay3_Pos = 0xc
	// Bit mask of Delay3 field.
	PIO_DELAYR_Delay3_Msk = 0xf000
	// Position of Delay4 field.
	PIO_DELAYR_Delay4_Pos = 0x10
	// Bit mask of Delay4 field.
	PIO_DELAYR_Delay4_Msk = 0xf0000
	// Position of Delay5 field.
	PIO_DELAYR_Delay5_Pos = 0x14
	// Bit mask of Delay5 field.
	PIO_DELAYR_Delay5_Msk = 0xf00000
	// Position of Delay6 field.
	PIO_DELAYR_Delay6_Pos = 0x18
	// Bit mask of Delay6 field.
	PIO_DELAYR_Delay6_Msk = 0xf000000
	// Position of Delay7 field.
	PIO_DELAYR_Delay7_Pos = 0x1c
	// Bit mask of Delay7 field.
	PIO_DELAYR_Delay7_Msk = 0xf0000000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	PIO_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PIO_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PIO_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PIO_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PIO_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	PIO_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PIO_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PIO_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PIO_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PIO_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for PMC: Power Management Controller
const (
	// PMC_SCER: System Clock Enable Register
	// Position of DDRCK field.
	PMC_PMC_SCER_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCER_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCER_DDRCK = 0x4
	// Position of UHP field.
	PMC_PMC_SCER_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCER_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCER_UHP = 0x40
	// Position of PCK0 field.
	PMC_PMC_SCER_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCER_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCER_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCER_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCER_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCER_PCK1 = 0x200

	// PMC_SCDR: System Clock Disable Register
	// Position of PCK field.
	PMC_PMC_SCDR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCDR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCDR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCDR_DDRCK = 0x4
	// Position of UHP field.
	PMC_PMC_SCDR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCDR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCDR_UHP = 0x40
	// Position of PCK0 field.
	PMC_PMC_SCDR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCDR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCDR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCDR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCDR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCDR_PCK1 = 0x200

	// PMC_SCSR: System Clock Status Register
	// Position of PCK field.
	PMC_PMC_SCSR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCSR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCSR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCSR_DDRCK = 0x4
	// Position of UHP field.
	PMC_PMC_SCSR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCSR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCSR_UHP = 0x40
	// Position of PCK0 field.
	PMC_PMC_SCSR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCSR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCSR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCSR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCSR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCSR_PCK1 = 0x200

	// PMC_PCER: Peripheral Clock Enable Register
	// Position of PID2 field.
	PMC_PMC_PCER_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCER_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCER_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCER_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCER_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCER_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCER_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCER_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCER_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCER_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCER_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCER_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCER_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCER_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCER_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCER_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCER_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCER_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCER_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCER_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCER_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCER_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCER_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCER_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCER_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCER_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCER_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCER_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCER_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCER_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCER_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCER_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCER_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCER_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCER_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCER_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCER_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCER_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCER_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCER_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCER_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCER_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCER_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCER_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCER_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCER_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCER_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCER_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCER_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCER_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCER_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCER_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCER_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCER_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCER_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCER_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCER_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCER_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCER_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCER_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCER_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCER_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCER_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCER_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCER_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCER_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCER_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCER_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCER_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCER_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCER_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCER_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCER_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCER_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCER_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCER_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCER_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCER_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCER_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCER_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCER_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCER_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCER_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCER_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCER_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCER_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCER_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCER_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCER_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCER_PID31 = 0x80000000

	// PMC_PCDR: Peripheral Clock Disable Register
	// Position of PID2 field.
	PMC_PMC_PCDR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCDR_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCDR_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCDR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCDR_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCDR_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCDR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCDR_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCDR_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCDR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCDR_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCDR_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCDR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCDR_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCDR_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCDR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCDR_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCDR_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCDR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCDR_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCDR_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCDR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCDR_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCDR_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCDR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCDR_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCDR_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCDR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCDR_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCDR_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCDR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCDR_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCDR_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCDR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCDR_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCDR_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCDR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCDR_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCDR_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCDR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCDR_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCDR_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCDR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCDR_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCDR_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCDR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCDR_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCDR_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCDR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCDR_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCDR_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCDR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCDR_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCDR_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCDR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCDR_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCDR_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCDR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCDR_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCDR_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCDR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCDR_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCDR_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCDR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCDR_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCDR_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCDR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCDR_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCDR_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCDR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCDR_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCDR_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCDR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCDR_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCDR_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCDR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCDR_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCDR_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCDR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCDR_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCDR_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCDR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCDR_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCDR_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCDR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCDR_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCDR_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCDR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCDR_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCDR_PID31 = 0x80000000

	// PMC_PCSR: Peripheral Clock Status Register
	// Position of PID2 field.
	PMC_PMC_PCSR_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCSR_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCSR_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCSR_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCSR_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCSR_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCSR_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCSR_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCSR_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCSR_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCSR_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCSR_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCSR_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCSR_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCSR_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCSR_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCSR_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCSR_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCSR_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCSR_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCSR_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCSR_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCSR_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCSR_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCSR_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCSR_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCSR_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCSR_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCSR_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCSR_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCSR_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCSR_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCSR_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCSR_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCSR_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCSR_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCSR_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCSR_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCSR_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCSR_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCSR_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCSR_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCSR_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCSR_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCSR_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCSR_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCSR_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCSR_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCSR_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCSR_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCSR_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCSR_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCSR_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCSR_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCSR_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCSR_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCSR_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCSR_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCSR_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCSR_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCSR_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCSR_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCSR_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCSR_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCSR_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCSR_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCSR_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCSR_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCSR_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCSR_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCSR_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCSR_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCSR_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCSR_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCSR_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCSR_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCSR_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCSR_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCSR_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCSR_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCSR_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCSR_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCSR_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCSR_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCSR_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCSR_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCSR_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCSR_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCSR_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCSR_PID31 = 0x80000000

	// CKGR_UCKR: UTMI Clock Register
	// Position of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Pos = 0x10
	// Bit mask of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Msk = 0x10000
	// Bit UPLLEN.
	PMC_CKGR_UCKR_UPLLEN = 0x10000
	// Position of PLLCOUNT field.
	PMC_CKGR_UCKR_PLLCOUNT_Pos = 0x14
	// Bit mask of PLLCOUNT field.
	PMC_CKGR_UCKR_PLLCOUNT_Msk = 0xf00000
	// Position of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Pos = 0x18
	// Bit mask of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Msk = 0x1000000
	// Bit BIASEN.
	PMC_CKGR_UCKR_BIASEN = 0x1000000
	// Position of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Pos = 0x1c
	// Bit mask of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Msk = 0xf0000000

	// CKGR_MOR: Main Oscillator Register
	// Position of MOSCEN field.
	PMC_CKGR_MOR_MOSCEN_Pos = 0x0
	// Bit mask of MOSCEN field.
	PMC_CKGR_MOR_MOSCEN_Msk = 0x1
	// Bit MOSCEN.
	PMC_CKGR_MOR_MOSCEN = 0x1
	// Position of OSCBYPASS field.
	PMC_CKGR_MOR_OSCBYPASS_Pos = 0x1
	// Bit mask of OSCBYPASS field.
	PMC_CKGR_MOR_OSCBYPASS_Msk = 0x2
	// Bit OSCBYPASS.
	PMC_CKGR_MOR_OSCBYPASS = 0x2
	// Position of OSCOUNT field.
	PMC_CKGR_MOR_OSCOUNT_Pos = 0x8
	// Bit mask of OSCOUNT field.
	PMC_CKGR_MOR_OSCOUNT_Msk = 0xff00

	// CKGR_MCFR: Main Clock Frequency Register
	// Position of MAINF field.
	PMC_CKGR_MCFR_MAINF_Pos = 0x0
	// Bit mask of MAINF field.
	PMC_CKGR_MCFR_MAINF_Msk = 0xffff
	// Position of MAINRDY field.
	PMC_CKGR_MCFR_MAINRDY_Pos = 0x10
	// Bit mask of MAINRDY field.
	PMC_CKGR_MCFR_MAINRDY_Msk = 0x10000
	// Bit MAINRDY.
	PMC_CKGR_MCFR_MAINRDY = 0x10000

	// CKGR_PLLAR: PLLA Register
	// Position of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Msk = 0xff
	// Position of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Pos = 0x8
	// Bit mask of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Msk = 0x3f00
	// Position of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Pos = 0xe
	// Bit mask of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Msk = 0xc000
	// Position of MULA field.
	PMC_CKGR_PLLAR_MULA_Pos = 0x10
	// Bit mask of MULA field.
	PMC_CKGR_PLLAR_MULA_Msk = 0xff0000
	// Position of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Pos = 0x1d
	// Bit mask of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Msk = 0x20000000
	// Bit STUCKTO1.
	PMC_CKGR_PLLAR_STUCKTO1 = 0x20000000

	// PMC_MCKR: Master Clock Register
	// Position of CSS field.
	PMC_PMC_MCKR_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_MCKR_CSS_Msk = 0x3
	// Position of PRES field.
	PMC_PMC_MCKR_PRES_Pos = 0x2
	// Bit mask of PRES field.
	PMC_PMC_MCKR_PRES_Msk = 0x1c
	// Position of MDIV field.
	PMC_PMC_MCKR_MDIV_Pos = 0x8
	// Bit mask of MDIV field.
	PMC_PMC_MCKR_MDIV_Msk = 0x300
	// Position of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Pos = 0xc
	// Bit mask of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Msk = 0x1000
	// Bit PLLADIV2.
	PMC_PMC_MCKR_PLLADIV2 = 0x1000

	// PMC_USB: USB Clock Register
	// Position of USBS field.
	PMC_PMC_USB_USBS_Pos = 0x0
	// Bit mask of USBS field.
	PMC_PMC_USB_USBS_Msk = 0x1
	// Bit USBS.
	PMC_PMC_USB_USBS = 0x1
	// Position of USBDIV field.
	PMC_PMC_USB_USBDIV_Pos = 0x8
	// Bit mask of USBDIV field.
	PMC_PMC_USB_USBDIV_Msk = 0xf00

	// PMC_PCK: Programmable Clock 0 Register
	// Position of CSS field.
	PMC_PMC_PCK_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_PCK_CSS_Msk = 0x3
	// Position of PRES field.
	PMC_PMC_PCK_PRES_Pos = 0x2
	// Bit mask of PRES field.
	PMC_PMC_PCK_PRES_Msk = 0x1c
	// Position of SLCKMCK field.
	PMC_PMC_PCK_SLCKMCK_Pos = 0x8
	// Bit mask of SLCKMCK field.
	PMC_PMC_PCK_SLCKMCK_Msk = 0x100
	// Bit SLCKMCK.
	PMC_PMC_PCK_SLCKMCK = 0x100

	// PMC_IER: Interrupt Enable Register
	// Position of MOSCS field.
	PMC_PMC_IER_MOSCS_Pos = 0x0
	// Bit mask of MOSCS field.
	PMC_PMC_IER_MOSCS_Msk = 0x1
	// Bit MOSCS.
	PMC_PMC_IER_MOSCS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IER_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IER_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IER_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IER_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IER_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IER_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IER_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IER_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IER_PCKRDY1 = 0x200

	// PMC_IDR: Interrupt Disable Register
	// Position of MOSCS field.
	PMC_PMC_IDR_MOSCS_Pos = 0x0
	// Bit mask of MOSCS field.
	PMC_PMC_IDR_MOSCS_Msk = 0x1
	// Bit MOSCS.
	PMC_PMC_IDR_MOSCS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IDR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IDR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IDR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IDR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IDR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IDR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IDR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IDR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IDR_PCKRDY1 = 0x200

	// PMC_SR: Status Register
	// Position of MOSCS field.
	PMC_PMC_SR_MOSCS_Pos = 0x0
	// Bit mask of MOSCS field.
	PMC_PMC_SR_MOSCS_Msk = 0x1
	// Bit MOSCS.
	PMC_PMC_SR_MOSCS = 0x1
	// Position of LOCKA field.
	PMC_PMC_SR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_SR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_SR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_SR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_SR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_SR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_SR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_SR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_SR_PCKRDY1 = 0x200

	// PMC_IMR: Interrupt Mask Register
	// Position of MOSCS field.
	PMC_PMC_IMR_MOSCS_Pos = 0x0
	// Bit mask of MOSCS field.
	PMC_PMC_IMR_MOSCS_Msk = 0x1
	// Bit MOSCS.
	PMC_PMC_IMR_MOSCS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IMR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IMR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IMR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IMR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IMR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IMR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IMR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IMR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IMR_PCKRDY1 = 0x200
)

// Constants for RSTC: Reset Controller
const (
	// CR: Control Register
	// Position of PROCRST field.
	SYSC_CR_PROCRST_Pos = 0x0
	// Bit mask of PROCRST field.
	SYSC_CR_PROCRST_Msk = 0x1
	// Bit PROCRST.
	SYSC_CR_PROCRST = 0x1
	// Position of PERRST field.
	SYSC_CR_PERRST_Pos = 0x2
	// Bit mask of PERRST field.
	SYSC_CR_PERRST_Msk = 0x4
	// Bit PERRST.
	SYSC_CR_PERRST = 0x4
	// Position of EXTRST field.
	SYSC_CR_EXTRST_Pos = 0x3
	// Bit mask of EXTRST field.
	SYSC_CR_EXTRST_Msk = 0x8
	// Bit EXTRST.
	SYSC_CR_EXTRST = 0x8
	// Position of KEY field.
	SYSC_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_CR_KEY_Msk = 0xff000000

	// SR: Status Register
	// Position of URSTS field.
	SYSC_SR_URSTS_Pos = 0x0
	// Bit mask of URSTS field.
	SYSC_SR_URSTS_Msk = 0x1
	// Bit URSTS.
	SYSC_SR_URSTS = 0x1
	// Position of RSTTYP field.
	SYSC_SR_RSTTYP_Pos = 0x8
	// Bit mask of RSTTYP field.
	SYSC_SR_RSTTYP_Msk = 0x700
	// Position of NRSTL field.
	SYSC_SR_NRSTL_Pos = 0x10
	// Bit mask of NRSTL field.
	SYSC_SR_NRSTL_Msk = 0x10000
	// Bit NRSTL.
	SYSC_SR_NRSTL = 0x10000
	// Position of SRCMP field.
	SYSC_SR_SRCMP_Pos = 0x11
	// Bit mask of SRCMP field.
	SYSC_SR_SRCMP_Msk = 0x20000
	// Bit SRCMP.
	SYSC_SR_SRCMP = 0x20000

	// MR: Mode Register
	// Position of URSTEN field.
	SYSC_MR_URSTEN_Pos = 0x0
	// Bit mask of URSTEN field.
	SYSC_MR_URSTEN_Msk = 0x1
	// Bit URSTEN.
	SYSC_MR_URSTEN = 0x1
	// Position of URSTIEN field.
	SYSC_MR_URSTIEN_Pos = 0x4
	// Bit mask of URSTIEN field.
	SYSC_MR_URSTIEN_Msk = 0x10
	// Bit URSTIEN.
	SYSC_MR_URSTIEN = 0x10
	// Position of ERSTL field.
	SYSC_MR_ERSTL_Pos = 0x8
	// Bit mask of ERSTL field.
	SYSC_MR_ERSTL_Msk = 0xf00
	// Position of KEY field.
	SYSC_MR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_MR_KEY_Msk = 0xff000000
)

// Constants for RTC: Real-time Clock
const (
	// CR: Control Register
	// Position of UPDTIM field.
	RTC_CR_UPDTIM_Pos = 0x0
	// Bit mask of UPDTIM field.
	RTC_CR_UPDTIM_Msk = 0x1
	// Bit UPDTIM.
	RTC_CR_UPDTIM = 0x1
	// Position of UPDCAL field.
	RTC_CR_UPDCAL_Pos = 0x1
	// Bit mask of UPDCAL field.
	RTC_CR_UPDCAL_Msk = 0x2
	// Bit UPDCAL.
	RTC_CR_UPDCAL = 0x2
	// Position of TIMEVSEL field.
	RTC_CR_TIMEVSEL_Pos = 0x8
	// Bit mask of TIMEVSEL field.
	RTC_CR_TIMEVSEL_Msk = 0x300
	// Minute change
	RTC_CR_TIMEVSEL_MINUTE = 0x0
	// Hour change
	RTC_CR_TIMEVSEL_HOUR = 0x1
	// Every day at midnight
	RTC_CR_TIMEVSEL_MIDNIGHT = 0x2
	// Every day at noon
	RTC_CR_TIMEVSEL_NOON = 0x3
	// Position of CALEVSEL field.
	RTC_CR_CALEVSEL_Pos = 0x10
	// Bit mask of CALEVSEL field.
	RTC_CR_CALEVSEL_Msk = 0x30000
	// Week change (every Monday at time 00:00:00)
	RTC_CR_CALEVSEL_WEEK = 0x0
	// Month change (every 01 of each month at time 00:00:00)
	RTC_CR_CALEVSEL_MONTH = 0x1
	// Year change (every January 1 at time 00:00:00)
	RTC_CR_CALEVSEL_YEAR = 0x2

	// MR: Mode Register
	// Position of HRMOD field.
	RTC_MR_HRMOD_Pos = 0x0
	// Bit mask of HRMOD field.
	RTC_MR_HRMOD_Msk = 0x1
	// Bit HRMOD.
	RTC_MR_HRMOD = 0x1

	// TIMR: Time Register
	// Position of SEC field.
	RTC_TIMR_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_TIMR_SEC_Msk = 0x7f
	// Position of MIN field.
	RTC_TIMR_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_TIMR_MIN_Msk = 0x7f00
	// Position of HOUR field.
	RTC_TIMR_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_TIMR_HOUR_Msk = 0x3f0000
	// Position of AMPM field.
	RTC_TIMR_AMPM_Pos = 0x16
	// Bit mask of AMPM field.
	RTC_TIMR_AMPM_Msk = 0x400000
	// Bit AMPM.
	RTC_TIMR_AMPM = 0x400000

	// CALR: Calendar Register
	// Position of CENT field.
	RTC_CALR_CENT_Pos = 0x0
	// Bit mask of CENT field.
	RTC_CALR_CENT_Msk = 0x7f
	// Position of YEAR field.
	RTC_CALR_YEAR_Pos = 0x8
	// Bit mask of YEAR field.
	RTC_CALR_YEAR_Msk = 0xff00
	// Position of MONTH field.
	RTC_CALR_MONTH_Pos = 0x10
	// Bit mask of MONTH field.
	RTC_CALR_MONTH_Msk = 0x1f0000
	// Position of DAY field.
	RTC_CALR_DAY_Pos = 0x15
	// Bit mask of DAY field.
	RTC_CALR_DAY_Msk = 0xe00000
	// Position of DATE field.
	RTC_CALR_DATE_Pos = 0x18
	// Bit mask of DATE field.
	RTC_CALR_DATE_Msk = 0x3f000000

	// TIMALR: Time Alarm Register
	// Position of SEC field.
	RTC_TIMALR_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_TIMALR_SEC_Msk = 0x7f
	// Position of SECEN field.
	RTC_TIMALR_SECEN_Pos = 0x7
	// Bit mask of SECEN field.
	RTC_TIMALR_SECEN_Msk = 0x80
	// Bit SECEN.
	RTC_TIMALR_SECEN = 0x80
	// Position of MIN field.
	RTC_TIMALR_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_TIMALR_MIN_Msk = 0x7f00
	// Position of MINEN field.
	RTC_TIMALR_MINEN_Pos = 0xf
	// Bit mask of MINEN field.
	RTC_TIMALR_MINEN_Msk = 0x8000
	// Bit MINEN.
	RTC_TIMALR_MINEN = 0x8000
	// Position of HOUR field.
	RTC_TIMALR_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_TIMALR_HOUR_Msk = 0x3f0000
	// Position of AMPM field.
	RTC_TIMALR_AMPM_Pos = 0x16
	// Bit mask of AMPM field.
	RTC_TIMALR_AMPM_Msk = 0x400000
	// Bit AMPM.
	RTC_TIMALR_AMPM = 0x400000
	// Position of HOUREN field.
	RTC_TIMALR_HOUREN_Pos = 0x17
	// Bit mask of HOUREN field.
	RTC_TIMALR_HOUREN_Msk = 0x800000
	// Bit HOUREN.
	RTC_TIMALR_HOUREN = 0x800000

	// CALALR: Calendar Alarm Register
	// Position of MONTH field.
	RTC_CALALR_MONTH_Pos = 0x10
	// Bit mask of MONTH field.
	RTC_CALALR_MONTH_Msk = 0x1f0000
	// Position of MTHEN field.
	RTC_CALALR_MTHEN_Pos = 0x17
	// Bit mask of MTHEN field.
	RTC_CALALR_MTHEN_Msk = 0x800000
	// Bit MTHEN.
	RTC_CALALR_MTHEN = 0x800000
	// Position of DATE field.
	RTC_CALALR_DATE_Pos = 0x18
	// Bit mask of DATE field.
	RTC_CALALR_DATE_Msk = 0x3f000000
	// Position of DATEEN field.
	RTC_CALALR_DATEEN_Pos = 0x1f
	// Bit mask of DATEEN field.
	RTC_CALALR_DATEEN_Msk = 0x80000000
	// Bit DATEEN.
	RTC_CALALR_DATEEN = 0x80000000

	// SR: Status Register
	// Position of ACKUPD field.
	RTC_SR_ACKUPD_Pos = 0x0
	// Bit mask of ACKUPD field.
	RTC_SR_ACKUPD_Msk = 0x1
	// Bit ACKUPD.
	RTC_SR_ACKUPD = 0x1
	// Position of ALARM field.
	RTC_SR_ALARM_Pos = 0x1
	// Bit mask of ALARM field.
	RTC_SR_ALARM_Msk = 0x2
	// Bit ALARM.
	RTC_SR_ALARM = 0x2
	// Position of SEC field.
	RTC_SR_SEC_Pos = 0x2
	// Bit mask of SEC field.
	RTC_SR_SEC_Msk = 0x4
	// Bit SEC.
	RTC_SR_SEC = 0x4
	// Position of TIMEV field.
	RTC_SR_TIMEV_Pos = 0x3
	// Bit mask of TIMEV field.
	RTC_SR_TIMEV_Msk = 0x8
	// Bit TIMEV.
	RTC_SR_TIMEV = 0x8
	// Position of CALEV field.
	RTC_SR_CALEV_Pos = 0x4
	// Bit mask of CALEV field.
	RTC_SR_CALEV_Msk = 0x10
	// Bit CALEV.
	RTC_SR_CALEV = 0x10

	// SCCR: Status Clear Command Register
	// Position of ACKCLR field.
	RTC_SCCR_ACKCLR_Pos = 0x0
	// Bit mask of ACKCLR field.
	RTC_SCCR_ACKCLR_Msk = 0x1
	// Bit ACKCLR.
	RTC_SCCR_ACKCLR = 0x1
	// Position of ALRCLR field.
	RTC_SCCR_ALRCLR_Pos = 0x1
	// Bit mask of ALRCLR field.
	RTC_SCCR_ALRCLR_Msk = 0x2
	// Bit ALRCLR.
	RTC_SCCR_ALRCLR = 0x2
	// Position of SECCLR field.
	RTC_SCCR_SECCLR_Pos = 0x2
	// Bit mask of SECCLR field.
	RTC_SCCR_SECCLR_Msk = 0x4
	// Bit SECCLR.
	RTC_SCCR_SECCLR = 0x4
	// Position of TIMCLR field.
	RTC_SCCR_TIMCLR_Pos = 0x3
	// Bit mask of TIMCLR field.
	RTC_SCCR_TIMCLR_Msk = 0x8
	// Bit TIMCLR.
	RTC_SCCR_TIMCLR = 0x8
	// Position of CALCLR field.
	RTC_SCCR_CALCLR_Pos = 0x4
	// Bit mask of CALCLR field.
	RTC_SCCR_CALCLR_Msk = 0x10
	// Bit CALCLR.
	RTC_SCCR_CALCLR = 0x10

	// IER: Interrupt Enable Register
	// Position of ACKEN field.
	RTC_IER_ACKEN_Pos = 0x0
	// Bit mask of ACKEN field.
	RTC_IER_ACKEN_Msk = 0x1
	// Bit ACKEN.
	RTC_IER_ACKEN = 0x1
	// Position of ALREN field.
	RTC_IER_ALREN_Pos = 0x1
	// Bit mask of ALREN field.
	RTC_IER_ALREN_Msk = 0x2
	// Bit ALREN.
	RTC_IER_ALREN = 0x2
	// Position of SECEN field.
	RTC_IER_SECEN_Pos = 0x2
	// Bit mask of SECEN field.
	RTC_IER_SECEN_Msk = 0x4
	// Bit SECEN.
	RTC_IER_SECEN = 0x4
	// Position of TIMEN field.
	RTC_IER_TIMEN_Pos = 0x3
	// Bit mask of TIMEN field.
	RTC_IER_TIMEN_Msk = 0x8
	// Bit TIMEN.
	RTC_IER_TIMEN = 0x8
	// Position of CALEN field.
	RTC_IER_CALEN_Pos = 0x4
	// Bit mask of CALEN field.
	RTC_IER_CALEN_Msk = 0x10
	// Bit CALEN.
	RTC_IER_CALEN = 0x10

	// IDR: Interrupt Disable Register
	// Position of ACKDIS field.
	RTC_IDR_ACKDIS_Pos = 0x0
	// Bit mask of ACKDIS field.
	RTC_IDR_ACKDIS_Msk = 0x1
	// Bit ACKDIS.
	RTC_IDR_ACKDIS = 0x1
	// Position of ALRDIS field.
	RTC_IDR_ALRDIS_Pos = 0x1
	// Bit mask of ALRDIS field.
	RTC_IDR_ALRDIS_Msk = 0x2
	// Bit ALRDIS.
	RTC_IDR_ALRDIS = 0x2
	// Position of SECDIS field.
	RTC_IDR_SECDIS_Pos = 0x2
	// Bit mask of SECDIS field.
	RTC_IDR_SECDIS_Msk = 0x4
	// Bit SECDIS.
	RTC_IDR_SECDIS = 0x4
	// Position of TIMDIS field.
	RTC_IDR_TIMDIS_Pos = 0x3
	// Bit mask of TIMDIS field.
	RTC_IDR_TIMDIS_Msk = 0x8
	// Bit TIMDIS.
	RTC_IDR_TIMDIS = 0x8
	// Position of CALDIS field.
	RTC_IDR_CALDIS_Pos = 0x4
	// Bit mask of CALDIS field.
	RTC_IDR_CALDIS_Msk = 0x10
	// Bit CALDIS.
	RTC_IDR_CALDIS = 0x10

	// IMR: Interrupt Mask Register
	// Position of ACK field.
	RTC_IMR_ACK_Pos = 0x0
	// Bit mask of ACK field.
	RTC_IMR_ACK_Msk = 0x1
	// Bit ACK.
	RTC_IMR_ACK = 0x1
	// Position of ALR field.
	RTC_IMR_ALR_Pos = 0x1
	// Bit mask of ALR field.
	RTC_IMR_ALR_Msk = 0x2
	// Bit ALR.
	RTC_IMR_ALR = 0x2
	// Position of SEC field.
	RTC_IMR_SEC_Pos = 0x2
	// Bit mask of SEC field.
	RTC_IMR_SEC_Msk = 0x4
	// Bit SEC.
	RTC_IMR_SEC = 0x4
	// Position of TIM field.
	RTC_IMR_TIM_Pos = 0x3
	// Bit mask of TIM field.
	RTC_IMR_TIM_Msk = 0x8
	// Bit TIM.
	RTC_IMR_TIM = 0x8
	// Position of CAL field.
	RTC_IMR_CAL_Pos = 0x4
	// Bit mask of CAL field.
	RTC_IMR_CAL_Msk = 0x10
	// Bit CAL.
	RTC_IMR_CAL = 0x10

	// VER: Valid Entry Register
	// Position of NVTIM field.
	RTC_VER_NVTIM_Pos = 0x0
	// Bit mask of NVTIM field.
	RTC_VER_NVTIM_Msk = 0x1
	// Bit NVTIM.
	RTC_VER_NVTIM = 0x1
	// Position of NVCAL field.
	RTC_VER_NVCAL_Pos = 0x1
	// Bit mask of NVCAL field.
	RTC_VER_NVCAL_Msk = 0x2
	// Bit NVCAL.
	RTC_VER_NVCAL = 0x2
	// Position of NVTIMALR field.
	RTC_VER_NVTIMALR_Pos = 0x2
	// Bit mask of NVTIMALR field.
	RTC_VER_NVTIMALR_Msk = 0x4
	// Bit NVTIMALR.
	RTC_VER_NVTIMALR = 0x4
	// Position of NVCALALR field.
	RTC_VER_NVCALALR_Pos = 0x3
	// Bit mask of NVCALALR field.
	RTC_VER_NVCALALR_Msk = 0x8
	// Bit NVCALALR.
	RTC_VER_NVCALALR = 0x8
)
